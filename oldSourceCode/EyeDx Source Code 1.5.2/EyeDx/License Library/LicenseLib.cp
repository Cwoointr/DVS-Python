// LicenseLib.cp//// This file implements the software-based EyeDx License scheme.//// Created by Merle F. McClelland, 5 April 1999//#include <stdio.h>#include <string.h>#include <time.h>#include "LicenseLib.h"EyeDxLicenseInfo::EyeDxLicenseInfo(){	// We set all of the fields to invalid values. This allows us	// to test in the routine that builds the license whether all 	// of the necessary fields have been set.		SNYear 		= LicenseYearInvalid;	SNMonth 	= LicenseMonthInvalid;	SNDay 		= LicenseDayInvalid;	SNTime		= 0;	ExpYear 	= LicenseYearInvalid;	ExpMonth 	= LicenseMonthInvalid;	ExpDay 		= LicenseDayInvalid;	Type 		= LicenseTypeInvalid;	Increment	= LicenseIncrInvalid;	Version		= LicenseVersionInvalid;	Version		= LicenseCurrentVers;}bool EyeDxLicenseInfo::SetType(short type){	if (type == LicenseTypeStandard || type == LicenseTypeDemo)	{		Type = type;		return true;	}	return false;}// Increment must be in multiples of LicenseIncMultiplierbool EyeDxLicenseInfo::SetIncrement(long increment){	if (increment % LicenseIncMultiplier)		return false;	// Not an increment of LicenseIncMultiplier!			increment /= LicenseIncMultiplier;		// Scale down		if (increment >= 0 || increment <= LicenseMaxIncr)	{		Increment = increment;		return true;	}	return false;}bool EyeDxLicenseInfo::SetSerialNumberYear(short year){	short yearCode = year - LicenseDateYearOffset;	if ((yearCode <= LicenseYearInvalid) || (yearCode > LicenseMaxYear))		return false;		SNYear = yearCode;	return true;}bool EyeDxLicenseInfo::SetSerialNumberMonth(short month){	if ((month < 1) || (month > 12))		return false;		SNMonth = month;	return true;}bool EyeDxLicenseInfo::SetSerialNumberDay(short day){	// Note that we do not do extensive testing on this. It is assumed that	// the caller validates the date information.		if ((day < 1) || (day > 31))		return false;		SNDay = day;	return true;}bool EyeDxLicenseInfo::SetSerialNumberTime(long time){	// The value passed must be less than the number of seconds in a day	if ((time < 0) || (time > (24 * 60 * 60)))		return false;		SNTime = time;	return true;}bool EyeDxLicenseInfo::SetExpYear(short year){	short yearCode = year - LicenseDateYearOffset;	if ((yearCode <= LicenseYearInvalid) || (yearCode > LicenseMaxYear))		return false;		ExpYear = yearCode;	return true;}bool EyeDxLicenseInfo::SetExpMonth(short month){	if ((month < 1) || (month > 12))		return false;		ExpMonth = month;	return true;}bool EyeDxLicenseInfo::SetExpDay(short day){	// Note that we do not do extensive testing on this. It is assumed that	// the caller validates the date information.		if ((day < 1) || (day > 31))		return false;		ExpDay = day;	return true;}static char BinToBase32[] ={	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', '8', 'm', 	'n', '9', 'p', 'q', 'r', 's', 't', 'A', 'B', 'w', 'x', 'y', 'z',	'2', '3', '4', '5', '6', '7'	};short	EyeDxLicenseInfo::Base32ToBinary(char character){	// We search the table to look up the value	for (int i = 0; i <= LicenseCharMaxBin; i++)	{		if (BinToBase32[i] == character)			return i;	}	return -1;}char	EyeDxLicenseInfo::BinaryToBase32(short bits){	if (bits > LicenseCharMaxBin)		return LicenseCharInvalid;			return(BinToBase32[bits]);}// This routine validates a passed License String. Note that the// string should not contain dash characters. The user interface should// request the four segments and concatenate them into a single string.bool	EyeDxLicenseInfo::IsValidLicenseString(const char *licenseString){	if (licenseString == 0L)		return false;	if (strlen(licenseString) != LicenseStringLen)		return false;			// We check to see that all of the characters are valid	// Base32 encoding characters.		for (int i = 0; i < LicenseStringLen; i++)	{		if (Base32ToBinary(licenseString[i]) == -1)			return false;	}			// Next, we validate the check character. This is done by adding the	// values of all of the decoded 6 bit values in the License String.	// The result should be zero. We don't have to explicitly pull out the	// check character and process it in a special way, since it should be	// the encoded value of the two's complement of the sum of the other 	// 6 bit values.		short sum = 0;		for (int i = 0; i < LicenseStringLen; i++)		sum += Base32ToBinary(licenseString[i]);				if ((sum & LicenseCharMask) != 0)		return false;			return true;}bool	EyeDxLicenseInfo::IsValidCustomerIDString(const char *customerID){	if (customerID == 0L)		return false;			if (strlen(customerID) < LicenseMinCustomerIDLen)		return false;	return true;}void EyeDxLicenseInfo::CalcEncoderValues(const char *customerID, 				long long &EncoderA, 				long long &EncoderB){	const long encodingPatternBytes = 8;		long long temp = 0;		EncoderA = 0;	EncoderB = 0;		//return;		if (!IsValidCustomerIDString(customerID))		return;			// First, we fill the replicatedID with the bytes from the customerID	// string. We have to handle customerID strings of any length. We use 	// the end of the string, since that is most likely to be unique for numeric	// IDs. So, we work backwards from the end till we hit the beginning.	// If we still have more bytes to fill, we reverse direction. This	// produces a mirroring of the ASCII bytes. in the customer ID.		int position = strlen(customerID) - 1;	int delta = -1;		long temp1 = 0;	long temp2 = 0;		for (int i = 0; i < encodingPatternBytes / 2; i++)	{		temp1 <<= 8;		long character = (customerID[position] & 0x7f);		temp1 = temp1 | character;		position += delta;				if (position < 0)		{			position = 0;			delta = -delta;		}		else		if (position == strlen(customerID))		{			position = strlen(customerID) - 1;			delta = -delta;		}	}		for (int i = 0; i < encodingPatternBytes / 2; i++)	{		temp2 <<= 8;		long character = (customerID[position] & 0x7f);		temp2 = temp2 | character;		position += delta;				if (position < 0)		{			position = 0;			delta = -delta;		}		else		if (position == strlen(customerID))		{			position = strlen(customerID) - 1;			delta = -delta;		}	}		temp = (((long long)temp1) << 32);	temp = temp | ((long long) temp2);		// Now we have a 64 bit pattern to use in encoding. We just use two	// different encoding schemes for the two words. One just takes the	// two's complement of the pattern and masks it to the correct length.	// The other squares it (with possible overflow, which is discarded),	// and masks it as well. Note that the masks are shifted down one bit	// to account for the carry bit in the resulting value in the license	// bits, which must be preserved.		EncoderA = (-temp) & (LicenseBitsMaskA >> 1);	EncoderB = (temp * temp) & (LicenseBitsMaskB >> 1);	}bool EyeDxLicenseInfo::EncodeLicense(char *licenseString, const char *customerID){	// The customerID must be valid		if (!IsValidCustomerIDString(customerID))		return false;			// The licenseString pointer must be non-NULL			if (licenseString == NULL)		return false;			// To encode, all of the fields must be valid		if (SNYear == LicenseYearInvalid)		return false;			if (SNMonth == LicenseMonthInvalid)		return false;			if (SNDay == LicenseDayInvalid)		return false;			if (ExpYear == LicenseYearInvalid)		return false;			if (ExpMonth == LicenseMonthInvalid)		return false;			if (ExpDay == LicenseDayInvalid)		return false;			if (Type == LicenseTypeInvalid)		return false;			if (Increment == LicenseIncrInvalid)		return false;			if (Version == LicenseVersionInvalid)		return false;			// Everything seems to be ok so far.		// First, we assemble the LicenseA bits	long long SNDate = (SNYear << LicenseADateYearShift) | 					   (SNMonth << LicenseADateMonthShift) |				  	   (SNDay << LicenseADateDayShift);				  	   	long long SerialNumber = (SNDate << LicenseASNDateShift) | 							 (SNTime << LicenseASNTimeShift);					LicenseA = (SerialNumber << LicenseASNShift);			   	// Now we assemble the LicenseB bits				  	long long ExpDate = (ExpYear << LicenseADateYearShift) | 					    (ExpMonth << LicenseADateMonthShift) |				  	    (ExpDay << LicenseADateDayShift);				  	    	LicenseB = (ExpDate << LicenseBExpShift) |			   (Increment << LicenseBIncShift) |			   (Version << LicenseBVersShift) |			   (Type  << LicenseBTypeShift);			   	// Next, we calculate the check nibble. This is done by adding the	// values of all of the nibbles in LicenseA and LicenceB together, and	// negating the result. The lower 4 bits of this result is the check code.		short checkCode = 0;	short numNibbles = (sizeof (long long) * 2);	long long temp = LicenseA;		for (int i = 0; i < numNibbles; i++)	{		checkCode += (temp & LicenseNibbleMask);		temp = temp >> LicenseNibbleShift;	}		temp = LicenseB;		for (int i = 0; i < numNibbles; i++)	{		checkCode += (temp & LicenseNibbleMask);		temp = temp >> LicenseNibbleShift;	}		// Negate, mask, and shift into position		checkCode = -checkCode;	checkCode = checkCode & LicenseBCheckMask;		// Add to the LicenseB component		LicenseB |= (checkCode << LicenseBCheckShift);		// Now, get the encoding values that are derived from the customer ID		long long EncoderA, EncoderB;		CalcEncoderValues(customerID, EncoderA, EncoderB);		// Finally, encode the values by adding the encoder to the license value		long long EncodedA, EncodedB;		EncodedA = LicenseA + EncoderA;	EncodedB = LicenseB + EncoderB;		// We shift EncodedA up to account for the location of the	// check digit. Doing this simplifies handling of the Base32	// encoding below.			EncodedA = EncodedA << LicenseCharShift;		 		// Create the license string		char theLicenseString[LicenseStringLen + 1];	theLicenseString[LicenseStringLen] = '\0';		// It's easier to process the values from the LSB's up by shifting	// down and masking. So, we point at the last character, and work our	// way up from there. We encode 48 bits per long long word.		short outputIndex = LicenseStringLen - 1;		// At the same time, we calculate the check digit value		short checkValue = 0;		// First process the digits for the "B" component		for (int i = 0; i < LicenseStrDigitsPerWord; i++)	{		short digit = EncodedB & LicenseCharMask;		EncodedB = EncodedB >> LicenseCharShift;				theLicenseString[outputIndex--] = BinaryToBase32(digit);		checkValue += digit;	}		// Now process the digits for the "A" component - note that space for	// the check digit is already in the EncodedA value, and it will be	// encoded as an all-zero value. This encoded character will be replaced	// by the actual encoded value of the check character.		for (int i = 0; i < LicenseStrDigitsPerWord; i++)	{		short digit = EncodedA & LicenseCharMask;		EncodedA = EncodedA >> LicenseCharShift;				theLicenseString[outputIndex--] = BinaryToBase32(digit);		checkValue += digit;	}		checkValue = (-checkValue) & LicenseCharMask;		theLicenseString[LicenseCheckCharPos] = BinaryToBase32(checkValue);		strcpy(licenseString, theLicenseString);		return true;}bool EyeDxLicenseInfo::UpdateLicense(char *, const char *){	return false;}// These are the encoding and decoding routines.bool EyeDxLicenseInfo::DecodeLicense(const char *licenseString, const char *customerID){	// First, see if the string represents a valid license		if (!IsValidLicenseString(licenseString))		return false;			long long EncodedA = 0;	long long EncodedB = 0;		// We convert the string into two long long values. We start at the end	// of the string, and work our way up		short inputIndex = 0;		// First process the digits for the "A" component - that's the upper bits		for (int i = 0; i < LicenseStrDigitsPerWord; i++)	{		short digit = Base32ToBinary(licenseString[inputIndex++]);		EncodedA = EncodedA << LicenseCharShift;		EncodedA |= digit;	}		// Now process the digits for the "B" component.		for (int i = 0; i < LicenseStrDigitsPerWord; i++)	{		short digit = Base32ToBinary(licenseString[inputIndex++]);		EncodedB = EncodedB << LicenseCharShift;		EncodedB |= digit;	}		// We get rid of the check character, since we've already validated it.		EncodedA = EncodedA >> LicenseCharShift;		 	// Now, get the encoding values that are derived from the customer ID		long long EncoderA, EncoderB;		CalcEncoderValues(customerID, EncoderA, EncoderB);		// Finally, decode the values by subtracting the encoder from the encoded value		LicenseA = EncodedA - EncoderA;	LicenseB = EncodedB - EncoderB;		// Next, we calculate the check nibble. This is done by adding the	// values of all of the nibbles in DecodedA and DecodedB together. The	// result should be zero, as the check nibble is calculated to be the	// two's complement of the sum of the other nibbles.		short sum = 0;	short numNibbles = (sizeof (long long) * 2);	long long temp = LicenseA;		for (int i = 0; i < numNibbles; i++)	{		sum += temp & LicenseNibbleMask;		temp = temp >> LicenseNibbleShift;	}		temp = LicenseB;		for (int i = 0; i < numNibbles; i++)	{		sum += temp & LicenseNibbleMask;		temp = temp >> LicenseNibbleShift;	}		sum &= LicenseNibbleMask;		if (sum != 0)		return false;			// Now we have decoded the two parts of the license. We do some validation	// of the fields.		long long SerialNumber = (LicenseA >> LicenseASNShift) & LicenseASNMask;		if (!SetSerialNumberTime((SerialNumber >> LicenseASNTimeShift) & LicenseASNTimeMask))		return false;		long long SNDate = (SerialNumber >> LicenseASNDateShift) & LicenseASNDateMask;		short year = ((SNDate >> LicenseADateYearShift) & LicenseADateYearMask) + LicenseDateYearOffset;		if (!SetSerialNumberYear(year))		return false;		if (!SetSerialNumberMonth((SNDate >> LicenseADateMonthShift) & LicenseADateMonthMask))		return false;		if (!SetSerialNumberDay((SNDate >> LicenseADateDayShift) & LicenseADateDayMask))		return false;		// Now we disassemble the LicenseB bits					  	if (!SetType((LicenseB >> LicenseBTypeShift) & LicenseBTypeMask))		return false;		long long ExpDate = (LicenseB >> LicenseBExpShift) & LicenseBExpMask;		year = ((ExpDate >> LicenseADateYearShift) & LicenseADateYearMask) + LicenseDateYearOffset;	if (!SetExpYear(year))		return false;				  	    	if (!SetExpMonth((ExpDate >> LicenseADateMonthShift) & LicenseADateMonthMask))		return false;				  	    	if (!SetExpDay((ExpDate >> LicenseADateDayShift) & LicenseADateDayMask))		return false;		long increment = ((LicenseB >> LicenseBIncShift) & LicenseBIncMask) * LicenseIncMultiplier;		if (!SetIncrement(increment))		return false;				  	    	if (((LicenseB >> LicenseBVersShift) & LicenseBVersMask) != LicenseCurrentVers)		return false;		return true;	}bool EyeDxLicenseInfo::FormatSerialNumber(char *serialNumberString){	sprintf(serialNumberString, "%4d-%02d-%02d-%06d", GetSerialNumberYear(), GetSerialNumberMonth(),								GetSerialNumberDay(), GetSerialNumberTime());	return true;}void EyeDxLicenseInfo::DecodeDateCode(long dateCode, short &year, short &month, short &day){	year = ((dateCode >> LicenseADateYearShift) & LicenseADateYearMask) + LicenseDateYearOffset;	month = (dateCode >> LicenseADateMonthShift) & LicenseADateMonthMask;	day = (dateCode >> LicenseADateDayShift) & LicenseADateDayMask;}long EyeDxLicenseInfo::CreateTodayAsDateCode(){	long dateCode;	long day;	long month;	long year;	#ifndef macintosh	time_t	aclock;	time (&aclock);		CTime theTimeNow(aclock);	day = theTimeNow.GetDay();	month = theTimeNow.GetMonth();	year = theTimeNow.GetYear();	#else	DateTimeRec theTimeNow;	::GetTime(&theTimeNow);		day = theTimeNow.day;	month = theTimeNow.month;	year = theTimeNow.year;	#endif		// Had to break this out as the 68K compiler optimized the shifting of the year incorrectly		year = year - LicenseDateYearOffset;	year = year << LicenseADateYearShift;	month = month << LicenseADateMonthShift;	day|= day << LicenseADateDayShift;	dateCode = year | month | day;		return (dateCode);}