// main.cp#include "main.h"BEGIN_MESSAGE_MAP( CMFCSummaryDlg, CDialog )ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)ON_BN_CLICKED(IDC_SUMMARY_RETAKE_UP, OnRetakeUpPressed)ON_BN_CLICKED(IDC_SUMMARY_RETAKE_SIDE, OnRetakeSidePressed)ON_BN_CLICKED(IDC_SUMMARY_REPORT, OnReportPressed)ON_BN_CLICKED(IDC_SUMMARY_REPORT, OnReportPressed)ON_BN_CLICKED(IDC_SUMMARY_UP_ZOOM_BUTTON, OnUpZoomButtonClicked)ON_BN_CLICKED(IDC_SUMMARY_SIDE_ZOOM_BUTTON, OnSideZoomButtonClicked)END_MESSAGE_MAP()CEyeDxBooleanType CMFCSummaryDlg::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);			CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}// This structure maps the eye images to the corresponding window elementsstatic int eyeImages[kNumEyeImages] ={	IDC_SUMMARY_EYE0_VIEW,	IDC_SUMMARY_EYE1_VIEW,	IDC_SUMMARY_EYE2_VIEW,	IDC_SUMMARY_EYE3_VIEW,	IDC_SUMMARY_EYE4_VIEW,	IDC_SUMMARY_EYE5_VIEW,	IDC_SUMMARY_EYE6_VIEW,	IDC_SUMMARY_EYE7_VIEW};CEyeDxBooleanType CMFCSummaryDlg::OnInitDialog(){	CDialog::OnInitDialog();	CenterWindow();			EnableToolTips(TRUE);		m_ctlResultsCaption = (CStatic *) GetDlgItem(IDC_SUMMARY_NOTE_CAPTION);	m_ctlNameCaption = (CStatic *) GetDlgItem(IDC_SUMMARY_NAME_CAPTION);	m_ctlUpCaption = (CStatic *) GetDlgItem(IDC_SUMMARY_UP_CAPTION);	m_ctlSideCaption = (CStatic *) GetDlgItem(IDC_SUMMARY_SIDE_CAPTION);	m_ctlUpTopCaption = (CStatic *) GetDlgItem(IDC_SUMMARY_UP_TOP_RESULTS);	m_ctlSideTopCaption = (CStatic *) GetDlgItem(IDC_SUMMARY_SIDE_TOP_RESULTS);	m_ctlBottomCaption1 = (CStatic *) GetDlgItem(IDC_SUMMARY_BOTTOM_CAPTION_1);	m_ctlBottomCaption2 = (CStatic *) GetDlgItem(IDC_SUMMARY_BOTTOM_CAPTION_2);	m_ctlRetakeUpButton = (CButton *) GetDlgItem(IDC_SUMMARY_RETAKE_UP);	m_ctlRetakeSideButton = (CButton *) GetDlgItem(IDC_SUMMARY_RETAKE_SIDE);	m_ctlStartOverButton = (CButton *) GetDlgItem(IDCANCEL);	m_ctlDoneButton = (CButton *) GetDlgItem(IDOK);	m_ctlUpThumbnail.SubclassDlgItem(IDC_SUMMARY_UP_VIEW, this);	m_ctlSideThumbnail.SubclassDlgItem(IDC_SUMMARY_SIDE_VIEW, this);	m_ctlUpZoomButton.SubclassDlgItem(IDC_SUMMARY_UP_ZOOM_BUTTON, this);	m_ctlSideZoomButton.SubclassDlgItem(IDC_SUMMARY_SIDE_ZOOM_BUTTON, this);	m_ctlUpZoomButton.LoadBitmaps("ZoomButtonU", "ZoomButtonD", "ZoomButtonF", NULL);	m_ctlSideZoomButton.LoadBitmaps("ZoomButtonU", "ZoomButtonD", "ZoomButtonF", NULL);	m_ctlNameCaption->SetWindowText(m_Results->ReportName);		switch (m_Results->ReferralCode)	{	case kYesReferralCode:		m_ctlResultsCaption->SetWindowText("Refer");		break;			case kNoReferralCode:		m_ctlResultsCaption->SetWindowText("Pass");			break;			case kSecondImageReferralCode:		m_ctlResultsCaption->SetWindowText("Second image required.");			break;			case kUnclearReferralCode:		m_ctlResultsCaption->SetWindowText("Image(s) unclear. Please repeat.");		break;			}	// If the caller doesn't want us to provide the retake options, hide a couple buttons	// And change the label on the default button		if (!m_ShowRetakeOptions)	{		m_ctlRetakeUpButton->ShowWindow(SW_HIDE);		m_ctlRetakeSideButton->ShowWindow(SW_HIDE);		m_ctlStartOverButton->ShowWindow(SW_HIDE);		m_ctlDoneButton->SetWindowText("Exit to Main Window");	}	// Force the default to something reasonable - there appears to be a bug in Windows - I cannot	// set the specific Retake Up or Retake Side buttons as default if they are visible. The DEFPUSHBUTTON	// (actually the FIRST push button) is _always_ the default! GRRRRRRRRRR.		//GotoDlgCtrl(m_ctlDoneButton);				switch (m_Results->ResultsCode)	{	case kNoErrors:		if (m_ShowRetakeOptions)		{			m_ctlBottomCaption1->SetWindowText("Final Check: Do the eyes appear to be captured properly?");			m_ctlBottomCaption2->SetWindowText("Yes: Press 'Done With Subject'    No: Press 'Retake Both'.");		}		else		{			m_ctlBottomCaption1->SetWindowText("Final Check: Be sure the eyes are captured properly.");			m_ctlBottomCaption2->SetWindowText("If not, retake picture(s) and rerun.");		}				break;			case kRetakeUp:		if (m_ShowRetakeOptions)		{			m_ctlBottomCaption1->SetWindowText("EyeDx recommends you press the Retake Up button.");			//GotoDlgCtrl(m_ctlRetakeSideButton);				}		else			m_ctlBottomCaption1->SetWindowText("EyeDx recommends you retake the Up picture.");				break;			case kRetakeSide:		if (m_ShowRetakeOptions)		{			m_ctlBottomCaption1->SetWindowText("EyeDx recommends you press the Retake Side button.");			//GotoDlgCtrl(m_ctlRetakeSideButton);				}		else			m_ctlBottomCaption1->SetWindowText("EyeDx recommends you retake the Side picture.");		break;			case kRetakeBoth:		if (m_ShowRetakeOptions)		{			m_ctlRetakeUpButton->ShowWindow(SW_HIDE); // No need for this, since the Retake Both button does this			m_ctlRetakeSideButton->ShowWindow(SW_HIDE); // No need for this, since the Retake Both button does this			m_ctlBottomCaption1->SetWindowText("EyeDx recommends you press the Retake Both button.");			//GotoDlgCtrl(m_ctlStartOverButton);		}		else			m_ctlBottomCaption1->SetWindowText("EyeDx recommends you retake both pictures.");					break;			}		m_ctlUpCaption->SetWindowText(m_Results->UpName);		m_ctlSideCaption->SetWindowText(m_Results->SideName);	// By default we hide the caption		m_ctlUpTopCaption->ShowWindow(SW_HIDE);	m_ctlSideTopCaption->ShowWindow(SW_HIDE);	CString path = DataPath;	int rows, cols;	unsigned char *rawdata;	path +=  m_Results->Simage_path[kUpSimage];		FILE *fileptr = fopen(path, "rb");		if (!fileptr)	{		MessageBox("Cannot open scaled image file.", AfxGetAppName());	}	else					{		if (ReadImage(fileptr, &rawdata, &rows, &cols,m_Results->Simage_path[kUpSimage], this, NULL, NULL, TRUE))		{			m_ctlUpThumbnail.SetImageFromRaw24Bit(rawdata, rows, cols);			free(rawdata);		}	}	path = DataPath;		path +=  m_Results->Simage_path[kSideSimage];		fileptr = fopen(path, "rb");		if (!fileptr)	{		MessageBox("Cannot open scaled image file.", AfxGetAppName());	}	else					{		if (ReadImage(fileptr, &rawdata, &rows, &cols,m_Results->Simage_path[kSideSimage], this, NULL, NULL, TRUE))		{			m_ctlSideThumbnail.SetImageFromRaw24Bit(rawdata, rows, cols);			free(rawdata);		}	}	// Now, we read in the eye images. If a particular image file doesn't exist, we skip it.	// Also, we display only the annotated images, which are the last 4 in the table		for (short i = kUpRightAnnotEye; i < kNumEyeImages; i++)	{		m_ctlEyeThumbnail[i].SubclassDlgItem(eyeImages[i], this);			m_RawEyeData[i] = NULL;				// We get the path of the eye image. If it is an empty string, we skip it. Otherwise, we open the		// file, and set the corresponding thumbnail to the image data.				if (strlen(m_Results->eye_image_path[i]) > 0)		{			path = DataPath;			path +=  m_Results->eye_image_path[i];						FILE *fileptr = fopen(path, "rb");						if (!fileptr)			{				MessageBox("Cannot open eye image file.", AfxGetAppName());			}			else							{				if (ReadImage(fileptr, &m_RawEyeData[i], &m_EyeRows, &m_EyeCols, m_Results->eye_image_path[i], this, NULL, NULL, TRUE))				{					m_ctlEyeThumbnail[i].SetImageFromRaw24Bit(m_RawEyeData[i], m_EyeRows, m_EyeCols);					m_ctlEyeThumbnail[i].ShowWindow(SW_SHOW);				}			}		}		else			m_ctlEyeThumbnail[i].ShowWindow(SW_HIDE);	}		CString m_ctlAnnotation;	CString m_ctlTempAnnotation;	CEyeDxBooleanType append = false;		// Now that the images are set up, we show the necessary captions		// If this string is set, we append it to the top annotation		if (strlen(m_Results->eye_image_annot[kUpBottomResult]) > 0)	{		// Remove any newlines - replace with spaces		char *p = m_Results->eye_image_annot[kUpBottomResult];		while (*p)		{			if (*p == '\n' || *p == '\r')				*p = ' ';			p++;		}		m_ctlTempAnnotation = m_Results->eye_image_annot[kUpBottomResult];		append = true;	}		if (strlen(m_Results->eye_image_annot[kUpTopResult]) > 0)	{		// Remove any newlines - replace with spaces		char *p = m_Results->eye_image_annot[kUpTopResult];		while (*p)		{			if (*p == '\n' || *p == '\r')				*p = ' ';			p++;		}				m_ctlAnnotation = m_Results->eye_image_annot[kUpTopResult];		if (append)		{			m_ctlAnnotation += " ";			m_ctlAnnotation += m_ctlTempAnnotation;			append = false;		}		m_ctlUpTopCaption->SetWindowText(m_ctlAnnotation);		m_ctlUpTopCaption->ShowWindow(SW_SHOW);	}		if (strlen(m_Results->eye_image_annot[kSideBottomResult]) > 0)	{		// Remove any newlines - replace with spaces		char *p = m_Results->eye_image_annot[kSideBottomResult];		while (*p)		{			if (*p == '\n' || *p == '\r')				*p = ' ';			p++;		}		m_ctlTempAnnotation = m_Results->eye_image_annot[kSideBottomResult];		append = true;	}		if (strlen(m_Results->eye_image_annot[kSideTopResult]) > 0)	{		// Remove any newlines - replace with spaces		char *p = m_Results->eye_image_annot[kSideTopResult];		while (*p)		{			if (*p == '\n' || *p == '\r')				*p = ' ';			p++;		}		m_ctlAnnotation = m_Results->eye_image_annot[kSideTopResult];		if (append)		{			m_ctlAnnotation += " ";			m_ctlAnnotation += m_ctlTempAnnotation;			append = false;		}		m_ctlSideTopCaption->SetWindowText(m_ctlAnnotation);		m_ctlSideTopCaption->ShowWindow(SW_SHOW);	}	// Got this from a MFC Hints and Tips web page		DWORD nNewDefID = IDOK;		if (m_ShowRetakeOptions)	{					switch (m_Results->ResultsCode)		{		case kNoErrors:			nNewDefID = IDOK;			break;					case kRetakeUp:			nNewDefID = IDC_SUMMARY_RETAKE_UP;									break;					case kRetakeSide:			nNewDefID = IDC_SUMMARY_RETAKE_SIDE;			break;					case kRetakeBoth:			nNewDefID = IDCANCEL;							break;				} 	}			// ... Set the new default button	SetDefID(nNewDefID);	// ... Add a border to the new default button	SendDlgItemMessage(nNewDefID, BM_SETSTYLE, BS_DEFPUSHBUTTON, (LPARAM)TRUE);	 	                                    	return TRUE;}void CMFCSummaryDlg::OnOK(){	m_NextStep = kNextStepContinue;	for (short i = kUpRightAnnotEye; i < kNumEyeImages; i++)			free(m_RawEyeData[i]);	CDialog::OnOK();}void CMFCSummaryDlg::OnRetakeUpPressed(){	m_NextStep = kNextStepRetakeUp;	for (short i = kUpRightAnnotEye; i < kNumEyeImages; i++)			free(m_RawEyeData[i]);	CDialog::OnOK();}void CMFCSummaryDlg::OnRetakeSidePressed(){	m_NextStep = kNextStepRetakeSide;	for (short i = kUpRightAnnotEye; i < kNumEyeImages; i++)			free(m_RawEyeData[i]);	CDialog::OnOK();}void CMFCSummaryDlg::OnCancel(){	m_NextStep = kNextStepRetakeBoth;	for (short i = kUpRightAnnotEye; i < kNumEyeImages; i++)			free(m_RawEyeData[i]);			CDialog::OnCancel();}void CMFCSummaryDlg::OnReportPressed(){	char updatedReportName[MAX_PATHNAME_CHARS];	 		// We have to create the entire path to pass to the OpenReport routine, as it is used to	// possibly open reports that are stored elsewhere.		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	CString thePath;		m_MainWindow->CreateReportPath(thePath, theVariable->GetValue(), m_Results);		OpenReport(thePath);}void CMFCSummaryDlg::OnUpZoomButtonClicked(){	CEyeDxLongStringType theFileName = up_filename;				m_MainWindow->HandleSummaryZoom(this, &theFileName, up_image, UP_ROWS, UP_COLS, m_RawEyeData[kUpRightAnnotEye], m_RawEyeData[kUpLeftAnnotEye], m_EyeRows, m_EyeCols);}		void CMFCSummaryDlg::OnSideZoomButtonClicked(){	CEyeDxLongStringType theFileName = side_filename;				m_MainWindow->HandleSummaryZoom(this, &theFileName, side_image, SIDE_ROWS, SIDE_COLS, m_RawEyeData[kSideRightAnnotEye], m_RawEyeData[kSideLeftAnnotEye], m_EyeRows, m_EyeCols);}