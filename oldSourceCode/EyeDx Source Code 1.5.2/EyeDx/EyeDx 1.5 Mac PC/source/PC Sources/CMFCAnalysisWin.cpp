#include "main.h"static LPCTSTR lpszClassName="EyeDxANA";static LPCTSTR lpszWindowName="Analysis";extern CMainApp gMainApp;CMFCAnalysisWin::CMFCAnalysisWin(CRect *posRect, CMainWindow *myParent, int SaveFullInputImages, 								 int AdjustReportName, EyeDxReportFormat reportFormat,								 CStringArray *userTextBlocks,								 AnalysisResults *pResults){	// This creates the Run From Disk window			CString strWndClass = AfxRegisterWndClass(		CS_DBLCLKS,		gMainApp.LoadStandardCursor(IDC_ARROW),		(HBRUSH) (COLOR_3DFACE + 1),		gMainApp.LoadIcon("ID_EYEDX_ICON_SM"));			CreateEx(0, strWndClass, lpszWindowName, 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,		posRect->left, posRect->top, posRect->Width(), posRect->Height(), 		NULL, NULL);	// Save the pointer to my parent so I can use it later to set its position				m_Parent = myParent;		m_VariableList = gGlobalProperties->GetVariableList();		m_SaveFullInputImages = SaveFullInputImages;		m_AdjReport = AdjustReportName;		m_Results = pResults;		m_UserTextBlocks = userTextBlocks;		m_ReportFormat = reportFormat;}BEGIN_MESSAGE_MAP( CMFCAnalysisWin, CWnd )ON_WM_CREATE()ON_WM_CLOSE()ON_MESSAGE(EYEDX_MFC_ANALYSIS_START_MESSAGE, StartAnalysis)ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)END_MESSAGE_MAP()CEyeDxBooleanType CMFCAnalysisWin::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);		CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}// If the user closes this window - we must tell the parent to close as// well, or else it is left hanging around. However, even if we send ourselves// a close message, this routine gets called. So, the m_MessageToSend variable is// set to WM_CLOSE most of the time, until the very end, when it is changed to// EYEDX_MFC_ANALYSIS_COMPLETE_MESSAGEvoid CMFCAnalysisWin::OnClose(){	//AfxGetMainWnd()->SendMessage(m_MessageToSend, 0, 0);	m_Parent->SendMessage(m_MessageToSend, 0, 0);	CWnd::OnClose();}// This function first sends a message to the// main window telling it that the ok button was pressed, and then we delete// ourselvesvoid CMFCAnalysisWin::PostNcDestroy(){	delete this;}void CMFCAnalysisWin::StartAnalysis(UINT /*wParam*/, LONG /*lParam*/){	CWaitCursor wait;	// Show the wait cursor while we analyze the images	m_ctlUpView.ResetImage();	m_ctlSideView.ResetImage();	m_ctlMainView.ResetImage();	// Now, set up the analysis window. If the Display Graphics flag is set, we	// hide the two small thumbnail views, and enable the larger view. Otherwise,	// we set the thumbnail views to match the images in the Run window views	// We first hide all of the views so that they don't change state while the window	// is visible		m_ctlUpView.ShowWindow(SW_HIDE);	m_ctlSideView.ShowWindow(SW_HIDE);	m_ctlMainView.ShowWindow(SW_HIDE);		m_ctlProgressCaption.ShowWindow(SW_SHOW);	m_ctlProgressBar.ShowWindow(SW_SHOW);		if (DisplayGraphics)	{		m_ctlMainView.ShowWindow(SW_SHOW);	}	else	{		m_ctlUpView.ShowWindow(SW_SHOW);		m_ctlSideView.ShowWindow(SW_SHOW);				m_ctlUpCaption.SetWindowText(up_filename);		m_ctlUpCaption.ShowWindow(SW_SHOW);				m_ctlSideCaption.SetWindowText(side_filename);		m_ctlSideCaption.ShowWindow(SW_SHOW);		m_ctlUpView.SetImageFromRaw24Bit(up_image, UP_ROWS, UP_COLS);		m_ctlSideView.SetImageFromRaw24Bit(side_image, SIDE_ROWS,SIDE_COLS);	}	// Force the window to update before we call the analysis routine			UpdateWindow();		char *reportText[kReportLayoutNumText];	long reportTextSize[kReportLayoutNumText];		// Convert each of the text blocks into a pointer and a length		CString debugStr;		for (long i = 0; i < kReportLayoutNumText; i++)	{			if (i <= m_UserTextBlocks->GetUpperBound())		{			CString theString = m_UserTextBlocks->GetAt(i);			reportText[i] = theString;			reportTextSize[i] = strlen(reportText[i]);		}		else		{			reportText[i] = NULL;			reportTextSize[i] = 0;		}	}		EyeDx(up_filename, side_filename, SideWhichWay, FALSE, m_AdjReport, 			m_Results, this, &m_ctlMainView, &m_ctlProgressBar, &m_ctlProgressCaption,				m_ReportFormat,				m_VariableList,				reportText,				reportTextSize,				kReportLayoutNumText);				RunInProgress = 0;		// Decrement the license count if the analysis was successful		LicenseError theStatus = m_Parent->UpdateLicenseCounter(m_Results->ReferralCode);			// Show the Main Window before we go away so that the transition is less	// abrupt		m_Parent->ShowWindow(SW_SHOW);		// Once we are done, hide the Analysis window and send a message to the parent window that	// we are done		m_MessageToSend = EYEDX_MFC_ANALYSIS_COMPLETE_MESSAGE;	PostMessage(WM_CLOSE, 0, 0);}int CMFCAnalysisWin::OnCreate(LPCREATESTRUCT lpcs){	if (CWnd::OnCreate(lpcs) == -1)		return -1;			// Set the sizes and positions of window elements based on the font for the window.	// This will account for larger font sizes that the user may select for the GUI.		CClientDC dc(this);		TEXTMETRIC tm;		dc.GetTextMetrics(&tm);	m_cxChar = tm.tmAveCharWidth;	m_cyChar = tm.tmHeight + tm.tmExternalLeading;		// Create a font for the static text elements in the window - they will be smaller than	// the normal boldface font.		int nHeight = -tm.tmHeight * 0.75;		m_ctlFont.CreateFont(nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,					CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, NULL);						CRect rect;		GetClientRect(&rect);		int WindowWidth = (rect.right-rect.left) / m_cxChar;		int CenterLine = WindowWidth / 2;		int LeftCenterLine = (ANALYSIS_VIEW_WIDTH / 2) + ANALYSIS_RIGHT_MARGIN;		int RightCenterLine = WindowWidth - ANALYSIS_RIGHT_MARGIN - (ANALYSIS_VIEW_WIDTH / 2);			// Analysis Progress caption		rect.SetRect(m_cxChar * ANALYSIS_PROGRESS_CAPTION_X, 				 m_cyChar * ANALYSIS_PROGRESS_CAPTION_Y, 				 m_cxChar * (ANALYSIS_PROGRESS_CAPTION_X + ANALYSIS_PROGRESS_CAPTION_WIDTH(WindowWidth)), 				 m_cyChar * (ANALYSIS_PROGRESS_CAPTION_Y + ANALYSIS_PROGRESS_CAPTION_HEIGHT));		m_ctlProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_ANALYSIS_PROGRESS_CAPTION);	m_ctlProgressCaption.SetFont(&m_ctlFont);	// Analysis Progress bar		rect.SetRect(m_cxChar * ANALYSIS_PROGRESS_BAR_X(WindowWidth), 				 m_cyChar * ANALYSIS_PROGRESS_BAR_Y, 				 m_cxChar * (ANALYSIS_PROGRESS_BAR_X(WindowWidth) + ANALYSIS_PROGRESS_BAR_WIDTH(WindowWidth)), 				 m_cyChar * (ANALYSIS_PROGRESS_BAR_Y + ANALYSIS_PROGRESS_BAR_HEIGHT));	m_ctlProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_ANALYSIS_PROGRESS_BAR);	// Up Image View		rect.SetRect(m_cxChar * ANALYSIS_UP_VIEW_X(LeftCenterLine), 				 m_cyChar * ANALYSIS_UP_VIEW_Y, 				 m_cxChar * (ANALYSIS_UP_VIEW_X(LeftCenterLine) + ANALYSIS_UP_VIEW_WIDTH), 				 m_cyChar * (ANALYSIS_UP_VIEW_Y + ANALYSIS_UP_VIEW_HEIGHT));		m_ctlUpView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_ANALYSIS_UP_VIEW);		// Side Image View		rect.SetRect(m_cxChar * ANALYSIS_SIDE_VIEW_X(RightCenterLine), 				 m_cyChar * ANALYSIS_SIDE_VIEW_Y, 				 m_cxChar * (ANALYSIS_SIDE_VIEW_X(RightCenterLine) + ANALYSIS_SIDE_VIEW_WIDTH), 				 m_cyChar * (ANALYSIS_SIDE_VIEW_Y + ANALYSIS_SIDE_VIEW_HEIGHT));		m_ctlSideView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_ANALYSIS_SIDE_VIEW);	// Up Image caption		rect.SetRect(m_cxChar * ANALYSIS_UP_CAPTION_X(LeftCenterLine), 				 m_cyChar * ANALYSIS_UP_CAPTION_Y, 				 m_cxChar * (ANALYSIS_UP_CAPTION_X(LeftCenterLine) + ANALYSIS_UP_CAPTION_WIDTH), 				 m_cyChar * (ANALYSIS_UP_CAPTION_Y + ANALYSIS_UP_CAPTION_HEIGHT));		m_ctlUpCaption.Create("", WS_CHILD | SS_LEFT, rect, this, IDC_ANALYSIS_UP_CAPTION);	m_ctlUpCaption.SetFont(&m_ctlFont);		// Side Image caption		rect.SetRect(m_cxChar * ANALYSIS_SIDE_CAPTION_X(RightCenterLine), 				 m_cyChar * ANALYSIS_SIDE_CAPTION_Y, 				 m_cxChar * (ANALYSIS_SIDE_CAPTION_X(RightCenterLine) + ANALYSIS_SIDE_CAPTION_WIDTH), 				 m_cyChar * (ANALYSIS_SIDE_CAPTION_Y + ANALYSIS_SIDE_CAPTION_HEIGHT));		m_ctlSideCaption.Create("", WS_CHILD | SS_LEFT, rect, this, IDC_ANALYSIS_SIDE_CAPTION);	m_ctlSideCaption.SetFont(&m_ctlFont);	// Animation Image View		rect.SetRect(m_cxChar * ANALYSIS_MAIN_VIEW_X, 				 m_cyChar * ANALYSIS_MAIN_VIEW_Y, 				 m_cxChar * (ANALYSIS_MAIN_VIEW_X + ANALYSIS_MAIN_VIEW_WIDTH(WindowWidth)), 				 m_cyChar * (ANALYSIS_MAIN_VIEW_Y + ANALYSIS_MAIN_VIEW_HEIGHT));		m_ctlMainView.Create("", WS_CHILD | SS_BITMAP | SS_SUNKEN, rect, this, IDC_ANALYSIS_MAIN_VIEW);		// The default message to send if the window is closed is to send a close to the	// parent as well		m_MessageToSend = WM_CLOSE;	// Finally, enable ToolTips for our window		EnableToolTips(TRUE);	// Once we are done, send a message to ourselves to start the analysis process. This	// will guarantee that the window is visible.		PostMessage(EYEDX_MFC_ANALYSIS_START_MESSAGE, 0, 0);		return 0;}