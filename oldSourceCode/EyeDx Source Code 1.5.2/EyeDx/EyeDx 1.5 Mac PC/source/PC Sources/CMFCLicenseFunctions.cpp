// =================================================================================//	CMFCLicenseFunctions.cpp					©1999 EyeDx, Inc. All rights reserved.// =================================================================================#include "main.h"#include <afx.h>const CString	kLicenseFileName = "EyeDxMisc";void CMainWindow::GetLicenseExpDateString(CString &theString){	// We use the international utilities to format the date as expected for the locale		short year;	short month;	short day;		EyeDxLicenseInfo::DecodeDateCode(mLicenseExpDateCode, year, month, day);	CTime theDateRec(year, month, day, 23, 59, 59);		theString = theDateRec.Format("%x");}void CMainWindow::GetLicenseCountString(CString &theString){	theString.Format("%d",  mLicenseCount);}void CMainWindow::SetLicenseStatusCaption(CEyeDxCaptionType *theCaption){	// Display the license status		CString theStatusLine;	CString theString;		GetLicenseCountString(theStatusLine);			theStatusLine = theStatusLine + " Runs Remaining, Valid Through ";		GetLicenseExpDateString(theString);		theStatusLine = theStatusLine + theString + ".";	theCaption->SetWindowText(theStatusLine);			}void CMainWindow::HandleLicenseDisplay(enum LicenseStatus theStatus){	if (theStatus == LicenseStatusNotInstalled)	{		MessageBox("There is no license installed.", AfxGetAppName());		return;	}		CMFCLicenseStatusDlg rdlg(theStatus, this);		rdlg.DoModal();}void CMainWindow::DisplayLicense(){	HandleLicenseDisplay(GetLicenseStatus());}void CMainWindow::HandleLicenseExpired(enum LicenseStatus inLicenseStatus){	CMFCLicenseExpiredDlg rdlg(inLicenseStatus, this);		rdlg.DoModal();}int CMainWindow::HandleLicenseEntry(enum LicenseStatus inLicenseStatus, CEyeDxBooleanType exitPrompt){	time_t	aclock;	time( &aclock );								 /* Get time in seconds */	CTime theTime(aclock);	CString theTimeString = "Is today ";	theTimeString += theTime.Format("%x");	theTimeString += "? If this is NOT today's date, you MUST set the computer's\nclock properly before installing the license.\n\nIf the year shown is 1980, the battery is most likely dead and must be replaced first.";	if (MessageBox(theTimeString, AfxGetAppName(), MB_YESNO) == IDNO)	{		if (exitPrompt)			exit(0);		else			return IDCANCEL;	}	CMFCLicenseEntryDlg rdlg(inLicenseStatus, exitPrompt, this);		int returnVal = rdlg.DoModal();		if (returnVal == IDOK)	{		// Display a notice showing the updated license information						HandleLicenseDisplay(GetLicenseStatus());	}	return returnVal;}int CMainWindow::EnterLicense(){	return (HandleLicenseEntry(GetLicenseStatus(), false));}// Values used to convert the long long values into two longsconst long long kLongLongLowerMask = 0x000000000ffffffff;const long		kLongLongUpperShift = 32;LicenseError CMainWindow::EncodeLicenseFileData(LicenseData *inLicenseData){	// We take the 	mLicenseExpDateCode, mLicenseCount, mLicenseSN, and mLicenseLastUse	// member values and encode them into the passed data structure. We also calculate	// a checksum for the record to prevent tamering.		// Clear the structure first		memset(inLicenseData, 0, sizeof(LicenseData));	// The fields are negated before being set		inLicenseData->version = kMISCVers1;	inLicenseData->expDate = -mLicenseExpDateCode;				inLicenseData->lastUseDate = -mLicenseLastUse;	inLicenseData->availableRuns = -mLicenseCount;		inLicenseData->serialNumberLow = -(mLicenseSN & kLongLongLowerMask);	inLicenseData->serialNumberHigh = -((mLicenseSN >> kLongLongUpperShift) & kLongLongLowerMask);	inLicenseData->checksum = -(inLicenseData->version +								inLicenseData->expDate + 								inLicenseData->lastUseDate +								inLicenseData->availableRuns +								inLicenseData->serialNumberLow +								inLicenseData->serialNumberHigh);	// The other fields are zero		return kLicenseNoError;}LicenseError CMainWindow::DecodeLicenseFileData(LicenseData *inLicenseData){	// We take the structure checksum for a valid value, and then check the individual fields	// for reasonable values. If all are reasonable, we transfer the values to the data members	// mLicenseExpDateCode, mLicenseCount, mLicenseSN, and mLicenseLastUse..		// Check the checksum. We chould be able to add up all of the fields and get zero.		long checksum = 0;		checksum = inLicenseData->checksum + inLicenseData->version +										 inLicenseData->expDate + 										 inLicenseData->lastUseDate +										 inLicenseData->availableRuns +										 inLicenseData->serialNumberLow +										 inLicenseData->serialNumberHigh;	// The other fields are zero				if (checksum != 0)		return kLicenseErrorNoLicense;			// The fields are negated before being set		if (inLicenseData->version != kMISCVers1)		return kLicenseErrorNoLicense;			// We check to see if the number of available runs is greater than -1 (0 is a valid number in this case) and	// less than a reasonably large number - currently 4000000.		if ((-inLicenseData->availableRuns < 0) || (-inLicenseData->availableRuns > (LicenseIncMaximum * LicenseIncMultiplier * 100)))		return kLicenseErrorNoLicense;		// Currently, we don't check the SN or date fields for validity.		mLicenseSN = ((-inLicenseData->serialNumberHigh) << kLongLongUpperShift) | (-inLicenseData->serialNumberLow);	mLicenseExpDateCode = -inLicenseData->expDate;				mLicenseLastUse = -inLicenseData->lastUseDate;		mLicenseCount = -inLicenseData->availableRuns;		return kLicenseNoError;}// This routine will check the mLicenseData member for status - either Valid,// Not Installed, or one of three Expired states (Date, Count, or Both),// and return the appropriate value. The first time through, it loads the// license information into the mLicenseData member functionLicenseStatus CMainWindow::GetLicenseStatus(){	LicenseError theError = LoadLicense();	if (theError == kLicenseErrorNoLicense)		return LicenseStatusNotInstalled;							LicenseStatus theStatus = LicenseStatusValid;		if (mLicenseExpDateCode < EyeDxLicenseInfo::CreateTodayAsDateCode())		theStatus = LicenseStatusExpiredDate;			if (mLicenseCount == 0)	{		if (theStatus == LicenseStatusExpiredDate)			theStatus = LicenseStatusExpiredBoth;		else			theStatus = LicenseStatusExpiredCount;	}		if (mLicenseLastUse > EyeDxLicenseInfo::CreateTodayAsDateCode())		theStatus = LicenseStatusDateOutOfRange;		return theStatus;}// This routine takes a license info object pointer and extracts the count, serial number, and// expiration date from the license. It checks the serial number against the license currently// installed (if any). If the serial number in the new license is less than or equal to the// currently-installed serial number, an error is reported// and the license is not updated. Likewise, the date is also checked.// If the license passes the tests, the routine adds the count to the existing mLicenseCount field,// saves the expiration date and serial number, and then writes out the new license information.LicenseError CMainWindow::UpdateLicense(EyeDxLicenseInfo *theLicense){	// The new license's serial number must be greater than the current one		if (mLicenseSN >= theLicense->GetSerialNumber())		return (kLicenseReuseError);		// The date codes can be directly compared, as older dates are smaller numbers.	// If for some reason they are installing a license that has an older expiration	// date than the license currently installed, that's an error.		if (mLicenseExpDateCode > theLicense->GetExpDateCode())		return (kLicenseNewOlderThanInstalledError);			// Also, the new license date code must be in the future - otherwise they are	// installing an expired license! We do allow the license to be today's date.		if (EyeDxLicenseInfo::CreateTodayAsDateCode() > theLicense->GetExpDateCode())		return (kLicenseExpiredError);	// Everything looks ok. Add the increment to the current number of available licenses.	// This number may be zero if no license is currently installed. We also save the	// new expiration date code and serial number.		mLicenseCount += theLicense->GetIncrement();	mLicenseExpDateCode = theLicense->GetExpDateCode();	mLicenseSN = theLicense->GetSerialNumber();		return (SaveLicense());}// This routine will load the mLicenseDate and mLicenseCount members from the license files// and do basic validation checking. Both license files must exist, and// the must be the same.LicenseError CMainWindow::LoadLicense(){	LicenseData thePrimaryLicenseData;	LicenseData theBackupLicenseData;			if (mPrimaryLicense == NULL)	{		// Create the primary license file object. This one takes just a filename and		// it will be created in the Windows folder as an invisible file.				char theWindowsDirectory[MAX_FILENAME_CHARS];		GetWindowsDirectory(theWindowsDirectory, MAX_FILENAME_CHARS);		CString theWindowsLicenseFile = theWindowsDirectory;		theWindowsLicenseFile += "\\";		theWindowsLicenseFile += kLicenseFileName;				mPrimaryLicense = new CMFCEyeDxLicenseFile(theWindowsLicenseFile);	}		if (mBackupLicense == NULL)	{		// Now, do the same for the backup file. This requires us to create a file spec		// based on the desired name and the desired folder. Currently, we use the EyeDx		// Folder.				CString theEyeDxLicenseFile = DataPath + kLicenseFileName;				mBackupLicense = new CMFCEyeDxLicenseFile(theEyeDxLicenseFile);	}		// Now that we have the objects, load the information. Note that we read the	// files _every_ time this routine is called to ensure that the user isn't playing	// around with the files.					mPrimaryLicense->LoadLicense(&thePrimaryLicenseData);		mBackupLicense->LoadLicense(&theBackupLicenseData);		// Ok. We now have the two license files. They have been created, and should be	// invisible. If they existed prior to these calls, the structures thePrimaryLicenseData	// and theBackupLicenseData should contain valid license information.		// There are four cases we have to deal with (failed == no license):	//	// 1. Load of primary failed but backup was ok - use the backup as the license.	// 2. Load of primary succeeded but backup failed - use the primary as the license.	// 3. Both loads failed - no license is installed.	// 4. Both loads succeeded - we just use the primary data.	//	// The SaveLicense routine will write both of the files, so they will be	// in sync at the end of this routine - we call SaveLicense.		mLicenseExpDateCode = 0;	mLicenseCount = 0;	mLicenseSN = 0;	mLicenseLastUse = 0L;		LicenseError returnVal = kLicenseNoError;	// First decode and validate the primary license. If it's ok, then we've taken care of cases	// 2 and 4 - just use the primary as the master. This routine will also fill-in the	// passed variables with the decoded values if the decoding succeeds, otherwise it will leave	// them alone.		returnVal = DecodeLicenseFileData(&thePrimaryLicenseData);		if (returnVal != kLicenseNoError)	{		// Primary is bad. This is case 1 or 3. Try decoding the backup data. If this fails, that's case 3 and there		// is no license installed. So note that, and will will write out empty data to both files.				returnVal = DecodeLicenseFileData(&theBackupLicenseData);				if (returnVal != kLicenseNoError)			returnVal = kLicenseErrorNoLicense;			else			// We have case case 1 - we'll use the backup data.			returnVal = kLicenseNoError;	}		// At this point the member data values for the license information have been loaded from the appropriate	// license file, or set to "no license" values. Both files will be updated the next time we call SaveLicense.	// We don't do that here so that we aren't always rewriting the files when we need to check the license	// status.			return returnVal;	}// This routine will write the mLicenseData member to the license filesLicenseError CMainWindow::SaveLicense(){	LicenseData theLicenseData;		// Note the date of last use		mLicenseLastUse = EyeDxLicenseInfo::CreateTodayAsDateCode();	// Encode the data	EncodeLicenseFileData(&theLicenseData);		// Write it out to both files		mPrimaryLicense->SaveLicense(&theLicenseData);		mBackupLicense->SaveLicense(&theLicenseData);		return kLicenseNoError;}// This routine will update the mLicenseData member, and save the updated count to the// license filesLicenseError CMainWindow::DecrementLicenseCounter(){	mLicenseCount--;	if (mLicenseCount < 0)		mLicenseCount = 0;	SaveLicense();	return kLicenseNoError;}LicenseError CMainWindow::UpdateLicenseCounter(EyeDxReferralCode theResult){	LicenseError theStatus = kLicenseNoError;		if ((theResult == kYesReferralCode) |		(theResult == kNoReferralCode))	{		theStatus = DecrementLicenseCounter();		if (theStatus != kLicenseNoError)		{			CString theStatusStr;			theStatusStr.Format("Sorry. Error %d occurred when updating your license. Please contact EyeDx customer service.");			MessageBox(theStatusStr, AfxGetAppName());		}	}	return (theStatus);}