// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "globals.h"#include "main.h"#if defined (WIN32)	#define IS_WIN32	TRUE#else	#define IS_WIN32	FALSE#endifBEGIN_MESSAGE_MAP( CMFCEditVariableDlg, CDialog )ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)ON_CBN_SELCHANGE(IDC_EDITVAR_VARTYPEMENU, OnChangeVariableType)ON_BN_CLICKED(IDC_EDITVAR_DEFINECHOICESBUTTON, OnDefineOptions)ON_BN_CLICKED(IDC_EDITVAR_PROMPTFORVALUEBUTTON, OnPromptForValue)ON_BN_CLICKED(IDC_EDITVAR_USEFIXEDVALUEBUTTON, OnUseFixedValue)END_MESSAGE_MAP()CMFCEditVariableDlg::CMFCEditVariableDlg(CWnd *pParentWnd, CEyeDxVariableList *theVariableList, CEyeDxVariable *theVariable, BOOL newVariable, BOOL showHidden) :		CDialog(IDD_EDITVAR_DIALOG, pParentWnd) {	m_ShowHidden = showHidden;	m_VariableList = theVariableList;	m_NewVariable = newVariable;		// Save the pointer to the variable so we can update it if they make changes		m_Variable = theVariable;		// We also make a copy of the variable so we can modify it and then back-up changes	// if they cancel		m_TempVariable = *m_Variable;	m_ThePreviousName = m_Variable->GetName();}CEyeDxBooleanType CMFCEditVariableDlg::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);			CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}CEyeDxBooleanType CMFCEditVariableDlg::OnInitDialog(){	CDialog::OnInitDialog();	CenterWindow();			m_VariableNameField = (CEdit *) GetDlgItem(IDC_EDITVAR_VAR_NAMEFIELD);		m_VariableNameField->SetLimitText(kCEyeDxVariableNameLength);		m_VariableTypeCaption = (CStatic *) GetDlgItem(IDC_EDITVAR_VAR_TYPECAPTION);		m_VariableCommentField = (CEdit *) GetDlgItem(IDC_EDITVAR_COMMENTFIELD);		m_VariableCommentField->SetLimitText(kCEyeDxVariableCommentLength);		m_HideCheckBox = (CButton *) GetDlgItem(IDC_EDITVAR_HIDECHECKBOX);		m_UseFixedValueButton = (CButton *) GetDlgItem(IDC_EDITVAR_USEFIXEDVALUEBUTTON);		m_PromptForValueButton = (CButton *) GetDlgItem(IDC_EDITVAR_PROMPTFORVALUEBUTTON);		m_FixedValueField = (CEdit *) GetDlgItem(IDC_EDITVAR_FIXEDVALUEFIELD);		m_FixedValueField->SetLimitText(kCEyeDxVariableValueLength);		m_WhenToPromptMenu = (CComboBox *) GetDlgItem(IDC_EDITVAR_WHENTOPROMPTMENU);		m_PromptStringField = (CEdit *) GetDlgItem(IDC_EDITVAR_PROMPTSTRINGFIELD);			m_PromptStringField->SetLimitText(kCEyeDxVariablePromptLength);		m_VarTypeMenu = (CComboBox *) GetDlgItem(IDC_EDITVAR_VARTYPEMENU);		m_DefineChoicesButton = (CButton *) GetDlgItem(IDC_EDITVAR_DEFINECHOICESBUTTON);		m_DefaultValueField = (CEdit *) GetDlgItem(IDC_EDITVAR_DEFAULTVALUEFIELD);		m_DefaultValueField->SetLimitText(kCEyeDxVariableDefaultLength);		m_DefaultValueCaption = (CStatic *) GetDlgItem(IDC_EDITVAR_DEFAULTVALUECAPTION);		m_MustEnterCheckBox = (CButton *) GetDlgItem(IDC_EDITVAR_MUSTENTERCHECKBOX);		m_EntryFieldLinesCaption = (CStatic *) GetDlgItem(IDC_EDITVAR_LINESINENTRYCAPTION);		m_EntryFieldLinesMenu = (CComboBox *) GetDlgItem(IDC_EDITVAR_ENTRYFIELDLINESMENU);		m_CheckedCheckBox = (CButton *) GetDlgItem(IDC_EDITVAR_CHECKEDCHECKBOX);		m_UncheckedCheckBox = (CButton *) GetDlgItem(IDC_EDITVAR_UNCHECKEDCHECKBOX);		m_DefaultMenuItemMenu = (CComboBox *) GetDlgItem(IDC_EDITVAR_DEFAULTMENUITEMMENU);		m_SaveButton = (CButton *) GetDlgItem(IDOK);		m_CancelButton = (CButton *) GetDlgItem(IDCANCEL);		CEyeDxLongStringType *theName = m_TempVariable.GetName();		m_VariableNameField->SetWindowText(*theName);		CEyeDxLongStringType *theComment = m_TempVariable.GetCommentString();		m_VariableCommentField->SetWindowText(*theComment);		m_VarTypeMenu->SetExtendedUI(TRUE);		m_DefaultMenuItemMenu->SetExtendedUI(TRUE);		// We set up the menus here		m_WhenToPromptMenu->AddString("Once When Program Starts");	m_WhenToPromptMenu->AddString("For Each New Subject");	m_WhenToPromptMenu->AddString("At Start of Each New Session");	m_WhenToPromptMenu->AddString("Don't Prompt (Prompt Disabled)");	m_VarTypeMenu->AddString("Any String");	m_VarTypeMenu->AddString("Integer Number");	m_VarTypeMenu->AddString("Time");	m_VarTypeMenu->AddString("Date");	m_VarTypeMenu->AddString("Date in the Past");	m_VarTypeMenu->AddString("Check Box");	m_VarTypeMenu->AddString("Menu of Choices");		m_EntryFieldLinesMenu->AddString("1");	m_EntryFieldLinesMenu->AddString("2");	m_EntryFieldLinesMenu->AddString("3");	m_EntryFieldLinesMenu->AddString("4");				SetOptionsForVariable();	EnableToolTips(TRUE);		return (TRUE);}// This is a lookup table that is index by a variable's type to get the associated Type Menu item indexstatic short kVariableTypeToMenuIndex[] ={	0,			// kGeneralString	3,			// kDate	2,			// kTime	1,			// kIntegerNumber	4,			// kPastDate	0,			// kFloatNumber - not implemented yet	5,			// kCheckBox	6			// kMenu};// And this is the inverse lookupstatic CEyeDxVariable::DataType kMenuIndexToVariableType[] ={	CEyeDxVariable::kGeneralString,	CEyeDxVariable::kIntegerNumber,  	CEyeDxVariable::kTime, 	CEyeDxVariable::kDate, 	CEyeDxVariable::kPastDate, 	CEyeDxVariable::kCheckBox,	CEyeDxVariable::kMenu };	// kFloatNumber not yet supported// This is a lookup table that is index by a variable's WhenToPrompt value to get the associated Type Menu item indexstatic short kVariableWhenToPromptToMenuIndex[] ={	0,			// kPromptOnStart	1,			// kPromptForSubject	2,			// TODO kPromptForSession	0,			// TODO kPromptForEndOfSession	3,			// kPromptDisabled};// And this is the inverse lookupstatic CEyeDxVariable::PromptType kMenuIndexToVariableWhenToPrompt[] ={	CEyeDxVariable::kPromptOnStart,	CEyeDxVariable::kPromptForSubject, 	CEyeDxVariable::kPromptForSession, 	// TODO CEyeDxVariable::kPromptForEndOfSession,	CEyeDxVariable::kPromptDisabled};void CMFCEditVariableDlg::SetOptionsForVariable(){	// Initially, just disable everything till we figure out what to enable			m_UseFixedValueButton->SetCheck(BST_UNCHECKED);	m_UseFixedValueButton->EnableWindow(FALSE);	m_FixedValueField->EnableWindow(FALSE);	m_FixedValueField->SetWindowText("");		m_PromptForValueButton->SetCheck(BST_UNCHECKED);	m_PromptForValueButton->EnableWindow(FALSE);	m_WhenToPromptMenu->EnableWindow(FALSE);		m_PromptStringField->EnableWindow(FALSE);	m_DefaultValueField->EnableWindow(FALSE);	m_DefaultValueField->ShowWindow(SW_HIDE);	m_PromptStringField->SetWindowText("");	m_DefaultValueField->SetWindowText("");	m_DefaultMenuItemMenu->ShowWindow(SW_HIDE);	m_DefaultMenuItemMenu->EnableWindow(FALSE);	m_DefaultValueCaption->ShowWindow(SW_SHOW);	m_DefaultValueCaption->SetWindowText("Default Value (optional):");					m_VarTypeMenu->EnableWindow(FALSE);	m_DefineChoicesButton->EnableWindow(FALSE);	m_CheckedCheckBox->EnableWindow(FALSE);	m_UncheckedCheckBox->EnableWindow(FALSE);	m_CheckedCheckBox->SetCheck(BST_UNCHECKED);	m_UncheckedCheckBox->SetCheck(BST_UNCHECKED);		m_CheckedCheckBox->ShowWindow(SW_HIDE);	m_UncheckedCheckBox->ShowWindow(SW_HIDE);		m_EntryFieldLinesMenu->EnableWindow(FALSE);	m_EntryFieldLinesMenu->ShowWindow(SW_HIDE);		m_EntryFieldLinesCaption->EnableWindow(FALSE);	m_EntryFieldLinesCaption->ShowWindow(SW_HIDE);	m_MustEnterCheckBox->EnableWindow(FALSE);		// If advanced features are enabled, allow the user to hide the variable		if (m_ShowHidden)		m_HideCheckBox->ShowWindow(SW_SHOW);	else		m_HideCheckBox->ShowWindow(SW_HIDE);			m_HideCheckBox->SetCheck(m_TempVariable.GetVariableIsHidden() ? BST_CHECKED : BST_UNCHECKED);		if (m_TempVariable.GetDataType() == CEyeDxVariable::kMenu)	{		// Now, we update the Option String menu to reflect the current list		m_DefaultMenuItemMenu->ResetContent();		CTemplateShortStrArray *theOptionStringList = m_TempVariable.GetOptionStringsArray();				int theItemCount = theOptionStringList->GetSize();				CEyeDxShortStringType *theString;				short theSelectedItem = 0;				for (int theItem = 0; theItem < theItemCount; theItem++)		{			theString = theOptionStringList->GetAt(theItem);						m_DefaultMenuItemMenu->AddString(*theString);						if (*theString == *(m_TempVariable.GetDefaultValue()))				theSelectedItem = theItem;		}				m_DefaultMenuItemMenu->SetCurSel(theSelectedItem);	}		if (m_TempVariable.GetVariableClass() == CEyeDxVariable::kEyeDx)	{		// Can't change the name or the comment!				m_VariableNameField->EnableWindow(FALSE);				m_VariableCommentField->EnableWindow(FALSE);			// Now, user can change some attributes of EyeDx variables, so we have to leave the buttons alone.				#if FALSE		// If hidden variables are displayed, the user can change whether they are displayed or not				if (!m_ShowHidden)		{			m_SaveButton->SetWindowText("OK");	// Just say OK, since they can't save any changes				m_CancelButton->EnableWindow(FALSE);	// No sense cancelling, since they can't change anything		}#endif				switch (m_TempVariable.GetVariableType())		{		case CEyeDxVariable::kFixed:					m_VariableTypeCaption->SetWindowText("EyeDx-defined Fixed Variable");					// Set the options for the Fixed style of variable					m_FixedValueField->SetWindowText(*(m_TempVariable.GetDefaultValue()));									break;					case CEyeDxVariable::kPrompted:					m_VariableTypeCaption->SetWindowText("EyeDx-defined Prompted Variable");					// Set the options for the Prompted style of variable						// The main radio button						m_PromptForValueButton->SetCheck(BST_CHECKED);						m_WhenToPromptMenu->SetCurSel(kVariableWhenToPromptToMenuIndex[m_TempVariable.GetWhenToPrompt()]);						// The prompt and default value fields						m_PromptStringField->SetWindowText(*(m_TempVariable.GetPromptString()));						// The variable validation type menu						m_VarTypeMenu->SetCurSel(kVariableTypeToMenuIndex[m_TempVariable.GetDataType()]);						switch (m_TempVariable.GetDataType())			{			case CEyeDxVariable::kGeneralString:				// Since it's a general string entry type, we set the number of lines in the entry field pop-up								short theMaxNumLines = m_EntryFieldLinesMenu->GetCount();								short theExtraEntryLines = m_TempVariable.GetExtraEntryLines();				if (theExtraEntryLines > (theMaxNumLines - 1))					theExtraEntryLines = theMaxNumLines - 1;				else				if (theExtraEntryLines < 0)					theExtraEntryLines = 0;									m_EntryFieldLinesMenu->SetCurSel(theExtraEntryLines);	// There's always at least one line				m_EntryFieldLinesMenu->ShowWindow(SW_SHOW);					m_EntryFieldLinesCaption->EnableWindow(FALSE);				m_EntryFieldLinesCaption->ShowWindow(SW_SHOW);				// Fall through to common stuff							case CEyeDxVariable::kDate:			case CEyeDxVariable::kTime:			case CEyeDxVariable::kIntegerNumber:			case CEyeDxVariable::kFloatNumber:			case CEyeDxVariable::kPastDate:							m_DefaultValueField->ShowWindow(SW_SHOW);				m_DefaultValueField->SetWindowText(*(m_TempVariable.GetDefaultValue()));				// Indicate whether it's a required entry item								m_MustEnterCheckBox->SetCheck(m_TempVariable.GetValueMustBeEntered() ? BST_CHECKED : BST_UNCHECKED);				// We allow the user to change this, even for EyeDx variables								m_MustEnterCheckBox->EnableWindow(TRUE);				break;							case CEyeDxVariable::kCheckBox:				m_CheckedCheckBox->ShowWindow(SW_SHOW);				m_UncheckedCheckBox->ShowWindow(SW_SHOW);								if (*(m_TempVariable.GetDefaultValue()) == kCheckBoxOnStr)					m_CheckedCheckBox->SetCheck(BST_CHECKED);				else					m_UncheckedCheckBox->SetCheck(BST_CHECKED);								m_MustEnterCheckBox->SetCheck(BST_CHECKED);				break;			case CEyeDxVariable::kMenu:							m_DefineChoicesButton->SetWindowText("Display Choices...");							m_DefineChoicesButton->EnableWindow(TRUE);								m_MustEnterCheckBox->SetCheck(BST_CHECKED);				m_DefaultValueCaption->SetWindowText("Default Choice:");								m_DefaultMenuItemMenu->ShowWindow(SW_SHOW);	// We show the menu, but don't enable it.				break;			}						break;		case CEyeDxVariable::kCalculated:					m_VariableTypeCaption->SetWindowText("EyeDx-defined Calculated Variable");					break;					}	}	else	// It's a user-defined variable - so enable various fields	{		m_UseFixedValueButton->EnableWindow(TRUE);		m_PromptForValueButton->EnableWindow(TRUE);		switch (m_TempVariable.GetVariableType())		{		case CEyeDxVariable::kFixed:					m_VariableTypeCaption->SetWindowText("User-defined Fixed Variable");					// Enable the options for the Fixed style of variable					m_UseFixedValueButton->SetCheck(BST_CHECKED);			m_FixedValueField->EnableWindow(TRUE);			m_FixedValueField->SetWindowText(*(m_TempVariable.GetDefaultValue()));						break;					case CEyeDxVariable::kPrompted:					m_VariableTypeCaption->SetWindowText("User-defined Prompted Variable");					// Enable the options for the Prompted style of variable						// The main radio button						m_PromptForValueButton->SetCheck(BST_CHECKED);						// The when to prompt radio buttons						m_WhenToPromptMenu->EnableWindow(TRUE);						// The prompt and default value fields						m_PromptStringField->EnableWindow(TRUE);			m_PromptStringField->SetWindowText(*(m_TempVariable.GetPromptString()));						m_WhenToPromptMenu->SetCurSel(kVariableWhenToPromptToMenuIndex[m_TempVariable.GetWhenToPrompt()]);						// The prompt and default value fields						m_PromptStringField->SetWindowText(*(m_TempVariable.GetPromptString()));			m_DefaultValueField->SetWindowText(*(m_TempVariable.GetDefaultValue()));						// The variable validation type menu						m_VarTypeMenu->EnableWindow(TRUE);						m_VarTypeMenu->SetCurSel(kVariableTypeToMenuIndex[m_TempVariable.GetDataType()]);						switch (m_TempVariable.GetDataType())			{			case CEyeDxVariable::kGeneralString:				// Since it's a general string entry type, we set the number of lines in the entry field pop-up								short theMaxNumLines = m_EntryFieldLinesMenu->GetCount();								short theExtraEntryLines = m_TempVariable.GetExtraEntryLines();				if (theExtraEntryLines > (theMaxNumLines - 1))					theExtraEntryLines = theMaxNumLines - 1;				else				if (theExtraEntryLines < 0)					theExtraEntryLines = 0;									m_EntryFieldLinesMenu->SetCurSel(theExtraEntryLines);	// There's always at least one line				m_EntryFieldLinesMenu->ShowWindow(SW_SHOW);					m_EntryFieldLinesMenu->EnableWindow(TRUE);					m_EntryFieldLinesCaption->EnableWindow(TRUE);				m_EntryFieldLinesCaption->ShowWindow(SW_SHOW);				// Fall through to common stuff							case CEyeDxVariable::kDate:			case CEyeDxVariable::kTime:			case CEyeDxVariable::kIntegerNumber:			case CEyeDxVariable::kFloatNumber:			case CEyeDxVariable::kPastDate:				m_DefaultValueField->EnableWindow(TRUE);				m_DefaultValueField->ShowWindow(SW_SHOW);				m_DefaultValueField->SetWindowText(*(m_TempVariable.GetDefaultValue()));				// Indicate whether it's a required entry item								m_MustEnterCheckBox->SetCheck(m_TempVariable.GetValueMustBeEntered() ? BST_CHECKED : BST_UNCHECKED);				// We allow the user to change this								m_MustEnterCheckBox->EnableWindow(TRUE);				break;							case CEyeDxVariable::kCheckBox:				m_CheckedCheckBox->EnableWindow(TRUE);				m_CheckedCheckBox->ShowWindow(SW_SHOW);				m_UncheckedCheckBox->EnableWindow(TRUE);				m_UncheckedCheckBox->ShowWindow(SW_SHOW);								if (*(m_TempVariable.GetDefaultValue()) == kCheckBoxOnStr)					m_CheckedCheckBox->SetCheck(BST_CHECKED);				else					m_UncheckedCheckBox->SetCheck(BST_CHECKED);								m_MustEnterCheckBox->SetCheck(BST_CHECKED);				break;			case CEyeDxVariable::kMenu:							m_DefineChoicesButton->SetWindowText("Define Choices...");							m_DefineChoicesButton->EnableWindow(TRUE);				m_MustEnterCheckBox->SetCheck(BST_CHECKED);				m_DefaultValueCaption->SetWindowText("Default Choice:");								m_DefaultMenuItemMenu->ShowWindow(SW_SHOW);				m_DefaultMenuItemMenu->EnableWindow(TRUE);								break;			}						break;		}	}}void CMFCEditVariableDlg::OnPromptForValue(){	// Change the temporary variable's type and change all of the window options		m_TempVariable.SetVariableType(CEyeDxVariable::kPrompted);		// Set some defaults if not initialized		if (m_TempVariable.GetWhenToPrompt() == CEyeDxVariable::kPromptNone)		m_TempVariable.SetWhenToPrompt(CEyeDxVariable::kPromptForSubject);		if (m_TempVariable.GetDataType() == CEyeDxVariable::kTypeNone)		m_TempVariable.SetDataType(CEyeDxVariable::kGeneralString);		// If the prompt order hasn't been set, then set it. This would normally happen on a brand new	// Fixed type variable that the user is converting to a prompted type.		if (m_TempVariable.GetPromptOrder() == kNoPromptOrder)	{		short nextAvailablePrompt = m_VariableList->GetNextAvailablePromptNumber(m_TempVariable.GetWhenToPrompt());		m_TempVariable.SetPromptOrder(nextAvailablePrompt);	}		SetOptionsForVariable();}void CMFCEditVariableDlg::OnUseFixedValue(){	// Change the temporary variable's type and change all of the window options		m_TempVariable.SetVariableType(CEyeDxVariable::kFixed);	m_TempVariable.SetWhenToPrompt(CEyeDxVariable::kPromptNone);	m_TempVariable.SetDataType(CEyeDxVariable::kGeneralString);	SetOptionsForVariable();}void CMFCEditVariableDlg::OnChangeVariableType(){	// The user is changing the variable type. We need to change the type and update the controls		int theItem = m_VarTypeMenu->GetCurSel();		if (theItem != CB_ERR)	{			CEyeDxVariable::DataType theOldVariableType = m_TempVariable.GetDataType();		CEyeDxVariable::DataType theNewVariableType = kMenuIndexToVariableType[theItem];				// If the old variable type was either the CheckBox or Menu type and we are changing to		// another type, we reset the default string to a blank. If going in the opposite direction,		// we set Menu types to the first item (value 0) and CheckBoxes to Checked (also value 1)				if (theNewVariableType == CEyeDxVariable::kCheckBox)				m_TempVariable.SetDefaultValue(kCheckBoxOnStr);		else if (theNewVariableType == CEyeDxVariable::kMenu)				m_TempVariable.SetDefaultValue(0);		else				m_TempVariable.SetDefaultValue("");									m_TempVariable.SetDataType(theNewVariableType);				// We want to preserve the user's entered prompt, as it may not be the same as stored in the		// temp variable. So grab its value here, and then restore it after the call to SetOptionsForVariable				CEyeDxShortStringType theCurrentPromptStr;				m_PromptStringField->GetWindowText(theCurrentPromptStr);				SetOptionsForVariable();		m_PromptStringField->SetWindowText(theCurrentPromptStr);			}}void CMFCEditVariableDlg::OnDefineOptions(){	CMFCDefineChoicesDlg dlg(this, &m_TempVariable, (m_TempVariable.GetVariableClass() == CEyeDxVariable::kUser));		if (dlg.DoModal() == IDOK)			SetOptionsForVariable();}void CMFCEditVariableDlg::OnOK(){	CEyeDxLongStringType theNameStr;	CEyeDxShortStringType theCommentStr;	CEyeDxShortStringType theDefaultValueStr;	CEyeDxShortStringType thePromptStr;			BOOL mValidInput = false;		// Assume inputs are invalid		// The name must be set, and if a new variable, must not match an existing variable		// First, assume an error will occur - we will pass msg_Nothing in the case where we don't want the normal	// processing of msg_OK to occur		// Note that EyeDx-defined variables cannot be changed by the dialog, as we have disabled editing the	// fields associated with the variable type. The only thing that can be changed is the value of the	// Hidden attribute, and we allow that only if we are allowing display of hidden variables.		if (m_TempVariable.GetVariableClass() == CEyeDxVariable::kEyeDx)	{		// Save whether the variable is hidden - we don't have to check whether the control		// is visible because we always set its value appropriately on startup				m_TempVariable.SetVariableIsHidden(m_HideCheckBox->GetCheck());				// We also allow the user to change the Must Enter checkbox, even for EyeDx variables				m_TempVariable.SetValueMustBeEntered(m_MustEnterCheckBox->GetCheck() == BST_CHECKED);										// Now save the results				*m_Variable = m_TempVariable;		mValidInput = true;	}	else	{				m_VariableNameField->GetWindowText(theNameStr);		m_VariableCommentField->GetWindowText(theCommentStr);		if (theNameStr.GetLength() == 0)		{			MessageBox("You must enter the name of the variable!", AfxGetAppName());		}		else		{			if (m_NewVariable && m_VariableList->VariableExists(theNameStr))			{				MessageBox("That variable name is already taken. Please use another name!", AfxGetAppName());			}			else			{									// See if the user changed the name of an existing variable								if (!m_NewVariable && (*m_ThePreviousName != theNameStr) && m_VariableList->VariableExists(theNameStr))				{					MessageBox("That variable name is already taken. Please use another name!", AfxGetAppName());				}				else				{					// Save the variable name											m_TempVariable.SetName(theNameStr);											m_TempVariable.SetCommentString(theCommentStr);											// Save whether the variable is hidden - we don't have to check whether the control					// is visible because we always set its value appropriately on startup										m_TempVariable.SetVariableIsHidden(m_HideCheckBox->GetCheck() == BST_CHECKED);					switch (m_TempVariable.GetVariableType())					{					case CEyeDxVariable::kFixed:																m_FixedValueField->GetWindowText(theDefaultValueStr);												if (theDefaultValueStr.GetLength() == 0)						{							MessageBox("You must enter a value for the variable!", AfxGetAppName());						}						else						{							m_TempVariable.SetDefaultValue(theDefaultValueStr);							m_TempVariable.SetPromptString("");							// We don't change the other values in case the user later decides to change the variable type														// Now save the results														*m_Variable = m_TempVariable;							mValidInput = true;						}												break;											case CEyeDxVariable::kPrompted:											m_PromptStringField->GetWindowText(thePromptStr);												if (thePromptStr.GetLength() == 0)						{							MessageBox("You must enter a prompt for the variable!", AfxGetAppName());						}						else						{							// From here, the variable mValidInput is used to indicate at the end whether the							// variable should be updated. Assume true for now.														mValidInput = true;							m_TempVariable.SetPromptString(thePromptStr);														if (m_TempVariable.GetDataType() == CEyeDxVariable::kCheckBox)							{								if (m_CheckedCheckBox->GetCheck() == BST_CHECKED)									m_TempVariable.SetDefaultValue(kCheckBoxOnStr);								else									m_TempVariable.SetDefaultValue(kCheckBoxOffStr);							}							else							if (m_TempVariable.GetDataType() == CEyeDxVariable::kMenu)							{								// Get the list of choices. If there is at least one choice, everything is fine																CTemplateShortStrArray *theOptionStringList = m_TempVariable.GetOptionStringsArray();																if (theOptionStringList->GetSize() == 0)								{									MessageBox("You must enter at least one menu choice for the variable!", AfxGetAppName());									mValidInput = false;								}								else								{									// We also have to save the default value																		short theChoice = m_DefaultMenuItemMenu->GetCurSel();																		if (theChoice != CB_ERR)									{										CEyeDxShortStringType *theChoiceString;																			theChoiceString = theOptionStringList->GetAt(theChoice);																			m_TempVariable.SetDefaultValue(*theChoiceString);									}								}							}							else							{								m_DefaultValueField->GetWindowText(theDefaultValueStr);															// Note that the default value can be left empty - that means that no value will be								// filled-in when the user is prompted.																m_TempVariable.SetDefaultValue(theDefaultValueStr);									short theMaxNumLines = m_EntryFieldLinesMenu->GetCurSel();																// If the menu isn't visible or no selection has been made, set it to zero								// extra lines																if (theMaxNumLines == CB_ERR)									theMaxNumLines = 0;											m_TempVariable.SetExtraEntryLines(theMaxNumLines);							}															if (mValidInput)							{															// Now just get the values of the menus and radio buttons and set the appropriate variable fields																int theItem = m_WhenToPromptMenu->GetCurSel();																if (theItem != CB_ERR)								{									m_TempVariable.SetWhenToPrompt(kMenuIndexToVariableWhenToPrompt[theItem]);																	int theTypeItem = m_VarTypeMenu->GetCurSel();																		if (theTypeItem != CB_ERR)									{																			m_TempVariable.SetDataType(kMenuIndexToVariableType[theTypeItem]);										m_TempVariable.SetValueMustBeEntered(m_MustEnterCheckBox->GetCheck() == BST_CHECKED);																		// Now save the results																		*m_Variable = m_TempVariable;									}								}							}						}						break;											case CEyeDxVariable::kCalculated:																							// Since this is a type defined at runtime, we don't change anything here. Actually,						// we shouldn't get here at all, since calculated variables are EyeDx-defined, and thus						// the first test after the case statement should bypass this whole section.																			mValidInput = true;												break;											}				}			}		}	}		if (mValidInput)		CDialog::OnOK();}