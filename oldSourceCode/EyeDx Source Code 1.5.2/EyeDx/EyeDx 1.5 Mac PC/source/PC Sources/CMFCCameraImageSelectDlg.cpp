/////////////////////////////////////////////////////////////////////////////// Copyright (C) 1998 by Jorge Lodos// All rights reserved//// Distribute and use freely, except:// 1. Don't alter or remove this notice.// 2. Mark the changes you made//// Send bug reports, bug fixes, enhancements, requests, etc. to://    lodos@cigb.edu.cu/////////////////////////////////////////////////////////////////////////////// PreviewFileDlg.cpp : implementation file//#define WINDOWS#include "stdafx.h"#include "resource.h"#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"#include "globals.h"#include "CMFCCameraImageSelectDlg.h"#include <dlgs.h>/////////////////////////////////////////////////////////////////////////////// CMFCCameraImageSelectDlgIMPLEMENT_DYNAMIC(CMFCCameraImageSelectDlg, CDialog)CMFCCameraImageSelectDlg::CMFCCameraImageSelectDlg(CWnd* pParentWnd, 						SideSelect theSide, 						char *pictNames, 						int numOfPicts,  						CEyeDxDibStatic *theMainWindowView, 						CStatic *theMainWindowCaption,						DCPictInfo *theMainWindowGenericPictInfo,						DC120PictInfo *theMainWindowPictInfo,						CStatic *theMainWindowQualityBitmap,						CBitmap *hBadBitmap,						CBitmap *hCautionBitmap,						CBitmap	*hGoodBitmap) :		CDialog(IDD_CAMERA_IMAGE_SELECT, pParentWnd){	// This indicates the which image we are selecting		m_Side = theSide;		// A pointer to the list of names downloaded from the camera		m_PictNamePtr = pictNames;		// The number of pictures in the list		m_NumOfPicts = numOfPicts;		// The thumbnail preview in the main window		m_MainWindowView = theMainWindowView;		// The caption in the main window to update		m_MainWindowCaption = theMainWindowCaption;	// The bitmap in the main window that indicates image quality		m_MainWindowQualityBitmap = theMainWindowQualityBitmap;	// Remember to save the item's current information, in case they just hit Select	// without clicking in the list box		m_MainWindowPictInfo = theMainWindowPictInfo;		m_PictInfo = *theMainWindowPictInfo;		m_MainWindowGenericPictInfo = theMainWindowGenericPictInfo;		m_GenericPictInfo = *theMainWindowGenericPictInfo;		m_hBadBitmap = hBadBitmap;	m_hCautionBitmap = hCautionBitmap;	m_hGoodBitmap = hGoodBitmap;}BEGIN_MESSAGE_MAP(CMFCCameraImageSelectDlg, CDialog)	ON_LBN_DBLCLK(IDC_CAMERA_LISTBOX, OnItemDoubleClicked)	ON_LBN_SELCHANGE(IDC_CAMERA_LISTBOX, OnSelectionChange)	ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)END_MESSAGE_MAP()CEyeDxBooleanType CMFCCameraImageSelectDlg::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);		CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}CEyeDxBooleanType CMFCCameraImageSelectDlg::OnInitDialog() {	CDialog::OnInitDialog();	CenterWindow();		CString message;		CWaitCursor wait;		m_DIBStaticCtrl.SubclassDlgItem(IDC_CAMERA_PREVIEW, this);		m_ImageListCtrl = (CListBox *) GetDlgItem(IDC_CAMERA_LISTBOX);	m_NameCtrl = (CStatic *) GetDlgItem(IDC_CAMERA_IMAGE_NAME);			m_QualityCtrl = (CStatic *) GetDlgItem(IDC_CAMERA_IMAGE_QUALITY);			// Now fill in the list box with the passed string list		const int thePictNameLength = 7;			char *p = m_PictNamePtr;	m_ImageListCtrl->SendMessage(WM_SETREDRAW, FALSE, 0);		for (int i = 0; i < m_NumOfPicts; i++)	{		char tmpStr[10];				strncpy(tmpStr, p, thePictNameLength);				tmpStr[thePictNameLength] = '\0';					m_ImageListCtrl->AddString(tmpStr);				p += DC120AlbumPictureSize;			}	m_ImageListCtrl->SendMessage(WM_SETREDRAW, TRUE, 0);		// Set up some variables based on the Up or Side image to be selected		switch (m_Side)	{	case UpImage:		m_CurrentItem = UpPictNum;		m_ItemPtr = &UpPictNum;		SetWindowText("Select Up Image");		break;	case SideImage:		m_CurrentItem = SidePictNum;		m_ItemPtr = &SidePictNum;		SetWindowText("Select Side Image");		break;	}	// Now, we select the the previously-selected item in the list		if (m_NumOfPicts > 0)	{		// Since the main window caption and view are already set, we just copy		// them instead of downloading - MUCH faster!		m_LastItem = *m_ItemPtr;				CString theString;				m_MainWindowCaption->GetWindowText(theString);		m_NameCtrl->SetWindowText(theString);				m_DIBStaticCtrl.CopyBitmapData(m_MainWindowView);				switch (m_MainWindowPictInfo->PictQuality)		{		case DC120NoCompression:			m_QualityCtrl->SetWindowText("Quality: No Compression");			break;		case DC120BestQuality:			m_QualityCtrl->SetWindowText("Quality: Best (recommended)");			break;		case DC120BetterQuality:			m_QualityCtrl->SetWindowText("Quality: Better");			break;		case DC120GoodQuality:			m_QualityCtrl->SetWindowText("Quality: Good");			break;		}				    		}		m_ImageListCtrl->SetCurSel((m_CurrentItem - 1));	EnableToolTips(TRUE);		return TRUE;  // return TRUE unless you set the focus to a control	              // EXCEPTION: OCX Property Pages should return FALSE}void CMFCCameraImageSelectDlg::OnOK() {	// We just update the captions, and copy the already-downloaded thumbnail data into the	// main window's view - no sense re-downloading it!		int m_Item = m_ImageListCtrl->GetCurSel();	if (m_Item >= 0)	{									*m_ItemPtr = m_Item + 1;			CString theString;				m_NameCtrl->GetWindowText(theString);		m_MainWindowCaption->SetWindowText(theString);		m_MainWindowView->CopyBitmapData(&m_DIBStaticCtrl);				m_MainWindowQualityBitmap->ShowWindow(SW_SHOW);				// If the quality isn't what we should be using, warn the user		if (m_PictInfo.PictQuality != DC120BestQuality)		{		 	MessageBox("This image was not taken with the recommended 'Best' image quality setting,\n"		 				"and analysis of this image may produce incorrect results.\n"		 				"EyeDx recommends you retake this picture.", AfxGetAppName());			m_MainWindowQualityBitmap->SetBitmap(*m_hCautionBitmap);		}		else			m_MainWindowQualityBitmap->SetBitmap(*m_hGoodBitmap);				// We also update the caller's pict info structure				*m_MainWindowGenericPictInfo = m_GenericPictInfo;			*m_MainWindowPictInfo = m_PictInfo;		}	CDialog::OnOK();}void CMFCCameraImageSelectDlg::OnCancel() {	*m_ItemPtr = m_CurrentItem;	CDialog::OnCancel();}void CMFCCameraImageSelectDlg::OnItemDoubleClicked(){	// This is the same as selecting the object, downloading the thumbnail, and hitting the Select button		// Get the selection, and copy the thumbnail to the main window's view, and also update its caption	// The camera interface starts counting at 1, whereas the list starts at 0		m_Item = m_ImageListCtrl->GetCurSel();			if (m_Item >= 0)	{		CWaitCursor wait;								m_NameCtrl->SetWindowText("Downloading image...");				*m_ItemPtr = m_Item + 1;					GetIconFromCamera(*m_ItemPtr, m_Side, &m_GenericPictInfo, &m_PictInfo, this, m_MainWindowView, m_MainWindowCaption);		m_MainWindowQualityBitmap->ShowWindow(SW_SHOW);		// If the quality isn't what we should be using, warn the user		if (m_PictInfo.PictQuality != DC120BestQuality)		{		 	MessageBox("This image was not taken with the recommended 'Best' image quality setting,\n"		 				"and analysis of this image may produce incorrect results.\n"		 				"EyeDx recommends you retake this picture.", AfxGetAppName());			m_MainWindowQualityBitmap->SetBitmap(*m_hCautionBitmap);		}		else			m_MainWindowQualityBitmap->SetBitmap(*m_hGoodBitmap);		// We also update the caller's pict info structure				*m_MainWindowGenericPictInfo = m_GenericPictInfo;		*m_MainWindowPictInfo = m_PictInfo;	}	CDialog::OnOK();}void CMFCCameraImageSelectDlg::OnSelectionChange(){	// This causes us to just download the thumbnail		// Get the selection, and copy the thumbnail	// The camera interface starts counting at 1, whereas the list starts at 0	m_LastItem = m_Item;	m_Item = m_ImageListCtrl->GetCurSel();	if (m_Item >= 0 && m_LastItem != m_Item)			{		CWaitCursor wait;								m_NameCtrl->SetWindowText("Downloading image...");		*m_ItemPtr = m_Item + 1;					GetIconFromCamera(*m_ItemPtr, m_Side, &m_GenericPictInfo, &m_PictInfo, this, &m_DIBStaticCtrl, m_NameCtrl);				switch (m_PictInfo.PictQuality)		{		case DC120NoCompression:			m_QualityCtrl->SetWindowText("Quality: No Compression");			break;		case DC120BestQuality:			m_QualityCtrl->SetWindowText("Quality: Best (recommended)");			break;		case DC120BetterQuality:			m_QualityCtrl->SetWindowText("Quality: Better");			break;		case DC120GoodQuality:			m_QualityCtrl->SetWindowText("Quality: Good");			break;		}							// Note that we do not update anything in the main window. We wait for the		// Select button to be pressed, so that a Cancel doesn't require any special handling		// to restore the main window values.	    	    						}}