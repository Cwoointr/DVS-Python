// main.cp#include "main.h"#include <errno.h>#include <mmsystem.h>BEGIN_MESSAGE_MAP( CMFCSplashDlg, CDialog )ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)ON_STN_CLICKED(IDC_SPLASH_VIEW, OnClick)ON_WM_TIMER()END_MESSAGE_MAP()CEyeDxBooleanType CMFCSplashDlg::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);			CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}CMFCSplashDlg::~CMFCSplashDlg(){}void CMFCSplashDlg::SetDialogSize(DWORD rows, DWORD cols){	CClientDC dc(this);		CRect rect;		// Get the size of the work area the following correction is needed when the taskbar is    // at the left or top and it is not "auto-hidden".        CRect workArea;    ::SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0);        // Make the rectangle a bit smaller        workArea.InflateRect(-5, -5);    	// If the picture is larger than the screen, we will set the window to the	// size of the screen.		DWORD newRows = rows;	DWORD newCols = cols;		if ((workArea.Height() < rows))	{		newRows = workArea.Height();		newCols = (cols * workArea.Height()) / rows;	}		if (workArea.Width() < newCols)	{		newCols = workArea.Width();		newRows = (newRows * workArea.Width()) / newCols;				}		// Set the size of the view		m_ctlPicture.SetWindowPos(NULL, 0, 0, newCols, newRows, SWP_NOZORDER | SWP_NOMOVE );	// And set the size of the dialog itself		rect.SetRect(0, 0, newCols, newRows);		CalcWindowRect(rect);		SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(), SWP_NOMOVE | SWP_NOZORDER);			CenterWindow();	}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------// This routine handles both single and multiple prompts for variables. If m_PromptOrder is set to "kNoPromptOrder",// that means that all variables that should be prompted in the current dialog should be prompted in a single// dialog. Otherwise, just the single variable that is specified by the m_PromptOrder should be requested.CEyeDxBooleanType CMFCSplashDlg::OnInitDialog(){	CRect rect;		// Note that we shouldn't be called if there isn't a picture to display! So m_PictureFile should be valid.	// We first just create a view of an arbitrary size, and load the bitmap file into it. Then we query the object	// to find out how big the BMP really is (vertical and horizontal dimensions). We scale these to fit on the screen,	// and then resize the dialog and the view to this value. Finally, we tell the view to redraw using this new size.		if (m_ImageFileName)	{		rect.SetRect(0, 0, 400, 400);				// Create this with the SS_NOTIFY attribute so that clicks will be passed to us				m_ctlPicture.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN | SS_NOTIFY, rect, this, IDC_SPLASH_VIEW);				int rows, cols;				// First try to read it as a BMP format file				if (m_ctlPicture.LoadDib(m_ImageFileName))		{			// Now, get the width and height of the image.						cols = m_ctlPicture.GetDibWidth();			rows = m_ctlPicture.GetDibHeight();			SetDialogSize(rows, cols);			// Make sure that the view repaints			m_ctlPicture.UpdateDib();		}		else		{			// That didn't work. Try reading it as a JPEG file			CEyeDxHandleType theImage;			FILE *fileptr = fopen(m_ImageFileName, "rb");			if (ReadImage(fileptr, &theImage, &rows, &cols, NULL, NULL, NULL, NULL, true))			{					// We set the view size _first_ so that it is the right size before we load and 				// possibly scale the JPEG image.							SetDialogSize(rows, cols);				m_ctlPicture.SetImageFromRaw24Bit(theImage, rows, cols);					}			else			{				// Can't read either BMP or JPEG. Just display a blank dialog!			}					}	}		if (m_SoundFileName)	{		::PlaySound(m_SoundFileName, NULL, SND_ASYNC | SND_FILENAME); 				// We set a timer that will automatically terminate the dialog when the		// sound is finished. We check once a second (1000 ms).				SetTimer(1, 1000, NULL);	}		return TRUE;}void CMFCSplashDlg::OnOK(){	// Stop the sound from playing	::PlaySound(NULL, NULL, SND_PURGE); 	CDialog::OnOK();}void CMFCSplashDlg::OnClick(){	OnOK();}void CMFCSplashDlg::OnChar(UINT, UINT, UINT){	OnOK();}void CMFCSplashDlg::OnTimer(UINT nTimerID){	// We periodically check to see if the sound is still playing. If not, we cancel the	// dialog. To check to see if the sound is still playing, we tell the PlaySound routine	// to not stop the current sound and return FALSE. If the sound isn't playing, we give the	// routine the name of the Silence WAVE resource in our application and tell it to not 	// stop the current sound. 		// If we succeed in playing the silent sound, that means that the previous sound was done! What a	// hack, but I don't see any other way of determining if the currently-playing Async sound	// is still playing or not.		if (::PlaySound("#129", NULL, SND_NOSTOP | SND_RESOURCE | SND_NOWAIT))		CDialog::OnOK();}