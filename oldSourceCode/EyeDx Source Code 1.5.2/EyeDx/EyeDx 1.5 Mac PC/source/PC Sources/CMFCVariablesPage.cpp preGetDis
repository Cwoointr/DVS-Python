// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "globals.h"#include "main.h"#if defined (WIN32)	#define IS_WIN32	TRUE#else	#define IS_WIN32	FALSE#endifIMPLEMENT_DYNCREATE(CMFCVariablesPage, CPropertyPage)BEGIN_MESSAGE_MAP( CMFCVariablesPage, CPropertyPage )ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)ON_BN_CLICKED(IDC_LAYOUTNEWBUTTON, OnNewPressed)ON_BN_CLICKED(IDC_LAYOUTEDITBUTTON, OnEditPressed)ON_BN_CLICKED(IDC_LAYOUTDELETEBUTTON, OnDeletePressed)ON_NOTIFY(NM_CLICK, IDC_LAYOUTVARIABLELIST, OnListClicked)ON_NOTIFY(NM_DBLCLK, IDC_LAYOUTVARIABLELIST, OnListDoubleClicked)ON_NOTIFY(LVN_COLUMNCLICK, IDC_LAYOUTVARIABLELIST, OnListColumnPressed)ON_WM_SIZE()END_MESSAGE_MAP()CEyeDxBooleanType CMFCVariablesPage::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);			CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}const int kMaxVariableNameCharLength = 30;const int kMaxVariableNameDispLength = 180;const int kMaxVariableClassDispLength = 45;const int kMaxVariableTypeDispLength = 135;const int kMaxVariableDataTypeDispLength = 80;const int kMaxVariableRequiredDispLength = 250;CEyeDxBooleanType CMFCVariablesPage::OnInitDialog(){	CPropertyPage::OnInitDialog();		m_VariableListBox = (CListCtrl *) GetDlgItem(IDC_LAYOUTVARIABLELIST);		m_NewButton = (CButton *) GetDlgItem(IDC_LAYOUTNEWBUTTON);		m_EditButton = (CButton *) GetDlgItem(IDC_LAYOUTEDITBUTTON);		m_DeleteButton = (CButton *) GetDlgItem(IDC_LAYOUTDELETEBUTTON);		m_SingleDialogCheckbox = (CButton *) GetDlgItem(IDC_LAYOUTSEPARATEDIALOG);		if (m_PromptingStyle == kPromptOneAtATime)		m_SingleDialogCheckbox->SetCheck(BST_CHECKED);	else		m_SingleDialogCheckbox->SetCheck(BST_UNCHECKED);			m_EditButton->EnableWindow(FALSE);	m_EditButton->SetWindowText("&View...");	m_DeleteButton->EnableWindow(FALSE);	// Finally, add all of the controls to the resizer object		m_Resizer.Add(this, IDC_LAYOUTVARIABLELIST, RESIZE_LOCKALL);	m_Resizer.Add(this, IDC_LAYOUTNEWBUTTON, RESIZE_LOCKLEFT | RESIZE_LOCKBOTTOM);	m_Resizer.Add(this, IDC_LAYOUTEDITBUTTON, RESIZE_LOCKLEFT | RESIZE_LOCKBOTTOM);	m_Resizer.Add(this, IDC_LAYOUTDELETEBUTTON, RESIZE_LOCKLEFT | RESIZE_LOCKBOTTOM);	m_Resizer.Add(this, IDC_LAYOUTSEPARATEDIALOG, RESIZE_LOCKLEFT | RESIZE_LOCKBOTTOM);		UpdateVariableList();		EnableToolTips(TRUE);		m_Modified = FALSE;		m_Index = -1;	// No item clicked		// Create stupid bitmaps for list - I don't need them, but they have to exist! Grrr...		m_imglLarge.Create(IDR_LARGEBLANK, 32, 1, RGB(255, 0, 255));	m_imglSmall.Create(IDR_SMALLBLANK, 16, 1, RGB(255, 0, 255));	m_VariableListBox->SetImageList(&m_imglLarge, LVSIL_NORMAL);	m_VariableListBox->SetImageList(&m_imglSmall, LVSIL_SMALL);	m_VariableListBox->InsertColumn(0, "Name", LVCFMT_LEFT, kMaxVariableNameDispLength, -1);	m_VariableListBox->InsertColumn(1, "Class", LVCFMT_LEFT, kMaxVariableClassDispLength, 1);	m_VariableListBox->InsertColumn(2, "Type", LVCFMT_LEFT, kMaxVariableTypeDispLength, 2);	m_VariableListBox->InsertColumn(3, "Data Type", LVCFMT_LEFT, kMaxVariableDataTypeDispLength, 3);	m_VariableListBox->InsertColumn(4, "Other Attributes", LVCFMT_LEFT, kMaxVariableRequiredDispLength, 4);			return TRUE;}void CMFCVariablesPage::OnSize(UINT nType, int cx, int cy) {	CPropertyPage::OnSize(nType, cx, cy);	// Resize!	m_Resizer.Resize(this);	}void CMFCVariablesPage::OnOK(){	if (m_SingleDialogCheckbox->GetCheck() == BST_CHECKED)		m_PromptingStyle = kPromptOneAtATime;	else		m_PromptingStyle = kPromptAllInOne;	if (m_Modified)		CancelToClose();}void CMFCVariablesPage::OnNewPressed(){	// Create a new variable for editing		CEyeDxVariable *theVariable = new CEyeDxVariable(CEyeDxVariable::kUser);		if (HandleEditVariable(m_VariableList, theVariable, TRUE, m_showHidden) == true)	{		// Add the new variable to both the local list (the one shown in the menus and scrolling list)		// and the full global list				m_VariableList->AddVariable(theVariable);				UpdateVariableList();			m_EditButton->EnableWindow(TRUE);		m_EditButton->SetWindowText("&Edit...");		m_DeleteButton->EnableWindow(TRUE);		CancelToClose();	}	else		delete theVariable;}void CMFCVariablesPage::EditItem(int theItem){	CString theName = m_VariableListBox->GetItemText(m_Index, 0);		CEyeDxVariable *theVariable = m_VariableList->GetVariableByName(theName);		if (theVariable->GetVariableClass() == CEyeDxVariable::kUser)	{		m_EditButton->EnableWindow(TRUE);		m_EditButton->SetWindowText("&Edit...");		m_DeleteButton->EnableWindow(TRUE);	}	else	{		m_EditButton->EnableWindow(TRUE);		m_EditButton->SetWindowText("&View...");		m_DeleteButton->EnableWindow(FALSE);	}			HandleEditVariable(m_VariableList, theVariable, FALSE, m_showHidden);	UpdateVariableList();	}void CMFCVariablesPage::OnListDoubleClicked(NMHDR *pnmh, LRESULT *pResult){	DWORD dwPos = ::GetMessagePos();	CPoint point ((int) LOWORD(dwPos), (int) HIWORD(dwPos));	m_VariableListBox->ScreenToClient(&point);		if ((m_Index = m_VariableListBox->HitTest(point)) != -1)		EditItem(m_Index);}	void CMFCVariablesPage::OnEditPressed(){	// They had to click on an item to be able to hit the Edit button. We handle	// the click in a separate routine, and track the item in the m_Index variable.		if (m_Index != -1)		EditItem(m_Index);}void CMFCVariablesPage::OnDeletePressed(){	// Look up the variable that is currently selected and confirm that they want to delete it			if (m_Index != -1)	{								CString theName = m_VariableListBox->GetItemText(m_Index, 0);				CEyeDxVariable *theVariable = m_VariableList->GetVariableByName(theName);							CString theMessage;		theMessage.Format("Are you sure you want to delete the variable %s (no undo!)?", *theName);				if (MessageBox(theMessage, AfxGetAppName(), MB_YESNO) == IDYES)		{			m_VariableList->DeleteVariableByName(*theName);			UpdateVariableList();				CancelToClose();		}	}			}void CMFCVariablesPage::OnListClicked(NMHDR *pnmh, LRESULT *pResult){	DWORD dwPos = ::GetMessagePos();	CPoint point ((int) LOWORD(dwPos), (int) HIWORD(dwPos));	m_VariableListBox->ScreenToClient(&point);		m_Index = m_VariableListBox->HitTest(point);		if (m_Index != -1)	{								CString theName = m_VariableListBox->GetItemText(m_Index, 0);				CEyeDxVariable *theVariable = m_VariableList->GetVariableByName(theName);			if (theVariable->GetVariableClass() == CEyeDxVariable::kUser)		{			m_EditButton->EnableWindow(TRUE);			m_EditButton->SetWindowText("&Edit...");			m_DeleteButton->EnableWindow(TRUE);		}		else		{			m_EditButton->EnableWindow(TRUE);			m_EditButton->SetWindowText("&View...");			m_DeleteButton->EnableWindow(FALSE);		}			}}void CMFCVariablesPage::OnListColumnPressed(NMHDR *pnmh, LRESULT *pResult){}void CMFCVariablesPage::UpdateVariableList(){	// Get the index of the item at the top of the list, so we can restore	// it later		int theTopItem = m_VariableListBox->GetTopIndex();	// We first delete all of the items from the variable scrolling list		m_VariableListBox->DeleteAllItems();			// Now we add all of the variables to the list box		m_VariableListBox->SendMessage(WM_SETREDRAW, FALSE, 0);		int theItemCount = m_VariableList->GetCount();		for (long theItem = 0; theItem < theItemCount; theItem++)	{		CEyeDxVariable *theVariable = m_VariableList->GetVariableByIndex(theItem);				if (m_showHidden || !theVariable->GetVariableIsHidden())		{			CString *theName = theVariable->GetName();			CString theTruncatedName = theName->Left(kMaxVariableNameCharLength);						CString theClassStr;			CString theTypeStr;			CString theDataTypeStr;			CString theOtherStr;			CString *theValueStr;						// If the variable is hidden, display that instead of the class						if (theVariable->GetVariableIsHidden())				theClassStr = "Hidden";			else			{				switch (theVariable->GetVariableClass())				{				case CEyeDxVariable::kUser:					theClassStr = "User";					break;									case CEyeDxVariable::kEyeDx:					theClassStr = "EyeDx";					break;				}				}						switch (theVariable->GetVariableType())			{			case CEyeDxVariable::kFixed:				theTypeStr = "Fixed";				break;							case CEyeDxVariable::kPrompted:				switch (theVariable->GetWhenToPrompt())				{				case CEyeDxVariable::kPromptNone:					theTypeStr = "No Prompt";					break;									case CEyeDxVariable::kPromptOnStart:					theTypeStr = "Prompt: On Startup";					break;				case CEyeDxVariable::kPromptForSubject:					theTypeStr = "Prompt: Each Subject";					break;								case CEyeDxVariable::kPromptForSession:					theTypeStr = "Prompt: Each Session";					break;								case CEyeDxVariable::kPromptForEndOfSession:					theTypeStr = "Prompt: End of Session";					break;				case CEyeDxVariable::kPromptDisabled:					theTypeStr = "Prompt: Disabled";					break;				}										break;							case CEyeDxVariable::kCalculated:				theTypeStr = "Calculated";				break;			}							switch (theVariable->GetDataType())			{			case CEyeDxVariable::kTypeNone:			case CEyeDxVariable::kGeneralString:				theDataTypeStr = "String";				break;							case CEyeDxVariable::kDate:				theDataTypeStr = "Date";				break;			case CEyeDxVariable::kPastDate:				theDataTypeStr = "Past Date";				break;						case CEyeDxVariable::kTime:				theDataTypeStr = "Time";				break;						case CEyeDxVariable::kIntegerNumber:				theDataTypeStr = "Number";				break;			case CEyeDxVariable::kCheckBox:				theDataTypeStr = "Check Box";				break;			case CEyeDxVariable::kMenu:				theDataTypeStr = "Menu";				break;			}									// If the variable is prompted, then indicate whether it is required or not			// If a fixed value, show the value in quotes. Otherwise, just display a blank.						theOtherStr = "";						switch (theVariable->GetVariableType())			{			case CEyeDxVariable::kPrompted:				// We only show optional/required if the prompted variable isn't disabled (it would				// be confusing to say it's required if it's disabled!).								if (theVariable->GetWhenToPrompt() != CEyeDxVariable::kPromptDisabled)				{					if (theVariable->GetValueMustBeEntered())						theOtherStr = "(Required Entry)";					else						theOtherStr = "(Optional Entry)";				}				break;			case CEyeDxVariable::kFixed:				theOtherStr = "\"";				theValueStr = theVariable->GetValue();				theOtherStr += *theValueStr;				theOtherStr += "\"";				break;			}						// Attach a pointer to the item which points to the variable. That			// allows us get the item selected (which will be sorted as we add them			// here, and thus won't match the order in them_VariableList object).						m_VariableListBox->InsertItem(theItem, (LPCTSTR) theTruncatedName);			m_VariableListBox->SetItemText(theItem, 1, (LPCTSTR) theClassStr);			m_VariableListBox->SetItemText(theItem, 2, (LPCTSTR) theTypeStr);			m_VariableListBox->SetItemText(theItem, 3, (LPCTSTR) theDataTypeStr);			m_VariableListBox->SetItemText(theItem, 4, (LPCTSTR) theOtherStr);			m_VariableListBox->SetItemData(theItem, (unsigned long) theVariable);		}	}		m_VariableListBox->SendMessage(WM_SETREDRAW, TRUE, 0);		m_VariableListBox->EnsureVisible(theTopItem, FALSE);}	BOOL CMFCVariablesPage::HandleEditVariable(CEyeDxVariableList *theVariableList, CEyeDxVariable *theVariable, BOOL newVariable, BOOL showHidden){	CMFCEditVariableDlg dlg(this, theVariableList, theVariable, newVariable, showHidden);	if (dlg.DoModal() == IDOK)	{		CancelToClose();		return TRUE;	}	else		return FALSE;}void CMFCVariablesPage::DoDataExchange(CDataExchange *pDX){	CPropertyPage::DoDataExchange(pDX);}