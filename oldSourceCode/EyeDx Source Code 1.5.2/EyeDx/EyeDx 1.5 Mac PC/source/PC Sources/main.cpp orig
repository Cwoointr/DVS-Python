// main.cp#include "main.h"		// a background image is loaded at startup and kept herestatic int				BACK_ROWS,BACK_COLS;		// backgroundstatic unsigned char	*back_image;				// backg datachar	DataPath[MAX_PATHNAME_CHARS];char	up_filename[MAX_FILENAME_CHARS];char	side_filename[MAX_FILENAME_CHARS];char	report_filename[MAX_FILENAME_CHARS];unsigned char	*up_image,*side_image;int				UP_ROWS,UP_COLS,SIDE_ROWS,SIDE_COLS;		// flags and variables for user controlint				SideWhichWay,DisplayGraphics,RunInProgress, SaveFullImages;		// analyzation variablesint				MinIrisRad,MaxIrisRad,MinPupilRad,MaxPupilRad;int				MinCRArea,MaxCRArea,BrightThresh;		// animation variablesint				CircleThickness,FramePause,ZoomSteps,Flashes;int				EYEDX_BKGND_DISPLAY_ROWS,EYEDX_BKGND_DISPLAY_COLS;	// display windowunsigned char	*eyedx_background_image;				// display datalong DebugFeatures;long AdvancedFeatures;DCBitRate CameraConnectionRate;LPCTSTR lpszClassName="EyeDx";LPCTSTR lpszWindowName="EyeDx Automated Digital Vision Screener";// These strings are used to save and restore preferences in the RegistryLPCTSTR RegistryEntryVersion = "Version 1.X";LPCTSTR SaveImagesEntry = "SaveImages";LPCTSTR DisplayReportEntry = "DisplayReport";LPCTSTR CameraRateEntry = "CameraRate";LPCTSTR CameraPortEntry = "CameraPort";LPCTSTR AdjustReportEntry = "AdjustReport";CMainApp gMainApp;BOOL CMainApp::InitInstance() {	// This tells the system to use the Registry for preferences for the application		SetRegistryKey(lpszClassName);	m_pMainWnd = new CMainWindow();	m_pMainWnd->ShowWindow( m_nCmdShow );	m_pMainWnd->UpdateWindow();	return TRUE;}BEGIN_MESSAGE_MAP( CMainWindow, CWnd )ON_WM_CREATE()ON_WM_ERASEBKGND()ON_WM_SETFOCUS()ON_BN_CLICKED(IDC_MAIN_CAMERA, 	OnCameraButtonClicked)ON_BN_CLICKED(IDC_MAIN_DISK, 	OnDiskButtonClicked)ON_BN_CLICKED(IDC_MAIN_REPORTS, OnReportsButtonClicked)ON_BN_CLICKED(IDC_MAIN_ABOUT, 	OnAboutButtonClicked)ON_BN_CLICKED(IDC_MAIN_EXIT, 	OnExitButtonClicked)ON_COMMAND(ID_APP_EXIT, OnExitButtonClicked)ON_COMMAND(ID_APP_ABOUT, OnAboutButtonClicked)ON_COMMAND(ID_FILE_INSTALL_LICENSE, EnterLicense)ON_COMMAND(ID_FILE_DISPLAY_LICENSE, DisplayLicense)ON_COMMAND(ID_FILE_EXPORT_REPORTS, HandleExportReports)ON_COMMAND(ID_FILE_PROPERTIES, HandleProperties)ON_MESSAGE(EYEDX_MFC_OK_MESSAGE, OnOkButtonClicked)ON_MESSAGE(EYEDX_MFC_CANCEL_MESSAGE, OnCancelButtonClicked)ON_MESSAGE(EYEDX_MFC_ANALYSIS_COMPLETE_MESSAGE, OnAnalysisComplete)ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)END_MESSAGE_MAP()CMainWindow::CMainWindow(){	// This variable prevents certain drawing operations from occurring before	// we are really initialized. This include the OnSetFocus call.		initialized = FALSE;		// This creates the main window		CString strWndClass = AfxRegisterWndClass(		CS_DBLCLKS,		gMainApp.LoadStandardCursor(IDC_ARROW),		(HBRUSH) (COLOR_3DFACE + 1),		gMainApp.LoadIcon("ID_EYEDX_ICON_SM"));			CreateEx(0, strWndClass, lpszWindowName, 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,		CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 		NULL, NULL);			// Add our menu to the main window		CMenu theMenu;	theMenu.LoadMenu("IDR_MAINFRAME");	SetMenu(&theMenu);	theMenu.Detach();	DrawMenuBar();}BOOL CMainWindow::PreTranslateMessage(MSG *pMsg){	if (IsDialogMessage(pMsg))		return TRUE;	else		return CWnd::PreTranslateMessage(pMsg);}void CMainWindow::OnSetFocus(CWnd *pOldWnd){	CWnd::OnSetFocus(pOldWnd);	//m_ctlCameraButton.SetButtonStyle(m_ctlCameraButton.GetButtonStyle() | BS_DEFPUSHBUTTON);		if (initialized)		m_ctlDiskButton.SetFocus();}void CMainWindow::LoadPreferences(){	// Load our preferences		m_SaveImages = gMainApp.GetProfileInt(RegistryEntryVersion, SaveImagesEntry, TRUE);		m_DisplayReport = gMainApp.GetProfileInt(RegistryEntryVersion, DisplayReportEntry, kDisplaySummary);	m_AdjReport = gMainApp.GetProfileInt(RegistryEntryVersion, AdjustReportEntry, kAdjustName);	m_CameraRate = (DCBitRate) gMainApp.GetProfileInt(RegistryEntryVersion, CameraRateEntry, DCBitRate115200);		m_CameraPort = (DCPortNum) gMainApp.GetProfileInt(RegistryEntryVersion, CameraPortEntry, DCPortNum1);	// Make sure the rate is a valid number		switch (m_CameraRate)	{	case DCBitRate57600:	case DCBitRate115200:		break;	default:		MessageBox("Invalid camera connection rate in registry. Setting to 115200 bps", AfxGetAppName());		m_CameraRate = DCBitRate115200;		break;	}		if ((m_CameraPort < DCPortNum1) || (m_CameraPort > DCPortNum4))		m_CameraPort = DCPortNum1;}void CMainWindow::SavePreferences(){	// Save our preferences		gMainApp.WriteProfileInt(RegistryEntryVersion, SaveImagesEntry, m_SaveImages);		gMainApp.WriteProfileInt(RegistryEntryVersion, DisplayReportEntry, m_DisplayReport);	gMainApp.WriteProfileInt(RegistryEntryVersion, AdjustReportEntry, m_AdjReport);	gMainApp.WriteProfileInt(RegistryEntryVersion, CameraRateEntry, m_CameraRate);	gMainApp.WriteProfileInt(RegistryEntryVersion, CameraPortEntry, m_CameraPort);}void CMainWindow::PostNcDestroy(){	// Delete the license files so that they get flushed out		delete mPrimaryLicense;	delete mBackupLicense;		// We always close the camera, just in case		CloseCamera(this);		delete this;}void CMainWindow::CreateSubdirs(){	// Create the necessary subdirectories if they don't exist - reports, Pimages, Simages, and eyes.		char pathname[MAX_PATHNAME_CHARS + 50];	HANDLE		hFind;	WIN32_FIND_DATA	fd;		strcpy(m_DefaultreportsDir,DataPath); 	if (m_DefaultreportsDir[strlen(m_DefaultreportsDir)-1] != PATHSEPARATOR)		strcat(m_DefaultreportsDir, PATHSEPARATORSTR);  	strcat(m_DefaultreportsDir,"reports");  	if ((hFind=FindFirstFile(m_DefaultreportsDir,&fd)) == INVALID_HANDLE_VALUE)    {    	if (!CreateDirectory(m_DefaultreportsDir,NULL))	  		MessageBox("Unable to create reports folder!\nWill save in EyeDx Folder.", AfxGetAppName());    } 	FindClose(hFind);	sprintf(m_DefaultPimagesDir,"%s%sPimages",DataPath,			(DataPath[strlen(DataPath)-1] == '\\' ? "" : "\\"));	if ((hFind=FindFirstFile(m_DefaultPimagesDir,&fd)) == INVALID_HANDLE_VALUE)	{	  	if (!CreateDirectory(m_DefaultPimagesDir,NULL))			MessageBox("Unable to create Pimages folder!\nWill save in EyeDx Folder.", AfxGetAppName());	}	FindClose(hFind);		sprintf(pathname,"%s%sSimages",DataPath,			(DataPath[strlen(DataPath)-1] == '\\' ? "" : "\\"));	if ((hFind=FindFirstFile(pathname,&fd)) == INVALID_HANDLE_VALUE)	{	  	if (!CreateDirectory(pathname,NULL))			MessageBox("Unable to create Simages folder!\nWill save in EyeDx Folder.", AfxGetAppName());	}	FindClose(hFind);		sprintf(pathname,"%s%seyes",DataPath,			(DataPath[strlen(DataPath)-1] == '\\' ? "" : "\\"));	if ((hFind=FindFirstFile(pathname,&fd)) == INVALID_HANDLE_VALUE)	{	  	if (!CreateDirectory(pathname,NULL))			MessageBox("Unable to create eyes folder!\nWill save in EyeDx Folder.", AfxGetAppName());	}	FindClose(hFind);			}int CMainWindow::OnCreate(LPCREATESTRUCT lpcs){	if (CWnd::OnCreate(lpcs) == -1)		return -1;			// Set the sizes and positions of window elements based on the font for the window.	// This will account for larger font sizes that the user may select for the GUI.		CClientDC dc(this);		TEXTMETRIC tm;		dc.GetTextMetrics(&tm);	m_cxChar = tm.tmAveCharWidth;	m_cyChar = tm.tmHeight + tm.tmExternalLeading;		CRect rect(0, 0, m_cxChar * EYEDX_WIN_WIDTH, m_cyChar * EYEDX_WIN_HEIGHT);			CalcWindowRect(&rect);		SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(), 				 SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW );				 				 // The first thing we do is check the device context for the screen				 // depth. If it is less than 16 bits per pixel, we alert the user than				 // we recommend 16 or more bits.				 	// Now check the depth of the monitor we are on. If it is 8 bits, tell the user that	// EyeDx recommends running on Thousands or Millions of colors		int theDepth = dc.GetDeviceCaps(BITSPIXEL); 	if (theDepth < 16)	{		MessageBox("For best image display quality, EyeDx recommends\nyou set your display to High Color (16 bit) or True Color (32 bit).", AfxGetAppName());	}	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 				 m_cyChar * MAIN_CAMERA_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH), 				 m_cyChar * (MAIN_CAMERA_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlCameraButton.Create("Run From &Camera", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_MAIN_CAMERA);	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 				 m_cyChar * MAIN_DISK_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH),				 m_cyChar * (MAIN_DISK_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlDiskButton.Create("Run From Card or &Disk", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_DEFPUSHBUTTON, rect, this, IDC_MAIN_DISK);	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 	 			 m_cyChar * MAIN_REPORTS_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH), 				 m_cyChar * (MAIN_REPORTS_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlReportsButton.Create("&View Stored Reports", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_MAIN_REPORTS);	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 				 m_cyChar * MAIN_ABOUT_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH), 				 m_cyChar * (MAIN_ABOUT_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlAboutButton.Create("&About EyeDx", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_MAIN_ABOUT);	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 		 		 m_cyChar * MAIN_EXIT_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH), 				 m_cyChar * (MAIN_EXIT_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlExitButton.Create("E&xit Application", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_MAIN_EXIT);	// We get the current directory, and use that as the parent directory for all file	// operations. This allows the software to be installed on any drive and in any folder.		DWORD dwResult = GetCurrentDirectory(sizeof(DataPath) / sizeof(TCHAR), DataPath);		if ((dwResult == 0) || (dwResult > (sizeof(DataPath) / sizeof(TCHAR))))	{		MessageBox("Can't get or store current directory! Defaulting to C:\\EyeDx\\", AfxGetAppName());		strcpy(DataPath,"C:\\EyeDx\\");	}	// We always assume that the path has the terminating path separator		if (DataPath[strlen(DataPath)] != '\\')		strcat(DataPath, "\\");			strcpy(report_filename,"");	strcpy(up_filename,"");	strcpy(side_filename,"");	up_image = side_image = NULL;		UP_ROWS = UP_COLS = SIDE_ROWS = SIDE_COLS = 0;		RunInProgress = 0;			// user interface used to be able to change all these values			// while we were researching this, but now they are fixed	DisplayGraphics = 0;		SideWhichWay = 0;	/* left */		MinIrisRad = MIN_IRIS_RAD;		MaxIrisRad = MAX_IRIS_RAD;		MinPupilRad = MIN_PUPIL_RAD;		MaxPupilRad = MAX_PUPIL_RAD;		MinCRArea = MIN_CR_AREA;		MaxCRArea = MAX_CR_AREA;		BrightThresh = BRIGHT_THRESH;		ZoomSteps = 20;		FramePause = 2000;		CircleThickness = 1;		Flashes = 20;			FILE *fp = fopen("EyeDxBg.jpg", "rb");		back_image = NULL;		if (fp != NULL)	{		if (ReadImage(fp, &back_image, &BACK_ROWS, &BACK_COLS, "EyeDxBg.jpg", this, NULL, NULL) == 0)	  		back_image = NULL;		else			fclose(fp);	}		if (back_image == NULL)	{		MessageBox("No background set.", AfxGetAppName());  		back_image = NULL;  		BACK_ROWS = BACK_COLS = 0;	}		// Make sure eyedx_background_image is NULL so we create the background image the first time through	// the background erase procedure		eyedx_background_image = NULL;		// We have not yet set the default directory for Run From Disk mode		m_DirectorySet = FALSE;		// Finally, load our preferences from the Registry		LoadPreferences();		// Set the global value		SaveFullImages = m_SaveImages;		CameraConnectionRate = m_CameraRate;		// Finally, enable ToolTips for our window		EnableToolTips(TRUE);	// This variable prevents certain drawing operations from occurring before	// we are really initialized. This include the OnSetFocus call.		initialized = TRUE;		m_ctlDiskButton.SetFocus();		mPrimaryLicense = NULL;	mBackupLicense = NULL;	// Now we see if there is a valid license. If not, we prompt for one.	// We remain in the license prompt routine until we either get a valid license, or the	// user presses the Cancel and Exit button.		// Determine whether there is a license installed and if so, is it valid. If valid, we	// skip the following entry handling. If the license is not installed, then we prompt 	// for a license. If the license is expired, we just display a notice, telling the user that	// they can still use certain features, and to obtain a new license.		LicenseStatus theLicenseStatus = GetLicenseStatus();		switch (theLicenseStatus)	{	case LicenseStatusNotInstalled:		if (HandleLicenseEntry(theLicenseStatus, true) == IDCANCEL)			exit (0);		break;			case LicenseStatusExpiredDate:	case LicenseStatusExpiredCount:	case LicenseStatusExpiredBoth:	case LicenseStatusDateOutOfRange:		HandleLicenseExpired(theLicenseStatus);		break;	case LicenseStatusValid:		// We just make sure that both license files are synchronized		SaveLicense();		break;	}		return 0;}BOOL CMainWindow::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);		CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}void CMainWindow::OnCameraButtonClicked(){	CRect rect;		if (GetLicenseStatus() != LicenseStatusValid)	{		HandleLicenseExpired(GetLicenseStatus());		return;	}		GetWindowRect(&rect);		// We create our subdirs here if necessary. This allows the user to rename the reports folder,	// for example, while the program is running, in order to organize report files by date or other	// convention. 		CreateSubdirs();		// Now, we display a dialog that allows the user to choose between the manual or automatic Run windows		CMFCCameraSetupDlg dlg(this);		switch (dlg.DoModal())	{	case IDC_PREPARE_CAMERA_MANUAL_BUTTON:		m_RunWin = new CMFCRunFromCameraWin(&rect, this, &m_DirectorySet, &m_DefaultPimagesDir[0], &m_CameraPort);		m_RunWin->ShowWindow( SW_SHOW );		m_RunWin->UpdateWindow();				// We hide the main window for now		ShowWindow( SW_HIDE );		break;			case IDOK:		// Force the animation off				DisplayGraphics = false;				m_RunWin = new CMFCRunFromCameraAutoWin(&rect, this, &m_DirectorySet, &m_DefaultPimagesDir[0], 												m_AdjReport, m_DisplayReport, &m_CameraPort);		m_RunWin->ShowWindow( SW_SHOW );		m_RunWin->UpdateWindow();				// We hide the main window for now		ShowWindow( SW_HIDE );				break;			case IDCANCEL:		break;	}}void CMainWindow::OnDiskButtonClicked(){	CRect rect;		if (GetLicenseStatus() != LicenseStatusValid)	{		HandleLicenseExpired(GetLicenseStatus());		return;	}		GetWindowRect(&rect);	// We create our subdirs here if necessary. This allows the user to rename the reports folder,	// for example, while the program is running, in order to organize report files by date or other	// convention. 		CreateSubdirs();		m_RunWin = new CMFCRunFromDiskWin(&rect, this, &m_DirectorySet, &m_DefaultPimagesDir[0]);	m_RunWin->ShowWindow( SW_SHOW );	m_RunWin->UpdateWindow();		// We hide the main window for now	ShowWindow( SW_HIDE );}static char szReportFilters[] = "Report files (*.htm)";static char szReportTitle[] = "EyeDx: Select Report to View";void CMainWindow::OnReportsButtonClicked(){	// We create our subdirs here if necessary. This allows the user to rename the reports folder,	// for example, while the program is running, in order to organize report files by date or other	// convention. Thus, we have to recreate the folder here if the next thing they do is try to display	// stored reports.		CreateSubdirs();		CFileDialog rdlg(TRUE, "htm", "*.htm", OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, szReportFilters, this);		rdlg.m_ofn.lpstrTitle = szReportTitle;	rdlg.m_ofn.lpstrInitialDir = m_DefaultreportsDir;		if (rdlg.DoModal() == IDOK)	{		OpenReport(rdlg.GetPathName());	}}void CMainWindow::OnAboutButtonClicked(){	CMFCAboutDialog dlg(this);		dlg.DoModal();}void CMainWindow::HandleProperties(){	CMFCPropertiesDlg dlg(this);		dlg.m_DisplayReport = m_DisplayReport;	dlg.m_SaveImages = m_SaveImages;	dlg.m_CameraRate = m_CameraRate;	dlg.m_AdjReport = m_AdjReport;	if (dlg.DoModal() == IDOK)	{		m_DisplayReport = dlg.m_DisplayReport;		SaveFullImages = m_SaveImages = dlg.m_SaveImages;		CameraConnectionRate = m_CameraRate = dlg.m_CameraRate;		m_AdjReport = dlg.m_AdjReport;		SavePreferences();	}}void CMainWindow::OnExitButtonClicked(){	PostMessage(WM_CLOSE, 0, 0);		// The user said to quit, so tell the window manager to close us}BOOL CMainWindow::OnEraseBkgnd(CDC *pDC){		// The first time through, we create the DIB image from the background image				if (back_image != NULL)	{		BITMAPINFOHEADER	bm_info_header;		BITMAPINFO			bm_info;				CRect rect;				GetClientRect(&rect);				if (eyedx_background_image == NULL)		{						EYEDX_BKGND_DISPLAY_ROWS=rect.bottom-rect.top;			EYEDX_BKGND_DISPLAY_COLS=rect.right-rect.left;						if (EYEDX_BKGND_DISPLAY_ROWS < 100)			  	EYEDX_BKGND_DISPLAY_ROWS=100;			if (EYEDX_BKGND_DISPLAY_COLS < 100)			  	EYEDX_BKGND_DISPLAY_COLS=100;			if (EYEDX_BKGND_DISPLAY_ROWS % 4 != 0)	// Windows pads to 4-byte boundaries			  	EYEDX_BKGND_DISPLAY_ROWS=(EYEDX_BKGND_DISPLAY_ROWS/4+1)*4;			if (EYEDX_BKGND_DISPLAY_COLS % 4 != 0)			  	EYEDX_BKGND_DISPLAY_COLS=(EYEDX_BKGND_DISPLAY_COLS/4+1)*4;		  	eyedx_background_image=(unsigned char *)calloc(EYEDX_BKGND_DISPLAY_ROWS*EYEDX_BKGND_DISPLAY_COLS*3,1);			if (eyedx_background_image == NULL)			{			    MessageBox("OnEraseBkgnd(): Out of memory", AfxGetAppName());			    std::exit(0);			}					 	for (int r=0; r<EYEDX_BKGND_DISPLAY_ROWS; r++)			{			   	int r2=(int)((double)r/(double)EYEDX_BKGND_DISPLAY_ROWS*(double)BACK_ROWS);			   	for (int c=0; c<EYEDX_BKGND_DISPLAY_COLS; c++)			  	{		/* image enters in RGB order, but windows wants it BGR */			   		int c2=(int)((double)c/(double)EYEDX_BKGND_DISPLAY_COLS*(double)BACK_COLS);			   		eyedx_background_image[(r*EYEDX_BKGND_DISPLAY_COLS+c)*3+0]=back_image[(r2*BACK_COLS+c2)*3+2];			   		eyedx_background_image[(r*EYEDX_BKGND_DISPLAY_COLS+c)*3+1]=back_image[(r2*BACK_COLS+c2)*3+1];			   		eyedx_background_image[(r*EYEDX_BKGND_DISPLAY_COLS+c)*3+2]=back_image[(r2*BACK_COLS+c2)*3+0];			    }			}		}		bm_info_header.biSize=sizeof(BITMAPINFOHEADER); 		bm_info_header.biWidth=EYEDX_BKGND_DISPLAY_COLS;		bm_info_header.biHeight=-EYEDX_BKGND_DISPLAY_ROWS; 		bm_info_header.biPlanes=1;		bm_info_header.biBitCount=24; 		bm_info_header.biCompression=BI_RGB; 		bm_info_header.biSizeImage=0; 		bm_info_header.biXPelsPerMeter=0; 		bm_info_header.biYPelsPerMeter=0;		bm_info_header.biClrUsed=0; 		bm_info_header.biClrImportant=0;		// bm_info.bmiColors=NULL;		bm_info.bmiHeader=bm_info_header;		SetDIBitsToDevice(pDC->GetSafeHdc(),0,0,EYEDX_BKGND_DISPLAY_COLS,EYEDX_BKGND_DISPLAY_ROWS,0,0,				  0, /* first scan line */				  EYEDX_BKGND_DISPLAY_ROWS, /* number of scan lines */				  eyedx_background_image,&bm_info,DIB_RGB_COLORS);	}	return TRUE;}// These routines handle the pop-up window's exiting. void CMainWindow::OnOkButtonClicked(UINT, LONG){	CRect rect;			GetWindowRect(&rect);	m_AnalysisWin = new CMFCAnalysisWin(&rect, this, SaveFullImages, m_AdjReport, &m_Results);	m_AnalysisWin->ShowWindow( SW_SHOW );	m_AnalysisWin->UpdateWindow();}void CMainWindow::OnCancelButtonClicked(UINT, LONG){	// Note that the Run From Disk or Camera Window made us visible		CleanupImages();}void CMainWindow::OpenReport(const char *reportpath){	char	BrowserCommand[MAX_PATHNAME_CHARS],BrowserPath[MAX_PATHNAME_CHARS];	char	text1[MAX_PATHNAME_CHARS];	CWaitCursor wait;			// Show a wait cursor while we fork the browser	HKEY	hKeyHTML,hKeyCommand;	DWORD	Type,Bytes;	STARTUPINFO si;	PROCESS_INFORMATION pi;	int openOK = FALSE;			// Set up the variables that define the browser process options	// used later in the CreateProcess call	ZeroMemory(&si, sizeof(STARTUPINFO));	si.cb = sizeof(STARTUPINFO);	si.dwFlags = STARTF_FORCEONFEEDBACK;		int i;		if (1 /* AutoReport == 1 */)	{		/* look in Windows registry for default command to open html file */		if (RegOpenKeyEx(HKEY_CLASSES_ROOT,".htm",0,KEY_ALL_ACCESS,&hKeyHTML) == ERROR_SUCCESS)		{			Bytes=250;			RegQueryValueEx(hKeyHTML,"",0L,&Type,(unsigned char *)text1,&Bytes);			strcat(text1,"\\shell\\open\\command");			if (RegOpenKeyEx(HKEY_CLASSES_ROOT,text1,0,KEY_ALL_ACCESS,&hKeyCommand) == ERROR_SUCCESS)			{				Bytes=MAX_PATHNAME_CHARS;				RegQueryValueEx(hKeyCommand,"",0L,&Type,(unsigned char *)BrowserCommand,&Bytes);				i=1;				while (BrowserCommand[i] != ':'	||	BrowserCommand[i+1] != '\\')					i++;				strcpy(BrowserPath,&(BrowserCommand[i-1]));				i=0;				while (i < (int)strlen(BrowserPath)	&&	BrowserPath[i] != ' ')					i++;				while (i > 0	&&	!(BrowserPath[i] == 'e'	||	BrowserPath[i] == 'E'))					i--;				BrowserPath[i+1]='\0';				RegCloseKey(hKeyCommand);				i=strlen(BrowserPath)-1;				while (BrowserPath[i] != '\\')					i--;				strcpy(BrowserCommand,&(BrowserPath[i+1]));			}			else			{				strcpy(BrowserPath,"NotGoingToWork");				strcpy(BrowserCommand,"CouldNotFindIt");			}			RegCloseKey(hKeyHTML);						// append the path for the report file to the command line						strcat(BrowserPath, " \"");			strcat(BrowserPath, reportpath);			strcat(BrowserPath, "\"");						printf("BrowserPath = %s\n", BrowserPath);		 	openOK = CreateProcess(NULL, BrowserPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);		}		else	/* try some default locations... */		{			// append the path for the report file to the command line						strcpy(BrowserPath, "C:\\Program Files\\Netscape\\Communicator\\Program\\netscape \"");			strcat(BrowserPath, reportpath);			strcat(BrowserPath, "\"");		 	if ((openOK = CreateProcess(NULL, BrowserPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) == FALSE)		 	{						 		// Must surround path with double quotes since the report names may contain spaces				strcpy(BrowserPath, "C:\\Program Files\\Netscape\\Navigator\\Program\\netscape \"");				strcat(BrowserPath, reportpath);				strcat(BrowserPath, "\"");		 		openOK = CreateProcess(NULL, BrowserPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);			}	  	}	  		  	if (openOK)	  	{	  		// Get rid of the handles since we don't care about the forked process			CloseHandle(pi.hProcess);			CloseHandle(pi.hThread);		}		else		{			MessageBox("Unable to start web browser.\nPlease display report manually.",					AfxGetAppName());		}	}}void CMainWindow::CreateReportPath(CString &thePath, AnalysisResults *theResults){	thePath.Format("%s%c%s%s.htm",  m_DefaultreportsDir, PATHSEPARATOR, theResults->ReferralIndicator, report_filename);}void CMainWindow::OnAnalysisComplete(UINT, LONG){	// Note that the Analysis Window made us visible			CleanupImages();	CString updatedReportName;	 		// We have to create the entire path to pass to the OpenReport routine, as it is used to	// possibly open reports that are stored elsewhere.		CreateReportPath(updatedReportName, &m_Results);		// Display the report if requested to do so. Note that the OpenReport routine handles	// the display of an alert if an error occurs. We return a next step indicator, which might be	// generated by the summary display. By default, we return the continue indication.		EyeDxNextStepCode theResult = kNextStepContinue;		if (m_DisplayReport == kDisplayReport)	{		OpenReport(updatedReportName);	}	else if (m_DisplayReport == kDisplaySummary)	{		theResult = HandleSummaryDisplay(&m_Results, FALSE);	}	RunInProgress = 0;}void CMainWindow::SetParentPosition(CRect *rect){	CString string;		CalcWindowRect(rect);		SetWindowPos(NULL, rect->left, rect->top, rect->Width(), rect->Height(), 				 SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW );				 	//m_ctlCameraButton.SetFocus();}// This routine checks if the specified report exists, and prompts the user// for what to do. It also checks the report string for length and illegal// characters, and displays a notice if appropriate.// Returns true if the operation should continue, and false if not.// It also updates the global report_filename variable.BOOL CMainWindow::CheckReportValidity(CWnd *theWindow, CString theReportNameString){	// Perform some validity checks on the report name			if (theReportNameString.GetLength() == 0)	{				theWindow->MessageBox("Please enter a report name.", AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);	}	else if (theReportNameString.GetLength() > kMaxReportNameLength)	{		CString theLengthStr;		theLengthStr.Format("The report name is too long (maximum %d characters)", kMaxReportNameLength);				theWindow->MessageBox(theLengthStr, AfxGetAppName(), MB_OK);	}	else if (theReportNameString.FindOneOf(ILLEGAL_FILENAME_CHARS) >= 0)	{					CString message;		message.Format("The report name cannot contain any of the characters %s", ILLEGAL_FILENAME_CHARS);					 	theWindow->MessageBox(message, AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);	}	else	{		strcpy(report_filename, theReportNameString);				// Check if this report already exists. If it does, prompt the user whether to continue		// If the adjustName feature is enabled, we have to loop through the possible prefixes, and		// warn the user that a possible conflict exists. Otherwise, just check for the same exact name.				if (m_AdjReport)		{			char *prefixes[] = {kYesReferralIndicator, 								kNoReferralIndicator,								kSecondImageReferralIndicator,								kUnclearReferralIndicator };						char theFileList[200];			strcpy(theFileList, "");			int existingReports = 0;			for (int prefixNum = 0; prefixNum < kNumValidPrefixes; prefixNum++)			{								char reportpath[255];			  	sprintf(reportpath, "%s\\%s%s.htm", m_DefaultreportsDir, prefixes[prefixNum], report_filename);				FILE *fp;				if ((fp = fopen(reportpath, "rw")) != NULL)				{					fclose(fp);					existingReports++;					if (strlen(theFileList) != 0)						strcat(theFileList, ", ");					strcat(theFileList, "'");					strcat(theFileList, prefixes[prefixNum]);					strcat(theFileList, report_filename);					strcat(theFileList, "'");				}			}						if (existingReports > 0)			{				CString thePrompt;								if (existingReports == 1)					thePrompt.Format("A report with this name and a referral prefix exists: %s.\nShould the program overwrite it if necessary?", theFileList);				else					thePrompt.Format("Reports with this name and referral prefixes exist: %s.\nShould the program overwrite one of these if necessary?", theFileList);				int item_hit = theWindow->MessageBox(thePrompt, AfxGetAppName(), MB_OKCANCEL | MB_ICONEXCLAMATION);							if (item_hit == IDOK)					return true;				else					return false;			}			return true;		}		else		{					char reportpath[255];	  		sprintf(reportpath, "%s\\%s.htm", m_DefaultreportsDir, report_filename);						// Check if this report already exists. If it does, prompt the user whether to continue					  						FILE *fp;						// Default to the no case			int item_hit = IDOK;			if ((fp = fopen(reportpath, "rw")) != NULL)			{				fclose(fp);				item_hit = theWindow->MessageBox("A report with this name already exists.\nOverwrite?", AfxGetAppName(), MB_OKCANCEL | MB_ICONEXCLAMATION);			}			if (item_hit == IDOK)				return TRUE;			else				return FALSE;		}	}	return FALSE;		}void CMainWindow::CleanupSideImage(){	if (side_image != NULL)	{		free(side_image);		side_image = NULL;		SIDE_ROWS = SIDE_COLS = 0;	}	strcpy(side_filename,"");}void CMainWindow::CleanupUpImage(){	if (up_image != NULL)	{		free(up_image);		up_image = NULL;		UP_ROWS = UP_COLS = 0;	}	strcpy(up_filename,"");}	void CMainWindow::CleanupImages(){	CleanupUpImage();	CleanupSideImage();		RunInProgress = 0;}EyeDxNextStepCode CMainWindow::HandleSummaryDisplay(AnalysisResults *theAnalysisResults,													bool showRetakeOptions){	CMFCSummaryDlg rdlg(this, theAnalysisResults, 						m_DefaultreportsDir, showRetakeOptions);	rdlg.DoModal();			return (rdlg.m_NextStep);}