// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"#include "globals.h"#include "PreviewFileDlg.h"#include "CMFCCameraImageSelectDlg.h"#include "CMFCAnalysisWin.h"#include "CMFCRunWin.h"#include "CMFCRunFromDiskWin.h"#include "CMFCRunFromCameraWin.h"#include "CMFCAboutDialog.h"#include "EyeDxMFCMessages.h"#include "main.h"extern CMainApp gMainApp;static LPCTSTR lpszWindowName="EyeDx Photoscreener";CMFCRunFromDiskWin::CMFCRunFromDiskWin(CRect *posRect, CMainWindow *myParent, 						BOOL *DirectorySetPtr, char *DefaultImagesDir)						: CMFCRunWin(posRect, myParent, DirectorySetPtr, DefaultImagesDir){	// This creates the Run From base window		CString strWndClass = AfxRegisterWndClass(		CS_DBLCLKS,		gMainApp.LoadStandardCursor(IDC_ARROW),		(HBRUSH) (COLOR_3DFACE + 1),		gMainApp.LoadIcon("ID_EYEDX_ICON_SM"));			CreateEx(0, strWndClass, lpszWindowName, 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,		posRect->left, posRect->top, posRect->Width(), posRect->Height(), 		NULL, NULL);}BEGIN_MESSAGE_MAP( CMFCRunFromDiskWin, CMFCRunWin )ON_BN_CLICKED(IDC_DISK_OK, 	OnOkButtonClicked)ON_BN_CLICKED(IDC_DISK_CANCEL, 	OnCancelButtonClicked)ON_BN_CLICKED(IDC_DISK_SELECT_UP_BUTTON, 	OnSelectUpButtonClicked)ON_BN_CLICKED(IDC_DISK_SELECT_SIDE_BUTTON, 	OnSelectSideButtonClicked)ON_BN_CLICKED(IDC_DISK_ANIMATE_CHECKBOX, OnAnimateCheckboxClicked)ON_WM_CREATE()END_MESSAGE_MAP()BOOL CMFCRunFromDiskWin::PreTranslateMessage(MSG *pMsg){	if (IsDialogMessage(pMsg) == TRUE)		return TRUE;	else if (CWnd::PreTranslateMessage(pMsg) == TRUE)		return TRUE;	else 		return FALSE;}int CMFCRunFromDiskWin::OnCreate(LPCREATESTRUCT lpcs){	if (CMFCRunWin::OnCreate(lpcs) == -1)		return -1;			RunInProgress = 2;	CRect rect;		GetClientRect(&rect);		int WindowWidth = (rect.right-rect.left) / m_cxChar;		int CenterLine = WindowWidth / 2;		int LeftCenterLine = (DISK_VIEW_WIDTH / 2) + DISK_RIGHT_MARGIN;		int RightCenterLine = WindowWidth - DISK_RIGHT_MARGIN - (DISK_VIEW_WIDTH / 2);			// Up Progress caption		rect.SetRect(m_cxChar * DISK_UP_PROGRESS_CAPTION_X(LeftCenterLine), 				 m_cyChar * DISK_UP_PROGRESS_CAPTION_Y, 				 m_cxChar * (DISK_UP_PROGRESS_CAPTION_X(LeftCenterLine) + DISK_UP_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (DISK_UP_PROGRESS_CAPTION_Y + DISK_UP_PROGRESS_CAPTION_HEIGHT));		m_ctlUpProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_UP_PROGRESS_CAPTION);	m_ctlUpProgressCaption.SetFont(&m_ctlFont);		// Side Progress caption		rect.SetRect(m_cxChar * DISK_SIDE_PROGRESS_CAPTION_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_PROGRESS_CAPTION_Y, 				 m_cxChar * (DISK_SIDE_PROGRESS_CAPTION_X(RightCenterLine) + DISK_SIDE_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (DISK_SIDE_PROGRESS_CAPTION_Y + DISK_SIDE_PROGRESS_CAPTION_HEIGHT));		m_ctlSideProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_SIDE_PROGRESS_CAPTION);	m_ctlSideProgressCaption.SetFont(&m_ctlFont);	// Up Progress bar		rect.SetRect(m_cxChar * DISK_UP_PROGRESS_BAR_X(LeftCenterLine), 				 m_cyChar * DISK_UP_PROGRESS_BAR_Y, 				 m_cxChar * (DISK_UP_PROGRESS_BAR_X(LeftCenterLine) + DISK_UP_PROGRESS_BAR_WIDTH), 				 m_cyChar * (DISK_UP_PROGRESS_BAR_Y + DISK_UP_PROGRESS_BAR_HEIGHT));	m_ctlUpProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_DISK_UP_PROGRESS_BAR);	// Side Progress bar		rect.SetRect(m_cxChar * DISK_SIDE_PROGRESS_BAR_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_PROGRESS_BAR_Y, 				 m_cxChar * (DISK_SIDE_PROGRESS_BAR_X(RightCenterLine) + DISK_SIDE_PROGRESS_BAR_WIDTH), 				 m_cyChar * (DISK_SIDE_PROGRESS_BAR_Y + DISK_SIDE_PROGRESS_BAR_HEIGHT));	m_ctlSideProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_DISK_SIDE_PROGRESS_BAR);	// Up Image View		rect.SetRect(m_cxChar * DISK_UP_VIEW_X(LeftCenterLine), 				 m_cyChar * DISK_UP_VIEW_Y, 				 m_cxChar * (DISK_UP_VIEW_X(LeftCenterLine) + DISK_UP_VIEW_WIDTH), 				 m_cyChar * (DISK_UP_VIEW_Y + DISK_UP_VIEW_HEIGHT));		m_ctlUpView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_DISK_UP_VIEW);		// Side Image View		rect.SetRect(m_cxChar * DISK_SIDE_VIEW_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_VIEW_Y, 				 m_cxChar * (DISK_SIDE_VIEW_X(RightCenterLine) + DISK_SIDE_VIEW_WIDTH), 				 m_cyChar * (DISK_SIDE_VIEW_Y + DISK_SIDE_VIEW_HEIGHT));		m_ctlSideView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_DISK_SIDE_VIEW);	// Up Image Quality Bitmap		rect.SetRect(m_cxChar * DISK_UP_QUALITY_ICON_X(LeftCenterLine), 				 m_cyChar * DISK_UP_QUALITY_ICON_Y, 				 m_cxChar * (DISK_UP_QUALITY_ICON_X(LeftCenterLine) + DISK_UP_QUALITY_ICON_WIDTH), 				 m_cyChar * (DISK_UP_QUALITY_ICON_Y + DISK_UP_QUALITY_ICON_HEIGHT));		m_ctlUpQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_DISK_UP_QUALITY_ICON);			m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);	// Side Image Quality Bitmap	rect.SetRect(m_cxChar * DISK_SIDE_QUALITY_ICON_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_QUALITY_ICON_Y, 				 m_cxChar * (DISK_SIDE_QUALITY_ICON_X(RightCenterLine) + DISK_SIDE_QUALITY_ICON_WIDTH), 				 m_cyChar * (DISK_SIDE_QUALITY_ICON_Y + DISK_SIDE_QUALITY_ICON_HEIGHT));		m_ctlSideQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_DISK_SIDE_QUALITY_ICON);	m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);	// Up Image caption		rect.SetRect(m_cxChar * DISK_UP_CAPTION_X(LeftCenterLine), 				 m_cyChar * DISK_UP_CAPTION_Y, 				 m_cxChar * (DISK_UP_CAPTION_X(LeftCenterLine) + DISK_UP_CAPTION_WIDTH), 				 m_cyChar * (DISK_UP_CAPTION_Y + DISK_UP_CAPTION_HEIGHT));		m_ctlUpCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_UP_CAPTION);	m_ctlUpCaption.SetFont(&m_ctlFont);		// Side Image caption		rect.SetRect(m_cxChar * DISK_SIDE_CAPTION_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_CAPTION_Y, 				 m_cxChar * (DISK_SIDE_CAPTION_X(RightCenterLine) + DISK_SIDE_CAPTION_WIDTH), 				 m_cyChar * (DISK_SIDE_CAPTION_Y + DISK_SIDE_CAPTION_HEIGHT));		m_ctlSideCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT , rect, this, IDC_DISK_SIDE_CAPTION);	m_ctlSideCaption.SetFont(&m_ctlFont);		// Select Up Image button			rect.SetRect(m_cxChar * DISK_SELECT_UP_BUTTON_X(LeftCenterLine), 				 m_cyChar * DISK_SELECT_UP_BUTTON_Y, 				 m_cxChar * (DISK_SELECT_UP_BUTTON_X(LeftCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_SELECT_UP_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlUpSelectButton.Create(DISK_SELECT_UP_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_DISK_SELECT_UP_BUTTON);	// Select Side Image button		rect.SetRect(m_cxChar * DISK_SELECT_SIDE_BUTTON_X(RightCenterLine), 				 m_cyChar * DISK_SELECT_SIDE_BUTTON_Y, 				 m_cxChar * (DISK_SELECT_SIDE_BUTTON_X(RightCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_SELECT_SIDE_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlSideSelectButton.Create(DISK_SELECT_SIDE_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_DISK_SELECT_SIDE_BUTTON);	// Show Animation during processing checkbox		rect.SetRect(m_cxChar * DISK_ANIMATE_CHECKBOX_X(CenterLine), 				 m_cyChar * DISK_ANIMATE_CHECKBOX_Y, 				 m_cxChar * (DISK_ANIMATE_CHECKBOX_X(CenterLine) + DISK_ANIMATE_CHECKBOX_WIDTH), 				 m_cyChar * (DISK_ANIMATE_CHECKBOX_Y + DISK_ANIMATE_CHECKBOX_HEIGHT));		m_ctlAnimateCheckbox.Create(DISK_ANIMATE_CHECKBOX_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_AUTOCHECKBOX, rect, this, IDC_DISK_ANIMATE_CHECKBOX);	// Report Name caption - This is aligned with the Animate Checkbox above		rect.SetRect(m_cxChar * DISK_ANIMATE_CHECKBOX_X(CenterLine), 				 m_cyChar * DISK_NAME_CAPTION_Y, 				 m_cxChar * (DISK_ANIMATE_CHECKBOX_X(CenterLine) + DISK_NAME_CAPTION_WIDTH), 				 m_cyChar * (DISK_NAME_CAPTION_Y + DISK_NAME_CAPTION_HEIGHT));		m_ctlNameCaption.Create(DISK_NAME_CAPTION_LABEL, 								WS_CHILD | WS_VISIBLE | SS_RIGHT, rect, this, IDC_DISK_NAME_EDIT_FIELD_CAPTION);		// Report Name edit field		rect.SetRect(m_cxChar * (DISK_ANIMATE_CHECKBOX_X(CenterLine) + DISK_NAME_CAPTION_WIDTH + 1), 				 m_cyChar * DISK_NAME_EDIT_FIELD_Y, 				 m_cxChar * ((DISK_ANIMATE_CHECKBOX_X(CenterLine) + DISK_NAME_CAPTION_WIDTH + 1) + DISK_NAME_EDIT_FIELD_WIDTH), 				 m_cyChar * (DISK_NAME_EDIT_FIELD_Y + DISK_NAME_EDIT_FIELD_HEIGHT));		m_ctlNameEditField.Create(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP | ES_LEFT,								rect, this, IDC_DISK_NAME_EDIT_FIELD);	rect.SetRect(m_cxChar * DISK_CANCEL_BUTTON_X(LeftCenterLine), 				 m_cyChar * DISK_CANCEL_BUTTON_Y, 				 m_cxChar * (DISK_CANCEL_BUTTON_X(LeftCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_CANCEL_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlOkButton.Create(DISK_CANCEL_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_DISK_CANCEL);	rect.SetRect(m_cxChar * DISK_OK_BUTTON_X(RightCenterLine), 				 m_cyChar * DISK_OK_BUTTON_Y, 				 m_cxChar * (DISK_OK_BUTTON_X(RightCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_OK_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlCancelButton.Create(DISK_OK_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_DEFPUSHBUTTON, rect, this, IDC_DISK_OK);	// Set the value of the edit field to the default		m_ctlNameEditField.SetWindowText("No name");	m_ctlNameEditField.SetLimitText(MAX_FILENAME_CHARS);		// Set the checkbox value to the stored default		m_ctlAnimateCheckbox.SetCheck((DisplayGraphics ? BST_CHECKED : BST_UNCHECKED));		m_ctlUpSelectButton.SetFocus();	return 0;}char szFilters[] = "KDC files (*.kdc)|*.kdc|JPEG files (*.jpg)|*.jpg||";void CMFCRunFromDiskWin::OnSelectUpButtonClicked(){	CPreviewFileDlg dlg(TRUE, "kdc", "*.kdc", OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, szFilters, this);		static char szTitle[] = "EyeDx: Select Up Image";	dlg.m_ofn.lpstrTitle = szTitle;		// If we have not set the default images directory, do it only the first time we present	// the open file dialog. We update the parent's flag indicating that we have done this,	// and this flag is passed to us on subsequent calls.		if (*m_DirectorySetPtr == FALSE)	{		*m_DirectorySetPtr = TRUE;		dlg.m_ofn.lpstrInitialDir = m_DefaultImagesDir;	}		if (dlg.DoModal() == IDOK)	{		CWaitCursor wait;				m_UpSelected = true;		// If a file is already displayed, delete the old one		if (up_image != NULL)		{		    free(up_image);		    up_image = NULL;		    UP_ROWS = UP_COLS = 0;		}		// Determine whether to copy files. First, default to the option the user		// has selected. Next, if the option is turned on, see if the source directory		// is the Pimages directory. If so, then there's no sense copying the file.				bool copyFiles = SaveFullImages;				if (copyFiles)		{			CString filePath = dlg.GetPathName();						// Check the file path to see if it contains the path for the Pimages directory.			// If so, we do not want to copy!			if (filePath.Find(m_DefaultImagesDir) >= 0)		    	copyFiles = false;		}   				strcpy(up_filename, dlg.GetFileName());				FILE *fileptr = fopen(dlg.GetPathName(), "rb");				if (!fileptr)			MessageBox("Cannot open file.", AfxGetAppName(), MB_OK);		else						{			// Assume that the pictinfo member isn't set - which will happen			// if the image is JPEG			m_UpPictInfoValid = FALSE;							m_ctlUpProgressBar.ShowWindow(SW_SHOW);			m_ctlUpProgressCaption.ShowWindow(SW_SHOW);			m_ctlUpCaption.ShowWindow(SW_SHOW);						if (ReadImageFromFile(fileptr, &up_image ,&UP_ROWS,&UP_COLS, up_filename, 									copyFiles,									NULL,									NULL,									&m_UpPictInfo, &m_UpPictInfoValid,									this, &m_ctlUpProgressBar, &m_ctlUpProgressCaption, &m_ctlUpCaption) == 0)			{				m_ctlUpProgressBar.ShowWindow(SW_HIDE);				m_ctlUpProgressCaption.ShowWindow(SW_HIDE);				m_ctlUpCaption.ShowWindow(SW_HIDE);				strcpy(up_filename,"");			}			else			{				m_ctlUpProgressBar.ShowWindow(SW_HIDE);				m_ctlUpProgressCaption.ShowWindow(SW_HIDE);				m_ctlUpQualityBitmap.ShowWindow(SW_SHOW);								// If the quality isn't what we should be using, warn the user				if (m_UpPictInfoValid && m_UpPictInfo.PictQuality != DC120BestQuality)				{				 	MessageBox("This image was not taken with the recommended 'Best' image quality setting\n"				 				"and analysis of this image may produce incorrect results.\n"				 				"EyeDx recommends you retake this picture.", AfxGetAppName(), MB_OK);					m_ctlUpQualityBitmap.SetBitmap(m_hCautionBitmap);				}				else					m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);				m_ctlUpView.SetImageFromRaw24Bit(up_image, UP_ROWS, UP_COLS);			}		}	}}void CMFCRunFromDiskWin::OnSelectSideButtonClicked(){	CPreviewFileDlg dlg(TRUE, "kdc", "*.kdc", OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, szFilters, this);		static char szTitle[] = "EyeDx: Select Side Image";	dlg.m_ofn.lpstrTitle = szTitle;		// If we have not set the default images directory, do it only the first time we present	// the open file dialog. We update the parent's flag indicating that we have done this,	// and this flag is passed to us on subsequent calls.		if (*m_DirectorySetPtr == FALSE)	{		*m_DirectorySetPtr = TRUE;		dlg.m_ofn.lpstrInitialDir = m_DefaultImagesDir;	}		if (dlg.DoModal() == IDOK)	{		CWaitCursor wait;				m_SideSelected = true;		// If a file is already displayed, delete the old one		if (side_image != NULL)		{		    free(side_image);		    side_image = NULL;		    SIDE_ROWS = SIDE_COLS = 0;		}		// Determine whether to copy files. First, default to the option the user		// has selected. Next, if the option is turned on, see if the source directory		// is the Pimages directory. If so, then there's no sense copying the file.				bool copyFiles = SaveFullImages;				if (copyFiles)		{			CString filePath = dlg.GetPathName();						// Check the file path to see if it contains the path for the Pimages directory.			// If so, we do not want to copy!			if (filePath.Find(m_DefaultImagesDir) >= 0)		    	copyFiles = false;		}   				strcpy(side_filename, dlg.GetFileName());				FILE *fileptr = fopen(dlg.GetPathName(), "rb");				if (!fileptr)			MessageBox("Cannot open file.", AfxGetAppName(), MB_OK);		else						{			// Assume that the pictinfo member isn't set - which will happen			// if the image is JPEG			m_SidePictInfoValid = FALSE;			m_ctlSideProgressBar.ShowWindow(SW_SHOW);			m_ctlSideProgressCaption.ShowWindow(SW_SHOW);			m_ctlSideCaption.ShowWindow(SW_SHOW);			if (ReadImageFromFile(fileptr, &side_image,&SIDE_ROWS,&SIDE_COLS, side_filename, 									copyFiles,									NULL,									NULL,									&m_SidePictInfo, &m_SidePictInfoValid,									this, &m_ctlSideProgressBar, &m_ctlSideProgressCaption, &m_ctlSideCaption) == 0)			{				m_ctlSideProgressBar.ShowWindow(SW_HIDE);				m_ctlSideProgressCaption.ShowWindow(SW_HIDE);				m_ctlSideCaption.ShowWindow(SW_HIDE);				strcpy(side_filename,"");			}			else			{				m_ctlSideProgressBar.ShowWindow(SW_HIDE);				m_ctlSideProgressCaption.ShowWindow(SW_HIDE);				m_ctlSideQualityBitmap.ShowWindow(SW_SHOW);								// If the quality isn't what we should be using, warn the user				if (m_SidePictInfoValid && m_SidePictInfo.PictQuality != DC120BestQuality)				{				 	MessageBox("This image was not taken with the recommended 'Best' image quality setting\n"				 				"and analysis of this image may produce incorrect results.\n"				 				"EyeDx recommends you retake this picture.", AfxGetAppName(), MB_OK);					m_ctlSideQualityBitmap.SetBitmap(m_hCautionBitmap);				}				else					m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);				m_ctlSideView.SetImageFromRaw24Bit(side_image, SIDE_ROWS, SIDE_COLS);			}		}	}}// This function is called when the Ok button is pressed. We send a message// to ourselves which will eventually destroy the Run From Disk window.// We also set the member that indicates the kind of message to send to // the parent. In the case of OK, we want the parent to go ahead and initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.int CMFCRunFromDiskWin::OnOkButtonClicked(){	// Call the base class to test whether to actually continue		if (CMFCRunWin::OnOkButtonClicked())	{		// Tell ourselves to close, which will send a message to our parent to begin		// analysis		PostMessage(WM_CLOSE, 0, 0);	}	return 0;}// This function is called when the Ok button is pressed. We send a message// to ourselves which will eventually destroy the Run From Disk window.// We also set the member that indicates the kind of message to send to // the parent. In the case of Cancel, we want the parent not initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.void CMFCRunFromDiskWin::OnCancelButtonClicked(){	CMFCRunWin::OnCancelButtonClicked();}