#pragma once#include "main.h"IMPLEMENT_SERIAL(CEyeDxProperties, CObject, kCEyeDxPropertiesCurrentSchema | VERSIONABLE_SCHEMA)// The constructor loads the properties from various default locations (Registry, resources, existing// user text block files, etc. This is done so that if no Properties file exists, the object will be// set up with the default values for everything. Once the object is serialized into a Properties file,// the contents of that file will take precedence over these defaults the next time the program runs.CEyeDxProperties::CEyeDxProperties(){	LPCTSTR RegistryEntryVersion = "Version 1.X";	LPCTSTR SaveImagesEntry = "SaveImages";	LPCTSTR DisplayReportEntry = "DisplayReport";	LPCTSTR CameraRateEntry = "CameraRate";	LPCTSTR CameraPortEntry = "CameraPort";	LPCTSTR AdjustReportEntry = "AdjustReport";	LPCTSTR ReportFormatEntry = "ReportFormat";	LPCTSTR PromptingStyleEntry = "PromptingStyle";	LPCTSTR UseSessionsEntry = "UseSessions";	LPCTSTR UserTextBlockFile = "UserReportText.DAT";	// For backwards compatibility, we first load properties from the registry. These will be the defaults	// for our internal variables.		m_SaveImages = gMainApp.GetProfileInt(RegistryEntryVersion, SaveImagesEntry, TRUE);		m_DisplayReport = gMainApp.GetProfileInt(RegistryEntryVersion, DisplayReportEntry, kDisplaySummary);	m_AdjReport = gMainApp.GetProfileInt(RegistryEntryVersion, AdjustReportEntry, kAdjustName);	m_ReportFormat = (EyeDxReportFormat) gMainApp.GetProfileInt(RegistryEntryVersion, ReportFormatEntry, kStandardReportFormat);	m_CameraRate = (DCBitRate) gMainApp.GetProfileInt(RegistryEntryVersion, CameraRateEntry, DCBitRate115200);		m_CameraPort = (DCPortNum) gMainApp.GetProfileInt(RegistryEntryVersion, CameraPortEntry, DCPortNum1);	m_PromptingStyle = gMainApp.GetProfileInt(RegistryEntryVersion, PromptingStyleEntry, kPromptOneAtATime);	m_UseSessions = gMainApp.GetProfileInt(RegistryEntryVersion, UseSessionsEntry, kNoSessions);		m_AutoCameraAutoStart = FALSE;	// Default for Version 3 Preferences	// Make sure the rate is a valid number		switch (m_CameraRate)	{	case DCBitRate57600:	case DCBitRate115200:		break;	default:		m_CameraRate = DCBitRate115200;		break;	}		if ((m_CameraPort < DCPortNum1) || (m_CameraPort > DCPortNum4))		m_CameraPort = DCPortNum1;			// Now we load the default text blocks from the application's string resources into both the defaults	// array and the user text block array. When we are serialized and loaded, user text blocks will overwrite	// these if they exist		for (long i = 0; i < kReportLayoutNumText; i++)	{		CString theString;		theString.LoadString(IDS_DEFAULTTEXTBASE + i);		m_DefaultTextBlocks.SetAtGrow(i, theString);		m_UserTextBlocks.SetAtGrow(i, theString);	}	// Now we attempt to load an existing User Text Block file. This is for backward compatibility	// purposes. If the file exists, we deserialize the m_UserTextBlocks values. If not, the defaults	// will be used until we are deserialized.		CFile userTextBlockFile;	CString userTextBlockFilePath(DataPath);	userTextBlockFilePath += UserTextBlockFile;		if (userTextBlockFile.Open(userTextBlockFilePath, CFile::modeRead))	{		CArchive ar(&userTextBlockFile, CArchive::load);				m_UserTextBlocks.Serialize(ar);		ar.Close();		userTextBlockFile.Close();	}		// Now we load the default variables. These variables are defined as resources within the application	// file. Thus, we have to extract them in a different manner than for the runtime variables that we load	// in the serialize function.		// First, create a new CEyeDxVariableList object to temporarily hold the read-in objects		m_TempVariableList = new CEyeDxVariableList;		// Also set the m_VariableList to the same pointer in case we aren't deserialzed		m_VariableList = m_TempVariableList;		HRSRC res;	HGLOBAL hres;	CEyeDxVariablePrefs *variablePtr;		// We have to get a handle to the resource		res = ::FindResource(AfxGetResourceHandle(), 						MAKEINTRESOURCE(IDC_DEFAULT_VARIABLE_TABLE), 						MAKEINTRESOURCE(IDC_DEFAULT_VARIABLE_TABLE_TYPE));		// Now, we load the resource and lock it so we can access it		BOOL varsLoaded = FALSE;		if (res != NULL)	{		hres = ::LoadResource(AfxGetResourceHandle(), res);				if (hres != NULL)		{			variablePtr = (CEyeDxVariablePrefs *) ::LockResource(hres);			if (variablePtr != NULL)			{				CEyeDxVariable *theVariable;				CString theString;								while (variablePtr->nameStrID != 0)				{					// Create a variable based on the input structure										theVariable = new CEyeDxVariable(NULL, variablePtr);															// Load the variable name from the string resource list, and set the variable name					theString.LoadString(variablePtr->nameStrID);					theVariable->SetName(theString);										// Ditto for the default value string					theString.LoadString(variablePtr->nameStrID + kEyeDxVariableWinDefaultStrOffset);					theVariable->SetDefaultValue(theString);										// Ditto for the prompt value string					theString.LoadString(variablePtr->nameStrID + kEyeDxVariableWinPromptStrOffset);					theVariable->SetPromptString(theString);										// Ditto for the comment value string					theString.LoadString(variablePtr->nameStrID + kEyeDxVariableWinCommentStrOffset);					theVariable->SetCommentString(theString);										// Now, if the variable says it has associated option strings, we look them up and add them					// to the options list										if (variablePtr->numOptionStrs > 0)					{						short theOptionStrID = variablePtr->nameStrID + kEyeDxVariableWinOptionsStrOffset;						short numOptionStr = variablePtr->numOptionStrs;						CTemplateShortStrArray	*theOptionsArray = theVariable->GetOptionStringsArray();																		while (numOptionStr--)						{							// Since the array just keeps a pointer to the string, we need to allocate each							// string as we loop and then add the pointer to the list														CEyeDxShortStringType *theOptionString = new CEyeDxShortStringType;														// Load the string resource							theOptionString->LoadString(theOptionStrID++);														// And add the string pointer to the options string array							theOptionsArray->Add(theOptionString);						}					}										// Add the variable to the list										m_TempVariableList->AddVariable(theVariable);									// Move on to the next string										variablePtr++;				}								// Unlock the resource since we are done with it. TODO - what is the Windows equivalent???								//::UnlockResource(hres);								varsLoaded = TRUE;			}						// Always compress and renumber the prompting and export order when loading						// Broken in Windows and not really needed				//m_TempVariableList->CompressPromptOrder();			//m_TempVariableList->CompressExportOrder();		}	}		// We're done. We've initialized everything from different sources. Now, if the caller	// opens an existing Properties file and calls our Serialize function, we will reload	// these values.}									// Destructor	CEyeDxProperties::~CEyeDxProperties(){	// We didn't allocate anything, so don't do anything here.}	void CEyeDxProperties::Serialize(CArchive &ar){	DWORD rate, port, format;	CObject::Serialize(ar);		if (ar.IsStoring())	{		// When bumping the schema version, add new items before existing ones! That way, when		// deserializing, the case statements for newer schemas can just fall through to the		// common code.				ar << m_AutoCameraAutoStart;		// Version 3				ar << m_UseSessions;				// Version 2				ar << m_DisplayReport;				// Version 1		ar << m_AdjReport;					// Version 1		ar << m_SaveImages;					// Version 1		// Have to use intermediate variables because the << operator isn't overloaded for these types		rate = m_CameraRate;				// Version 1		ar << rate;		port = m_CameraPort;				// Version 1		ar << port;			format = m_ReportFormat;			// Version 1		ar << format;			ar << m_PromptingStyle;				// Version 1				// Always compress and renumber the prompting and export order when saving				// Broken in Windows and not really needed			//m_VariableList->CompressPromptOrder();		//m_VariableList->CompressExportOrder();		ar.WriteObject(m_VariableList);		// Version 1		m_UserTextBlocks.Serialize(ar);		// Version 1	}	else	{		switch (ar.GetObjectSchema())		{		case kCEyeDxPropertiesCurrentSchema:					ar >> m_AutoCameraAutoStart;		case kCEyeDxPropertiesSecondSchema:						ar >> m_UseSessions;			// Note that we fall through here to the common schema data					case kCEyeDxPropertiesFirstSchema:									ar >> m_DisplayReport;			ar >> m_AdjReport;			ar >> m_SaveImages;						// Have to use intermediate variables because the << operator isn't overloaded for these types			ar >> rate;			m_CameraRate = (DCBitRate) rate;			ar >> port;			m_CameraPort = (DCPortNum) port;			ar >> format;			m_ReportFormat = (EyeDxReportFormat) format;			ar >> m_PromptingStyle;						// Now we read in the second list of variables									// We use the ReadObject routine so that the proper object information is deserialized			// for a VERSIONABLE_SCHEMA type object						m_TempVariableList = (CEyeDxVariableList *) ar.ReadObject(RUNTIME_CLASS(CEyeDxVariableList));						// The next step is to go through this second list, an merge it into the			// main m_VariableList. We do  this by iterating through the m_TempVariableList, and			// grabbing each variable. We then look up the variable in the m_VariableList.			// If it  exists, we delete it from the main list. Then, in either case, we			// add the variable to the main list.						for (long theItem = 0; theItem < m_TempVariableList->GetCount(); theItem++)			{				CEyeDxVariable *theVariable = m_TempVariableList->GetVariableByIndex(theItem);								// if the variable exists in the passed-in table already, that means that				// EyeDx provided it as a template for the user to use. We delete the EyeDx				// template, since the user has already defined a variable of the same name.								CEyeDxLongStringType *theName = theVariable->GetName();								if (m_VariableList->GetVariableByName(*theName) != NULL)					m_VariableList->DeleteVariableByName(*theName);								m_VariableList->AddVariable(theVariable);							}						// Now we can delete the  second list						delete m_TempVariableList;						// Finally, we read in the text block list			m_UserTextBlocks.Serialize(ar);						// If these are more default text blocks, the we append the additional blocks to the			// user blocks						if (m_DefaultTextBlocks.GetSize() > m_UserTextBlocks.GetSize())			{				for (int i = m_UserTextBlocks.GetSize(); i < m_DefaultTextBlocks.GetSize(); i++)				{					CString theString = m_DefaultTextBlocks.GetAt(i);					m_UserTextBlocks.SetAtGrow(i, theString);				}			}						// Always compress and renumber the prompting and export order when loading						// Broken in Windows and not really needed				//m_VariableList->CompressPromptOrder();			//m_VariableList->CompressExportOrder();				break;		}	}}	