// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "globals.h"#include "main.h"#if defined (WIN32)	#define IS_WIN32	TRUE#else	#define IS_WIN32	FALSE#endifBEGIN_MESSAGE_MAP( CMFCReportLayoutDlg, CDialog )ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)ON_CBN_SELCHANGE(IDC_LAYOUTCUSTOMTEXTTYPE, OnTextType)ON_CBN_SELENDOK(IDC_LAYOUTINSERTVARIABLE, OnInsertVariable)ON_BN_CLICKED(IDC_LAYOUTREVERTTOSAVED, OnRevert)ON_BN_CLICKED(IDC_LAYOUTSETTODEFAULT, OnSetDefault)ON_BN_CLICKED(IDC_LAYOUTNEWBUTTON, OnNewPressed)ON_BN_CLICKED(IDC_LAYOUTEDITBUTTON, OnEditPressed)ON_BN_CLICKED(IDC_LAYOUTDELETEBUTTON, OnDeletePressed)ON_BN_CLICKED(IDC_LAYOUTDEFINEEXPORTORDER, OnExportPressed)ON_LBN_SELCHANGE(IDC_LAYOUTVARIABLELIST, OnListSelect)ON_LBN_DBLCLK(IDC_LAYOUTVARIABLELIST, OnEditPressed)END_MESSAGE_MAP()CMFCReportLayoutDlg::CMFCReportLayoutDlg(CWnd *pParentWnd, BOOL showHidden) :		CDialog(IDD_REPORTLAYOUT_DIALOG, pParentWnd) {	m_VariableList = gGlobalProperties->GetVariableList();	m_showHidden = showHidden;}CEyeDxBooleanType CMFCReportLayoutDlg::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);			CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}void CMFCReportLayoutDlg::SetDefineTextCaption(){	CHARFORMAT cf;	PARAFORMAT pf;		m_EditText->GetSelectionCharFormat(cf);	m_EditText->GetParaFormat(pf);		pf.dwMask = PFM_ALIGNMENT;	switch (m_CurrentDefineTextMenuItem)	{	case kReportLayoutHeaderText:				m_HTMLFormat->SetWindowText("Displayed as bold, centered, large font");				// Select all of the text		m_EditText->SetSel(0,-1);			cf.dwMask = CFM_SIZE | CFM_FACE | CFM_BOLD;			cf.yHeight = 12 * 20; // for twips - 12 point		cf.dwEffects = CFE_BOLD;		::lstrcpy(cf.szFaceName, "Times New Roman");				pf.wAlignment = PFA_CENTER;				//m_EditText->SetFont(&m_timesRomanBoldFont);		break;	case kReportLayoutIntroductionText:	case kReportLayoutPassResultText:	case kReportLayoutReferResultText:	case kReportLayoutRetakeResultText:	case kReportLayoutFooterText:				m_HTMLFormat->SetWindowText("Displayed as normal font");				// Select all of the text		m_EditText->SetSel(0,-1);				cf.dwMask = CFM_SIZE | CFM_FACE | CFM_BOLD;			cf.yHeight = 10 * 20; // for twips - 12 point		cf.dwEffects = 0;		::lstrcpy(cf.szFaceName, "Times New Roman");		pf.wAlignment = PFA_LEFT;				//m_EditText->SetFont(&m_timesRomanNormalFont);		break;	case kReportLayoutSessionSummaryText:		m_HTMLFormat->SetWindowText("Saved in summary file as monospaced font");				// Select all of the text		m_EditText->SetSel(0,-1);				cf.dwMask = CFM_SIZE | CFM_FACE | CFM_BOLD;			cf.yHeight = 10 * 20; // for twips - 12 point		cf.dwEffects = 0;		::lstrcpy(cf.szFaceName, "Courier New");		pf.wAlignment = PFA_LEFT;		break;	}	m_EditText->SetSelectionCharFormat(cf);	m_EditText->SetParaFormat(pf);	// Deselect all of the text	m_EditText->SetSel(0,0);	}const int kMaxVariableNameCharLength = 30;const int kMaxVariableNameDispLength = 160;const int kMaxVariableClassDispLength = 35;const int kMaxVariableTypeDispLength = 80;const int kMaxVariableDataTypeDispLength = 50;const int kMaxVariableRequiredDispLength = 250;static int kTabStops[] = { 	kMaxVariableNameDispLength, 	kMaxVariableNameDispLength + kMaxVariableClassDispLength,	kMaxVariableNameDispLength + kMaxVariableClassDispLength + kMaxVariableTypeDispLength,	kMaxVariableNameDispLength + kMaxVariableClassDispLength + kMaxVariableTypeDispLength + kMaxVariableDataTypeDispLength,	kMaxVariableNameDispLength + kMaxVariableClassDispLength + kMaxVariableTypeDispLength + kMaxVariableDataTypeDispLength + kMaxVariableRequiredDispLength};const int kNumTabStops = 5;CEyeDxBooleanType CMFCReportLayoutDlg::OnInitDialog(){	CDialog::OnInitDialog();	CenterWindow();			m_VariableListBox = (CListBox *) GetDlgItem(IDC_LAYOUTVARIABLELIST);		int tempTabStops[kNumTabStops];		DWORD dw = ::GetDialogBaseUnits();		for (int i = 0; i < kNumTabStops; i++)	{		tempTabStops[i] = (kTabStops[i] * LOWORD(dw)) / 4;	}		m_VariableListBox->SetHorizontalExtent(tempTabStops[kNumTabStops - 1]);		m_VariableListBox->SetTabStops(kNumTabStops, &kTabStops[0]);		m_NewButton = (CButton *) GetDlgItem(IDC_LAYOUTNEWBUTTON);		m_EditButton = (CButton *) GetDlgItem(IDC_LAYOUTEDITBUTTON);		m_DeleteButton = (CButton *) GetDlgItem(IDC_LAYOUTDELETEBUTTON);		m_SingleDialogCheckbox = (CButton *) GetDlgItem(IDC_LAYOUTSEPARATEDIALOG);		if (gGlobalProperties->GetPromptingStyle() == kPromptOneAtATime)		m_SingleDialogCheckbox->SetCheck(BST_CHECKED);	else		m_SingleDialogCheckbox->SetCheck(BST_UNCHECKED);			m_ctlTextType = (CComboBox *) GetDlgItem(IDC_LAYOUTCUSTOMTEXTTYPE);		m_ctlTextType->SetExtendedUI(TRUE);		m_EditText = (CRichEditCtrl *) GetDlgItem(IDC_LAYOUTCUSTOMTEXTEDIT);		m_HTMLFormat = (CStatic *) GetDlgItem(IDC_LAYOUTTEXTHTMLFORMAT);		m_InsertVariable = (CComboBox *) GetDlgItem(IDC_LAYOUTINSERTVARIABLE);		m_ctlTextType->SetExtendedUI(TRUE);		m_ctlTextType->AddString("Header");	m_ctlTextType->AddString("Introduction");	m_ctlTextType->AddString("Pass Result");	m_ctlTextType->AddString("Refer Result");	m_ctlTextType->AddString("Retake Result");	m_ctlTextType->AddString("Footer");	m_ctlTextType->AddString("Session Summary Report");		m_CurrentDefineTextMenuItem = kReportLayoutHeaderText;	m_ctlTextType->SetCurSel(m_CurrentDefineTextMenuItem);		// Make copies of the current user text		m_TempUserTextBlocks.Copy(*m_UserTextBlocks);			SetDefineTextCaption();	m_EditText->SetWindowText(m_TempUserTextBlocks[m_CurrentDefineTextMenuItem]);	m_EditButton->EnableWindow(FALSE);	m_EditButton->SetWindowText("&View...");	m_DeleteButton->EnableWindow(FALSE);	UpdateVariableList();		EnableToolTips(TRUE);		return TRUE;}void CMFCReportLayoutDlg::OnTextType(){			CString theText;		m_EditText->GetWindowText(theText);		// This will throw away the previous text block and set it to the new one		m_TempUserTextBlocks[m_CurrentDefineTextMenuItem] = theText;		if (theText.GetLength() > kWarnAboutLongOptionalFmt1Text)		MessageBox("The number of characters you have entered may cause the report to print on more than one page.\nRun an analysis and test printing.", AfxGetAppName());		// Now, get the newly-selected item, and load it		m_CurrentDefineTextMenuItem = m_ctlTextType->GetCurSel();		// We set the window contents to empty first so that the window doesn't flicker	// when we change the attributes.		m_EditText->SetWindowText("");		SetDefineTextCaption();		m_EditText->SetWindowText(m_TempUserTextBlocks[m_CurrentDefineTextMenuItem]);	}void CMFCReportLayoutDlg::OnOK(){	CString theText;		m_EditText->GetWindowText(theText);		// This will throw away the previous text block and set it to the new one		m_TempUserTextBlocks[m_CurrentDefineTextMenuItem] = theText;		if (theText.GetLength() > kWarnAboutLongOptionalFmt1Text)		MessageBox("The number of characters you have entered may cause the report to print on more than one page.\nRun an analysis and test printing.", AfxGetAppName());			// For each of the text block types, discard the previous text, and save the new text		m_UserTextBlocks->Copy(m_TempUserTextBlocks);	if (m_SingleDialogCheckbox->GetCheck() == BST_CHECKED)		gGlobalProperties->SetPromptingStyle(kPromptOneAtATime);	else		gGlobalProperties->SetPromptingStyle(kPromptAllInOne);		CDialog::OnOK();}void CMFCReportLayoutDlg::OnRevert(){	// Just set the text back to what they had previously entered				m_EditText->SetWindowText(m_TempUserTextBlocks[m_CurrentDefineTextMenuItem]);}void CMFCReportLayoutDlg::OnSetDefault(){	// Just set the text back to what they had previously entered				m_EditText->SetWindowText(m_DefaultTextBlocks->GetAt(m_CurrentDefineTextMenuItem));}void CMFCReportLayoutDlg::OnInsertVariable(){	// We grab the selected item in the list, and insert the text		CString theVariableName;	CString theVariableStr;	// First, we get the index of the selected item, and then get the associated text		int theIndex;		theIndex = m_InsertVariable->GetCurSel();		// CB_ERR indicates no selection is active		if (theIndex != CB_ERR)	{			m_InsertVariable->GetLBText(theIndex, theVariableName);				// This test handles the case where no item has been selected - we don't want to		// insert just braces!				if (theVariableName.GetLength() > 0)		{			// We now have the variable text.				theVariableStr = "{" + theVariableName + "}";					m_EditText->ReplaceSel(theVariableStr, TRUE);		}	}		// Now set the current selection to none		m_InsertVariable->SetCurSel(LB_ERR);	m_InsertVariable->Clear();}void CMFCReportLayoutDlg::OnNewPressed(){	// Create a new variable for editing		CEyeDxVariable *theVariable = new CEyeDxVariable(CEyeDxVariable::kUser);		if (HandleEditVariable(m_VariableList, theVariable, TRUE, m_showHidden) == true)	{		// Add the new variable to both the local list (the one shown in the menus and scrolling list)		// and the full global list				m_VariableList->AddVariable(theVariable);				UpdateVariableList();			m_EditButton->EnableWindow(TRUE);		m_EditButton->SetWindowText("&Edit...");		m_DeleteButton->EnableWindow(TRUE);	}	else		delete theVariable;}void CMFCReportLayoutDlg::OnEditPressed(){	// Look up the variable that they double-clicked on, or the currently-selected	// item if the Edit button was pressed, and fetch it for editing		long theItem = m_VariableListBox->GetCurSel();		if (theItem != LB_ERR)	{								CEyeDxVariable *theVariable = (CEyeDxVariable *) m_VariableListBox->GetItemDataPtr(theItem);			if (theVariable->GetVariableClass() == CEyeDxVariable::kUser)		{			m_EditButton->EnableWindow(TRUE);			m_EditButton->SetWindowText("&Edit...");			m_DeleteButton->EnableWindow(TRUE);		}		else		{			m_EditButton->EnableWindow(TRUE);			m_EditButton->SetWindowText("&View...");			m_DeleteButton->EnableWindow(FALSE);		}				HandleEditVariable(m_VariableList, theVariable, FALSE, m_showHidden);		UpdateVariableList();		}}void CMFCReportLayoutDlg::OnDeletePressed(){	// Look up the variable that is currently selected and confirm that they want to delete it		long theItem = m_VariableListBox->GetCurSel();		if (theItem != LB_ERR)	{								CEyeDxVariable *theVariable = (CEyeDxVariable *) m_VariableListBox->GetItemDataPtr(theItem);				CEyeDxLongStringType *theName = theVariable->GetName();				CString theMessage;		theMessage.Format("Are you sure you want to delete the variable %s (no undo!)?", *theName);				if (MessageBox(theMessage, AfxGetAppName(), MB_YESNO) == IDYES)		{			m_VariableList->DeleteVariableByName(*theName);			UpdateVariableList();			}	}			}void CMFCReportLayoutDlg::OnListSelect(){	// Look up the variable that they clicked on		long theItem = m_VariableListBox->GetCurSel();		if (theItem != LB_ERR)	{								CEyeDxVariable *theVariable = (CEyeDxVariable *) m_VariableListBox->GetItemDataPtr(theItem);			if (theVariable->GetVariableClass() == CEyeDxVariable::kUser)		{			m_EditButton->EnableWindow(TRUE);			m_EditButton->SetWindowText("&Edit...");			m_DeleteButton->EnableWindow(TRUE);		}		else		{			m_EditButton->EnableWindow(TRUE);			m_EditButton->SetWindowText("&View...");			m_DeleteButton->EnableWindow(FALSE);		}			}}void CMFCReportLayoutDlg::UpdateVariableList(){	// Get the index of the item at the top of the list, so we can restore	// it later		int theTopItem = m_VariableListBox->GetTopIndex();	// We first delete all of the items from the variable scrolling list		m_VariableListBox->ResetContent();			// Now we add all of the variables to the list box		m_VariableListBox->SendMessage(WM_SETREDRAW, FALSE, 0);		int theItemCount = m_VariableList->GetCount();		for (long theItem = 0; theItem < theItemCount; theItem++)	{		CEyeDxVariable *theVariable = m_VariableList->GetVariableByIndex(theItem);				if (m_showHidden || !theVariable->GetVariableIsHidden())		{			CString *theName = theVariable->GetName();			CString theTruncatedName = theName->Left(kMaxVariableNameCharLength);						CString theClassStr;			CString theTypeStr;			CString theDataTypeStr;			CString theOtherStr;			CString *theValueStr;						// If the variable is hidden, display that instead of the class						if (theVariable->GetVariableIsHidden())				theClassStr = "Hidden";			else			{				switch (theVariable->GetVariableClass())				{				case CEyeDxVariable::kUser:					theClassStr = "User";					break;									case CEyeDxVariable::kEyeDx:					theClassStr = "EyeDx";					break;				}				}						switch (theVariable->GetVariableType())			{			case CEyeDxVariable::kFixed:				theTypeStr = "Fixed";				break;							case CEyeDxVariable::kPrompted:				switch (theVariable->GetWhenToPrompt())				{				case CEyeDxVariable::kPromptNone:					theTypeStr = "No Prompt";					break;									case CEyeDxVariable::kPromptOnStart:					theTypeStr = "Prompt: On Startup";					break;				case CEyeDxVariable::kPromptForSubject:					theTypeStr = "Prompt: Each Subject";					break;								case CEyeDxVariable::kPromptForSession:					theTypeStr = "Prompt: Each Session";					break;								case CEyeDxVariable::kPromptForEndOfSession:					theTypeStr = "Prompt: End of Session";					break;				case CEyeDxVariable::kPromptDisabled:					theTypeStr = "Prompt: Disabled";					break;				}										break;							case CEyeDxVariable::kCalculated:				theTypeStr = "Calculated";				break;			}							switch (theVariable->GetDataType())			{			case CEyeDxVariable::kTypeNone:			case CEyeDxVariable::kGeneralString:				theDataTypeStr = "String";				break;							case CEyeDxVariable::kDate:				theDataTypeStr = "Date";				break;			case CEyeDxVariable::kPastDate:				theDataTypeStr = "Past Date";				break;						case CEyeDxVariable::kTime:				theDataTypeStr = "Time";				break;						case CEyeDxVariable::kIntegerNumber:				theDataTypeStr = "Number";				break;			case CEyeDxVariable::kCheckBox:				theDataTypeStr = "Check Box";				break;			case CEyeDxVariable::kMenu:				theDataTypeStr = "Menu";				break;			}									// If the variable is prompted, then indicate whether it is required or not			// If a fixed value, show the value in quotes. Otherwise, just display a blank.						theOtherStr = "";						switch (theVariable->GetVariableType())			{			case CEyeDxVariable::kPrompted:				// We only show optional/required if the prompted variable isn't disabled (it would				// be confusing to say it's required if it's disabled!).								if (theVariable->GetWhenToPrompt() != CEyeDxVariable::kPromptDisabled)				{					if (theVariable->GetValueMustBeEntered())						theOtherStr = "(Required Entry)";					else						theOtherStr = "(Optional Entry)";				}				break;			case CEyeDxVariable::kFixed:				theOtherStr = "\"";				theValueStr = theVariable->GetValue();				theOtherStr += *theValueStr;				theOtherStr += "\"";				break;			}						CString theEntryString;						theEntryString.Format("%s\t%s\t%s\t%s\t%s", theTruncatedName, theClassStr, theTypeStr, theDataTypeStr, theOtherStr);						int listItem = m_VariableListBox->AddString(theEntryString);						// Attach a pointer to the item which points to the variable. That			// allows us get the item selected (which will be sorted as we add them			// here, and thus won't match the order in them_VariableList object).						m_VariableListBox->SetItemDataPtr(listItem, theVariable);		}	}		m_VariableListBox->SendMessage(WM_SETREDRAW, TRUE, 0);		m_VariableListBox->SetTopIndex(theTopItem);		m_InsertVariable->SendMessage(WM_SETREDRAW, FALSE, 0);		m_InsertVariable->ResetContent();		// Now we add all of the variables to the Insert Variable combo box		theItemCount = m_VariableList->GetCount();		for (long theItem =0; theItem < theItemCount; theItem++)	{		CEyeDxVariable *theVariable = m_VariableList->GetVariableByIndex(theItem);				CString *theName = theVariable->GetName();				// If the advanced feature mode is on, we show everything				if (m_showHidden || !theVariable->GetVariableIsHidden())			m_InsertVariable->AddString(*theName);	}		m_InsertVariable->SendMessage(WM_SETREDRAW, TRUE, 0);}	BOOL CMFCReportLayoutDlg::HandleEditVariable(CEyeDxVariableList *theVariableList, CEyeDxVariable *theVariable, BOOL newVariable, BOOL showHidden){	CMFCEditVariableDlg dlg(this, theVariableList, theVariable, newVariable, showHidden);	if (dlg.DoModal() == IDOK)		return TRUE;	else		return FALSE;}void CMFCReportLayoutDlg::OnExportPressed(){	CMFCDefineExportOrderDlg dlg(this, m_VariableList);	dlg.DoModal();}