// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "globals.h"#include "main.h"#if defined (WIN32)	#define IS_WIN32	TRUE#else	#define IS_WIN32	FALSE#endifIMPLEMENT_DYNCREATE(CMFCReportLayoutPage, CPropertyPage)BEGIN_MESSAGE_MAP( CMFCReportLayoutPage, CPropertyPage )ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)ON_CBN_SELCHANGE(IDC_LAYOUTCUSTOMTEXTTYPE, OnTextType)ON_CBN_SELENDOK(IDC_LAYOUTINSERTVARIABLE, OnInsertVariable)ON_BN_CLICKED(IDC_LAYOUTREVERTTOSAVED, OnRevert)ON_BN_CLICKED(IDC_LAYOUTSETTODEFAULT, OnSetDefault)ON_WM_SIZE()END_MESSAGE_MAP()CEyeDxBooleanType CMFCReportLayoutPage::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);			CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}void CMFCReportLayoutPage::SetDefineTextCaption(){	CHARFORMAT cf;	PARAFORMAT pf;		m_EditText->GetSelectionCharFormat(cf);	m_EditText->GetParaFormat(pf);		pf.dwMask = PFM_ALIGNMENT;	switch (m_CurrentDefineTextMenuItem)	{	case kReportLayoutHeaderText:				m_HTMLFormat->SetWindowText("Displayed as bold, centered, large font");				// Select all of the text		m_EditText->SetSel(0,-1);			cf.dwMask = CFM_SIZE | CFM_FACE | CFM_BOLD;			cf.yHeight = 12 * 20; // for twips - 12 point		cf.dwEffects = CFE_BOLD;		::lstrcpy(cf.szFaceName, "Times New Roman");				pf.wAlignment = PFA_CENTER;				//m_EditText->SetFont(&m_timesRomanBoldFont);		break;	case kReportLayoutIntroductionText:	case kReportLayoutPassResultText:	case kReportLayoutReferResultText:	case kReportLayoutRetakeResultText:	case kReportLayoutFooterText:				m_HTMLFormat->SetWindowText("Displayed as normal font");				// Select all of the text		m_EditText->SetSel(0,-1);				cf.dwMask = CFM_SIZE | CFM_FACE | CFM_BOLD;			cf.yHeight = 10 * 20; // for twips - 12 point		cf.dwEffects = 0;		::lstrcpy(cf.szFaceName, "Times New Roman");		pf.wAlignment = PFA_LEFT;				//m_EditText->SetFont(&m_timesRomanNormalFont);		break;	case kReportLayoutSessionSummaryText:		m_HTMLFormat->SetWindowText("Saved in summary file as monospaced font");				// Select all of the text		m_EditText->SetSel(0,-1);				cf.dwMask = CFM_SIZE | CFM_FACE | CFM_BOLD;			cf.yHeight = 10 * 20; // for twips - 12 point		cf.dwEffects = 0;		::lstrcpy(cf.szFaceName, "Courier New");		pf.wAlignment = PFA_LEFT;		break;	}	m_EditText->SetSelectionCharFormat(cf);	m_EditText->SetParaFormat(pf);	// Deselect all of the text	m_EditText->SetSel(0,0);	}CEyeDxBooleanType CMFCReportLayoutPage::OnInitDialog(){#ifdef DEBUG_PROPERTIESAfxMessageBox("D1", IDOK);#endif	CPropertyPage::OnInitDialog();				#ifdef DEBUG_PROPERTIESAfxMessageBox("D2", IDOK);#endif	m_ctlTextType = (CComboBox *) GetDlgItem(IDC_LAYOUTCUSTOMTEXTTYPE);		m_ctlTextType->SetExtendedUI(TRUE);		m_EditText = (CRichEditCtrl *) GetDlgItem(IDC_LAYOUTCUSTOMTEXTEDIT);		m_HTMLFormat = (CStatic *) GetDlgItem(IDC_LAYOUTTEXTHTMLFORMAT);		m_InsertVariable = (CComboBox *) GetDlgItem(IDC_LAYOUTINSERTVARIABLE);		m_ctlTextType->SetExtendedUI(TRUE);		m_ctlTextType->AddString("Header");	m_ctlTextType->AddString("Introduction");	m_ctlTextType->AddString("Pass Result");	m_ctlTextType->AddString("Refer Result");	m_ctlTextType->AddString("Retake Result");	m_ctlTextType->AddString("Footer");	m_ctlTextType->AddString("Session Summary Report");		m_CurrentDefineTextMenuItem = kReportLayoutHeaderText;	m_ctlTextType->SetCurSel(m_CurrentDefineTextMenuItem);	#ifdef DEBUG_PROPERTIESAfxMessageBox("D3", IDOK);#endif	// Make copies of the current user text		m_TempUserTextBlocks.Copy(*m_UserTextBlocks);			SetDefineTextCaption();	m_EditText->SetWindowText(m_TempUserTextBlocks[m_CurrentDefineTextMenuItem]);#ifdef DEBUG_PROPERTIESAfxMessageBox("D5", IDOK);#endif	// Finally, add all of the controls to the resizer object		m_Resizer.Add(this, IDC_LAYOUTDEFINETEXTLABEL, RESIZE_LOCKLEFT | RESIZE_LOCKTOP);	m_Resizer.Add(this, IDC_LAYOUTCUSTOMTEXTTYPE, RESIZE_LOCKLEFT | RESIZE_LOCKTOP);	m_Resizer.Add(this, IDC_LAYOUTTEXTHTMLFORMAT, RESIZE_LOCKLEFT | RESIZE_LOCKTOP);	m_Resizer.Add(this, IDC_LAYOUTCUSTOMTEXTEDIT, RESIZE_LOCKALL);	m_Resizer.Add(this, IDC_LAYOUTREVERTTOSAVED,  RESIZE_LOCKLEFT | RESIZE_LOCKBOTTOM);	m_Resizer.Add(this, IDC_LAYOUTSETTODEFAULT,   RESIZE_LOCKLEFT | RESIZE_LOCKBOTTOM);	m_Resizer.Add(this, IDC_LAYOUTINSERTVARIABLE, RESIZE_LOCKLEFT | RESIZE_LOCKBOTTOM);	m_Resizer.Add(this, IDC_LAYOUTINSERTLABEL,    RESIZE_LOCKLEFT | RESIZE_LOCKBOTTOM);#ifdef DEBUG_PROPERTIESAfxMessageBox("D6", IDOK);#endif	// We don't haved to update the variable list here, as we our OnSetActive routine will	// be called when we are chosen.			EnableToolTips(TRUE);	#ifdef DEBUG_PROPERTIESAfxMessageBox("D7", IDOK);#endif	return TRUE;}void CMFCReportLayoutPage::OnSize(UINT nType, int cx, int cy) {	CPropertyPage::OnSize(nType, cx, cy);	// Resize!	m_Resizer.Resize(this);	}void CMFCReportLayoutPage::OnTextType(){			CString theText;		m_EditText->GetWindowText(theText);		// This will throw away the previous text block and set it to the new one		m_TempUserTextBlocks[m_CurrentDefineTextMenuItem] = theText;		if (theText.GetLength() > kWarnAboutLongOptionalFmt1Text)		MessageBox("The number of characters you have entered may cause the report to print on more than one page.\nRun an analysis and test printing.", AfxGetAppName());		// Now, get the newly-selected item, and load it		m_CurrentDefineTextMenuItem = m_ctlTextType->GetCurSel();		// We set the window contents to empty first so that the window doesn't flicker	// when we change the attributes.		m_EditText->SetWindowText("");		SetDefineTextCaption();		m_EditText->SetWindowText(m_TempUserTextBlocks[m_CurrentDefineTextMenuItem]);	}void CMFCReportLayoutPage::OnOK(){	CString theText;		m_EditText->GetWindowText(theText);		// This will throw away the previous text block and set it to the new one		m_TempUserTextBlocks[m_CurrentDefineTextMenuItem] = theText;		if (theText.GetLength() > kWarnAboutLongOptionalFmt1Text)		MessageBox("The number of characters you have entered may cause the report to print on more than one page.\nRun an analysis and test printing.", AfxGetAppName());			// For each of the text block types, discard the previous text, and save the new text.	// Also, change the buttons in the Property Window to indicate a unreversable change.		for (int i = 0; i < kReportLayoutNumText; i++)	{		if (m_UserTextBlocks->GetAt(i) != m_TempUserTextBlocks.GetAt(i))		{			m_UserTextBlocks->SetAt(i, m_TempUserTextBlocks.GetAt(i));			CancelToClose();		}	}	//m_UserTextBlocks->Copy(m_TempUserTextBlocks);	}void CMFCReportLayoutPage::OnRevert(){	// Just set the text back to what they had previously entered				m_EditText->SetWindowText(m_TempUserTextBlocks[m_CurrentDefineTextMenuItem]);}void CMFCReportLayoutPage::OnSetDefault(){	// Just set the text back to what they had previously entered				m_EditText->SetWindowText(m_DefaultTextBlocks->GetAt(m_CurrentDefineTextMenuItem));}void CMFCReportLayoutPage::OnInsertVariable(){	// We grab the selected item in the list, and insert the text		CString theVariableName;	CString theVariableStr;	// First, we get the index of the selected item, and then get the associated text		int theIndex;		theIndex = m_InsertVariable->GetCurSel();		// CB_ERR indicates no selection is active		if (theIndex != CB_ERR)	{			m_InsertVariable->GetLBText(theIndex, theVariableName);				// This test handles the case where no item has been selected - we don't want to		// insert just braces!				if (theVariableName.GetLength() > 0)		{			// We now have the variable text.				theVariableStr = "{" + theVariableName + "}";					m_EditText->ReplaceSel(theVariableStr, TRUE);		}	}		// Now set the current selection to none		m_InsertVariable->SetCurSel(LB_ERR);	m_InsertVariable->Clear();}void CMFCReportLayoutPage::UpdateVariableList(){	m_InsertVariable->SendMessage(WM_SETREDRAW, FALSE, 0);		m_InsertVariable->ResetContent();		// Now we add all of the variables to the Insert Variable combo box		int theItemCount = m_VariableList->GetCount();		for (long theItem =0; theItem < theItemCount; theItem++)	{		CEyeDxVariable *theVariable = m_VariableList->GetVariableByIndex(theItem);				CString *theName = theVariable->GetName();				// If the advanced feature mode is on, we show everything				if (m_showHidden || !theVariable->GetVariableIsHidden())			m_InsertVariable->AddString(*theName);	}		m_InsertVariable->SendMessage(WM_SETREDRAW, TRUE, 0);	// Now set the current selection to none		m_InsertVariable->SetCurSel(LB_ERR);	m_InsertVariable->Clear();}BOOL CMFCReportLayoutPage::OnSetActive(){	if (!CPropertyPage::OnSetActive())		return FALSE;		// Anytime our page becomes active, we update the menu so that it reflects	// the current list of variables		UpdateVariableList();		return TRUE;}void CMFCReportLayoutPage::DoDataExchange(CDataExchange *pDX){	CPropertyPage::DoDataExchange(pDX);}