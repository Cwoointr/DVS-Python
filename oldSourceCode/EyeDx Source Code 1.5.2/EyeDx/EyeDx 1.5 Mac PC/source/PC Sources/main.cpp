// main.cp#include "main.h"		// a background image is loaded at startup and kept herestatic int				BACK_ROWS,BACK_COLS;		// backgroundstatic unsigned char	*back_image;				// backg datachar	DataPath[MAX_PATHNAME_CHARS];char	up_filename[MAX_FILENAME_CHARS];char	side_filename[MAX_FILENAME_CHARS];char	report_filename[MAX_FILENAME_CHARS];unsigned char	*up_image,*side_image;int				UP_ROWS,UP_COLS,SIDE_ROWS,SIDE_COLS;		// flags and variables for user controlint				SideWhichWay,DisplayGraphics,RunInProgress, SaveFullImages;		// analyzation variablesint				MinIrisRad,MaxIrisRad,MinPupilRad,MaxPupilRad;int				MinCRArea,MaxCRArea,BrightThresh;		// animation variablesint				CircleThickness,FramePause,ZoomSteps,Flashes;int				EYEDX_BKGND_DISPLAY_ROWS,EYEDX_BKGND_DISPLAY_COLS;	// display windowunsigned char	*eyedx_background_image;				// display datalong DebugFeatures;long AdvancedFeatures;LPCTSTR lpszClassName="EyeDx";LPCTSTR lpszWindowName="EyeDx Automated Digital Vision Screener";LPCTSTR	kStartupPictureFileName	= "StartupPicture";LPCTSTR	kStartupSoundFileName	= "StartupSound";// This is the name of the EyeDx Properties fileLPCTSTR UserPropertiesFile = "EyeDx Properties";// This is the global properties object that is created by the main program when it starts upCEyeDxProperties *gGlobalProperties = NULL;CMainApp gMainApp;CEyeDxBooleanType CMainApp::InitInstance() {	// This tells the system to use the Registry for preferences for the application		SetRegistryKey(lpszClassName);	AfxInitRichEdit();	AfxOleInit();		m_pMainWnd = new CMainWindow();	m_pMainWnd->ShowWindow( m_nCmdShow );	m_pMainWnd->UpdateWindow();		return TRUE;}BEGIN_MESSAGE_MAP( CMainWindow, CWnd )ON_WM_CREATE()ON_WM_ERASEBKGND()ON_WM_SETFOCUS()ON_BN_CLICKED(IDC_MAIN_CAMERA, 	OnCameraButtonClicked)ON_BN_CLICKED(IDC_MAIN_DISK, 	OnDiskButtonClicked)ON_BN_CLICKED(IDC_MAIN_REPORTS, OnReportsButtonClicked)ON_BN_CLICKED(IDC_MAIN_ABOUT, 	OnAboutButtonClicked)ON_BN_CLICKED(IDC_MAIN_EXIT, 	OnExitButtonClicked)ON_BN_CLICKED(IDC_MAIN_SESSION,	OnSessionButtonClicked)ON_COMMAND(ID_APP_EXIT, OnExitButtonClicked)ON_COMMAND(ID_APP_ABOUT, OnAboutButtonClicked)ON_COMMAND(ID_FILE_INSTALL_LICENSE, EnterLicense)ON_COMMAND(ID_FILE_DISPLAY_LICENSE, DisplayLicense)ON_COMMAND(ID_FILE_EXPORT_REPORTS, OnExportReports)ON_COMMAND(ID_FILE_FLATTEN_REPORTS, OnFlattenReports)ON_COMMAND(ID_FILE_PROPERTIES, HandleProperties)ON_COMMAND(IDC_MAIN_ADVANCED_FEATURES, OnAdvancedFeatures)ON_MESSAGE(EYEDX_MFC_OK_MESSAGE, OnOkButtonClicked)ON_MESSAGE(EYEDX_MFC_AUTORUN_MESSAGE, OnCameraButtonClicked)ON_MESSAGE(EYEDX_MFC_CANCEL_MESSAGE, OnCancelButtonClicked)ON_MESSAGE(EYEDX_MFC_ANALYSIS_COMPLETE_MESSAGE, OnAnalysisComplete)ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)END_MESSAGE_MAP()CMainWindow::CMainWindow(){	// This variable prevents certain drawing operations from occurring before	// we are really initialized. This include the OnSetFocus call.		initialized = FALSE;		// We display the splash screen first!			HandleSplashDialog();	// This creates the main window		CString strWndClass = AfxRegisterWndClass(		CS_DBLCLKS,		gMainApp.LoadStandardCursor(IDC_ARROW),		(HBRUSH) (COLOR_3DFACE + 1),		gMainApp.LoadIcon("ID_EYEDX_ICON_SM"));			CreateEx(0, strWndClass, lpszWindowName, 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,		CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 		NULL, NULL);			AdvancedFeatures = FALSE;		// Add our menu to the main window		CMenu theMenu;	theMenu.LoadMenu("IDR_MAINFRAME");	SetMenu(&theMenu);	theMenu.Detach();	DrawMenuBar();}CEyeDxBooleanType CMainWindow::PreTranslateMessage(MSG *pMsg){	if (m_hAccel != NULL)		if (::TranslateAccelerator( m_hWnd, m_hAccel, pMsg))			return TRUE;		if (IsDialogMessage(pMsg))		return TRUE;	else		return CWnd::PreTranslateMessage(pMsg);}void CMainWindow::OnSetFocus(CWnd *pOldWnd){	CWnd::OnSetFocus(pOldWnd);	//m_ctlCameraButton.SetButtonStyle(m_ctlCameraButton.GetButtonStyle() | BS_DEFPUSHBUTTON);		if (initialized)		m_ctlDiskButton.SetFocus();}void CMainWindow::LoadPreferences(){	// Check to see if we have created the global Properties object yet		if (gGlobalProperties == NULL)		gGlobalProperties = new CEyeDxProperties;			// Now, we load the properties from the file. Note that the constructor for the gGlobalProperties	// object handles setting up defaults for all of these, as well as backward compatibilty with prior	// use of the Windows Registry. If there is no existing EyeDx Properties file, the defaults will	// suffice.		CFile userPropertiesFile;	CString userPropertiesFilePath(DataPath);	userPropertiesFilePath += UserPropertiesFile;		if (userPropertiesFile.Open(userPropertiesFilePath, CFile::modeRead))	{		CArchive ar(&userPropertiesFile, CArchive::load);				ar >> gGlobalProperties;		ar.Close();		userPropertiesFile.Close();	}}void CMainWindow::SavePreferences(){	// Save our preferences - note that the Registry is no longer used.		// If the Properties file exists, we first make a backup of it		// TODO - backup Properties file		CFile userPropertiesFile;	CString userPropertiesFilePath(DataPath);	userPropertiesFilePath += UserPropertiesFile;		if (userPropertiesFile.Open(userPropertiesFilePath, CFile::modeWrite | CFile::modeCreate))	{		CArchive ar(&userPropertiesFile, CArchive::store);				ar << gGlobalProperties;		ar.Close();		userPropertiesFile.Close();	}}void CMainWindow::PostNcDestroy(){	// Delete the license files so that they get flushed out		delete mPrimaryLicense;	delete mBackupLicense;		// We always close the camera, just in case		CloseCamera(this);		SaveSessionStatus();	delete this;}int CMainWindow::OnCreate(LPCREATESTRUCT lpcs){	if (CWnd::OnCreate(lpcs) == -1)		return -1;			m_hAccel = ::LoadAccelerators(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINWINDOW));			// Set the sizes and positions of window elements based on the font for the window.	// This will account for larger font sizes that the user may select for the GUI.		CClientDC dc(this);		TEXTMETRIC tm;		dc.GetTextMetrics(&tm);	m_cxChar = tm.tmAveCharWidth;	m_cyChar = tm.tmHeight + tm.tmExternalLeading;		CRect rect(0, 0, m_cxChar * EYEDX_WIN_WIDTH, m_cyChar * EYEDX_WIN_HEIGHT);			CalcWindowRect(&rect);		SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(), 				 SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW );				 				 // The first thing we do is check the device context for the screen				 // depth. If it is less than 16 bits per pixel, we alert the user than				 // we recommend 16 or more bits.				 	// Now check the depth of the monitor we are on. If it is 8 bits, tell the user that	// EyeDx recommends running on Thousands or Millions of colors		int theDepth = dc.GetDeviceCaps(BITSPIXEL); 	if (theDepth < 16)	{		MessageBox("For best image display quality, EyeDx recommends\nyou set your display to High Color (16 bit) or True Color (32 bit).", AfxGetAppName());	}	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 				 m_cyChar * MAIN_SESSION_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH), 				 m_cyChar * (MAIN_SESSION_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlSessionButton.Create("Start &Session", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_MAIN_SESSION);	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 				 m_cyChar * MAIN_CAMERA_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH), 				 m_cyChar * (MAIN_CAMERA_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlCameraButton.Create("Run From &Camera", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_MAIN_CAMERA);	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 				 m_cyChar * MAIN_DISK_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH),				 m_cyChar * (MAIN_DISK_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlDiskButton.Create("Run From Card or &Disk", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_DEFPUSHBUTTON, rect, this, IDC_MAIN_DISK);	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 	 			 m_cyChar * MAIN_REPORTS_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH), 				 m_cyChar * (MAIN_REPORTS_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlReportsButton.Create("&View Stored Reports", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_MAIN_REPORTS);	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 				 m_cyChar * MAIN_ABOUT_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH), 				 m_cyChar * (MAIN_ABOUT_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlAboutButton.Create("&About EyeDx", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_MAIN_ABOUT);	rect.SetRect(m_cxChar * MAIN_BUTTON_X, 		 		 m_cyChar * MAIN_EXIT_BUTTON_Y, 				 m_cxChar * (MAIN_BUTTON_X + MAIN_BUTTON_WIDTH), 				 m_cyChar * (MAIN_EXIT_BUTTON_Y + MAIN_BUTTON_HEIGHT));		m_ctlExitButton.Create("E&xit Application", 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_MAIN_EXIT);	// We get the current directory, and use that as the parent directory for all file	// operations. This allows the software to be installed on any drive and in any folder.		DWORD dwResult = GetCurrentDirectory(sizeof(DataPath) / sizeof(TCHAR), DataPath);		if ((dwResult == 0) || (dwResult > (sizeof(DataPath) / sizeof(TCHAR))))	{		MessageBox("Can't get or store current directory! Defaulting to C:\\EyeDx\\", AfxGetAppName());		strcpy(DataPath,"C:\\EyeDx\\");	}	// We always assume that the path has the terminating path separator		if (DataPath[strlen(DataPath) - 1] != '\\')		strcat(DataPath, "\\");			strcpy(report_filename,"");	strcpy(up_filename,"");	strcpy(side_filename,"");	up_image = side_image = NULL;		UP_ROWS = UP_COLS = SIDE_ROWS = SIDE_COLS = 0;		RunInProgress = 0;			// user interface used to be able to change all these values			// while we were researching this, but now they are fixed	DisplayGraphics = 0;		SideWhichWay = 0;	/* left */		MinIrisRad = MIN_IRIS_RAD;		MaxIrisRad = MAX_IRIS_RAD;		MinPupilRad = MIN_PUPIL_RAD;		MaxPupilRad = MAX_PUPIL_RAD;		MinCRArea = MIN_CR_AREA;		MaxCRArea = MAX_CR_AREA;		BrightThresh = BRIGHT_THRESH;		ZoomSteps = 20;		FramePause = 2000;		CircleThickness = 1;		Flashes = 20;			FILE *fp = fopen("EyeDxBg.jpg", "rb");		back_image = NULL;		if (fp != NULL)	{		if (ReadImage(fp, &back_image, &BACK_ROWS, &BACK_COLS, "EyeDxBg.jpg", this, NULL, NULL) == 0)	  		back_image = NULL;		else			fclose(fp);	}		if (back_image == NULL)	{		MessageBox("No background set.", AfxGetAppName());  		back_image = NULL;  		BACK_ROWS = BACK_COLS = 0;	}		// Make sure eyedx_background_image is NULL so we create the background image the first time through	// the background erase procedure		eyedx_background_image = NULL;		// We have not yet set the default directory for Run From Disk mode		m_DirectorySet = FALSE;		// Finally, load our preferences from the Registry		LoadPreferences();		// Set the global value		SaveFullImages = gGlobalProperties->GetSaveImages();		// Finally, enable ToolTips for our window		EnableToolTips(TRUE);	// This variable prevents certain drawing operations from occurring before	// we are really initialized. This include the OnSetFocus call.		initialized = TRUE;		m_ctlDiskButton.SetFocus();		mPrimaryLicense = NULL;	mBackupLicense = NULL;	// Now we see if there is a valid license. If not, we prompt for one.	// We remain in the license prompt routine until we either get a valid license, or the	// user presses the Cancel and Exit button.		// Determine whether there is a license installed and if so, is it valid. If valid, we	// skip the following entry handling. If the license is not installed, then we prompt 	// for a license. If the license is expired, we just display a notice, telling the user that	// they can still use certain features, and to obtain a new license.		LicenseStatus theLicenseStatus = GetLicenseStatus();		switch (theLicenseStatus)	{	case LicenseStatusNotInstalled:		if (HandleLicenseEntry(theLicenseStatus, true) == IDCANCEL)			exit (0);		break;			case LicenseStatusExpiredDate:	case LicenseStatusExpiredCount:	case LicenseStatusExpiredBoth:	case LicenseStatusDateOutOfRange:		HandleLicenseExpired(theLicenseStatus);		break;	case LicenseStatusValid:		// DO NOT write the license out here. Do it only when an actual analysis is run.		// This prevents (partially) the problem if the date has been set forward and then		// set back with the EyeDx software run between. It still will fail if the user		// tries to run analysis between, but just starting the software shouldn't cause		// a problem.		//SaveLicense();		break;	}		// Get the application version information		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theApplVersionVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableAPPLICATIONVERSION));	CFileVersion version;	CString theApplication;		theApplication.Format("%s%s.EXE", DataPath, gMainApp.m_pszExeName);	if (theApplVersionVariable)	{		if (version.Open(theApplication) == TRUE)		{			theApplVersionVariable->SetValue(version.GetProductVersion());			version.Close();			}		else			theApplVersionVariable->SetValue("No Version Number");	}		CEyeDxVariable *theSubjectsMeasuredVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTSMEASURED));	if (theSubjectsMeasuredVariable)		theSubjectsMeasuredVariable->ResetValue();				// Prompt for the startup variables first		if (HandlePromptForVariables(this, theVariableList, gGlobalProperties->GetPromptingStyle(), CEyeDxVariable::kPromptOnStart) == kEyeDxDialogCancelMessage)		PostMessage(WM_CLOSE, 0, 0);		// The user said to quit, so tell the window manager to close us	else	{		// Always set the TODAYS DATE variable so that it can be used in the end of session operation.				CEyeDxVariable *theTodaysDateVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableTODAYSDATE));		theTodaysDateVariable->ResetValue();		// We have to set up a default session name if one was not saved				CEyeDxLongStringType *theSessionName = NULL;				CEyeDxVariable *theSessionNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));		// Note that when loaded the variable's value is set to the default				theSessionName = theSessionNameVariable->GetValue();				// Always set up the main button to the proper value based on the current state of the variable				UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), theSessionNameVariable, &m_ctlSessionButton, (CStatic *)NULL);					if (*theSessionName != CommonStringLiteral_(kDefaultSessionName))		{			// Prompt the user and ask if they wish to continue using this session						// Make sure that the preferences are set up properly for sessions						gGlobalProperties->SetUseSessions(kUseSessions);						// If they say to end the session, perform the end session functions. It will ask the user if they want			// to start a new session, and do the appropriate things. If they don't it will automatically set up the			// default session. This call will update the main window button as needed.						CMFCStartupSessionDlg dlg(this, theSessionName);			if (dlg.DoModal() == IDCANCEL)			{				CStringArray *theCustomReportStrings = gGlobalProperties->GetUserTextBlocks();				CString theSessionSummaryText = theCustomReportStrings->GetAt(kReportLayoutSessionSummaryText);				HandleEndOfSession(this, theVariableList, &m_ctlSessionButton, (CStatic *)NULL, 									theSessionNameVariable, 									theSessionSummaryText, 									theSessionSummaryText.GetLength(),									gGlobalProperties->GetPromptingStyle());							}			else			{				// We have to re-prompt for the session variables, since we do not save them across runs!				//HandlePromptForVariables(this, theVariableList, gGlobalProperties->GetPromptingStyle(), CEyeDxVariable::kPromptForSession);							}		}		// And create the necessary folders				CreateSubdirs(this);			}		// If the auto start Auto Camera mode function is enabled, send ourselves a message to start that mode.		m_FirstTimeAutoStart = FALSE;	if (gGlobalProperties->GetAutoCameraAutoStart())	{		m_FirstTimeAutoStart = TRUE;		PostMessage(EYEDX_MFC_AUTORUN_MESSAGE, 0, 0);	}	return 0;}CEyeDxBooleanType CMainWindow::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);		CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}void CMainWindow::OnCameraButtonClicked(){	CRect rect;		if (GetLicenseStatus() != LicenseStatusValid)	{		HandleLicenseExpired(GetLicenseStatus());		return;	}		GetWindowRect(&rect);		// We create our subdirs here if necessary. This allows the user to rename the reports folder,	// for example, while the program is running, in order to organize report files by date or other	// convention. 		CreateSubdirs(this);		// Now, we display a dialog that allows the user to choose between the manual or automatic Run windows		CMFCCameraSetupDlg dlg(this, m_FirstTimeAutoStart);		m_FirstTimeAutoStart = false;	DCPortNum thePortNum = gGlobalProperties->GetCameraPort();			switch (dlg.DoModal())	{	case IDC_PREPARE_CAMERA_MANUAL_BUTTON:		m_RunWin = new CMFCRunFromCameraWin(&rect, this, &m_DirectorySet, &m_DefaultPimagesDir[0], &thePortNum, gGlobalProperties->GetCameraRate());		m_RunWin->ShowWindow( SW_SHOW );		m_RunWin->UpdateWindow();				// We hide the main window for now		ShowWindow( SW_HIDE );		break;			case IDOK:		// Force the animation off				DisplayGraphics = false;				m_RunWin = new CMFCRunFromCameraAutoWin(&rect, this, &m_DirectorySet, &m_DefaultPimagesDir[0], 												gGlobalProperties->GetAdjustReport(), gGlobalProperties->GetDisplayReport(), gGlobalProperties->GetReportFormat(),												gGlobalProperties->GetUserTextBlocks(), &thePortNum, gGlobalProperties->GetCameraRate());				m_RunWin->ShowWindow( SW_SHOW );		m_RunWin->UpdateWindow();				// We hide the main window for now		ShowWindow( SW_HIDE );				break;			case IDCANCEL:		break;	}	// Save the updated port number		gGlobalProperties->SetCameraPort(thePortNum);}void CMainWindow::OnDiskButtonClicked(){	CRect rect;		if (GetLicenseStatus() != LicenseStatusValid)	{		HandleLicenseExpired(GetLicenseStatus());		return;	}		GetWindowRect(&rect);	// We create our subdirs here if necessary. This allows the user to rename the reports folder,	// for example, while the program is running, in order to organize report files by date or other	// convention. 		CreateSubdirs(this);		m_RunWin = new CMFCRunFromDiskWin(&rect, this, &m_DirectorySet, &m_DefaultPimagesDir[0]);	m_RunWin->ShowWindow( SW_SHOW );	m_RunWin->UpdateWindow();		// We hide the main window for now	ShowWindow( SW_HIDE );}static char szReportFilters[] = "Report files (*.htm)|*.htm||";static char szReportTitle[] = "EyeDx: Select Report to View";void CMainWindow::OnReportsButtonClicked(){	// We create our subdirs here if necessary. This allows the user to rename the reports folder,	// for example, while the program is running, in order to organize report files by date or other	// convention. Thus, we have to recreate the folder here if the next thing they do is try to display	// stored reports.		CreateSubdirs(this);		CFileDialog rdlg(TRUE, "htm", "*.htm", OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, szReportFilters, this);		rdlg.m_ofn.lpstrTitle = szReportTitle;	rdlg.m_ofn.lpstrInitialDir = m_DefaultreportsDir;		if (rdlg.DoModal() == IDOK)	{		OpenReport(rdlg.GetPathName());	}}void CMainWindow::OnAboutButtonClicked(){	CMFCAboutDialog dlg(this);		dlg.DoModal();}void CMainWindow::ApplyNow(CMFCPropertiesDlg *){}void CMainWindow::HandleProperties(){#ifdef DEBUG_PROPERTIESAfxMessageBox("A1", IDOK);#endif	CMFCGeneralPropsPage	m_GeneralPropsPage;#ifdef DEBUG_PROPERTIESAfxMessageBox("A2", IDOK);#endif	CMFCVariablesPage		m_VariablesPage;#ifdef DEBUG_PROPERTIESAfxMessageBox("A3", IDOK);#endif	CMFCReportLayoutPage	m_ReportLayoutPage;#ifdef DEBUG_PROPERTIESAfxMessageBox("A4", IDOK);#endif	CMFCDatabaseOutputPage	m_DatabaseOutputPage;	#ifdef DEBUG_PROPERTIESAfxMessageBox("A5", IDOK);#endif	CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	// Set up variables for the General Props Page		m_GeneralPropsPage.m_DisplayReport = gGlobalProperties->GetDisplayReport();	m_GeneralPropsPage.m_ReportFormat = gGlobalProperties->GetReportFormat();	m_GeneralPropsPage.m_SaveImages = gGlobalProperties->GetSaveImages();	m_GeneralPropsPage.m_CameraRate = gGlobalProperties->GetCameraRate();	m_GeneralPropsPage.m_AdjReport = gGlobalProperties->GetAdjustReport();	m_GeneralPropsPage.m_UseSessions = gGlobalProperties->GetUseSessions();	m_GeneralPropsPage.m_AutoCameraAutoStart = gGlobalProperties->GetAutoCameraAutoStart();	CEyeDxVariable *theSessionNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	m_GeneralPropsPage.m_SessionName = theSessionNameVariable->GetValue();	// Set up variables for the Variables Page		m_VariablesPage.m_VariableList = theVariableList; 	m_VariablesPage.m_showHidden = AdvancedFeatures;		m_VariablesPage.m_PromptingStyle = gGlobalProperties->GetPromptingStyle();		// Set up variables for the Report Layout Page		m_ReportLayoutPage.m_AdvancedFeatures = AdvancedFeatures; 	m_ReportLayoutPage.m_DefaultTextBlocks = gGlobalProperties->GetDefaultTextBlocks(); 	m_ReportLayoutPage.m_UserTextBlocks = gGlobalProperties->GetUserTextBlocks(); 	m_ReportLayoutPage.m_showHidden = AdvancedFeatures;		m_ReportLayoutPage.m_VariableList = theVariableList; 	// Set up variables for the Database Output Page		m_DatabaseOutputPage.m_VariableList = theVariableList; 	#ifdef DEBUG_PROPERTIESAfxMessageBox("A6", IDOK);#endif	CMFCPropertiesDlg dlg(this);	#ifdef DEBUG_PROPERTIESAfxMessageBox("A7", IDOK);#endif	dlg.AddPage(&m_GeneralPropsPage);#ifdef DEBUG_PROPERTIESAfxMessageBox("A8", IDOK);#endif	dlg.AddPage(&m_VariablesPage);#ifdef DEBUG_PROPERTIESAfxMessageBox("A9", IDOK);#endif	dlg.AddPage(&m_ReportLayoutPage);#ifdef DEBUG_PROPERTIESAfxMessageBox("A10", IDOK);#endif	dlg.AddPage(&m_DatabaseOutputPage);#ifdef DEBUG_PROPERTIESAfxMessageBox("A11", IDOK);#endif	if (dlg.DoModal() == IDOK)	{#ifdef DEBUG_PROPERTIESAfxMessageBox("A12", IDOK);#endif		gGlobalProperties->SetDisplayReport(m_GeneralPropsPage.m_DisplayReport);		gGlobalProperties->SetReportFormat(m_GeneralPropsPage.m_ReportFormat);		SaveFullImages = m_GeneralPropsPage.m_SaveImages;		gGlobalProperties->SetSaveImages(SaveFullImages);		gGlobalProperties->SetCameraRate(m_GeneralPropsPage.m_CameraRate);		gGlobalProperties->SetUseSessions(m_GeneralPropsPage.m_UseSessions);		gGlobalProperties->SetAdjustReport(m_GeneralPropsPage.m_AdjReport);		gGlobalProperties->SetPromptingStyle(m_VariablesPage.m_PromptingStyle);		gGlobalProperties->SetAutoCameraAutoStart(m_GeneralPropsPage.m_AutoCameraAutoStart);		SavePreferences();		UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), theSessionNameVariable, &m_ctlSessionButton, (CStatic *) NULL);				}#ifdef DEBUG_PROPERTIESAfxMessageBox("A13", IDOK);#endif}void CMainWindow::OnExitButtonClicked(){	// Now we check to see if the user is running a session other than the default, ask if they want to end the session	// or remember it for the next run.		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theSessionNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	if (theSessionNameVariable)	{		CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();				if (*theSessionName != CommonStringLiteral_(kDefaultSessionName))		{								// Prompt the user and ask if they wish to save this session for later use						// If they say to end the session, perform the end session functions, and then set the session name 			// to the default name			CMFCShutdownSessionDlg dlg(this, theSessionName);			if (dlg.DoModal() == IDCANCEL)			{				CStringArray *theCustomReportStrings = gGlobalProperties->GetUserTextBlocks();				CString theSessionSummaryText = theCustomReportStrings->GetAt(kReportLayoutSessionSummaryText);								HandleEndOfSession(this, theVariableList, &m_ctlSessionButton, (CStatic *)NULL, 									theSessionNameVariable, 									theSessionSummaryText, 									theSessionSummaryText.GetLength(),									gGlobalProperties->GetPromptingStyle(), TRUE);				}		}	}	PostMessage(WM_CLOSE, 0, 0);		// The user said to quit, so tell the window manager to close us}CEyeDxBooleanType CMainWindow::OnEraseBkgnd(CDC *pDC){		// The first time through, we create the DIB image from the background image				if (back_image != NULL)	{		BITMAPINFOHEADER	bm_info_header;		BITMAPINFO			bm_info;				CRect rect;				GetClientRect(&rect);				if (eyedx_background_image == NULL)		{						EYEDX_BKGND_DISPLAY_ROWS=rect.bottom-rect.top;			EYEDX_BKGND_DISPLAY_COLS=rect.right-rect.left;						if (EYEDX_BKGND_DISPLAY_ROWS < 100)			  	EYEDX_BKGND_DISPLAY_ROWS=100;			if (EYEDX_BKGND_DISPLAY_COLS < 100)			  	EYEDX_BKGND_DISPLAY_COLS=100;			if (EYEDX_BKGND_DISPLAY_ROWS % 4 != 0)	// Windows pads to 4-byte boundaries			  	EYEDX_BKGND_DISPLAY_ROWS=(EYEDX_BKGND_DISPLAY_ROWS/4+1)*4;			if (EYEDX_BKGND_DISPLAY_COLS % 4 != 0)			  	EYEDX_BKGND_DISPLAY_COLS=(EYEDX_BKGND_DISPLAY_COLS/4+1)*4;		  	eyedx_background_image=(unsigned char *)calloc(EYEDX_BKGND_DISPLAY_ROWS*EYEDX_BKGND_DISPLAY_COLS*3,1);			if (eyedx_background_image == NULL)			{			    MessageBox("OnEraseBkgnd(): Out of memory", AfxGetAppName());			    std::exit(0);			}					 	for (int r=0; r<EYEDX_BKGND_DISPLAY_ROWS; r++)			{			   	int r2=(int)((double)r/(double)EYEDX_BKGND_DISPLAY_ROWS*(double)BACK_ROWS);			   	for (int c=0; c<EYEDX_BKGND_DISPLAY_COLS; c++)			  	{		/* image enters in RGB order, but windows wants it BGR */			   		int c2=(int)((double)c/(double)EYEDX_BKGND_DISPLAY_COLS*(double)BACK_COLS);			   		eyedx_background_image[(r*EYEDX_BKGND_DISPLAY_COLS+c)*3+0]=back_image[(r2*BACK_COLS+c2)*3+2];			   		eyedx_background_image[(r*EYEDX_BKGND_DISPLAY_COLS+c)*3+1]=back_image[(r2*BACK_COLS+c2)*3+1];			   		eyedx_background_image[(r*EYEDX_BKGND_DISPLAY_COLS+c)*3+2]=back_image[(r2*BACK_COLS+c2)*3+0];			    }			}		}		bm_info_header.biSize=sizeof(BITMAPINFOHEADER); 		bm_info_header.biWidth=EYEDX_BKGND_DISPLAY_COLS;		bm_info_header.biHeight=-EYEDX_BKGND_DISPLAY_ROWS; 		bm_info_header.biPlanes=1;		bm_info_header.biBitCount=24; 		bm_info_header.biCompression=BI_RGB; 		bm_info_header.biSizeImage=0; 		bm_info_header.biXPelsPerMeter=0; 		bm_info_header.biYPelsPerMeter=0;		bm_info_header.biClrUsed=0; 		bm_info_header.biClrImportant=0;		// bm_info.bmiColors=NULL;		bm_info.bmiHeader=bm_info_header;		SetDIBitsToDevice(pDC->GetSafeHdc(),0,0,EYEDX_BKGND_DISPLAY_COLS,EYEDX_BKGND_DISPLAY_ROWS,0,0,				  0, /* first scan line */				  EYEDX_BKGND_DISPLAY_ROWS, /* number of scan lines */				  eyedx_background_image,&bm_info,DIB_RGB_COLORS);	}	return TRUE;}// These routines handle the pop-up window's exiting. void CMainWindow::OnOkButtonClicked(UINT, LONG){	CRect rect;			GetWindowRect(&rect);		HandleStartOfSubject(gGlobalProperties->GetVariableList());	m_AnalysisWin = new CMFCAnalysisWin(&rect, this, 										gGlobalProperties->GetSaveImages(), 										gGlobalProperties->GetAdjustReport(), 										gGlobalProperties->GetReportFormat(), 										gGlobalProperties->GetUserTextBlocks(), 										&m_Results);	m_AnalysisWin->ShowWindow( SW_SHOW );	m_AnalysisWin->UpdateWindow();}void CMainWindow::OnCancelButtonClicked(UINT, LONG){	// Note that the Run From Disk or Camera Window made us visible		CleanupImages();	// We also update the main window Session button in case the user changed sessions during the run mode.	// This won't happen because the code for the mode will be updating only its own button and caption.		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), theVariable, &m_ctlSessionButton, (CStatic *) NULL);			}void CMainWindow::CreateReportPath(CString &thePath, CString *theSessionName, AnalysisResults *theResults){	thePath.Format("%s%s%creports%c%s%s.htm", DataPath, *theSessionName, PATHSEPARATOR, PATHSEPARATOR, theResults->ReferralIndicator, report_filename);}void CMainWindow::OnAnalysisComplete(UINT, LONG){	// Note that the Analysis Window made us visible			CString updatedReportName;	 		// We have to create the entire path to pass to the OpenReport routine, as it is used to	// possibly open reports that are stored elsewhere.		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	CreateReportPath(updatedReportName, theVariable->GetValue(), &m_Results);		// Display the report if requested to do so. Note that the OpenReport routine handles	// the display of an alert if an error occurs. We return a next step indicator, which might be	// generated by the summary display. By default, we return the continue indication.		EyeDxNextStepCode theResult = kNextStepContinue;		if (gGlobalProperties->GetDisplayReport() == kDisplayReport)	{		CleanupImages();		OpenReport(updatedReportName);	}	else if (gGlobalProperties->GetDisplayReport() == kDisplaySummary)	{		// We must cleanup image _after_ the Summary Window is displayed so that		// the full images are available for the zoom operation.		theResult = HandleSummaryDisplay(this, this, &m_Results, FALSE);		CleanupImages();	}	else		CleanupImages();	CString theDatabaseName = kDefaultDatabaseReportName;	HandleEndOfSubject(gGlobalProperties->GetVariableList(), this, &theDatabaseName);	// We also want to save the current session status in case of crash				SaveSessionStatus();	// We also update the main window Session button in case the user changed sessions during this mode.	// This won't happen because the code for the mode will be updating only its own button and caption.		UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), theVariable, &m_ctlSessionButton, (CStatic *)NULL);				RunInProgress = 0;}void CMainWindow::SetParentPosition(CRect *rect){	CString string;		CalcWindowRect(rect);		SetWindowPos(NULL, rect->left, rect->top, rect->Width(), rect->Height(), 				 SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW );				 	//m_ctlCameraButton.SetFocus();}void CMainWindow::CleanupSideImage(){	if (side_image != NULL)	{		free(side_image);		side_image = NULL;		SIDE_ROWS = SIDE_COLS = 0;	}	strcpy(side_filename,"");}void CMainWindow::CleanupUpImage(){	if (up_image != NULL)	{		free(up_image);		up_image = NULL;		UP_ROWS = UP_COLS = 0;	}	strcpy(up_filename,"");}	void CMainWindow::CleanupImages(){	CleanupUpImage();	CleanupSideImage();		RunInProgress = 0;}EyeDxNextStepCode CMainWindow::HandleSummaryDisplay(CWnd *pParentWnd, CMainWindow *pMainWnd, AnalysisResults *theAnalysisResults,													CEyeDxBooleanType showRetakeOptions){	CMFCSummaryDlg rdlg(pParentWnd, pMainWnd, theAnalysisResults, 						m_DefaultreportsDir, showRetakeOptions);	    rdlg.DoModal();			return (rdlg.m_NextStep);}void CMainWindow::OnAdvancedFeatures(){	int theMessage = IDOK;		// Ask the user for the password if the Advanced Features flag is not on - no	// need to ask for a password to turn it off. Default the message to the OK state	// for the turn-off condition.				if (!AdvancedFeatures)	{		CMFCPasswordDlg rdlg(this);	    	theMessage = rdlg.DoModal();		}		if (theMessage == IDOK)	{		AdvancedFeatures = ~AdvancedFeatures;				if (AdvancedFeatures)			MessageBox("Advanced features enabled.", AfxGetAppName());		else			MessageBox("Advanced features disabled.", AfxGetAppName());	}}void CMainWindow::SaveSessionStatus(){	SavePreferences();	}void CMainWindow::OnSessionButtonClicked(){	// If we are currently using the default session, the the button says "Start Session". So, we	// call the HandleNewSession routine.		// Otherwise, we are in an active session, and want to close out this one. Note that in this specific	// case we don't care about the return values. The state of the current session will be self-consistent	// regardless of whether the user completed the operation or Cancelled.		// In all cases, the subroutines will update the main window button's label as required.		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	CEyeDxLongStringType *theSessionName = theVariable->GetValue();		if (*theSessionName == CommonStringLiteral_(kDefaultSessionName))		HandleNewSession(this, theVariableList, &m_ctlSessionButton, (CStatic *)NULL, gGlobalProperties->GetPromptingStyle());	else	{		CStringArray *theCustomReportStrings = gGlobalProperties->GetUserTextBlocks();		CString theSessionSummaryText = theCustomReportStrings->GetAt(kReportLayoutSessionSummaryText);		HandleEndOfSession(this, theVariableList, &m_ctlSessionButton, (CStatic *)NULL, 							theVariable, 							theSessionSummaryText, 							theSessionSummaryText.GetLength(),							gGlobalProperties->GetPromptingStyle());	}		// Create the subfolders in case the user changed the session		CreateSubdirs(this);}void CMainWindow::OnExportReports(){	HandleExportReports(false);}void CMainWindow::OnFlattenReports(){	HandleExportReports(true);}void CMainWindow::HandleSummaryZoom(CWnd *pParentWnd, 								CEyeDxLongStringType *theName, 							 	CEyeDxHandleType theImage, 							  	int theMainImageRows,							  	int theMainImageCols,							  	CEyeDxHandleType theRightEyeImage,							  	CEyeDxHandleType theLeftEyeImage,							  	int theEyeImageRows,							  	int theEyeImageCols){	CMFCSummaryZoomDlg rdlg(pParentWnd, 							theName, 							theImage, 							theMainImageRows,							theMainImageCols,							theRightEyeImage,							theLeftEyeImage,							theEyeImageRows,							theEyeImageCols);	    rdlg.DoModal();	}void CMainWindow::HandleSplashDialog(){	// We see if the picture file exists. If it does, we then see if	// the sound file exists.		char imagePath[MAX_PATHNAME_CHARS];	char soundPath[MAX_PATHNAME_CHARS];		LPCTSTR imagePtr = NULL;	LPCTSTR soundPtr = NULL;		FILE *fp;		// We first check to see if a BMP file exists.		sprintf(imagePath, "%s%s.bmp", DataPath, kStartupPictureFileName);		if ((fp = fopen(imagePath, "rb")) != NULL)	{		fclose(fp);		imagePtr = imagePath;	}	else	{		// No BMP file - try JPG				sprintf(imagePath, "%s%s.jpg", DataPath, kStartupPictureFileName);		if ((fp = fopen(imagePath, "rb")) != NULL)		{			fclose(fp);			imagePtr = imagePath;		}		else		{			// No JPG file - try JPEG - aren't extensions wonderful! Grrr...						sprintf(imagePath, "%s%s.jpeg", DataPath, kStartupPictureFileName);			if ((fp = fopen(imagePath, "rb")) != NULL)			{				fclose(fp);				imagePtr = imagePath;			}		}	}		// If there's an image file, we proceed to the dialog. Next, check to see if the sound	// file exists			if (imagePtr != NULL)	{		sprintf(soundPath, "%s%s.wav", DataPath, kStartupSoundFileName);		if ((fp = fopen(soundPath, "rb")) != NULL)		{			fclose(fp);			soundPtr = soundPath;		}		CMFCSplashDlg rdlg(this, imagePtr, soundPtr);	    	rdlg.DoModal();		}}