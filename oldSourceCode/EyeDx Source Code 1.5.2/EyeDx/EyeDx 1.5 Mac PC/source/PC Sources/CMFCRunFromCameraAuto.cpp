#include "main.h"static LPCTSTR lpszWindowName="Run From Camera (Auto)";extern CMainApp gMainApp;CMFCRunFromCameraAutoWin::CMFCRunFromCameraAutoWin(CRect *posRect, CMainWindow *myParent, 								CEyeDxBooleanType *DirectorySetPtr, char *DefaultImagesDir, 								CEyeDxBooleanType pAdjustName, int pDisplayReport, 								EyeDxReportFormat reportFormat,								CStringArray *UserTextBlocks,								DCPortNum *pPortNum, DCBitRate pConnectionRate)						: CMFCRunWin(posRect, myParent, DirectorySetPtr, DefaultImagesDir){	// This variable prevents certain drawing operations from occurring before	// we are really initialized. This include the OnSetFocus call.		initialized = FALSE;		m_PortNum = pPortNum;	m_ConnectionRate = pConnectionRate;	m_AdjustName = pAdjustName;	m_DisplayReport = pDisplayReport;	m_ReportFormat = reportFormat;	m_UserTextBlocks = UserTextBlocks;		// This creates the Run From Camera window			CString strWndClass = AfxRegisterWndClass(		CS_DBLCLKS,		gMainApp.LoadStandardCursor(IDC_ARROW),		(HBRUSH) (COLOR_3DFACE + 1),		gMainApp.LoadIcon("ID_EYEDX_ICON_SM"));			CreateEx(0, strWndClass, lpszWindowName, 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,		posRect->left, posRect->top, posRect->Width(), posRect->Height(), 		NULL, NULL);}BEGIN_MESSAGE_MAP( CMFCRunFromCameraAutoWin, CMFCRunWin )ON_MESSAGE(EYEDX_MFC_START_AUTO_CAMERA_MESSAGE, HandleRunFromCameraAuto)ON_WM_CLOSE()ON_WM_CREATE()END_MESSAGE_MAP()// If the user closes this window - we must tell the parent to close as// well, or else it is left hanging around. However, even if we send ourselves// a close message, this routine gets called. So, the m_MessageToSend variable is// set to WM_CLOSE most of the time, until the very end, when it is changed to// EYEDX_MFC_AUTO_CAMERA_COMPLETE_MESSAGEvoid CMFCRunFromCameraAutoWin::OnClose(){	//AfxGetMainWnd()->SendMessage(m_MessageToSend, 0, 0);	m_Parent->SendMessage(m_MessageToSend, 0, 0);	CWnd::OnClose();}int CMFCRunFromCameraAutoWin::OnCreate(LPCREATESTRUCT lpcs){	if (CMFCRunWin::OnCreate(lpcs) == -1)		return -1;			RunInProgress = 1;		m_hCameraUpBitmap.LoadBitmap("ID_CAMERA_UP_BITMAP");	m_hCameraSideBitmap.LoadBitmap("ID_CAMERA_SIDE_BITMAP");	m_hBatteryOKBitmap.LoadMappedBitmap(ID_BATTERY_OK_BITMAP);	m_hBatteryWeakBitmap.LoadMappedBitmap(ID_BATTERY_WEAK_BITMAP);	m_hBatteryEmptyBitmap.LoadMappedBitmap(ID_BATTERY_EMPTY_BITMAP);			CRect rect;		GetClientRect(&rect);		int WindowWidth = (rect.right-rect.left) / m_cxChar;		int CenterLine = WindowWidth / 2;		int LeftCenterLine = (AUTO_CAMERA_VIEW_WIDTH / 2) + AUTO_CAMERA_RIGHT_MARGIN;		int RightCenterLine = WindowWidth - AUTO_CAMERA_RIGHT_MARGIN - (AUTO_CAMERA_VIEW_WIDTH / 2);			// These following two elements overlap some of the other items in the window - only one set will be	// displayed at a time. Note that they are not created as "WS_VISIBLE".		// Analysis Progress caption		rect.SetRect(m_cxChar * AUTO_CAMERA_PROGRESS_CAPTION_X, 				 m_cyChar * AUTO_CAMERA_PROGRESS_CAPTION_Y, 				 m_cxChar * (AUTO_CAMERA_PROGRESS_CAPTION_X + AUTO_CAMERA_PROGRESS_CAPTION_WIDTH(WindowWidth)), 				 m_cyChar * (AUTO_CAMERA_PROGRESS_CAPTION_Y + AUTO_CAMERA_PROGRESS_CAPTION_HEIGHT));		m_ctlProgressCaption.Create("", WS_CHILD | SS_LEFT, rect, this, IDC_AUTO_CAMERA_PROGRESS_CAPTION);	m_ctlProgressCaption.SetFont(&m_ctlFont);	// Analysis Progress bar		rect.SetRect(m_cxChar * AUTO_CAMERA_PROGRESS_BAR_X(WindowWidth), 				 m_cyChar * AUTO_CAMERA_PROGRESS_BAR_Y, 				 m_cxChar * (AUTO_CAMERA_PROGRESS_BAR_X(WindowWidth) + AUTO_CAMERA_PROGRESS_BAR_WIDTH(WindowWidth)), 				 m_cyChar * (AUTO_CAMERA_PROGRESS_BAR_Y + AUTO_CAMERA_PROGRESS_BAR_HEIGHT));	m_ctlProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_AUTO_CAMERA_PROGRESS_BAR);		// Up Progress caption		rect.SetRect(m_cxChar * AUTO_CAMERA_UP_PROGRESS_CAPTION_X(LeftCenterLine), 				 m_cyChar * AUTO_CAMERA_UP_PROGRESS_CAPTION_Y, 				 m_cxChar * (AUTO_CAMERA_UP_PROGRESS_CAPTION_X(LeftCenterLine) + AUTO_CAMERA_UP_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (AUTO_CAMERA_UP_PROGRESS_CAPTION_Y + AUTO_CAMERA_UP_PROGRESS_CAPTION_HEIGHT));		m_ctlUpProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_AUTO_CAMERA_UP_PROGRESS_CAPTION);	m_ctlUpProgressCaption.SetFont(&m_ctlFont);		// Side Progress caption		rect.SetRect(m_cxChar * AUTO_CAMERA_SIDE_PROGRESS_CAPTION_X(RightCenterLine), 				 m_cyChar * AUTO_CAMERA_SIDE_PROGRESS_CAPTION_Y, 				 m_cxChar * (AUTO_CAMERA_SIDE_PROGRESS_CAPTION_X(RightCenterLine) + AUTO_CAMERA_SIDE_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (AUTO_CAMERA_SIDE_PROGRESS_CAPTION_Y + AUTO_CAMERA_SIDE_PROGRESS_CAPTION_HEIGHT));		m_ctlSideProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_AUTO_CAMERA_SIDE_PROGRESS_CAPTION);	m_ctlSideProgressCaption.SetFont(&m_ctlFont);	// Up Progress bar		rect.SetRect(m_cxChar * AUTO_CAMERA_UP_PROGRESS_BAR_X(LeftCenterLine), 				 m_cyChar * AUTO_CAMERA_UP_PROGRESS_BAR_Y, 				 m_cxChar * (AUTO_CAMERA_UP_PROGRESS_BAR_X(LeftCenterLine) + AUTO_CAMERA_UP_PROGRESS_BAR_WIDTH), 				 m_cyChar * (AUTO_CAMERA_UP_PROGRESS_BAR_Y + AUTO_CAMERA_UP_PROGRESS_BAR_HEIGHT));	m_ctlUpProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_AUTO_CAMERA_UP_PROGRESS_BAR);	// Side Progress bar		rect.SetRect(m_cxChar * AUTO_CAMERA_SIDE_PROGRESS_BAR_X(RightCenterLine), 				 m_cyChar * AUTO_CAMERA_SIDE_PROGRESS_BAR_Y, 				 m_cxChar * (AUTO_CAMERA_SIDE_PROGRESS_BAR_X(RightCenterLine) + AUTO_CAMERA_SIDE_PROGRESS_BAR_WIDTH), 				 m_cyChar * (AUTO_CAMERA_SIDE_PROGRESS_BAR_Y + AUTO_CAMERA_SIDE_PROGRESS_BAR_HEIGHT));	m_ctlSideProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_AUTO_CAMERA_SIDE_PROGRESS_BAR);	// Up Image View		rect.SetRect(m_cxChar * AUTO_CAMERA_UP_VIEW_X(LeftCenterLine), 				 m_cyChar * AUTO_CAMERA_UP_VIEW_Y, 				 m_cxChar * (AUTO_CAMERA_UP_VIEW_X(LeftCenterLine) + AUTO_CAMERA_UP_VIEW_WIDTH), 				 m_cyChar * (AUTO_CAMERA_UP_VIEW_Y + AUTO_CAMERA_UP_VIEW_HEIGHT));		m_ctlUpView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_AUTO_CAMERA_UP_VIEW);		// Side Image View		rect.SetRect(m_cxChar * AUTO_CAMERA_SIDE_VIEW_X(RightCenterLine), 				 m_cyChar * AUTO_CAMERA_SIDE_VIEW_Y, 				 m_cxChar * (AUTO_CAMERA_SIDE_VIEW_X(RightCenterLine) + AUTO_CAMERA_SIDE_VIEW_WIDTH), 				 m_cyChar * (AUTO_CAMERA_SIDE_VIEW_Y + AUTO_CAMERA_SIDE_VIEW_HEIGHT));		m_ctlSideView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_AUTO_CAMERA_SIDE_VIEW);	// Up Image Quality Bitmap		rect.SetRect(m_cxChar * AUTO_CAMERA_UP_QUALITY_ICON_X(LeftCenterLine), 				 m_cyChar * AUTO_CAMERA_UP_QUALITY_ICON_Y, 				 m_cxChar * (AUTO_CAMERA_UP_QUALITY_ICON_X(LeftCenterLine) + AUTO_CAMERA_UP_QUALITY_ICON_WIDTH), 				 m_cyChar * (AUTO_CAMERA_UP_QUALITY_ICON_Y + AUTO_CAMERA_UP_QUALITY_ICON_HEIGHT));		m_ctlUpQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_AUTO_CAMERA_UP_QUALITY_ICON);			m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);	// Side Image Quality Bitmap	rect.SetRect(m_cxChar * AUTO_CAMERA_SIDE_QUALITY_ICON_X(RightCenterLine), 				 m_cyChar * AUTO_CAMERA_SIDE_QUALITY_ICON_Y, 				 m_cxChar * (AUTO_CAMERA_SIDE_QUALITY_ICON_X(RightCenterLine) + AUTO_CAMERA_SIDE_QUALITY_ICON_WIDTH), 				 m_cyChar * (AUTO_CAMERA_SIDE_QUALITY_ICON_Y + AUTO_CAMERA_SIDE_QUALITY_ICON_HEIGHT));		m_ctlSideQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_AUTO_CAMERA_SIDE_QUALITY_ICON);	m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);	// Up Image caption		rect.SetRect(m_cxChar * AUTO_CAMERA_UP_CAPTION_X(LeftCenterLine), 				 m_cyChar * AUTO_CAMERA_UP_CAPTION_Y, 				 m_cxChar * (AUTO_CAMERA_UP_CAPTION_X(LeftCenterLine) + AUTO_CAMERA_UP_CAPTION_WIDTH), 				 m_cyChar * (AUTO_CAMERA_UP_CAPTION_Y + AUTO_CAMERA_UP_CAPTION_HEIGHT));		m_ctlUpCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_AUTO_CAMERA_UP_CAPTION);	m_ctlUpCaption.SetFont(&m_ctlFont);		// Side Image caption		rect.SetRect(m_cxChar * AUTO_CAMERA_SIDE_CAPTION_X(RightCenterLine), 				 m_cyChar * AUTO_CAMERA_SIDE_CAPTION_Y, 				 m_cxChar * (AUTO_CAMERA_SIDE_CAPTION_X(RightCenterLine) + AUTO_CAMERA_SIDE_CAPTION_WIDTH), 				 m_cyChar * (AUTO_CAMERA_SIDE_CAPTION_Y + AUTO_CAMERA_SIDE_CAPTION_HEIGHT));		m_ctlSideCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_AUTO_CAMERA_SIDE_CAPTION);	m_ctlSideCaption.SetFont(&m_ctlFont);		// Report Name caption		rect.SetRect(m_cxChar * AUTO_CAMERA_NAME_CAPTION_X(CenterLine), 				 m_cyChar * AUTO_CAMERA_NAME_CAPTION_Y, 				 m_cxChar * (AUTO_CAMERA_NAME_CAPTION_X(CenterLine) + AUTO_CAMERA_NAME_CAPTION_WIDTH), 				 m_cyChar * (AUTO_CAMERA_NAME_CAPTION_Y + AUTO_CAMERA_NAME_CAPTION_HEIGHT));		m_ctlNameCaption.Create(AUTO_CAMERA_NAME_CAPTION_LABEL, 								WS_CHILD | WS_VISIBLE | SS_RIGHT, rect, this, IDC_AUTO_CAMERA_NAME_CAPTION);		// Report Name caption		rect.SetRect(m_cxChar * (AUTO_CAMERA_NAME_CAPTION_X(CenterLine) + AUTO_CAMERA_NAME_CAPTION_WIDTH + 1), 				 m_cyChar * AUTO_CAMERA_NAME_DISPLAY_Y, 				 m_cxChar * ((AUTO_CAMERA_NAME_CAPTION_X(CenterLine) + AUTO_CAMERA_NAME_CAPTION_WIDTH + 1) + AUTO_CAMERA_NAME_DISPLAY_WIDTH), 				 m_cyChar * (AUTO_CAMERA_NAME_DISPLAY_Y + AUTO_CAMERA_NAME_DISPLAY_HEIGHT));		m_ctlNameDisplayCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT,								rect, this, IDC_AUTO_CAMERA_NAME_DISPLAY);	rect.SetRect(m_cxChar * AUTO_CAMERA_SESSION_CAPTION_X(CenterLine), 				 m_cyChar * AUTO_CAMERA_SESSION_CAPTION_Y, 				 m_cxChar * (AUTO_CAMERA_SESSION_CAPTION_X(CenterLine) + AUTO_CAMERA_SESSION_CAPTION_WIDTH), 				 m_cyChar * (AUTO_CAMERA_SESSION_CAPTION_Y + AUTO_CAMERA_SESSION_CAPTION_HEIGHT));		m_ctlSessionCaption.Create(AUTO_CAMERA_SESSION_CAPTION_LABEL, 				WS_CHILD | WS_VISIBLE | SS_CENTER, rect, this, IDC_AUTO_CAMERA_SESSION_CAPTION);	m_ctlSessionCaption.SetFont(&m_ctlFont);	// And indicate the current session		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), theVariable, (CButton *)NULL, &m_ctlSessionCaption);				initialized = TRUE;		// Once we are done, send a message to ourselves to start the camera connection	// process. This will guarantee that the window is visible.		PostMessage(EYEDX_MFC_START_AUTO_CAMERA_MESSAGE, 0, 0);		return 0;}int CMFCRunFromCameraAutoWin::GetReportName(){	// This routine displays a dialog to prompt for the report name.	// If OK is pressed, the name is validated, and the user prompted if it is	// invalid. Otherwise, we return IDOK. IDCANCEL is returned as well.		CMFCGetReportNameDlg rdlg(this, m_Parent, m_AdjustName);		return (rdlg.DoModal());}CEyeDxBooleanType CMFCRunFromCameraAutoWin::OpenCamera(CStatic *theStatusCaption){	CWaitCursor wait;	// Set the pointer to the stop watch while we are setting up		theStatusCaption->SetWindowText("Looking for camera...");		DCStatus			GenericStatus;	DC120Status 		FullDC120Status; // Structure of DC120Status	// Save the last picture count		LastNumOfPicts = NumOfPicts;	NumOfPicts = 0;	PictNamePtr = NULL;	if (OpenCameraDriver(&GenericStatus, &FullDC120Status, (CWnd *)this, theStatusCaption, m_PortNum, m_ConnectionRate, true) == 0)  	{		theStatusCaption->SetWindowText("");	    	return false;	}		RunInProgress = 1;	// We return true if we successfully connected and false otherwise. 		theStatusCaption->SetWindowText("");	return true;}CEyeDxBooleanType CMFCRunFromCameraAutoWin::PromptForAndTakePicture(enum eOrientation theOrientation,											DCPictInfo *theGenericPictInfo,											DC120PictInfo *thePictInfo, 										   CEyeDxDibStatic *theMainWindowView, 										   CStatic *theMainWindowCaption,										    EyeDxNextStepCode theResult){	CMFCTakePictureDlg rdlg(this, theOrientation, theGenericPictInfo, thePictInfo, theMainWindowView, theMainWindowCaption, theResult);	// Handle dialog messages.	int theMessage = rdlg.DoModal();	if ( theMessage == IDCANCEL ) 	{		return false;				} 	else if ( theMessage == IDOK ) 	{			return true;	}	return false;}// This routine will set up the camera with the standard parameters. If it gets an// error, it returns false. Otherwise, it returns trueCEyeDxBooleanType CMFCRunFromCameraAutoWin::SetCameraPictureParams(CStatic *theStatusCaption){	CWaitCursor wait;	// Set the pointer to the stop watch while we are getting the image		if (!SetCameraConfiguration(this, theStatusCaption))	{		return false;	}			return true;}enum ePictureVerifyStatus CMFCRunFromCameraAutoWin::VerifyPicture(enum eOrientation Location, 											CEyeDxVariableList *pVariableList,											DCPictInfo *theGenericPictInfo,											DC120PictInfo *thePictInfo, 										    CEyeDxDibStatic *theMainWindowView, 										    CStatic *theMainWindowCaption,										    CStatic *theMainWindowQualityBitmap,										    CEyeDxBooleanType *theImageAlreadyDownloaded){	CMFCVerifyPictureDlg rdlg(this, m_Parent, pVariableList, Location, theGenericPictInfo, thePictInfo, theMainWindowView, theMainWindowCaption, theMainWindowQualityBitmap, theImageAlreadyDownloaded);					int theMessage = rdlg.DoModal();	if ( theMessage == IDCANCEL ) 	{		return kPictureVerifyCancel;				} 	else if ( theMessage == IDOK ) 	{		return kPictureVerifyOK;	}	else if (theMessage == IDD_VERIFY_PICTURE_RETAKE_BUTTON)	{		return kPictureVerifyRetake;	}}CEyeDxBooleanType CMFCRunFromCameraAutoWin::DownloadPictures(EyeDxNextStepCode theResult, CEyeDxBooleanType upImageAlreadyDownloaded, CEyeDxBooleanType sideImageAlreadyDownloaded){	CEyeDxVariable *theSessionNameVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	CWaitCursor wait;	// Set the pointer to the stop watch while we are downloading	// Force a redraw of the main window		// We download the Up image in all cases except when we are retaking the Side image		if ((theResult != kNextStepRetakeSide) && !upImageAlreadyDownloaded)	{		m_ctlUpProgressBar.ShowWindow(SW_SHOW);		m_ctlUpProgressCaption.ShowWindow(SW_SHOW);							UpdateWindow();				CEyeDxVariable *theUpImageVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGE));			if (!DownloadImageFromCamera(1,&up_image,&UP_ROWS,&UP_COLS,up_filename, theSessionNameVariable, theUpImageVariable,									this, &m_ctlUpProgressBar, &m_ctlUpProgressCaption, SaveFullImages))			return false;		m_ctlUpProgressBar.ShowWindow(SW_HIDE);		m_ctlUpProgressCaption.ShowWindow(SW_HIDE);		UpdateWindow();	}		// Force a refresh of the window to get the thermometer and caption to hide properly		// We download the Side image in all cases except when we are retaking the Up image		if ((theResult != kNextStepRetakeUp) && !sideImageAlreadyDownloaded)	{		m_ctlSideProgressBar.ShowWindow(SW_SHOW);		m_ctlSideProgressCaption.ShowWindow(SW_SHOW);		UpdateWindow();							CEyeDxVariable *theSideImageVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGE));			if (!DownloadImageFromCamera(2,&side_image,&SIDE_ROWS,&SIDE_COLS,side_filename, theSessionNameVariable, theSideImageVariable,	 									this, &m_ctlSideProgressBar, &m_ctlSideProgressCaption, SaveFullImages))					return false;		m_ctlSideProgressBar.ShowWindow(SW_HIDE);		m_ctlSideProgressCaption.ShowWindow(SW_HIDE);		UpdateWindow();	}				return true;}CEyeDxBooleanType CMFCRunFromCameraAutoWin::CleanupCameraAutoMode(){	// ALWAYS close the camera!!		CloseCamera(this);		// The user can cancel at any time. We just hide the Run From Disk Window and show	// the Control Window			m_Parent->CleanupImages();		RunInProgress = 0;	// Show the Main Window before we go away so that the transition is less	// abrupt		m_Parent->ShowWindow(SW_SHOW);		// Once we are done, hide the Analysis window and send a message to the parent window that	// we are done		m_MessageToSend = EYEDX_MFC_CANCEL_MESSAGE;	PostMessage(WM_CLOSE, 0, 0);		return true;}int CMFCRunFromCameraAutoWin::HandleAnotherSubjectPrompt(){	// This routine displays a dialog to prompt for the report name.	// If OK is pressed, the name is validated, and the user prompted if it is	// invalid. Otherwise, we return IDOK. IDCANCEL is returned as well.		CMFCAnotherSubjectDlg rdlg(this, m_Parent);		return (rdlg.DoModal());}int CMFCRunFromCameraAutoWin::HandleDeletePicture(CEyeDxCaptionType *theProgressCaption, DCPictInfo *theGenericPictInfo){	// Create on the stack so it is destroyed as soon as we exit		CMFCErasePictureDlg rdlg(this);		rdlg.Create(IDD_ERASE_PICTURE_DIALOG, this);		rdlg.ShowWindow(SW_SHOW);		rdlg.UpdateWindow();		return (DeletePicture(this, theProgressCaption, theGenericPictInfo));}CEyeDxBooleanType CMFCRunFromCameraAutoWin::CameraAutoLoop(){	EyeDxNextStepCode theResult;	m_SessionNameVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));		CEyeDxBooleanType anotherSubject = TRUE;	// We will keep track of the total number of retakes for this subject	long totalRetakes = 0;		// These are the generic picture info structures that we use to delete images that the user	// retakes.	m_ctlUpProgressCaption.ShowWindow(SW_SHOW);		m_ctlUpView.ResetImage();	m_ctlUpCaption.SetWindowText("");	m_ctlUpQualityBitmap.ShowWindow(SW_HIDE);	m_ctlSideProgressCaption.ShowWindow(SW_SHOW);	m_ctlSideView.ResetImage();	m_ctlSideCaption.SetWindowText("");	m_ctlSideQualityBitmap.ShowWindow(SW_HIDE);	m_ctlNameDisplayCaption.SetWindowText("Not specified yet.");			// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 	// three 3 byte deep images (since there's no graphics in Auto mode), plus about 10% overhead.	// Since we've already allocated the memory for the images, we don't include them in the counts here.		short num3ByteDeepImages = 3;	// For the two input images and one pre-scaled annotated image that is written out for the report	short num1ByteDeepImages = 1;	// For the threshold image		CEyeDxLongStringType hintString = EMPTYSTR;		CEyeDxMessageType theMemoryMessage = DoCheckForMemory(this, 						false,						IMAGE_HEIGHT,						IMAGE_WIDTH,						num3ByteDeepImages,						num1ByteDeepImages,						&hintString);	if (theMemoryMessage == kEyeDxDialogCancelMessage)		return false;			// Indicate the current session in the analysis window footer		UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), m_SessionNameVariable, (CButton *)NULL, &m_ctlSessionCaption);				// First, we prompt the user for the report name. If they cancel, we just return, as nothing	// was allocated or initiated yet.			if (GetReportName() == IDCANCEL)		return false;		// Indicate any new session in the main Auto Camera window footer (user may have changed it in GetReportName dialog)		UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), m_SessionNameVariable, (CButton *)NULL, &m_ctlSessionCaption);				// Now, prompt for additional variables, if any. Note that this will return true if no variables	// are present, so we will continue. A return value of false means that the user cancelled the	// dialog.		if (HandlePromptForVariables(this, m_VariableList, m_PromptStyle, CEyeDxVariable::kPromptForSubject) == kEyeDxDialogCancelMessage)		return (HandleAnotherSubjectPrompt() != IDCANCEL);		// Default to the continue case		theResult = kNextStepContinue;		m_UpSelected = false;	m_SideSelected = false;				BOOL theUpImageDownloaded = false;		BOOL theSideImageDownloaded = false;					do	{		m_ctlNameDisplayCaption.SetWindowText(report_filename);				// We next prompt the user to get ready to take the Up picture.		// This dialog allows the user to simply click the mouse anywhere to snap the shutter		// If the m_UpSelected flag is already set, we skip this step					while (!m_UpSelected)		{			m_ctlUpQualityBitmap.ShowWindow(SW_SHOW);			if (!PromptForAndTakePicture(kUpOrientation, &m_UpGenericPictInfo, &m_UpPictInfo,  &m_ctlUpView, &m_ctlUpCaption, theResult))			{				// We have to delete the side image if we are in the process of doing a retake								if (m_SideSelected)					HandleDeletePicture(&m_ctlSideProgressCaption, &m_SideGenericPictInfo);													m_Parent->CleanupImages();						return (HandleAnotherSubjectPrompt() != IDCANCEL);			}						enum ePictureVerifyStatus verifyStatus = VerifyPicture(kUpOrientation, 																		m_VariableList,																		&m_UpGenericPictInfo,																		&m_UpPictInfo, 																		&m_ctlUpView, 																		&m_ctlUpCaption,																		&m_ctlUpQualityBitmap,																		&theUpImageDownloaded);						switch (verifyStatus)			{			case kPictureVerifyCancel:							// Delete the Up picture in the camera since we are quitting							if (!HandleDeletePicture(&m_ctlUpProgressCaption, &m_UpGenericPictInfo))					return false;												if (m_SideSelected)				{					// If the side image number is greater than the up image number, we have to decrement					// the side image number because the deletion of the up image changed the numbering in the					// camera									if (m_SideGenericPictInfo.PictNumber > m_UpGenericPictInfo.PictNumber)						m_SideGenericPictInfo.PictNumber--;					HandleDeletePicture(&m_ctlSideProgressCaption, &m_SideGenericPictInfo);				}												m_Parent->CleanupImages();						return (HandleAnotherSubjectPrompt() != IDCANCEL);				break;							case kPictureVerifyRetake:							totalRetakes++;				m_ctlUpView.ResetImage();				m_ctlUpQualityBitmap.ShowWindow(SW_HIDE);								UpdateWindow();													// Delete the bad picture								if (!HandleDeletePicture(&m_ctlUpProgressCaption, &m_UpGenericPictInfo))				{					// Failed during delete - all bets are off as to what to do!					return false;				}								break;							case kPictureVerifyOK:				m_UpSelected = true;				break;			}		}				// We next prompt the user to get ready to take the Side picture.		// This dialog allows the user to simply click the mouse anywhere to snap the shutter		// If the m_SideSelected flag is already set, we skip this step						while (!m_SideSelected)		{			m_ctlSideQualityBitmap.ShowWindow(SW_SHOW);						if (!PromptForAndTakePicture(kSideOrientation, &m_SideGenericPictInfo, &m_SidePictInfo, &m_ctlSideView, &m_ctlSideCaption, theResult))			{				// Delete the Up picture in the camera since we are quitting							HandleDeletePicture(&m_ctlUpProgressCaption, &m_UpGenericPictInfo);								m_Parent->CleanupImages();						return (HandleAnotherSubjectPrompt() != IDCANCEL);			}						enum ePictureVerifyStatus verifyStatus = VerifyPicture(kSideOrientation, 																		m_VariableList,																		&m_SideGenericPictInfo,																		&m_SidePictInfo, 																		&m_ctlSideView,																		&m_ctlSideCaption,																		&m_ctlSideQualityBitmap,																		&theSideImageDownloaded);						switch (verifyStatus)			{			case kPictureVerifyCancel:							// Delete both pictures in the camera since we are quitting							if (!HandleDeletePicture(&m_ctlUpProgressCaption, &m_UpGenericPictInfo))					return false;												if (m_SideGenericPictInfo.PictNumber > m_UpGenericPictInfo.PictNumber)					m_SideGenericPictInfo.PictNumber--;								HandleDeletePicture(&m_ctlSideProgressCaption, &m_SideGenericPictInfo);				m_Parent->CleanupImages();						return (HandleAnotherSubjectPrompt() != IDCANCEL);				break;							case kPictureVerifyRetake:							totalRetakes++;				m_ctlSideView.ResetImage();				m_ctlSideQualityBitmap.ShowWindow(SW_HIDE);				// Delete the bad picture								UpdateWindow();								if (!HandleDeletePicture(&m_ctlSideProgressCaption, &m_SideGenericPictInfo))					return false;							break;							case kPictureVerifyOK:				m_SideSelected = true;				break;			}		}				// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 		// three 3 byte deep images (since animation isn't enabled in Auto mode), plus about 10% overhead.		// Since we've already allocated the memory for the images, we don't include them in the counts here.		// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.				short num3ByteDeepImages = 3;	// For the two input images and one pre-scaled annotated image that is written out for the report		short num1ByteDeepImages = 1;	// For the threshold image				CEyeDxLongStringType hintString = EMPTYSTR;				CEyeDxMessageType theMemoryMessage = DoCheckForMemory(this, 							false,							IMAGE_HEIGHT,							IMAGE_WIDTH,							num3ByteDeepImages,							num1ByteDeepImages,							&hintString);		if (theMemoryMessage == kEyeDxDialogCancelMessage)		{			// The user could not free-up memory. We DO NOT delete the images - that will allow them to			// run the images manually after Auto mode quits.						// The images should already be cleared, but we have this here to also clear the thumbnails.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						// Clean up everything - thumbnails and memory since we finished one way or another						m_Parent->CleanupImages();									MessageBox("The images you took will be left in the camera. Use Run From Camera Manual to analyze them after freeing memory.", AfxGetAppName());			UpdateWindow();					return false;		}								// At this point, we have both the Up and Side pictures selected. We download the		// actual images, and analyze them using the standard analysis window. The result code is		// passed in, so we can skip downloading images we already have.					if (!DownloadPictures(theResult, theUpImageDownloaded, theSideImageDownloaded))			return false;				theUpImageDownloaded = true;		theSideImageDownloaded = true;		// If we are displaying the summary window, we tell the AnalyzeImages routine to not clean up		// the images. That allows us to retake specific images as needed. This means we are responsible		// for cleanup. However, if the Summary Window is not displayed, there are no retake options, and		// the Analyze Images routine will do the cleanup so that the memory is freed before the browser		// is invoked. Note that after the call to AnalyzeImages we may have to do cleanup regardless of		// the display option. So the cleanupImages option is there simply as a memory optimization when		// browser option is selected, so that the memory is freed before the browser is forked.				CEyeDxBooleanType cleanupImages = true;				if (m_DisplayReport == kDisplaySummary)			cleanupImages = false;				// We keep track of the total number of retakes for this subject. Set the variable here so it is available for		// the report generation and database output functions called by the AnalyzeImages routine.				CEyeDxVariable *theTotalRetakesVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTTOTALRETAKES));		theTotalRetakesVariable->SetValue(long(totalRetakes));		// Again, we see if there's enough temporary memory to run now that we've downloaded. The peak usage is 		// one 8 bit deep image and one 3 byte deep images (since animation isn't enabled in Auto mode), plus 		// about 10% overhead. We've already allocated the memory for the images, we don't include them in the 		// counts here, since we are checking for enough _additional_ memory to run.				num3ByteDeepImages = 1;	// For the pre-scaled annotated save image		num1ByteDeepImages = 1;	// For the threshold image				theMemoryMessage = DoCheckForMemory(this, 							false,							IMAGE_HEIGHT,							IMAGE_WIDTH,							num3ByteDeepImages,							num1ByteDeepImages,							&hintString);		if (theMemoryMessage == kEyeDxDialogCancelMessage)		{			// The user could not free-up memory. We DO NOT delete the images - that will allow them to			// run the images manually after Auto mode quits.						// The images should already be cleared, but we have this here to also clear the thumbnails.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						// Clean up everything - thumbnails and memory since we finished one way or another						m_Parent->CleanupImages();									MessageBox("The images you took will be left in the camera. Use Run From Camera Manual to analyze them after freeing memory.", AfxGetAppName());			UpdateWindow();					return false;		}							// Indicate any new session in the main Auto Camera window footer				UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), m_SessionNameVariable, NULL, &m_ctlSessionCaption);					// We use the current value of theResult to determine if we are doing a retake. The AnalyzeImages routine uses the		// current value to determine which images to pass to the EyeDx routine for analysis				theResult = AnalyzeImages(SaveFullImages, true, cleanupImages, theResult);				// This is a kludge - we delay a bit so that if the Display Report preference is set,		// the browser window has a bit of a chance to come up. This is not ideal, since this is		// a fixed delay, and we have no idea when the actual report window appears (varies		// greatly based on processor speed, memory availability, browser chosen, etc.)				if (m_DisplayReport == kDisplayReport)		{			// We indicate in the window that we are waiting for the report to display						m_ctlUpProgressCaption.ShowWindow(SW_SHOW);			m_ctlUpProgressCaption.SetWindowText("Waiting for browser...");			UpdateWindow();			OSSleep(CalculateDelay(5));			m_ctlUpProgressCaption.SetWindowText("");		}		// Refresh the main window				UpdateWindow();				// If we told the AnalyzeImages routine to not cleanup. It is our responsibility to do		// so. Check the return status from AnalyzeImages, and do the appropriate thing				switch (theResult)		{		case kNextStepRetakeUp:					// Delete the Up picture in the camera since we are going to retake it					if (!HandleDeletePicture(&m_ctlUpProgressCaption, &m_UpGenericPictInfo))				return false;									// If the side image number is greater than the up image number, we have to decrement			// the side image number because the deletion of the up image changed the numbering in the			// camera						if (m_SideGenericPictInfo.PictNumber > m_UpGenericPictInfo.PictNumber)				m_SideGenericPictInfo.PictNumber--;							// The Up image was bad						m_UpSelected = false;			theUpImageDownloaded = false;				// The image should already be cleared, but we have this here to also clear the thumbnail.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						m_Parent->CleanupUpImage();			break;			case kNextStepRetakeSide:					// Delete the Side picture in the camera since we are going to retake it					if (!HandleDeletePicture(&m_ctlSideProgressCaption, &m_SideGenericPictInfo))				return false;						// If the side image number is greater than the up image number, we have to decrement			// the side image number because the deletion of the up image changed the numbering in the			// camera						if (m_UpGenericPictInfo.PictNumber > m_SideGenericPictInfo.PictNumber)				m_UpGenericPictInfo.PictNumber--;							// The Side image was bad						m_SideSelected = false;						theSideImageDownloaded = false;			// The image should already be cleared, but we have this here to also clear the thumbnail.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						m_Parent->CleanupSideImage();			break;			case kNextStepRetakeBoth:					// Delete both pictures in the camera since we are going to retake both					if (!HandleDeletePicture(&m_ctlUpProgressCaption, &m_UpGenericPictInfo))				return false;										// If the side image number is greater than the up image number, we have to decrement			// the side image number because the deletion of the up image changed the numbering in the			// camera						if (m_SideGenericPictInfo.PictNumber > m_UpGenericPictInfo.PictNumber)				m_SideGenericPictInfo.PictNumber--;							if (!HandleDeletePicture(&m_ctlSideProgressCaption, &m_SideGenericPictInfo))				return false;						// Both images were bad, so clean up both images						m_UpSelected = false;			m_SideSelected = false;						theUpImageDownloaded = false;			theSideImageDownloaded = false;						// The image should already be cleared, but we have this here to also clear the thumbnail.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						m_Parent->CleanupImages();			break;			case kNextStepContinue:					// Ask the user whether we should go on to the next subject. If they hit No (Cancel),			// we clean up (including deleting the camera images, and then return to the caller.			// If they hit yes, we delete the images, and then continue with the loop.						anotherSubject = (HandleAnotherSubjectPrompt() != IDCANCEL);			// Delete both pictures in the camera since are done with them. We do this after the			// prompt for the next patient so the user can start preparing the next patient in			// parallel with deleting the images.					if (!HandleDeletePicture(&m_ctlUpProgressCaption, &m_UpGenericPictInfo))				return false;			// If the side image number is greater than the up image number, we have to decrement			// the side image number because the deletion of the up image changed the numbering in the			// camera						if (m_SideGenericPictInfo.PictNumber > m_UpGenericPictInfo.PictNumber)				m_SideGenericPictInfo.PictNumber--;							if (!HandleDeletePicture(&m_ctlSideProgressCaption, &m_SideGenericPictInfo))				return false;						// Everything was fine, so clean up the images			// The images should already be cleared, but we have this here to also clear the thumbnails.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						m_Parent->CleanupImages();									break;		}				// We stay in this loop, for the same subject, if the Summary Window says to do a start over.		// Note that the report_filename variable needs to be left alone for this to work.			} while ((theResult == kNextStepRetakeUp) || (theResult == kNextStepRetakeSide) || (theResult == kNextStepRetakeBoth));	// We're done with this subject - return the value returned by		return anotherSubject;}void CMFCRunFromCameraAutoWin::HandleRunFromCameraAuto(UINT wParam, LONG lParam){		// Hide the Main Window		m_ctlUpProgressCaption.ShowWindow(SW_SHOW);		m_ctlUpView.ShowWindow(SW_SHOW);	m_ctlUpView.ResetImage();	m_ctlSideView.ShowWindow(SW_SHOW);	m_ctlSideView.ResetImage();	m_ctlUpQualityBitmap.ShowWindow(SW_HIDE);	m_ctlSideQualityBitmap.ShowWindow(SW_HIDE);	m_ctlNameDisplayCaption.SetWindowText("");	m_ctlUpCaption.SetWindowText("");	m_ctlSideCaption.SetWindowText("");	UpdateWindow();			// First, we connect to the camera - put up a status window so that the user knows what is	// going on. We do this only once per loop to save time reopening it each time.		if (OpenCamera(&m_ctlUpProgressCaption))	{			// Refresh the window			UpdateWindow();								// We loop in this mode until the user cancels any of the dialogs				CEyeDxBooleanType anotherSubject = true;				while (anotherSubject)		{			HandleStartOfSubject(m_VariableList);			anotherSubject = CameraAutoLoop();						// Now update the variables for the end of a subject						CString theDatabaseName = kDefaultDatabaseReportName;			HandleEndOfSubject(m_VariableList, this, &theDatabaseName);									// We also want to save the current session status in case of crash						m_Parent->SaveSessionStatus();			// Clean up everything - thumbnails and memory since we finished one way or another						m_Parent->CleanupImages();									}	}		CleanupCameraAutoMode();			return;}EyeDxNextStepCode CMFCRunFromCameraAutoWin::AnalyzeImages(CEyeDxBooleanType SaveFullInputImages,						    								CEyeDxBooleanType showRetakeOptions,						   									CEyeDxBooleanType cleanupImages,						   									EyeDxNextStepCode imagesToAnalyze){	CWaitCursor wait;	// Show the wait cursor while we analyze the images	// Now, set up the analysis window. If the Display Graphics flag is set, we	// hide the two small thumbnail views, and enable the larger view. Otherwise,	// we set the thumbnail views to match the images in the Run window views	// We first hide all of the views so that they don't change state while the window	// is visible		m_ctlProgressCaption.ShowWindow(SW_SHOW);	m_ctlProgressBar.ShowWindow(SW_SHOW);		// Force the window to update before we call the analysis routine			UpdateWindow();		char *reportText[kReportLayoutNumText];	long reportTextSize[kReportLayoutNumText];		// Convert each of the text blocks into a pointer and a length		for (long i = 0; i < kReportLayoutNumText; i++)	{			if (i <= m_UserTextBlocks->GetUpperBound())		{			CString theString = m_UserTextBlocks->GetAt(i);			reportText[i] = (char *)theString;			reportTextSize[i] = strlen(reportText[i]);		}		else		{			reportText[i] = NULL;			reportTextSize[i] = 0;		}	}		// Save the picture information in the appropriate variables		SavePictureInformation(m_VariableList, TRUE, m_UpGenericPictInfo, m_UpPictInfo, TRUE, m_SideGenericPictInfo, m_SidePictInfo);			// Depending on whether we are doing reanalysis or not, we will tell the EyeDx routine to	// process both or just one of the two images by passing NULL pointers for the images to skip.	// The previous results are saved in m_AnalysisResults, which is passed into the EyeDx routine 	// and updated by it.		char *up_selector;	char *side_selector;		switch (imagesToAnalyze)	{	case kNextStepContinue:			// This is the non-retake code	case kNextStepRetakeBoth:			up_selector = up_filename;		side_selector = side_filename;			break;			case kNextStepRetakeUp:			up_selector = up_filename;		side_selector = NULL;							break;			case kNextStepRetakeSide:			up_selector = NULL;		side_selector = side_filename;							break;	}					EyeDx(up_selector, side_selector, SideWhichWay, FALSE, m_AdjustName, 			&m_AnalysisResults, this, NULL, &m_ctlProgressBar, &m_ctlProgressCaption,				m_ReportFormat,				m_VariableList,				reportText,				reportTextSize,				kReportLayoutNumText);				// Decrement the license count if the analysis was successful		LicenseError theStatus = m_Parent->UpdateLicenseCounter(m_AnalysisResults.ReferralCode);		CString updatedReportName;	 		// We have to create the entire path to pass to the OpenReport routine, as it is used to	// possibly open reports that are stored elsewhere.		CEyeDxLongStringType *theSessionName = m_SessionNameVariable->GetValue();	m_Parent->CreateReportPath(updatedReportName, theSessionName, &m_AnalysisResults);		if (cleanupImages)		m_Parent->CleanupImages();		// Display the report if requested to do so. Note that the OpenReport routine handles	// the display of an alert if an error occurs. We return a next step indicator, which might be	// generated by the summary display. By default, we return the continue indication.		EyeDxNextStepCode theResult = kNextStepContinue;		if (m_DisplayReport == kDisplayReport)	{		OpenReport(updatedReportName);	}	else if (m_DisplayReport == kDisplaySummary)	{				theResult = m_Parent->HandleSummaryDisplay(this, m_Parent, &m_AnalysisResults, TRUE);	}		m_ctlProgressCaption.ShowWindow(SW_HIDE);	m_ctlProgressBar.ShowWindow(SW_HIDE);		RunInProgress = 0;		return (theResult);}