// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"#include "globals.h"#include "CMFCCameraImageSelectDlg.h"#include "CMFCAnalysisWin.h"#include "CMFCRunWin.h"#include "CMFCRunFromDiskWin.h"#include "CMFCRunFromCameraWin.h"#include "CMFCAboutDialog.h"#include "EyeDxMFCMessages.h"#include "PreviewFileDlg.h"#include "main.h"extern CMainApp gMainApp;CMFCRunWin::CMFCRunWin(CRect * /*posRect*/, CMainWindow *myParent, CEyeDxBooleanType *DirectorySetPtr, char *DefaultImagesDir){	// Save the pointer to my parent so I can use it later to set its position				m_Parent = myParent;		m_VariableList = gGlobalProperties->GetVariableList();		m_PromptStyle = gGlobalProperties->GetPromptingStyle();		// Also set the pointer to the parent's flag that indicates the initial images directory	// has been set, and also the name of the initial directory		m_DirectorySetPtr = DirectorySetPtr;		m_DefaultImagesDir = DefaultImagesDir;}BEGIN_MESSAGE_MAP( CMFCRunWin, CWnd )ON_WM_SETFOCUS()ON_WM_CREATE()ON_WM_CLOSE()ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)END_MESSAGE_MAP()void CMFCRunWin::OnSetFocus(CWnd *pOldWnd){	CWnd::OnSetFocus(pOldWnd);	//if (initialized)		//m_ctlUpSelectButton.SetFocus();}CEyeDxBooleanType CMFCRunWin::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);		CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}// If the user closes this window - we must tell the parent to close as// well, or else it is left hanging aroundvoid CMFCRunWin::OnClose(){	AfxGetMainWnd()->SendMessage(m_MessageToSend, 0, 0);	CWnd::OnClose();}// This function first sends a message to the// main window telling it that the ok button was pressed, and then we delete// ourselvesvoid CMFCRunWin::PostNcDestroy(){	delete this;}int CMFCRunWin::OnCreate(LPCREATESTRUCT lpcs){	if (CWnd::OnCreate(lpcs) == -1)		return -1;			// Set up common variables		Init();		// Finally, enable ToolTips for our window		EnableToolTips(TRUE);	return 0;}void CMFCRunWin::Init(){	// Set the sizes and positions of window elements based on the font for the window.	// This will account for larger font sizes that the user may select for the GUI.		CClientDC dc(this);		TEXTMETRIC tm;		dc.GetTextMetrics(&tm);	m_cxChar = tm.tmAveCharWidth;	m_cyChar = tm.tmHeight + tm.tmExternalLeading;		// Create a font for the static text elements in the window - they will be smaller than	// the normal boldface font.		int nHeight = -tm.tmHeight * 0.75;		m_ctlFont.CreateFont(nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,					CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, NULL);								m_hBadBitmap.LoadMappedBitmap(ID_BAD_QUALITY_BITMAP);	m_hGoodBitmap.LoadMappedBitmap(ID_GOOD_QUALITY_BITMAP);	m_hCautionBitmap.LoadMappedBitmap(ID_CAUTION_QUALITY_BITMAP);	m_hTopOfHeadSidewaysBitmap.LoadMappedBitmap(ID_TOP_OF_HEAD_SIDEWAYS_BITMAP);	// Default to sending the WM_CLOSE message to my parent. We change this only when the	// Cancel or OK buttons are pressed.		m_MessageToSend = WM_CLOSE;		// Set up some of our variables		up_image = NULL;	side_image = NULL;		m_UpSelected = FALSE;	m_SideSelected = FALSE;			m_UpDownloaded = FALSE;	m_SideDownloaded = FALSE;}// This function is called when the Ok button is pressed. If everything looks// ok, we set the message type that will be sent to our parent window.// In the case of OK, we want the parent to go ahead and initiate// analysis. We also get our current rectangle on the screen, and set the// parent window's location to match our's.// However, if the report doesn't pass muster, we return a "1" to the caller// and don't do anything about sending a message to the parent.int CMFCRunWin::OnOkButtonClicked(){	int returnVal = 0;		CRect popUpRect;		if (m_UpSelected && m_SideSelected)	{		CString theReportNameString;				m_ctlNameEditField.GetWindowText(theReportNameString);				if (CheckReportValidity(this, 								&theReportNameString,								m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME)),								gGlobalProperties->GetAdjustReport()))		{			GetClientRect(&popUpRect);			m_Parent->SetParentPosition(&popUpRect);						// We don't Show the Main window here, as it will be transitioning to 			// the Analysis window				m_MessageToSend = EYEDX_MFC_OK_MESSAGE;			returnVal = 1;		}	}	else	{		MessageBox("You must choose both images.", AfxGetAppName(), MB_OK);	}	return returnVal;}// This function is called when the Ok button is pressed. We send a message// to ourselves which will eventually destroy the Run From  window.// We also set the member that indicates the kind of message to send to // the parent. In the case of Cancel, we want the parent not initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.void CMFCRunWin::OnCancelButtonClicked(){	CRect popUpRect;		// Set the Main Window's postion, and then show it. That will make it	// visible before we disappear, so that the transition between windows	// is less abrupt.		GetClientRect(&popUpRect);	m_Parent->SetParentPosition(&popUpRect);	m_Parent->ShowWindow(SW_SHOW);		m_MessageToSend = EYEDX_MFC_CANCEL_MESSAGE;	PostMessage(WM_CLOSE, 0, 0);}void CMFCRunWin::OnAnimateCheckboxClicked(){	DisplayGraphics = (m_ctlAnimateCheckbox.GetCheck() ? 1 : 0);}void CMFCRunWin::OnSelectUpButtonClicked(){}void CMFCRunWin::OnSelectSideButtonClicked(){}