// =================================================================================//	ReportFunctions.cp// =================================================================================//	This file contains the code that handles the Report Functions//#define WINDOWS#include <stdio.h>#include <string.h>#include "folder_dialog.h"//#include "FolderDialog.h"//extern long DebugFeatures;//extern long AdvancedFeatures;// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"#include "globals.h"#include "CMFCCopyProgressDlg.h"#include "CMFCCameraImageSelectDlg.h"#include "CMFCAnalysisWin.h"#include "CMFCRunWin.h"#include "CMFCRunFromCameraWin.h"#include "CMFCRunFromDiskWin.h"#include "CMFCAboutDialog.h"#include "EyeDxMFCMessages.h"#include "main.h"const int errInvalidHTML = -314159;const char *theSRCTokenString = "SRC";// The buffer we are passed in ptr is NULL-terminated. So we can just parse the entire buffer as// one big string.					OSErr CMainWindow::ParseForSRCTags(CFile *copyReportFile, char *ptr, FilePathPairList **theFilePathPairList, long *theFilePathListCount, 										CString srcDirPath, CString dstSimagesPath, CString dstEyesPath,										BOOL flattenReport){	long theCount;	CFileException e;		// Scan through the provided buffer, looking for patterns that look like 'SRC[ ]=[ ]"string"'		// Save the pointer		char *p = ptr;	long bufLength = strlen(ptr);		// NULL the pointer to the FilePathPairList, and set the count to zero		*theFilePathPairList = NULL;		*theFilePathListCount = 0;		// Get the first token		char *theSRCToken = strstr(p, theSRCTokenString);		while (theSRCToken)	{		// We want to write out the source file from where we left off last time to this point.				theCount = (theSRCToken - p);				TRY		{			copyReportFile->Write(p, theCount);		}		CATCH(CFileException, e)		{			ReportCopyError(e->m_cause, "write", copyReportFile->GetFileName());			return -1;		}		END_CATCH						p = theSRCToken + 1;			// We found a token. Now look for an equals sign, a double quote, a newline, or a return		// Any of these are terminations for the SRC token. Only the equals sign is valid. Note		// That we may have just found a "SRC" string embedded in the report name, so we do not		// consider this an error. We just move on to the next token.				char *theFollowingToken = strpbrk(p, "=\n\r\"");		if ((theFollowingToken == NULL) || (*theFollowingToken != '='))		{			// Now get the next SRC token. First, if we are outputting the modified report, output			// the 'S' that we skipped over.						TRY			{				copyReportFile->Write(theSRCToken,1 );			}			CATCH(CFileException, e)			{				ReportCopyError(e->m_cause, "write", copyReportFile->GetFileName());				return -1;			}			END_CATCH							// Now get the next SRC token			theSRCToken = strstr(p, theSRCTokenString);			continue;		}				p = theFollowingToken + 1;				// Ok, we've found the '='. Now look for an opening double quote.		// In this case, if it is not found, we have a string that looks like		// "SRC=" but is not an HTML tag. This could be a valid string in the		// report name, for example. So, we just move on. Since double quotes are		// illegal in report names, from this point on we must be dealing with an HTML		// tag, and handle invalid cases as errors.				theFollowingToken = strpbrk(p, "\n\r\"");		if ((theFollowingToken == NULL) || (*theFollowingToken != '"'))		{			// Now get the next SRC token. First, output the 'SRC=' that we skipped over.			// Do not output the character after the =, since we didn't find a double quote,			// that's where we'll output from (from p) when we loop again.						theCount = 4;						TRY			{				copyReportFile->Write(theSRCToken, theCount);			}			CATCH(CFileException, e)			{				ReportCopyError(e->m_cause, "write", copyReportFile->GetFileName());				return -1;			}			END_CATCH						// And look for the next token			theSRCToken = strstr(p, theSRCTokenString);			continue;		}					// We output the SRC=" string to the output file.				theCount = (theFollowingToken - theSRCToken + 1);		TRY		{			copyReportFile->Write(theSRCToken, theCount);		}		CATCH(CFileException, e)		{			ReportCopyError(e->m_cause, "write", copyReportFile->GetFileName());			return -1;		}		END_CATCH		p = theFollowingToken + 1;				// Now we are pointing at the opening double quote. We bump the pointer		// up, and save the starting pointer for the URL (which should be a file reference -		// if not, we ignore it				char *theStartOfURL = p;				// Now, look for a valid terminating double quote. If we don't find it before hitting		// the end of the buffer or a newline or carriage return, its an error		theFollowingToken = strpbrk(p, "\n\r\"");		if ((theFollowingToken == NULL) || (*theFollowingToken != '"'))		{			if (*theFilePathPairList)				free(*theFilePathPairList);			ReportCopyError(e.m_cause, "parse", copyReportFile->GetFileName());			return errInvalidHTML;		}		// We can now calculate the length of the URL string. It is theFollowingToken - theStartofURL		// We use this to copy the URL into an allocated string, and tack-on a terminating NULL.				long theURLSize = theFollowingToken - theStartOfURL;		char *theURL = new char [theURLSize + 1];				strncpy(theURL, theStartOfURL, theURLSize);		theURL[theURLSize] = '\0';				p = theFollowingToken + 1;		// Finally, we have extracted the URL from the text. We attempt to convert it into a FilePath.		// We have to determine the directory portion. It should be either "Simages" or "eyes". If		// neither of these strings exist in the URL, we simply ignore it. This takes care of the		// logo file. Of course, it breaks if new directories are added to the EyeDx hierarchy, but		// so does other portions of the EyeDx code that deal only with the know directories.				// Note that the input FilePath for the conversion routine is the reports directory. It will		// resolve the actual directory based on the UNIX path.				CEyeDxBooleanType theCreateFlag = false;		CString theInPath;		CString theOutPath;				if (strstr(theURL, "Simages") != NULL)		{			theOutPath = dstSimagesPath;			theCreateFlag = true;		}		else		if (strstr(theURL, "eyes") != NULL)		{			theOutPath = dstEyesPath;			theCreateFlag = true;		}					char *theURLptr = theURL;					// Find the last "/" in the buffer, as we want to copy from that point on to the end		char *lastSlash = strrchr(theURL, '/');					if (theCreateFlag)		{			// It's an SImages file. So we build the FilePath using the passed-in 						// Skip over any leading "../" or "./" strings, so that the URL is relative to			// the session directory, not the reports directory.						while (*theURLptr == '.' || *theURLptr == '/')				theURLptr++;							// Now convert '/' characters to '\' to match Windows conventions						char *cvtURLptr = theURLptr;						while (*cvtURLptr)			{				if (*cvtURLptr == '/')					*cvtURLptr = '\\';				cvtURLptr++;			}									// We now have the FilePath for the source file. Copy the name to the destination			// Path. We just pull out the file name, since we need to adjust the source and			// destination directories depending on what type of export operation (normal or			// flatten) are are performing.						char *theNamePtr = theURLptr;			if (lastSlash != NULL)				theNamePtr = lastSlash + 1;							// The path srcDirPath and theOutPath already point to the correct directory, and have			// the path separator in place at the end of the string. So just tack-on the file name that			// we extracted above.						theInPath = srcDirPath + theURLptr;			theOutPath += theNamePtr;						// Now we have the in and out Path. Create another element in the output list.			// First, bump the count of elements. The tack on space on the end of the array,			// and then copy in the FilePaths we just created.						(*theFilePathListCount)++;						FilePathPairList *theList = *theFilePathPairList;						theList = (FilePathPairList *)realloc(theList, sizeof(struct FilePathPairList) * (*theFilePathListCount));						*theFilePathPairList = theList;						strcpy(theList[*theFilePathListCount - 1].theSrcPath, theInPath);			strcpy(theList[*theFilePathListCount - 1].theDstPath, theOutPath);		}							// Now, we either output the truncated file name (no ../ strings) if we are flattening,		// or we just output the whole URL. Note that this assumes that ALL SRC URLs in the file		// are image files.				if (flattenReport)		{			// This will output just the last component of the URL and the terminating double quote			// If lastSlash is not NULL, that means we found the last slash. If it is NULL, no slash			// exists in the string, so we want to output the entire string.						if (lastSlash)			{				theCount = theURLSize - ((lastSlash + 1) - theURL);				TRY				{					copyReportFile->Write((lastSlash + 1), theCount);				}				CATCH(CFileException, e)				{					ReportCopyError(e->m_cause, "write", copyReportFile->GetFileName());					return -1;				}				END_CATCH						}			else			{				theCount = theURLSize;				TRY				{					copyReportFile->Write(theURL, theCount);				}				CATCH(CFileException, e)				{					ReportCopyError(e->m_cause, "write", copyReportFile->GetFileName());					return -1;				}				END_CATCH						}						// Now output the terminating double quote from the input buffer			theCount = 1;			TRY			{				copyReportFile->Write(theFollowingToken, theCount);			}			CATCH(CFileException, e)			{				ReportCopyError(e->m_cause, "write", copyReportFile->GetFileName());				return -1;			}			END_CATCH					}		else		{			// This will output the entire URL and the terminating double quote from the input buffer			theCount = (theFollowingToken - theStartOfURL + 1);			TRY			{				copyReportFile->Write(theStartOfURL, theCount);			}			CATCH(CFileException, e)			{				ReportCopyError(e->m_cause, "write", copyReportFile->GetFileName());				return -1;			}			END_CATCH					}									// We don't need the string anymore, so delete it				delete theURL;				// Now get the next SRC token		theSRCToken = strstr(p, theSRCTokenString);		}		// Finally, we have to output the rest of the file. Calculate the buffer length based	// on the current pointer minus the beginning pointer (the amount we've already handled)	// and then subtract that from the original buffer length. Output from p to the end.		theCount = (bufLength - (p - ptr));	TRY	{		copyReportFile->Write(p, theCount);	}	CATCH(CFileException, e)	{		ReportCopyError(e->m_cause, "write", copyReportFile->GetFileName());		return -1;	}	END_CATCH					return 0;			}static char szFilters[] = "Report files (*.htm)|*.htm||";static char szTitle[] = "EyeDx: Choose Reports (Control-click to choose multiple)";const int MaxFiles = 20;void CMainWindow::HandleExportReports(BOOL flattenReports){		// We create our subdirs here if necessary. This allows the user to rename the reports folder,	// for example, while the program is running, in order to organize report files by date or other	// convention. We do it here in case the very next thing they try to do is run Export Reports.		CreateSubdirs(this);		CFileDialog rdlg(TRUE, "htm", "*.htm", OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_ALLOWMULTISELECT, szFilters, this);		rdlg.m_ofn.lpstrTitle = szTitle;		rdlg.m_ofn.lpstrInitialDir = m_DefaultreportsDir;		char pathBuffer[MAX_PATHNAME_CHARS * MaxFiles];	rdlg.m_ofn.lpstrFile = pathBuffer;	rdlg.m_ofn.nMaxFile = MAX_PATHNAME_CHARS * MaxFiles;		if (rdlg.DoModal() == IDOK)				{		// Next, if the user chose a report, ask them to select a destination. This		// should be a folder or volume.				CString destDirPath;				CFolderDialog fdlg(&destDirPath);				CEyeDxBooleanType selected = FALSE;				while (!selected)		{			int result = fdlg.DoModal();					if (result == IDOK)			{				// Append a path separator only if needed								if (destDirPath[destDirPath.GetLength() - 1] != '\\')					destDirPath = destDirPath + "\\";							// Check to see if the path is the EyeDx Reports folder. If so, tell the user				// that they must choose a different folder, and redisplay the dialog								CString reportsDir = m_DefaultreportsDir;				reportsDir += "\\";												if (destDirPath == DataPath)				{					MessageBox("Sorry, please select a folder other than the EyeDx folder.", AfxGetAppName());				}				else if (destDirPath == reportsDir)				{					MessageBox("Sorry, please select a folder other than the EyeDx reports folder.", AfxGetAppName());				}				else					selected = TRUE;			}			else			{				MessageBox("Export Reports Cancelled - No destination folder selected.", AfxGetAppName());				return;			}		}				// We fell out of the loop, so they must have hit OK with a valid folder chosen				// If a folder or volume is chosen, then we process each report that was chosen.		// The first step is to copy the EyeDxLogo.jpg file into the root directory of the destination		// folder.							CString destLogoFile = destDirPath + "EyeDxLogo.jpg";		CString rootDir = DataPath;		CString srcLogoFile = rootDir + "EyeDxLogo.jpg";							if (CopyFile(srcLogoFile, destLogoFile, FALSE) == FALSE)		{			ReportCopyError(GetLastError(), "copy", "EyeDxLogo.jpg");			return;		}								// Next, create the subfolders (reports, Simages, eyes) if necessary.		// We just ignore errors here - if the directories already exist, fine.				CString destReportsDir;		CString destSimagesDir;		CString destEyesDir;				if (!flattenReports)		{			destReportsDir = destDirPath + "reports";					CreateDirectory(destReportsDir, NULL);						destReportsDir += "\\";			destSimagesDir = destDirPath + "Simages";						CreateDirectory(destSimagesDir, NULL);						destSimagesDir += "\\";						destEyesDir = destDirPath + "eyes";						CreateDirectory(destEyesDir, NULL);						destEyesDir += "\\";		}		else		{			// We're going to copy everything into the same folder. So, we just copy the destination folder spec into			// the spec for all of the eyes, reports, and Simages.			destReportsDir = destDirPath;					destSimagesDir = destDirPath;						destEyesDir = destDirPath;		}				// Next, for each file that was selected, copy the file into the reports folder. Then, 		// look into the file for all SRC tags. Error handling consists of making a list of the files		// associated with each report that are copied. If an error occurs, such as running out of disk		// space, the program will remove the last report and the lartial list of associated files from		// the destination. This is so that partial reports are not accidentally exported.				// Create a LProgressDialog to show progress as we copy. We pass the address of our flag		// that the dialog will set if its Cancel button is clicked. 				CString theLabel;				if (flattenReports)			theLabel = "Export Reports for Emailing";		else			theLabel = "Export Reports";						CEyeDxBooleanType CancelClicked = FALSE;				CMFCCopyProgressDlg *theProgressDialog = new CMFCCopyProgressDlg(&CancelClicked);		// Now, show the progress dialog				int result = theProgressDialog->Create("IDD_COPY_PROGRESS_DLG", this);				theProgressDialog->SetWindowText(theLabel);				theProgressDialog->SetFocus();				POSITION thePosition = rdlg.GetStartPosition();				while (thePosition != NULL)		{										// Get the file, and copy it, first confirming overwrite if the destination exists						CString srcReportPath = rdlg.GetNextPathName(thePosition);						// Extract the name of the report						CString reportName = strrchr(srcReportPath, '\\') + 1;						// Extract the name of the report's parent directory. That is the the string after we delete			// the report name and the next-higher path component (normally the string "reports"). This is			// then used as the base path for copying the associated images.						CString tmpStr = srcReportPath.Left(srcReportPath.ReverseFind('\\'));			CString reportSrcDir = tmpStr.Left(tmpStr.ReverseFind('\\'));			reportSrcDir += '\\';	// Make sure that the path has the separator at the end.						// Show progress in the dialog as we copy						CString theActionStr;			CString	theStepStr;						theActionStr = "Exporting " + reportName;			theProgressDialog->SetActionText(theActionStr);						theStepStr = "Copying " + reportName;			theProgressDialog->SetStepText(theStepStr);						// Create the destination path						CString dstReportPath;						dstReportPath = destReportsDir + reportName;						// Check to see if the destination file exists						// Assume that the default is yes.						int item_hit = IDYES;			HANDLE		hFind;			WIN32_FIND_DATA	fd;						if ((hFind = FindFirstFile(dstReportPath, &fd)) != INVALID_HANDLE_VALUE)			{				CString thePrompt;								thePrompt.Format("A report named '%s' already exists in the export folder.\nOverwrite?", reportName);				item_hit = MessageBox(thePrompt, AfxGetAppName(), MB_YESNO);				// We have to reset the focus on the non-modal window so the user can				// press the Cancel button. Dispay a MessageBox changes the focus								theProgressDialog->SetFocus();				if (item_hit == IDYES)				{													if (DeleteFile(dstReportPath) != TRUE)					{						ReportCopyError(GetLastError(), "delete", reportName);						theProgressDialog->DestroyWindow();						delete theProgressDialog;						return;					}				}			}			FindClose(hFind);			// else the file didn't exist, and that's just swell. 				if (item_hit == IDYES)			{												// This is a bit of a kludge. We use the CopyFile routine to initially copy the source to the				// destination. This routine preserves all of the associated attributes. Rather than reproducing 				// all of that, we just copy the file.								// Then, we re-open the file, and rewrite it from the start, possibly modifying the URLs if we				// are flattening it. Not the most efficient way to do this, but since the file size is relatively				// small, it's better than having to duplicate 99% of the code in the FileCopy routine!													   				if (CopyFile(srcReportPath, dstReportPath, FALSE) == FALSE)				{					ReportCopyError(GetLastError(), "copy", reportName);					theProgressDialog->DestroyWindow();					delete theProgressDialog;					return;				}								// Now parse the report file looking for SRC tags.								// To simplify things, we just read the entire report file into temporary memory. Since report				// files are small (or should be!), this shouldn't be a problem. Note that we check to make sure				// that there is sufficient memory available to do this.								long theFileSize;								// Open the source file				CFile srcFile;				CFileException e;								if (srcFile.Open(srcReportPath, CFile::modeRead, &e) == FALSE)				{					srcFile.Abort();					ReportCopyError(e.m_cause, "open", reportName);					theProgressDialog->DestroyWindow();					delete theProgressDialog;					return;				}								theFileSize = srcFile.GetLength();								CFile dstFile;								if (dstFile.Open(dstReportPath, CFile::modeCreate | CFile::modeWrite, &e) == FALSE)				{					srcFile.Abort();					dstFile.Abort();					ReportCopyError(e.m_cause, "open", reportName);					theProgressDialog->DestroyWindow();					delete theProgressDialog;					return;				}								// We will NULL-terminate the read buffer, so bump its size up by one byte								char *thePointer = (char *) malloc((theFileSize + 1));				if (thePointer == NULL)				{					srcFile.Abort();					dstFile.Abort();					ReportCopyError(0, "allocate memory to read", reportName);					theProgressDialog->DestroyWindow();					delete theProgressDialog;					return;				}														// Read the file, looking for the SRC = "URL" tags.				TRY				{					srcFile.Read(thePointer, theFileSize);				}				CATCH(CFileException, e)				{					srcFile.Abort();					dstFile.Abort();					ReportCopyError(e->m_cause, "read", reportName);					theProgressDialog->DestroyWindow();					delete theProgressDialog;					return;				}				END_CATCH								// NULL terminate the buffer, so that the string functions we use in the				// parse function won't run off the end.								thePointer[theFileSize] = '\0';				// Parse the memory, and build a list of FilePaths that represent				// image files that need to be copied, minus the logo file. We pass				// in the FilePaths for the destination SImages and eyes folder.								FilePathPairList *theFilePathPairList;				long theFilePathListCount;								int theError = ParseForSRCTags(&dstFile, thePointer, &theFilePathPairList, &theFilePathListCount, 										reportSrcDir, destSimagesDir, destEyesDir, flattenReports);				if (theError != 0)				{					srcFile.Abort();					dstFile.Abort();					// The error is reported by the ParseForSRCTags routine					theProgressDialog->DestroyWindow();					delete theProgressDialog;					return;				}				// Close the input file								TRY				{					srcFile.Close();				}				CATCH(CFileException, e)				{					ReportCopyError(e->m_cause, "close", reportName);					theProgressDialog->DestroyWindow();					delete theProgressDialog;					return;				}				END_CATCH								// Close the output file								TRY				{					dstFile.Close();				}				CATCH(CFileException, e)				{					ReportCopyError(e->m_cause, "close", reportName);					theProgressDialog->DestroyWindow();					delete theProgressDialog;					return;				}				END_CATCH								// Release the temporary memory, since we are done parsing.								free(thePointer);								// For each SRC tag found, convert the path into a file reference, and copy the 				// file into the appropriate subfolder in the destination folder.								// Point to the first element in the list								FilePathPairList *theImagePairPath = theFilePathPairList;								// We have two choices for handling any existing files in the destination folder.				// Since the current naming scheme doesn't tie an image to a report, if we delete the				// images we may be changing the contents of other reports that also used this image				// previously. The alternative is to prompt the user to tell them that these images				// exist, and if they say to overwrite, we do so. If they say to skip, then we presumably				// remove the report file that we just copied.												// However, the alternative is to just delete any existing duplicate names in the destination				// and tell the user that we had to do that.								// Neither is ideal. The image naming scheme should really use the name of the report in the				// file name so that if we see a duplicate, we know that we are replacing images for the				// report that the user just confirmed overwriting. 								// Right now, we take the easy way out, and just delete the offending files.								// Point back to the start of the list								theImagePairPath = theFilePathPairList;											for (long theImageFile = 0; theImageFile < theFilePathListCount; theImageFile++)				{					char *theFileName = strrchr(theImagePairPath->theSrcPath, '\\');					if (theFileName == NULL)						theFileName = theImagePairPath->theSrcPath;					else						theFileName++;	// Skip over the slash								theStepStr = "Copying ";					theStepStr = theStepStr + theFileName;					theProgressDialog->SetStepText(theStepStr);										// We call the copy routine, specifying that it not fail if the destination exists										if (CopyFile(theImagePairPath->theSrcPath, theImagePairPath->theDstPath, FALSE) == FALSE)					{						ReportCopyError(GetLastError(), "copy", theImagePairPath->theSrcPath);						theProgressDialog->DestroyWindow();						delete theProgressDialog;						return;					}								// Move to the next image pair										theImagePairPath++;									}				// Delete the memory allocated for the image list								if (theFilePathPairList != NULL)					free((void *)theFilePathPairList);			}						// Check to see if the user hit the Cancel button. If so, we should clean up the current			// report. We detect this by checking the flag			if (CancelClicked == TRUE)			{				theProgressDialog->DestroyWindow();				delete theProgressDialog;								MessageBox("Export Reports Cancelled", AfxGetAppName());				return;			}		}		// Delete the Progress window				theProgressDialog->DestroyWindow();		delete theProgressDialog;			if (flattenReports)			MessageBox("To email reports, attach the files in the destination folder to the email message. Do not try to attach the destination folder itself.\n\nUse MIME encoding (see your email program's instructions) for best compatibility with the receiver's email program.", AfxGetAppName());	}}void CMainWindow::ReportCopyError(int errorCode, CString theActionString, CString theFileString){	CString theErrorPrefixStr;	LPTSTR result;		theErrorPrefixStr.Format("Couldn't %s '%s'.\n", theActionString, theFileString);		::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |					FORMAT_MESSAGE_FROM_SYSTEM,					NULL,					errorCode,					0,					(LPTSTR)&result,					0,					NULL);	theErrorPrefixStr = theErrorPrefixStr + result + "\nCancelling Export Report operation.";		MessageBox(theErrorPrefixStr, AfxGetAppName());}// This routine will check the passed filename string for any of the illegal// filename characters. We use a common set of illegal characters for both// platforms, so that files can easily be exchanged between systems.static CEyeDxBooleanType LegalFilename(const CEyeDxShortStringType *theString){	if (theString->FindOneOf(ILLEGAL_FILENAME_CHARS) >= 0)		return FALSE;	// The file name cannot be all blanks!		short theStrLength = theString->GetLength();		short i = 0;	while (i < theStrLength)	{		if (theString->GetAt(i) != ' ')			return TRUE;		i++;	}		return FALSE;}// This routine checks if the specified report exists, and prompts the user// for what to do. It also checks the report string for length and illegal// characters, and displays a notice if appropriate.// Returns true if the operation should continue, and false if not.// It also updates the global report_filename variable.CEyeDxBooleanType CheckReportValidity(CEyeDxWindowType *theWindow, CEyeDxLongStringType *theReportNameString, CEyeDxVariable *theSessionNameVariable, CEyeDxBooleanType adjustName){	CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();	// Perform some validity checks on the report name			if ((theReportNameString->GetLength() < kMinReportNameLength))	{				CString theLengthStr;		theLengthStr.Format("Please enter a report name that is at least %d characters long.", kMinReportNameLength);				theWindow->MessageBox(theLengthStr, AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);	}	else if (theReportNameString->GetLength() > kMaxReportNameLength)	{		CString theLengthStr;		theLengthStr.Format("The report name cannot be longer than %d characters.", kMaxReportNameLength);				theWindow->MessageBox(theLengthStr, AfxGetAppName(), MB_OK);	}	else if (!LegalFilename(theReportNameString))	{					CString message;		message.Format("The report name cannot contain any of the characters %s and must not be blank.", ILLEGAL_FILENAME_CHARS);					 	theWindow->MessageBox(message, AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);	}	else	{		strcpy(report_filename, *theReportNameString);				// Check if this report already exists. If it does, prompt the user whether to continue		// If the adjustName feature is enabled, we have to loop through the possible prefixes, and		// warn the user that a possible conflict exists. Otherwise, just check for the same exact name.				if (adjustName)		{			char *prefixes[] = {kYesReferralIndicator, 								kNoReferralIndicator,								kSecondImageReferralIndicator,								kUnclearReferralIndicator };						char theFileList[MAX_PATHNAME_CHARS];			strcpy(theFileList, "");			int existingReports = 0;			for (int prefixNum = 0; prefixNum < kNumValidPrefixes; prefixNum++)			{								char reportpath[MAX_PATHNAME_CHARS];			  	sprintf(reportpath, "%s%s%creports%c%s%s.htm", DataPath, LPCTSTR(*theSessionName), PATHSEPARATOR, PATHSEPARATOR, prefixes[prefixNum], report_filename);				FILE *fp;				if ((fp = fopen(reportpath, "rw")) != NULL)				{					fclose(fp);					existingReports++;					if (strlen(theFileList) != 0)						strcat(theFileList, ", ");					strcat(theFileList, "'");					strcat(theFileList, prefixes[prefixNum]);					strcat(theFileList, report_filename);					strcat(theFileList, "'");				}			}						if (existingReports > 0)			{				CString thePrompt;								if (existingReports == 1)					thePrompt.Format("A report with this name and a referral prefix exists in this session: %s.\nShould the program overwrite it if necessary?", theFileList);				else					thePrompt.Format("Reports with this name and referral prefixes exist in this session: %s.\nShould the program overwrite one of these if necessary?", theFileList);				int item_hit = theWindow->MessageBox(thePrompt, AfxGetAppName(), MB_OKCANCEL | MB_ICONEXCLAMATION);							if (item_hit == IDOK)					return true;				else					return false;			}			return true;		}		else		{					char reportpath[MAX_PATHNAME_CHARS];	  		sprintf(reportpath, "%s%s%creports%c%s.htm", DataPath, LPCTSTR(*theSessionName), PATHSEPARATOR, PATHSEPARATOR, report_filename);						// Check if this report already exists. If it does, prompt the user whether to continue					  						FILE *fp;						// Default to the no case			int item_hit = IDOK;			if ((fp = fopen(reportpath, "rw")) != NULL)			{				fclose(fp);				item_hit = theWindow->MessageBox("A report with this name already exists.\nOverwrite?", AfxGetAppName(), MB_OKCANCEL | MB_ICONEXCLAMATION);			}			if (item_hit == IDOK)				return TRUE;			else				return FALSE;		}	}	return FALSE;		}// This routine checks if the specified session exists, and prompts the user// if so. It also checks the session name string for length and illegal// characters, and displays a notice if appropriate.// Returns true if the operation should continue, and false if not.CEyeDxBooleanType CheckSessionValidity(CEyeDxWindowType *theWindow, CEyeDxLongStringType *theSessionNameString){	// Perform some validity checks on the report name			if ((theSessionNameString->GetLength() < kMinSessionNameLength))	{				CString theLengthStr;		theLengthStr.Format("Please enter a session name that is at least %d characters long.", kMinSessionNameLength);		theWindow->MessageBox(theLengthStr, AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);	}	else if (theSessionNameString->GetLength() > kMaxSessionNameLength)	{		CString theLengthStr;		theLengthStr.Format("The session name cannot be longer than %d characters.", kMaxSessionNameLength);				theWindow->MessageBox(theLengthStr, AfxGetAppName(), MB_OK);	}	else if (!LegalFilename(theSessionNameString))	{					CString message;		message.Format("The session name cannot contain any of the characters %s and must not be blank.", ILLEGAL_FILENAME_CHARS);					 	theWindow->MessageBox(message, AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);	}	else	{		CEyeDxLongStringType theSessionPath = DataPath;		theSessionPath += *theSessionNameString;							WIN32_FIND_DATA FindData;			HANDLE hFind = ::FindFirstFile(theSessionPath, &FindData);			// If there is no such session, then we will have an invalid file handle				FindClose(hFind);				// Check if this session already exists. If it does, prompt the user					  							if (hFind != INVALID_HANDLE_VALUE)		{			theWindow->MessageBox("A session or file with this name already exists.", AfxGetAppName(), MB_OK | MB_ICONEXCLAMATION);			return FALSE;		}		return TRUE;	}	return FALSE;		}// This routine will parse the specified session folder, generating a list of report names. It then sorts the// list alphabetically, and returns it and the number of elements to the caller. The list must be a C String// list because it is called by cross-platform common code. The caller is responsible for freeing the allocated// memoryCTemplateShortStrArray *GetReportList(CEyeDxLongStringType *theSessionName){	CEyeDxLongStringType theReportsFolder = DataPath;	theReportsFolder += *theSessionName;	theReportsFolder += PATHSEPARATOR;	theReportsFolder += "reports";		CTemplateShortStrArray *tmpStringArray = new CTemplateShortStrArray();		WIN32_FIND_DATA FindData;	TCHAR szCurrDir[_MAX_DIR];		// Save the current directory, and switch to the reports directory		GetCurrentDirectory(sizeof(szCurrDir) / sizeof(TCHAR), szCurrDir);		SetCurrentDirectory(theReportsFolder);		HANDLE hFind = ::FindFirstFile(__TEXT("*.htm"), &FindData);		// If there are no items, then we will have an invalid file handle		bool done = (hFind == INVALID_HANDLE_VALUE);		while (!done)	{		if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)		{			CEyeDxShortStringType *theStringCopy;			CEyeDxShortStringType theOriginalString = FindData.cFileName;				// We strip-off the ".htm" extension						// Convert the input filename into a filename w/o extension.									// Since filenames can contain multiple "." characters, we find the location of			// the _last_ one. Then we see if the following string is 'htm'.						int lastperiod = theOriginalString.ReverseFind('.');						if (lastperiod != -1)				theStringCopy = new CEyeDxShortStringType(theOriginalString.Left(lastperiod));			else				theStringCopy = new CEyeDxShortStringType(theOriginalString);							// Now, find where to insert the string in the list. We want to sort it alphabetically						int numStrings = tmpStringArray->GetSize();			int i = 0;						while ((numStrings-- > 0) && (*(tmpStringArray->GetAt(i)) < *theStringCopy))				i++;							tmpStringArray->InsertAt(i, theStringCopy);		}		done = !::FindNextFile(hFind, &FindData);			}		FindClose(hFind);		// Restore the previous directory		SetCurrentDirectory(szCurrDir);	return tmpStringArray;}void CMainWindow::CreateSubdirs(CEyeDxWindowType	*theWindow){	// Create the necessary subdirectories if they don't exist - reports, Pimages, Simages, and eyes.		char pathname[MAX_PATHNAME_CHARS + 50];	HANDLE		hFind;	WIN32_FIND_DATA	fd;		CEyeDxLongStringType *theSessionName;	CEyeDxLongStringType theSessionNamePath;		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theSessionNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	if (theSessionNameVariable)		theSessionName = theSessionNameVariable->GetValue();	else		return;	// A failure that should not occur			theSessionNamePath = DataPath;	theSessionNamePath += *theSessionName;	// First, create the session folder				  	if ((hFind=FindFirstFile(theSessionNamePath,&fd)) == INVALID_HANDLE_VALUE)    {    	if (!CreateDirectory(theSessionNamePath,NULL))	  		theWindow->MessageBox("Unable to create session folder!\nWill save in EyeDx Folder.", AfxGetAppName());    } 	FindClose(hFind);	strcpy(m_DefaultreportsDir,theSessionNamePath);  	strcat(m_DefaultreportsDir,"\\reports");  	if ((hFind=FindFirstFile(m_DefaultreportsDir,&fd)) == INVALID_HANDLE_VALUE)    {    	if (!CreateDirectory(m_DefaultreportsDir,NULL))	  		theWindow->MessageBox("Unable to create reports folder!\nWill save in EyeDx Folder.", AfxGetAppName());    } 	FindClose(hFind);	strcpy(m_DefaultPimagesDir,theSessionNamePath);  	strcat(m_DefaultPimagesDir,"\\Pimages");	if ((hFind=FindFirstFile(m_DefaultPimagesDir,&fd)) == INVALID_HANDLE_VALUE)	{	  	if (!CreateDirectory(m_DefaultPimagesDir,NULL))			theWindow->MessageBox("Unable to create Pimages folder!\nWill save in EyeDx Folder.", AfxGetAppName());	}	FindClose(hFind);		strcpy(pathname,theSessionNamePath);  	strcat(pathname,"\\Simages");	if ((hFind=FindFirstFile(pathname,&fd)) == INVALID_HANDLE_VALUE)	{	  	if (!CreateDirectory(pathname,NULL))			theWindow->MessageBox("Unable to create Simages folder!\nWill save in EyeDx Folder.", AfxGetAppName());	}	FindClose(hFind);		strcpy(pathname,theSessionNamePath);  	strcat(pathname,"\\eyes");	if ((hFind=FindFirstFile(pathname,&fd)) == INVALID_HANDLE_VALUE)	{	  	if (!CreateDirectory(pathname,NULL))			theWindow->MessageBox("Unable to create eyes folder!\nWill save in EyeDx Folder.", AfxGetAppName());	}	FindClose(hFind);	// Finally, we copy the EyeDxLogo.jpg file into the new session folder		CString destLogoFile = theSessionNamePath;	destLogoFile += "\\EyeDxLogo.jpg";	CString srcLogoFile = DataPath;	srcLogoFile += "EyeDxLogo.jpg";					if (CopyFile(srcLogoFile, destLogoFile, FALSE) == FALSE)		theWindow->MessageBox("Unable to create logo file in session folder!", AfxGetAppName());						}void OpenReport(const char *reportpath){	char	BrowserCommand[MAX_PATHNAME_CHARS],BrowserPath[MAX_PATHNAME_CHARS];	char	text1[MAX_PATHNAME_CHARS];	CWaitCursor wait;			// Show a wait cursor while we fork the browser	HKEY	hKeyHTML,hKeyCommand;	DWORD	Type,Bytes;	STARTUPINFO si;	PROCESS_INFORMATION pi;	int openOK = FALSE;			// Set up the variables that define the browser process options	// used later in the CreateProcess call	ZeroMemory(&si, sizeof(STARTUPINFO));	si.cb = sizeof(STARTUPINFO);	si.dwFlags = STARTF_FORCEONFEEDBACK;		int i;		if (1 /* AutoReport == 1 */)	{		/* look in Windows registry for default command to open html file */		if (RegOpenKeyEx(HKEY_CLASSES_ROOT,".htm",0,KEY_ALL_ACCESS,&hKeyHTML) == ERROR_SUCCESS)		{			Bytes=250;			RegQueryValueEx(hKeyHTML,"",0L,&Type,(unsigned char *)text1,&Bytes);			strcat(text1,"\\shell\\open\\command");			if (RegOpenKeyEx(HKEY_CLASSES_ROOT,text1,0,KEY_ALL_ACCESS,&hKeyCommand) == ERROR_SUCCESS)			{				Bytes=MAX_PATHNAME_CHARS;				RegQueryValueEx(hKeyCommand,"",0L,&Type,(unsigned char *)BrowserCommand,&Bytes);				i=1;				while (BrowserCommand[i] != ':'	||	BrowserCommand[i+1] != '\\')					i++;				strcpy(BrowserPath,&(BrowserCommand[i-1]));				i=0;				while (i < (int)strlen(BrowserPath)	&&	BrowserPath[i] != ' ')					i++;				while (i > 0	&&	!(BrowserPath[i] == 'e'	||	BrowserPath[i] == 'E'))					i--;				BrowserPath[i+1]='\0';				RegCloseKey(hKeyCommand);				i=strlen(BrowserPath)-1;				while (BrowserPath[i] != '\\')					i--;				strcpy(BrowserCommand,&(BrowserPath[i+1]));			}			else			{				strcpy(BrowserPath,"NotGoingToWork");				strcpy(BrowserCommand,"CouldNotFindIt");			}			RegCloseKey(hKeyHTML);						// append the path for the report file to the command line						strcat(BrowserPath, " \"");			strcat(BrowserPath, reportpath);			strcat(BrowserPath, "\"");						printf("BrowserPath = %s\n", BrowserPath);		 	openOK = CreateProcess(NULL, BrowserPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);		}		else	/* try some default locations... */		{			// append the path for the report file to the command line						strcpy(BrowserPath, "C:\\Program Files\\Netscape\\Communicator\\Program\\netscape \"");			strcat(BrowserPath, reportpath);			strcat(BrowserPath, "\"");		 	if ((openOK = CreateProcess(NULL, BrowserPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) == FALSE)		 	{						 		// Must surround path with double quotes since the report names may contain spaces				strcpy(BrowserPath, "C:\\Program Files\\Netscape\\Navigator\\Program\\netscape \"");				strcat(BrowserPath, reportpath);				strcat(BrowserPath, "\"");		 		openOK = CreateProcess(NULL, BrowserPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);			}	  	}	  		  	if (openOK)	  	{	  		// Get rid of the handles since we don't care about the forked process			CloseHandle(pi.hProcess);			CloseHandle(pi.hThread);		}		else		{			AfxMessageBox("Unable to start web browser.\nPlease display report manually.", MB_ICONEXCLAMATION | MB_OK);		}	}}void OpenTextFile(const char *filepath){	char	ViewerCommand[MAX_PATHNAME_CHARS],ViewerPath[MAX_PATHNAME_CHARS];	char	text1[MAX_PATHNAME_CHARS];	CWaitCursor wait;			// Show a wait cursor while we fork the viewer	HKEY	hKeyTXT,hKeyCommand;	DWORD	Type,Bytes;	STARTUPINFO si;	PROCESS_INFORMATION pi;	int openOK = FALSE;			// Set up the variables that define the viewer process options	// used later in the CreateProcess call	ZeroMemory(&si, sizeof(STARTUPINFO));	si.cb = sizeof(STARTUPINFO);	si.dwFlags = STARTF_FORCEONFEEDBACK;		int i;		if (1 /* AutoReport == 1 */)	{		/* look in Windows registry for default command to open text file */		if (RegOpenKeyEx(HKEY_CLASSES_ROOT,".txt",0,KEY_ALL_ACCESS,&hKeyTXT) == ERROR_SUCCESS)		{			Bytes=250;			RegQueryValueEx(hKeyTXT,"",0L,&Type,(unsigned char *)text1,&Bytes);			strcat(text1,"\\shell\\open\\command");			if (RegOpenKeyEx(HKEY_CLASSES_ROOT,text1,0,KEY_ALL_ACCESS,&hKeyCommand) == ERROR_SUCCESS)			{				Bytes=MAX_PATHNAME_CHARS;				RegQueryValueEx(hKeyCommand,"",0L,&Type,(unsigned char *)ViewerCommand,&Bytes);				i=1;				while (ViewerCommand[i] != ':'	||	ViewerCommand[i+1] != '\\')					i++;				strcpy(ViewerPath,&(ViewerCommand[i-1]));				i=0;				while (i < (int)strlen(ViewerPath)	&&	ViewerPath[i] != ' ')					i++;				while (i > 0	&&	!(ViewerPath[i] == 'e'	||	ViewerPath[i] == 'E'))					i--;				ViewerPath[i+1]='\0';				RegCloseKey(hKeyCommand);				i=strlen(ViewerPath)-1;				while (ViewerPath[i] != '\\')					i--;				strcpy(ViewerCommand,&(ViewerPath[i+1]));			}			else			{				strcpy(ViewerPath,"NotGoingToWork");				strcpy(ViewerCommand,"CouldNotFindIt");			}			RegCloseKey(hKeyTXT);						// append the path for the report file to the command line						strcat(ViewerPath, " \"");			strcat(ViewerPath, filepath);			strcat(ViewerPath, "\"");					 	openOK = CreateProcess(NULL, ViewerPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);		}	  		  	if (openOK)	  	{	  		// Get rid of the handles since we don't care about the forked process			CloseHandle(pi.hProcess);			CloseHandle(pi.hThread);		}		else		{			AfxMessageBox("Unable to start the viewer program.\nPlease display file manually.", MB_ICONEXCLAMATION | MB_OK);		}	}}short *GetReportDuplicateList(CTemplateShortStrArray *theReportList, 							  CEyeDxBooleanType *duplicatesFound){	// If there's nothing in the list, indicate so without going through all of the motions.		if (theReportList->GetSize() == 0)	{		*duplicatesFound = false;		return NULL;	}		// First, we allocate an array of shorts that has same number of elements	// as in the passed-in report list. We initialize it to zero as we iterate through the list.		short *theCountList = new short [theReportList->GetSize()];		// Compare each item against every other item. This will produce a count for each item of how	// many of the items in the list contain the current item as a substring. This is not fullproof,	// since a short report name, such as "a", will probably show up in just about every other report.		// We have to initialize the counts outside the loop, since within the loop we access the	// elements in a somewhat random fashion.		for (long item = 0; item < theReportList->GetSize(); item++)		theCountList[item] = 0;			for (long item = 0; item < theReportList->GetSize(); item++)	{		// Grab the current report name				CEyeDxShortStringType *theCurrentItem = theReportList->GetAt(item);				// Make a copy of the string so we can modify it for comparisons				CEyeDxShortStringType theCurrentItemCopy = *theCurrentItem;				// Now we strip off any prefix that might exist, since we want to compare report names		// that may share the same base name.				if (theCurrentItemCopy.Find(CommonStringLiteral_(kYesReferralIndicator) == 0)          ||			theCurrentItemCopy.Find(CommonStringLiteral_(kNoReferralIndicator) == 0)           ||			theCurrentItemCopy.Find(CommonStringLiteral_(kSecondImageReferralIndicator) == 0)  ||			theCurrentItemCopy.Find(CommonStringLiteral_(kUnclearReferralIndicator) == 0))		{			// We convert the prefix to spaces, which will be deleted in the next step						theCurrentItemCopy.SetAt(0, ' ');			theCurrentItemCopy.SetAt(1, ' ');		}					// Strip-off leading spaces				theCurrentItemCopy.TrimLeft();					// We convert the string to lowercase to compare, since filenames are not distinguished by case				theCurrentItemCopy.MakeLower();		// Now that we have the base string, we loop through all of the members of the list.		// We compare each (sans the prefix and after making it all lowercase) to the current item.		// If the current item is a substring of this second item, we bump the current item's count.		// Once we have finished, the count should be at least w (since we will at some point match		// in both directions) the current item. Any items that have counts > 2 may have reports 		// that could be repeat runs of the same subject.		for (long item2 = 0; item2 < theReportList->GetSize(); item2++)		{			CEyeDxShortStringType *theSecondItem = theReportList->GetAt(item2);			// Make a copy of the string so we can modify it for comparisons					CEyeDxShortStringType theSecondItemCopy = *theSecondItem;						// Now we strip off any prefix that might exist, since we want to compare report names			// that may share the same base name.						if (theSecondItemCopy.Find(CommonStringLiteral_(kYesReferralIndicator) == 0)          ||				theSecondItemCopy.Find(CommonStringLiteral_(kNoReferralIndicator) == 0)           ||				theSecondItemCopy.Find(CommonStringLiteral_(kSecondImageReferralIndicator) == 0)  ||				theSecondItemCopy.Find(CommonStringLiteral_(kUnclearReferralIndicator) == 0))			{				// We convert the prefix to spaces, which will be deleted in the next step								theSecondItemCopy.SetAt(0, ' ');				theSecondItemCopy.SetAt(1, ' ');			}						// Strip-off leading spaces						theSecondItemCopy.TrimLeft();						// We convert the string to lowercase to compare, since filenames are not distinguished by case						theSecondItemCopy.MakeLower();			// Ok. Does the second item contain the first as a substring?						if (theSecondItemCopy.Find(theCurrentItemCopy) == 0)			{				// We bump the counters of _both_ items, to show the two-way relationship between the substring				// and the longer string that it was found inside.								theCountList[item]++;				theCountList[item2]++;			}		}	}		// Now go through the list to see if any duplicates exist		for (long item = 0; item < theReportList->GetSize(); item++)	{		if (theCountList[item] > 2)		{			*duplicatesFound = true;			break;		}	}		// We return the list of counters to the caller, who must delete it when done. The count list is in the	// same order as the input report list.		return theCountList;}