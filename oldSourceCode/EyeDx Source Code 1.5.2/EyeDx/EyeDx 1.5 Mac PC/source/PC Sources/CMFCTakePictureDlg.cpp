// main.cp#include "main.h"BEGIN_MESSAGE_MAP( CMFCTakePictureDlg, CDialog )ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipText)ON_BN_CLICKED(IDC_TAKE_PICTURE, OnOK)END_MESSAGE_MAP()CEyeDxBooleanType CMFCTakePictureDlg::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);			CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}CEyeDxBooleanType CMFCTakePictureDlg::PreTranslateMessage(MSG *pMsg){	if (m_hAccel != NULL)		if (::TranslateAccelerator( m_hWnd, m_hAccel, pMsg))			return TRUE;			//	if (IsDialogMessage(pMsg) == TRUE)//		return TRUE;	return CDialog::PreTranslateMessage(pMsg);}CEyeDxBooleanType CMFCTakePictureDlg::OnInitDialog(){	CDialog::OnInitDialog();	CenterWindow();		m_hAccel = ::LoadAccelerators(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_TAKEPICTUREDLG));			EnableToolTips(TRUE);		m_ctlCancelButton = (CButton *) GetDlgItem(IDCANCEL);	m_ctlOkButton = (CButton *) GetDlgItem(IDOK);		m_ctlTakePictureCaption = (CStatic*) GetDlgItem(IDD_PREPARE_PICTURE_CAPTION);			m_ctlCameraBitmap = (CStatic*) GetDlgItem(IDD_PREPARE_PICTURE_BITMAP);	m_ctlBatteryLevelBitmap = (CStatic*) GetDlgItem(IDD_PREPARE_PICTURE_BATTERY_BITMAP);	m_ctlBatteryLevelCaption = (CStatic*) GetDlgItem(IDD_PREPARE_PICTURE_BATTERY_CAPTION);		m_hBatteryOKBitmap.LoadMappedBitmap(ID_BATTERY_OK_BITMAP);	m_hBatteryWeakBitmap.LoadMappedBitmap(ID_BATTERY_WEAK_BITMAP);	m_hBatteryEmptyBitmap.LoadMappedBitmap(ID_BATTERY_EMPTY_BITMAP);	m_hCameraUpBitmap.LoadBitmap("ID_CAMERA_UP_BITMAP");	m_hCameraSideBitmap.LoadBitmap("ID_CAMERA_SIDE_BITMAP");	// Disable the buttons until we know we can take the picture		m_ctlOkButton->EnableWindow(FALSE);	m_ctlCancelButton->EnableWindow(FALSE);	// Show the dialog so that the user sees status updates		ShowWindow(SW_SHOW);	short picturesNeeded; 	// Used to check the camera if it has enough memory for the required number of							// pictures at this particular step	CString thePromptStr;		switch (m_Orientation)	{	case kUpOrientation:		m_ctlCameraBitmap->SetBitmap(m_hCameraUpBitmap);		thePromptStr = "Prepare to take the 'Up' picture. Position subject the correct distance from the camera, and hold camera with the handle on the right side. Press Take Picture when ready.";		// Now we determine how many pictures are still required at this step. If the result code passed-in is either the Continue		// or Retake Both state, we need to take 2 pictures. Otherwise, we need to take just one (we're retaking just the Up or Side		// picture).		if (m_TheResult == kNextStepRetakeBoth || m_TheResult == kNextStepContinue)			picturesNeeded = 2;		else			picturesNeeded = 1;		break;			case kSideOrientation:		m_ctlCameraBitmap->SetBitmap(m_hCameraSideBitmap);		thePromptStr = "Prepare to take the 'Side' picture. Position subject the correct distance from the camera, and hold camera with the handle on the bottom. Press Take Picture when ready.";		// A count of 1 is always correct here - in the case of a new subject (kContinue) or retaking both (kNextStepRetakeBoth),		// we've already taken the Up picture. And if we're just retaking the Side picture, only one is required. If retaking the		// Up picture, we won't be in this case. Thus only one is required.				picturesNeeded = 1;		break;	}	// Force the dialog to refresh		UpdateWindow();			DC120BatteryStatus theBatteryLevel;	CEyeDxBooleanType theFlashStatus = false;	short picturesRemaining;		if (!CheckCameraStatus(this, picturesNeeded, &picturesRemaining, m_ctlTakePictureCaption, &theBatteryLevel, &theFlashStatus))	{		EndDialog(IDCANCEL);	}		// Wait for the flash to recharge. Only wait for a while, though		switch (theBatteryLevel)	{	case DC120BatteryOK:		m_ctlBatteryLevelBitmap->SetBitmap(m_hBatteryOKBitmap);		m_ctlBatteryLevelCaption->SetWindowText("OK");		break;			case DC120BatteryWeak:		m_ctlBatteryLevelBitmap->SetBitmap(m_hBatteryWeakBitmap);		m_ctlBatteryLevelCaption->SetWindowText("Weak");		break;			case DC120BatteryEmpty:		m_ctlBatteryLevelBitmap->SetBitmap(m_hBatteryEmptyBitmap);		m_ctlBatteryLevelCaption->SetWindowText("Empty");		StopAlert(this, CommonStringLiteral_("The camera does not have enough battery power to take another picture. Replace batteries or use AC Adaptor."));		break;	}		// Force the items to show up		UpdateWindow();			// Set the camera parameters		if (!m_Parent->SetCameraPictureParams(m_ctlTakePictureCaption))	{		EndDialog(IDCANCEL);	}			// Now, we finally draw the correct prompt, based on the current orientation (Up or Side)					m_ctlTakePictureCaption->SetWindowText(thePromptStr);			m_ctlOkButton->EnableWindow(TRUE);	m_ctlCancelButton->EnableWindow(TRUE);				return TRUE;}void CMFCTakePictureDlg::OnOK(){	CWaitCursor wait;	// Set the pointer to the stop watch while we are getting the image		m_ctlOkButton->EnableWindow(FALSE);	m_ctlCancelButton->EnableWindow(FALSE);	if (!TakePicture(m_Orientation, this, m_ctlTakePictureCaption, m_MainWindowCaption, m_MainWindowView, m_GenericPictInfo, m_PictInfo))	{		CDialog::OnCancel();	}	CDialog::OnOK();}