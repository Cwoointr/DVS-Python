// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"#include "globals.h"#include "PreviewFileDlg.h"#include "CMFCCameraImageSelectDlg.h"#include "CMFCAnalysisWin.h"#include "CMFCRunWin.h"#include "CMFCRunFromDiskWin.h"#include "CMFCRunFromCameraWin.h"#include "CMFCAboutDialog.h"#include "EyeDxMFCMessages.h"#include "main.h"extern CMainApp gMainApp;static LPCTSTR lpszWindowName="Run From Card or Disk";CMFCRunFromDiskWin::CMFCRunFromDiskWin(CRect *posRect, CMainWindow *myParent, 						CEyeDxBooleanType *DirectorySetPtr, char *DefaultImagesDir)						: CMFCRunWin(posRect, myParent, DirectorySetPtr, DefaultImagesDir){	initialized = FALSE;		// This creates the Run From base window		CString strWndClass = AfxRegisterWndClass(		CS_DBLCLKS,		gMainApp.LoadStandardCursor(IDC_ARROW),		(HBRUSH) (COLOR_3DFACE + 1),		gMainApp.LoadIcon("ID_EYEDX_ICON_SM"));			CreateEx(0, strWndClass, lpszWindowName, 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,		posRect->left, posRect->top, posRect->Width(), posRect->Height(), 		NULL, NULL);}BEGIN_MESSAGE_MAP( CMFCRunFromDiskWin, CMFCRunWin )ON_BN_CLICKED(IDC_DISK_OK, 	OnOkButtonClicked)ON_BN_CLICKED(IDCANCEL, 	OnCancelButtonClicked)ON_BN_CLICKED(IDC_DISK_SELECT_UP_BUTTON, 	OnSelectUpButtonClicked)ON_BN_CLICKED(IDC_DISK_SELECT_SIDE_BUTTON, 	OnSelectSideButtonClicked)ON_BN_CLICKED(IDC_DISK_ANIMATE_CHECKBOX, OnAnimateCheckboxClicked)ON_BN_CLICKED(IDC_DISK_UP_ZOOM_BUTTON, 	OnUpZoomButtonClicked)ON_BN_CLICKED(IDC_DISK_SIDE_ZOOM_BUTTON, 	OnSideZoomButtonClicked)ON_WM_SETFOCUS()ON_WM_CREATE()END_MESSAGE_MAP()CEyeDxBooleanType CMFCRunFromDiskWin::PreTranslateMessage(MSG *pMsg){	if (IsDialogMessage(pMsg) == TRUE)		return TRUE;	else if (CWnd::PreTranslateMessage(pMsg) == TRUE)		return TRUE;	else 		return FALSE;}void CMFCRunFromDiskWin::OnSetFocus(CWnd *pOldWnd){	CWnd::OnSetFocus(pOldWnd);	//m_ctlUpSelectButton.SetButtonStyle(m_ctlUpSelectButton.GetButtonStyle() | BS_DEFPUSHBUTTON);	if (initialized)		m_ctlUpSelectButton.SetFocus();}int CMFCRunFromDiskWin::OnCreate(LPCREATESTRUCT lpcs){	if (CMFCRunWin::OnCreate(lpcs) == -1)		return -1;			RunInProgress = 2;	CRect rect;		GetClientRect(&rect);		int WindowWidth = (rect.right-rect.left) / m_cxChar;		int CenterLine = WindowWidth / 2;		int LeftCenterLine = (DISK_VIEW_WIDTH / 2) + DISK_RIGHT_MARGIN - (DISK_CENTER_GAP / 3);		int RightCenterLine = WindowWidth - DISK_RIGHT_MARGIN - (DISK_VIEW_WIDTH / 2) + (DISK_CENTER_GAP / 3);			// Up Progress caption		rect.SetRect(m_cxChar * DISK_UP_PROGRESS_CAPTION_X(LeftCenterLine), 				 m_cyChar * DISK_UP_PROGRESS_CAPTION_Y, 				 m_cxChar * (DISK_UP_PROGRESS_CAPTION_X(LeftCenterLine) + DISK_UP_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (DISK_UP_PROGRESS_CAPTION_Y + DISK_UP_PROGRESS_CAPTION_HEIGHT));		m_ctlUpProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_UP_PROGRESS_CAPTION);	m_ctlUpProgressCaption.SetFont(&m_ctlFont);		// Side Progress caption		rect.SetRect(m_cxChar * DISK_SIDE_PROGRESS_CAPTION_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_PROGRESS_CAPTION_Y, 				 m_cxChar * (DISK_SIDE_PROGRESS_CAPTION_X(RightCenterLine) + DISK_SIDE_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (DISK_SIDE_PROGRESS_CAPTION_Y + DISK_SIDE_PROGRESS_CAPTION_HEIGHT));		m_ctlSideProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_SIDE_PROGRESS_CAPTION);	m_ctlSideProgressCaption.SetFont(&m_ctlFont);	// Up Progress bar		rect.SetRect(m_cxChar * DISK_UP_PROGRESS_BAR_X(LeftCenterLine), 				 m_cyChar * DISK_UP_PROGRESS_BAR_Y, 				 m_cxChar * (DISK_UP_PROGRESS_BAR_X(LeftCenterLine) + DISK_UP_PROGRESS_BAR_WIDTH), 				 m_cyChar * (DISK_UP_PROGRESS_BAR_Y + DISK_UP_PROGRESS_BAR_HEIGHT));	m_ctlUpProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_DISK_UP_PROGRESS_BAR);	// Side Progress bar		rect.SetRect(m_cxChar * DISK_SIDE_PROGRESS_BAR_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_PROGRESS_BAR_Y, 				 m_cxChar * (DISK_SIDE_PROGRESS_BAR_X(RightCenterLine) + DISK_SIDE_PROGRESS_BAR_WIDTH), 				 m_cyChar * (DISK_SIDE_PROGRESS_BAR_Y + DISK_SIDE_PROGRESS_BAR_HEIGHT));	m_ctlSideProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_DISK_SIDE_PROGRESS_BAR);	// Up Image View		rect.SetRect(m_cxChar * DISK_UP_VIEW_X(LeftCenterLine), 				 m_cyChar * DISK_UP_VIEW_Y, 				 m_cxChar * (DISK_UP_VIEW_X(LeftCenterLine) + DISK_UP_VIEW_WIDTH), 				 m_cyChar * (DISK_UP_VIEW_Y + DISK_UP_VIEW_HEIGHT));		m_ctlUpView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_DISK_UP_VIEW);		// Side Image View		rect.SetRect(m_cxChar * DISK_SIDE_VIEW_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_VIEW_Y, 				 m_cxChar * (DISK_SIDE_VIEW_X(RightCenterLine) + DISK_SIDE_VIEW_WIDTH), 				 m_cyChar * (DISK_SIDE_VIEW_Y + DISK_SIDE_VIEW_HEIGHT));		m_ctlSideView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_DISK_SIDE_VIEW);	// Up Image Quality Bitmap		rect.SetRect(m_cxChar * DISK_UP_QUALITY_ICON_X(LeftCenterLine), 				 m_cyChar * DISK_UP_QUALITY_ICON_Y, 				 m_cxChar * (DISK_UP_QUALITY_ICON_X(LeftCenterLine) + DISK_UP_QUALITY_ICON_WIDTH), 				 m_cyChar * (DISK_UP_QUALITY_ICON_Y + DISK_UP_QUALITY_ICON_HEIGHT));		m_ctlUpQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_DISK_UP_QUALITY_ICON);			m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);	// Side Image Quality Bitmap	rect.SetRect(m_cxChar * DISK_SIDE_QUALITY_ICON_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_QUALITY_ICON_Y, 				 m_cxChar * (DISK_SIDE_QUALITY_ICON_X(RightCenterLine) + DISK_SIDE_QUALITY_ICON_WIDTH), 				 m_cyChar * (DISK_SIDE_QUALITY_ICON_Y + DISK_SIDE_QUALITY_ICON_HEIGHT));		m_ctlSideQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_DISK_SIDE_QUALITY_ICON);	m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);	// Side Image Top of Head Bitmap	rect.SetRect(m_cxChar * DISK_SIDE_TOP_OF_HEAD_BITMAP_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_TOP_OF_HEAD_BITMAP_Y, 				 m_cxChar * (DISK_SIDE_TOP_OF_HEAD_BITMAP_X(RightCenterLine) + DISK_SIDE_TOP_OF_HEAD_BITMAP_WIDTH), 				 m_cyChar * (DISK_SIDE_TOP_OF_HEAD_BITMAP_Y + DISK_SIDE_TOP_OF_HEAD_BITMAP_HEIGHT));		m_ctlSideTopOfHeadBitmap.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP, rect, this, IDC_DISK_SIDE_TOP_OF_HEAD_BITMAP);	m_ctlSideTopOfHeadBitmap.SetBitmap(m_hTopOfHeadSidewaysBitmap);	// Up Image caption		rect.SetRect(m_cxChar * DISK_UP_CAPTION_X(LeftCenterLine), 				 m_cyChar * DISK_UP_CAPTION_Y, 				 m_cxChar * (DISK_UP_CAPTION_X(LeftCenterLine) + DISK_UP_CAPTION_WIDTH), 				 m_cyChar * (DISK_UP_CAPTION_Y + DISK_UP_CAPTION_HEIGHT));		m_ctlUpCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_UP_CAPTION);	m_ctlUpCaption.SetFont(&m_ctlFont);		// Side Image caption		rect.SetRect(m_cxChar * DISK_SIDE_CAPTION_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_CAPTION_Y, 				 m_cxChar * (DISK_SIDE_CAPTION_X(RightCenterLine) + DISK_SIDE_CAPTION_WIDTH), 				 m_cyChar * (DISK_SIDE_CAPTION_Y + DISK_SIDE_CAPTION_HEIGHT));		m_ctlSideCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT , rect, this, IDC_DISK_SIDE_CAPTION);	m_ctlSideCaption.SetFont(&m_ctlFont);		// The Zoom Buttons - note that the calculations have to use the actual Bitmap width and height, and thus	// cannot be scaled by the character cell sizes.		rect.SetRect((m_cxChar * (DISK_UP_VIEW_X(LeftCenterLine) + DISK_UP_VIEW_WIDTH)) - DISK_UP_ZOOM_BUTTON_WIDTH, 				 m_cyChar * DISK_UP_ZOOM_BUTTON_Y, 				 (m_cxChar * (DISK_UP_VIEW_X(LeftCenterLine) + DISK_UP_VIEW_WIDTH)), 				 (m_cyChar * DISK_UP_ZOOM_BUTTON_Y) + DISK_UP_ZOOM_BUTTON_HEIGHT);		m_ctlUpZoomButton.Create(DISK_UP_ZOOM_BUTTON_LABEL, 				WS_CHILD  | WS_TABSTOP | BS_OWNERDRAW, rect, this, IDC_DISK_UP_ZOOM_BUTTON);	m_ctlUpZoomButton.LoadBitmaps("ZoomButtonU", "ZoomButtonD", "ZoomButtonF", NULL);		rect.SetRect((m_cxChar * (DISK_SIDE_VIEW_X(RightCenterLine) + DISK_SIDE_VIEW_WIDTH)) - DISK_SIDE_ZOOM_BUTTON_WIDTH, 				 m_cyChar * DISK_SIDE_ZOOM_BUTTON_Y, 				 (m_cxChar * (DISK_SIDE_VIEW_X(RightCenterLine) + DISK_SIDE_VIEW_WIDTH)), 				 (m_cyChar * DISK_SIDE_ZOOM_BUTTON_Y) + DISK_SIDE_ZOOM_BUTTON_HEIGHT);		m_ctlSideZoomButton.Create(DISK_SIDE_ZOOM_BUTTON_LABEL, 				WS_CHILD  | WS_TABSTOP | BS_OWNERDRAW, rect, this, IDC_DISK_SIDE_ZOOM_BUTTON);	m_ctlSideZoomButton.LoadBitmaps("ZoomButtonU", "ZoomButtonD", "ZoomButtonF", NULL);		// Select Up Image button			rect.SetRect(m_cxChar * DISK_SELECT_UP_BUTTON_X(LeftCenterLine), 				 m_cyChar * DISK_SELECT_UP_BUTTON_Y, 				 m_cxChar * (DISK_SELECT_UP_BUTTON_X(LeftCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_SELECT_UP_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlUpSelectButton.Create(DISK_SELECT_UP_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_DEFPUSHBUTTON, rect, this, IDC_DISK_SELECT_UP_BUTTON);	// Select Side Image button		rect.SetRect(m_cxChar * DISK_SELECT_SIDE_BUTTON_X(RightCenterLine), 				 m_cyChar * DISK_SELECT_SIDE_BUTTON_Y, 				 m_cxChar * (DISK_SELECT_SIDE_BUTTON_X(RightCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_SELECT_SIDE_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlSideSelectButton.Create(DISK_SELECT_SIDE_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_DISK_SELECT_SIDE_BUTTON);	// Show Animation during processing checkbox		rect.SetRect(m_cxChar * DISK_ANIMATE_CHECKBOX_X(CenterLine), 				 m_cyChar * DISK_ANIMATE_CHECKBOX_Y, 				 m_cxChar * (DISK_ANIMATE_CHECKBOX_X(CenterLine) + DISK_ANIMATE_CHECKBOX_WIDTH), 				 m_cyChar * (DISK_ANIMATE_CHECKBOX_Y + DISK_ANIMATE_CHECKBOX_HEIGHT));		m_ctlAnimateCheckbox.Create(DISK_ANIMATE_CHECKBOX_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_AUTOCHECKBOX, rect, this, IDC_DISK_ANIMATE_CHECKBOX);	// Report Name caption - This is aligned with the Animate Checkbox above		rect.SetRect(m_cxChar * DISK_NAME_CAPTION_X(CenterLine), 				 m_cyChar * DISK_NAME_CAPTION_Y, 				 m_cxChar * (DISK_NAME_CAPTION_X(CenterLine) + DISK_NAME_CAPTION_WIDTH), 				 m_cyChar * (DISK_NAME_CAPTION_Y + DISK_NAME_CAPTION_HEIGHT));		m_ctlNameCaption.Create(DISK_NAME_CAPTION_LABEL, 								WS_CHILD | WS_VISIBLE | SS_RIGHT, rect, this, IDC_DISK_NAME_EDIT_FIELD_CAPTION);		// Report Name edit field		rect.SetRect(m_cxChar * DISK_NAME_EDIT_FIELD_X(CenterLine), 				 m_cyChar * DISK_NAME_EDIT_FIELD_Y, 				 m_cxChar * (DISK_NAME_EDIT_FIELD_X(CenterLine) + DISK_NAME_EDIT_FIELD_WIDTH), 				 m_cyChar * (DISK_NAME_EDIT_FIELD_Y + DISK_NAME_EDIT_FIELD_HEIGHT));		m_ctlNameEditField.Create(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP | ES_LEFT | ES_AUTOHSCROLL,								rect, this, IDC_DISK_NAME_EDIT_FIELD);	rect.SetRect(m_cxChar * DISK_CANCEL_BUTTON_X(LeftCenterLine), 				 m_cyChar * DISK_CANCEL_BUTTON_Y, 				 m_cxChar * (DISK_CANCEL_BUTTON_X(LeftCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_CANCEL_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlOkButton.Create(DISK_CANCEL_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDCANCEL);	rect.SetRect(m_cxChar * DISK_OK_BUTTON_X(RightCenterLine), 				 m_cyChar * DISK_OK_BUTTON_Y, 				 m_cxChar * (DISK_OK_BUTTON_X(RightCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_OK_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlCancelButton.Create(DISK_OK_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_DISK_OK);	rect.SetRect(m_cxChar * DISK_LICENSE_CAPTION_X(CenterLine), 				 m_cyChar * DISK_LICENSE_CAPTION_Y, 				 m_cxChar * (DISK_LICENSE_CAPTION_X(CenterLine) + DISK_LICENSE_CAPTION_WIDTH), 				 m_cyChar * (DISK_LICENSE_CAPTION_Y + DISK_LICENSE_CAPTION_HEIGHT));		m_ctlLicenseCaption.Create(DISK_LICENSE_CAPTION_LABEL, 				WS_CHILD | WS_VISIBLE | SS_CENTER, rect, this, IDC_DISK_LICENSE_CAPTION);	m_ctlLicenseCaption.SetFont(&m_ctlFont);	rect.SetRect(m_cxChar * DISK_SESSION_CAPTION_X(CenterLine), 				 m_cyChar * DISK_SESSION_CAPTION_Y, 				 m_cxChar * (DISK_SESSION_CAPTION_X(CenterLine) + DISK_SESSION_CAPTION_WIDTH), 				 m_cyChar * (DISK_SESSION_CAPTION_Y + DISK_SESSION_CAPTION_HEIGHT));		m_ctlSessionCaption.Create(DISK_SESSION_CAPTION_LABEL, 				WS_CHILD | WS_VISIBLE | SS_CENTER, rect, this, IDC_DISK_SESSION_CAPTION);	m_ctlSessionCaption.SetFont(&m_ctlFont);	// Set the value of the edit field to the default		m_ctlNameEditField.SetWindowText("");	m_ctlNameEditField.SetLimitText(MAX_FILENAME_CHARS);		// Set the checkbox value to the stored default		m_ctlAnimateCheckbox.SetCheck((DisplayGraphics ? BST_CHECKED : BST_UNCHECKED));		m_ctlUpSelectButton.SetFocus();	// Finally, set the license caption		m_Parent->SetLicenseStatusCaption(&m_ctlLicenseCaption);		// And indicate the current session		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), theVariable, (CButton *)NULL, &m_ctlSessionCaption);				initialized = TRUE;		return 0;}char szFilters[] = "KDC files (*.kdc)|*.kdc|JPEG files (*.jpg)|*.jpg|Other files (*.*)|*.*||";void CMFCRunFromDiskWin::OnSelectUpButtonClicked(){	CPreviewFileDlg dlg(TRUE, "kdc", "*.kdc", OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, szFilters, this);		static char szTitle[] = "EyeDx: Select Up Image";	dlg.m_ofn.lpstrTitle = szTitle;		// If we have not set the default images directory, do it only the first time we present	// the open file dialog. We update the parent's flag indicating that we have done this,	// and this flag is passed to us on subsequent calls.		if (*m_DirectorySetPtr == FALSE)	{		*m_DirectorySetPtr = TRUE;		dlg.m_ofn.lpstrInitialDir = m_DefaultImagesDir;	}		if (dlg.DoModal() == IDOK)	{		// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 		// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.		// Actually, it's a bit more complicated. If we haven't selected either image, 3 or 4 is correct. If either image		// is selected (just one), it's 2 or 3, and if they've already selected both images and are just reselecting this		// one, it's 1 or 2.		// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.				short num3ByteDeepImages;				if (m_UpSelected && m_SideSelected)			num3ByteDeepImages = 1;		// For one pre-scaled annotated image that is written out for the report		else		if (m_UpSelected || m_SideSelected)			num3ByteDeepImages = 2;		// For the remaining input image and one pre-scaled annotated image that is written out for the report		else			num3ByteDeepImages = 3;		// For the two input images and one pre-scaled annotated image that is written out for the report		short num1ByteDeepImages = 1;	// For the threshold image				CEyeDxLongStringType hintString = (DisplayGraphics ? "Or, press Cancel, turn off animation, and run again." : EMPTYSTR);				CEyeDxMessageType theMemoryMessage = DoCheckForMemory(this, 							DisplayGraphics,							IMAGE_HEIGHT,							IMAGE_WIDTH,							num3ByteDeepImages,							num1ByteDeepImages,							&hintString);			if (theMemoryMessage == kEyeDxDialogOKMessage)		{			CWaitCursor wait;						m_UpSelected = true;			// If a file is already displayed, delete the old one			if (up_image != NULL)			{			    free(up_image);			    up_image = NULL;			    UP_ROWS = UP_COLS = 0;			}			// Determine whether to copy files. First, default to the option the user			// has selected. Next, if the option is turned on, see if the source directory			// is the Pimages directory. If so, then there's no sense copying the file.						CEyeDxBooleanType copyFiles = SaveFullImages;						if (copyFiles)			{				CString filePath = dlg.GetPathName();								// Check the file path to see if it contains the path for the Pimages directory.				// If so, we do not want to copy!				if (filePath.Find(m_DefaultImagesDir) >= 0)			    	copyFiles = false;			}   						strcpy(up_filename, dlg.GetFileName());						FILE *fileptr = fopen(dlg.GetPathName(), "rb");						if (!fileptr)				MessageBox("Cannot open file.", AfxGetAppName(), MB_OK);			else							{				// Assume that the pictinfo member isn't set - which will happen				// if the image is JPEG				m_UpPictInfoValid = FALSE;									m_ctlUpProgressBar.ShowWindow(SW_SHOW);				m_ctlUpProgressCaption.ShowWindow(SW_SHOW);				m_ctlUpCaption.ShowWindow(SW_SHOW);								CEyeDxVariable *theUpImageVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGE));				CEyeDxVariable *theSessionNameVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));						if (ReadImageFromFile(fileptr, &up_image ,&UP_ROWS,&UP_COLS, up_filename, theSessionNameVariable, theUpImageVariable,										copyFiles,										NULL,										NULL,										&m_UpGenericPictInfo, &m_UpPictInfo, &m_UpPictInfoValid,										this, &m_ctlUpProgressBar, &m_ctlUpProgressCaption, &m_ctlUpCaption) == 0)				{					m_ctlUpProgressBar.ShowWindow(SW_HIDE);					m_ctlUpProgressCaption.ShowWindow(SW_HIDE);					m_ctlUpCaption.ShowWindow(SW_HIDE);					strcpy(up_filename,"");				}				else				{					m_ctlUpProgressBar.ShowWindow(SW_HIDE);					m_ctlUpProgressCaption.ShowWindow(SW_HIDE);					m_ctlUpQualityBitmap.ShowWindow(SW_SHOW);					m_ctlUpZoomButton.ShowWindow(SW_SHOW);										// If the quality isn't what we should be using, warn the user					if (m_UpPictInfoValid && m_UpPictInfo.PictQuality != DC120BestQuality)					{					 	MessageBox("This image was not taken with the recommended 'Best' image quality setting\n"					 				"and analysis of this image may produce incorrect results.\n"					 				"EyeDx recommends you retake this picture.", AfxGetAppName(), MB_OK);						m_ctlUpQualityBitmap.SetBitmap(m_hCautionBitmap);					}					else						m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);					m_ctlUpView.SetImageFromRaw24Bit(up_image, UP_ROWS, UP_COLS);				}			}		}	}}void CMFCRunFromDiskWin::OnSelectSideButtonClicked(){	CPreviewFileDlg dlg(TRUE, "kdc", "*.kdc", OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, szFilters, this);		static char szTitle[] = "EyeDx: Select Side Image";	dlg.m_ofn.lpstrTitle = szTitle;		// If we have not set the default images directory, do it only the first time we present	// the open file dialog. We update the parent's flag indicating that we have done this,	// and this flag is passed to us on subsequent calls.		if (*m_DirectorySetPtr == FALSE)	{		*m_DirectorySetPtr = TRUE;		dlg.m_ofn.lpstrInitialDir = m_DefaultImagesDir;	}		if (dlg.DoModal() == IDOK)	{		// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 		// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.		// Actually, it's a bit more complicated. If we haven't selected either image, 3 or 4 is correct. If either image		// is selected (just one), it's 2 or 3, and if they've already selected both images and are just reselecting this		// one, it's 1 or 2.		// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.				short num3ByteDeepImages;				if (m_UpSelected && m_SideSelected)			num3ByteDeepImages = 1;		// For one pre-scaled annotated image that is written out for the report		else		if (m_UpSelected || m_SideSelected)			num3ByteDeepImages = 2;		// For the remaining input image and one pre-scaled annotated image that is written out for the report		else			num3ByteDeepImages = 3;		// For the two input images and one pre-scaled annotated image that is written out for the report		short num1ByteDeepImages = 1;	// For the threshold image				CEyeDxLongStringType hintString = (DisplayGraphics ? "Or, press Cancel, turn off animation, and run again." : EMPTYSTR);				CEyeDxMessageType theMemoryMessage = DoCheckForMemory(this, 							DisplayGraphics,							IMAGE_HEIGHT,							IMAGE_WIDTH,							num3ByteDeepImages,							num1ByteDeepImages,							&hintString);			if (theMemoryMessage == kEyeDxDialogOKMessage)		{			CWaitCursor wait;						m_SideSelected = true;			// If a file is already displayed, delete the old one			if (side_image != NULL)			{			    free(side_image);			    side_image = NULL;			    SIDE_ROWS = SIDE_COLS = 0;			}			// Determine whether to copy files. First, default to the option the user			// has selected. Next, if the option is turned on, see if the source directory			// is the Pimages directory. If so, then there's no sense copying the file.						CEyeDxBooleanType copyFiles = SaveFullImages;						if (copyFiles)			{				CString filePath = dlg.GetPathName();								// Check the file path to see if it contains the path for the Pimages directory.				// If so, we do not want to copy!				if (filePath.Find(m_DefaultImagesDir) >= 0)			    	copyFiles = false;			}   						strcpy(side_filename, dlg.GetFileName());						FILE *fileptr = fopen(dlg.GetPathName(), "rb");						if (!fileptr)				MessageBox("Cannot open file.", AfxGetAppName(), MB_OK);			else							{				// Assume that the pictinfo member isn't set - which will happen				// if the image is JPEG				m_SidePictInfoValid = FALSE;				m_ctlSideProgressBar.ShowWindow(SW_SHOW);				m_ctlSideProgressCaption.ShowWindow(SW_SHOW);				m_ctlSideCaption.ShowWindow(SW_SHOW);				CEyeDxVariable *theSideImageVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGE));				CEyeDxVariable *theSessionNameVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));						if (ReadImageFromFile(fileptr, &side_image,&SIDE_ROWS,&SIDE_COLS, side_filename, theSessionNameVariable, theSideImageVariable,										copyFiles,										NULL,										NULL,										&m_SideGenericPictInfo, &m_SidePictInfo, &m_SidePictInfoValid,										this, &m_ctlSideProgressBar, &m_ctlSideProgressCaption, &m_ctlSideCaption) == 0)				{					m_ctlSideProgressBar.ShowWindow(SW_HIDE);					m_ctlSideProgressCaption.ShowWindow(SW_HIDE);					m_ctlSideCaption.ShowWindow(SW_HIDE);					strcpy(side_filename,"");				}				else				{					m_ctlSideProgressBar.ShowWindow(SW_HIDE);					m_ctlSideProgressCaption.ShowWindow(SW_HIDE);					m_ctlSideQualityBitmap.ShowWindow(SW_SHOW);					m_ctlSideZoomButton.ShowWindow(SW_SHOW);										// If the quality isn't what we should be using, warn the user					if (m_SidePictInfoValid && m_SidePictInfo.PictQuality != DC120BestQuality)					{					 	MessageBox("This image was not taken with the recommended 'Best' image quality setting\n"					 				"and analysis of this image may produce incorrect results.\n"					 				"EyeDx recommends you retake this picture.", AfxGetAppName(), MB_OK);						m_ctlSideQualityBitmap.SetBitmap(m_hCautionBitmap);					}					else						m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);					m_ctlSideView.SetImageFromRaw24Bit(side_image, SIDE_ROWS, SIDE_COLS);				}			}		}	}}// This function is called when the Ok button is pressed. We send a message// to ourselves which will eventually destroy the Run From Disk window.// We also set the member that indicates the kind of message to send to // the parent. In the case of OK, we want the parent to go ahead and initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.int CMFCRunFromDiskWin::OnOkButtonClicked(){	// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 	// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.	// Since we've already allocated the memory for the images, we don't include them in the counts here.	// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.		short num3ByteDeepImages = 1;	// For one pre-scaled annotated image that is written out for the report	short num1ByteDeepImages = 1;	// For the threshold image		CEyeDxLongStringType hintString = (DisplayGraphics ? "Or, press Cancel, turn off animation, and run again." : EMPTYSTR);			CEyeDxMessageType theMemoryMessage = DoCheckForMemory(this, 						DisplayGraphics,						IMAGE_HEIGHT,						IMAGE_WIDTH,						num3ByteDeepImages,						num1ByteDeepImages,						&hintString);	if (theMemoryMessage == kEyeDxDialogOKMessage)	{					// Call the base class to test whether to actually continue				if (CMFCRunWin::OnOkButtonClicked())		{			if (HandlePromptForVariables(this,  m_VariableList, m_PromptStyle, CEyeDxVariable::kPromptForSubject) == kEyeDxDialogCancelMessage)			{				OnCancelButtonClicked();			}			else			{				// Save the picture information in the appropriate variables				SavePictureInformation(m_VariableList, m_UpPictInfoValid, m_UpGenericPictInfo, m_UpPictInfo, m_SidePictInfoValid, m_SideGenericPictInfo, m_SidePictInfo);							// Tell ourselves to close, which will send a message to our parent to begin				// analysis				PostMessage(WM_CLOSE, 0, 0);			}		}	}	return 0;}// This function is called when the Cancel button is pressed. We send a message// to ourselves which will eventually destroy the Run From Disk window.// We also set the member that indicates the kind of message to send to // the parent. In the case of Cancel, we want the parent not initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.void CMFCRunFromDiskWin::OnCancelButtonClicked(){	CMFCRunWin::OnCancelButtonClicked();}void CMFCRunFromDiskWin::OnUpZoomButtonClicked(){	CEyeDxLongStringType theFileName = up_filename;				m_Parent->HandleSummaryZoom(this, &theFileName, up_image, UP_ROWS, UP_COLS, NULL, NULL, 0, 0);}		void CMFCRunFromDiskWin::OnSideZoomButtonClicked(){	CEyeDxLongStringType theFileName = side_filename;				m_Parent->HandleSummaryZoom(this, &theFileName, side_image, SIDE_ROWS, SIDE_COLS, NULL, NULL, 0, 0);}