// =================================================================================//	CMyGWorldView.cp  					©1995-1998 Metrowerks Inc. All rights reserved.// =================================================================================#include <UDrawingState.h>#include <UGWorld.h>#include "CMyGWorldView.h"#include <TextUtils.h>#include <stdio.h>#include "memlogger.h"void CMyGWorldView::Init(){	Rect frame;	CalcLocalFrameRect(frame);	mGWorld = new LGWorld(frame, 32, useTempMem);	CMyGWorldView::ResetImage();}void CMyGWorldView::ResetImage(){	Rect frame;	Rect saveFrame;	LStr255 theString = "[None]";		CalcLocalFrameRect(frame);		// Make sure that we match our view's bounds		FocusDraw(nil);		mGWorld->Update(frame, 32);	saveFrame = frame;	// Save and normalize the text state.	StTextState	theTextState;	StTextState::Normalize();		// Set the font and size.	TextFont( kFontIDTimes );	TextSize( 12 );	// Get the font info.	FontInfo	theFontInfo;	::GetFontInfo( &theFontInfo );		// Create a light gray RGB color to fill the window with	RGBColor	myFillColor;	myFillColor.red = myFillColor.green = myFillColor.blue = 0xC000;		RGBColor	myBlackColor;	myBlackColor.red = myBlackColor.green = myBlackColor.blue = 0x0000;		// Draw in GWorld - the default image is a gray fill with the	// word "None" in the middle		mGWorld->BeginDrawing();	::PenNormal();	::FrameRect(&frame);	::InsetRect(&frame, 1, 1);	::RGBForeColor(&myFillColor);	::PenPat(&UQDGlobals::GetQDGlobals()->black);	::PaintRect(&frame);			::RGBForeColor(&myBlackColor);	short textWidth = ::StringWidth(theString);	short textX = ((saveFrame.right - saveFrame.left) / 2) - (textWidth / 2);	short textY = ((saveFrame.bottom - saveFrame.top) / 2) + ((theFontInfo.ascent + theFontInfo.descent) / 2);	::MoveTo(textX, textY);	::DrawString(theString);		mGWorld->EndDrawing();}// ---------------------------------------------------------------------------------//		¥ CMyGWorldView// ---------------------------------------------------------------------------------CMyGWorldView::CMyGWorldView(){	Init();}// ---------------------------------------------------------------------------------//		¥ CMyGWorldView(SPaneInfo&, SViewInfo&)// ---------------------------------------------------------------------------------CMyGWorldView::CMyGWorldView(	const SPaneInfo	&inPaneInfo,	const SViewInfo &inViewInfo )		: LView( inPaneInfo, inViewInfo ){	Init();}// ---------------------------------------------------------------------------------//		¥ CMyGWorldView(const CMyGWorldView&)// ---------------------------------------------------------------------------------CMyGWorldView::CMyGWorldView(	const CMyGWorldView	&inOriginal )		: LView( inOriginal ){	Init();}// ---------------------------------------------------------------------------------//		¥ CMyGWorldView(LStream*)// ---------------------------------------------------------------------------------CMyGWorldView::CMyGWorldView(	LStream	*inStream )		: LView( inStream ){	Init();}// ---------------------------------------------------------------------------------//		¥ ~CMyGWorldView// ---------------------------------------------------------------------------------CMyGWorldView::~CMyGWorldView(){	delete mGWorld;}void CMyGWorldView::DrawPicture(PicHandle thePicture){	Rect	frame;	CalcLocalFrameRect(frame);		GWorldPtr theGWorld = mGWorld->GetMacGWorld();		// Create a black RGB color to fill the window with	RGBColor	myBlackColor;	myBlackColor.red = myBlackColor.green = myBlackColor.blue = 0x0000;		mGWorld->BeginDrawing();	// Draw in GWorld		::PenNormal();	::FrameRect(&frame);	::RGBForeColor(&myBlackColor);	::PenPat(&UQDGlobals::GetQDGlobals()->black);	::PaintRect(&frame);			// Now that we've initialized the image, draw the picture. This is necessary	// in the case where the PICT being drawn isn't rectangular.		::DrawPicture(thePicture, &frame);		mGWorld->EndDrawing();	CMyGWorldView::Draw(nil);}void CMyGWorldView::SetImageFromRaw24Bit(unsigned char *raw, long rows, long columns){	Rect	frame;	CalcLocalFrameRect(frame);		if (raw)	{		GWorldPtr theGWorld = mGWorld->GetMacGWorld();		mGWorld->BeginDrawing();	// Draw in GWorld		  		PixMapHandle thePix = GetGWorldPixMap(theGWorld);    	long rowBytes = (**thePix).rowBytes & 0x3FFF;    	Ptr imageBaseAddr = GetPixBaseAddr(thePix);         Ptr base = imageBaseAddr;         	    	long frame_height = frame.bottom - frame.top;    	long frame_width = frame.right - frame.left;    	    	long srcRowBytes = columns * 3;    			long srcY = 0;				double theXscale = (double) columns / (double) frame_width;		double theYscale = (double) rows / (double) frame_height;				// We use long-word transfer to speed things up				unsigned long *srcPtr;		unsigned long *dstPtr;    	for (long y = 0; y < frame_height; y++)    	{    		long srcX = 0;    	    dstPtr = (unsigned long *) ((Ptr)base + (rowBytes * y));    		for (long x = 0; x < frame_width; x++)    		{    			srcPtr = (unsigned long *) &raw[(srcY * srcRowBytes) + srcX];    			    			// We load _four_ bytes from the source (RGBr). We shift them down    			// so we have only the RGB values in the low 24 bits, and the shift    			// will zero-fill the top byte    				    		*dstPtr++ = (*srcPtr >> 8);               	               	srcX = (double) x * theXscale;               	srcX *= 3; // Account for 3 bytes per pixel in the raw source image    		}    		srcY = (double) y * theYscale;    	}		    			mGWorld->EndDrawing();	}	else		ResetImage();			CMyGWorldView::Draw(nil);}void CMyGWorldView::ZoomImageFromRaw24Bit(unsigned char *raw, long rows, long columns,										  long dCols, long dRows, long dx, long dy){	Rect	frame;	CalcLocalFrameRect(frame);		if (raw)	{		GWorldPtr theGWorld = mGWorld->GetMacGWorld();		mGWorld->BeginDrawing();	// Draw in GWorld		  		PixMapHandle thePix = GetGWorldPixMap(theGWorld);    	long rowBytes = (**thePix).rowBytes & 0x3FFF;    	Ptr imageBaseAddr = GetPixBaseAddr(thePix);         Ptr base = imageBaseAddr;         	    	long frame_height = frame.bottom - frame.top;    	long frame_width = frame.right - frame.left;    	    	long srcRowBytes = columns * 3;    			long srcY = 0;				double theXScale = (double) dCols / (double) frame_width;		double theYScale = (double) dRows / (double) frame_height;				// We use long-word transfer to speed things up				unsigned long *srcPtr;		unsigned long *dstPtr;    	for (long y = 0; y < frame_height; y++)    	{    		long r2 = (long)((double) y * theYScale) + dy;    		    	    dstPtr = (unsigned long *) ((Ptr)base + (rowBytes * y));    		for (long x = 0; x < frame_width; x++)    		{    			long c2 = (long)((double) x * theXScale) + dx;    			    			srcPtr = (unsigned long *) &raw[(r2 * columns + c2) * 3];    				    			// We load _four_ bytes from the source (RGBr). We shift them down    			// so we have only the RGB values in the low 24 bits, and the shift    			// will zero-fill the top byte    				    		*dstPtr++ = (*srcPtr >> 8);    		}    	}		    			mGWorld->EndDrawing();	}	else		ResetImage();			CMyGWorldView::Draw(nil);}void CMyGWorldView::SetImageFromRaw32Bit(unsigned char *raw, long rows, long columns){	Rect	frame;	CalcLocalFrameRect(frame);		if (raw)	{		GWorldPtr theGWorld = mGWorld->GetMacGWorld();		mGWorld->BeginDrawing();	// Draw in GWorld		  		PixMapHandle thePix = GetGWorldPixMap(theGWorld);    	long rowBytes = (**thePix).rowBytes & 0x3FFF;    	Ptr imageBaseAddr = GetPixBaseAddr(thePix);         Ptr base = imageBaseAddr;         	    	long frame_height = frame.bottom - frame.top;    	long frame_width = frame.right - frame.left;    	    	long srcRowBytes = columns * 4;    			long srcY = 0;				double theXscale = (double) columns / (double) frame_width;		double theYscale = (double) rows / (double) frame_height;				// We use long-word transfer to speed things up				unsigned long *srcPtr;		unsigned long *dstPtr;    	for (long y = 0; y < frame_height; y++)    	{    		long srcX = 0;    	    dstPtr = (unsigned long *) ((Ptr)base + (rowBytes * y));    		for (long x = 0; x < frame_width; x++)    		{    			srcPtr = (unsigned long *) &raw[(srcY * srcRowBytes) + srcX];    			// We load _four_ bytes from the source (ARGB).     				    		*dstPtr++ = *srcPtr;               	               	srcX = (double) x * theXscale;               	srcX *= 4; // Account for 4 bytes per pixel in the raw source image    		}    		srcY = (double) y * theYscale;    	}		    			mGWorld->EndDrawing();	}	else		ResetImage();			CMyGWorldView::Draw(nil);}// This routine takes position the position, radius, and RGB values for a// circle to draw. The values of rows and columns allow for scaling the// input x, y, and radius to the current viewvoid CMyGWorldView::DrawCircle(long rows, long columns,						   double x, double y, double radius, 						   short penwidth,						   short red, short green, short blue){	Rect	frame;	int result = CalcLocalFrameRect(frame);	long frame_height = frame.bottom - frame.top;		long frame_width = frame.right - frame.left;		// Round all of these calculations up by adding 0.5 before truncation occurs	short theScaledX = (short)((x / (double) columns) * (double) frame_width + 0.5);		short theScaledY = (short)((y / (double) rows) * (double) frame_height + 0.5);		short theScaledHalfWidth = (short)((radius / (double) columns) * (double) frame_width + 0.5);		short theScaledHalfHeight = (short)((radius / (double) rows) * (double) frame_height + 0.5);		Rect theOval;	::SetRect(&theOval, (short)(theScaledX - theScaledHalfWidth),						(short)(theScaledY - theScaledHalfHeight),						(short)(theScaledX + theScaledHalfWidth + 1),						(short)(theScaledY + theScaledHalfHeight + 1));							RGBColor	myFillColor;	myFillColor.red = (unsigned short)(red << 8);	myFillColor.green = (unsigned short)(green << 8);	myFillColor.blue = (unsigned short)(blue << 8);		// Draw in GWorld - 		mGWorld->BeginDrawing();	::PenNormal();	::PenSize(penwidth, penwidth);	::RGBForeColor(&myFillColor);	::PenPat(&UQDGlobals::GetQDGlobals()->black);	::FrameOval(&theOval);		mGWorld->EndDrawing();	CMyGWorldView::Draw(nil);}// Will copy the input PixMap into this object's PixMapvoid CMyGWorldView::CopyPixMapData(PixMapHandle thePixMapHandle){	GWorldPtr theGWorld = mGWorld->GetMacGWorld();	mGWorld->BeginDrawing();	// Draw in GWorld		PixMapHandle thePix = GetGWorldPixMap(theGWorld);	Rect srcRect = (**thePixMapHandle).bounds;	Rect dstRect = (**thePix).bounds;	::CopyBits((BitMap *)*thePixMapHandle, (BitMap *)*thePix, &srcRect, &dstRect, srcCopy, NULL);		mGWorld->EndDrawing();		CMyGWorldView::Draw(nil);}PixMapHandle CMyGWorldView::GetPixMapHandle(){		GWorldPtr theGWorld = mGWorld->GetMacGWorld();  		return (GetGWorldPixMap(theGWorld));}// ---------------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------------voidCMyGWorldView::DrawSelf(){	Rect	frame;	CalcLocalFrameRect(frame);	StColorState	saveColors;	StColorState::Normalize();	// CopyBits wants this	mGWorld->CopyImage(GetMacPort(), frame);	// Let the OS have some time	//EventRecord theEvent;	//::WaitNextEvent(0, &theEvent, 1L, nil);}