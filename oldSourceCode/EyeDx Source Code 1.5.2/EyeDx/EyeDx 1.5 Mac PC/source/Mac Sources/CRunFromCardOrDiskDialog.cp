// =================================================================================//	CRunFromCardOrDiskDialog.cp				©1995 Metrowerks Inc. All rights reserved.// =================================================================================//	CRunFromCardOrDiskDialog.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include <LStdControl.h>#include <PP_Messages.h>#include <UReanimator.h>#include "CRunFromCardOrDiskDialog.h"#include <UStandardDialogs.h>extern "C"{#include <FSp_fopen.h>}// ---------------------------------------------------------------------------------//		¥ CRunFromCardOrDiskDialog(LStream *)// ---------------------------------------------------------------------------------CRunFromCardOrDiskDialog::CRunFromCardOrDiskDialog(	LStream *inStream )		: LGADialog( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CRunFromCardOrDiskDialog// ---------------------------------------------------------------------------------CRunFromCardOrDiskDialog::~CRunFromCardOrDiskDialog(){}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCRunFromCardOrDiskDialog::FinishCreateSelf(){	// Call inherited. LDialogBox's FinishCreateSelf	// sets up the default and cancel buttons.	LGADialog::FinishCreateSelf();		// Link the dialog to the controls.	UReanimator::LinkListenerToControls( this, this, RidL_RunFromCardOrDiskDialog );	}voidCRunFromCardOrDiskDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	// Indicates whether the file open call was successful		CEyeDxBooleanType	openOK = false;	switch (inMessage) 	{				case msg_Cancel: 			// The user can cancel at any time. We just hide the Run From Disk Window and show		// the Control Window					CleanupImages(mDiskUpView, mUpHandle, mDiskSideView, mSideHandle);				break;			case msg_OK:			// We only allow the user to continue if they have selected both the Up and Side Images				if (mUpSelected && mSideSelected)		{			// First, we see if there's enough temporary memory to run. The peak usage is one 8 bit deep image and 			// one or two 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.			// We've already allocated the memory for the images, we don't include them in the counts here, since			// we are checking for enough _additional_ memory to run.			// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.						short num3ByteDeepImages = 1;	// For one pre-scaled annotated image that is written out for the report								short num1ByteDeepImages = 1;	// For the threshold image						CEyeDxLongStringType hintString = (DisplayGraphics ? CommonStringLiteral_("Or, press Cancel, turn off animation, and run again.") : Str_Empty);						MessageT theMessage = DoCheckForMemory(this, 								DisplayGraphics,								IMAGE_HEIGHT,								IMAGE_WIDTH,								num3ByteDeepImages,								num1ByteDeepImages,								&hintString);			if (theMessage == msg_OK)			{				CEyeDxShortStringType theReportNameString;								mDiskReportName->GetDescriptor(theReportNameString);								if (mParent->CheckReportValidity(&theReportNameString))				{					if (HandlePromptForVariables(this, mVariableList, mPromptingPrefs->promptingStyle, CEyeDxVariable::kPromptForSubject) == kEyeDxDialogCancelMessage)					{						// The user can cancel at any time.													CleanupImages(mDiskUpView, mUpHandle, mDiskSideView, mSideHandle);					}					else					{						StCursor wait;	// Set the pointer to the stop watch while we are setting up						// We keep track of the total number of retakes for this subject. However, for manual modes, this value is						// not used. So we set it to zero so it has a valid value for						// the report generation and database output functions called by the AnalyzeImages routine.												CEyeDxVariable *theTotalRetakesVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTTOTALRETAKES));						theTotalRetakesVariable->ResetValue();						mParent->AnalyzeImages(this, mDiskUpView, mDiskSideView, false);											// Now update the variables for the end of a subject												HandleEndOfSubject(mVariableList, NULL, mDefaultDatabaseReportName);					}				}			}		}		else			NoteAlert(this, CommonStringLiteral_("You must choose both images."));		break;							// This handles the pressing of the Select Side Image button		case msg_DiskSideSelectImage:		{			// We build a temporary object listing the file types we are interested in - namely, KDC, JPEG and TEXT						PP_PowerPlant::LFileTypeList	theImageFileTypes(PP_PowerPlant::fileTypes_All);			// We also build temporary file chooser objects using the Standard File dialogs						PP_PowerPlant::PP_StandardDialogs::LFileChooser	theImageChooser;						// Set up the filter proc for theImageChooser to look for just kKDCType, 			// and files ending with extension ".kdc".						theImageChooser.SetPreviewProc((NavPreviewProcPtr) MyNavImagePreviewFilter);			theImageChooser.SetObjectFilterProc((NavObjectFilterProcPtr) MyNavImageObjectFilter);				NavDialogOptions	*options = theImageChooser.GetDialogOptions();			if (options != nil) 				LString::CopyPStr(CommonStringLiteral_("EyeDx: Select Side Image"), options->windowTitle);			theImageChooser.SetDefaultLocation(*mLastImageDirSpec, FALSE);			openOK = theImageChooser.AskChooseOneFile(theImageFileTypes, mSideFileSpec);			if (openOK)			{				// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 				// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.								// Actually, it's a bit more complicated. If we haven't selected either image, 3 or 4 is correct. If either image				// is selected (just one), it's 2 or 3, and if they've already selected both images and are just reselecting this				// one, it's 1 or 2.				// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.								short num3ByteDeepImages;								if (mUpSelected && mSideSelected)					num3ByteDeepImages = 1;		// For one pre-scaled annotated image that is written out for the report				else				if (mUpSelected || mSideSelected)					num3ByteDeepImages = 2;		// For the remaining input image and one pre-scaled annotated image that is written out for the report				else					num3ByteDeepImages = 3;		// For the two input images and one pre-scaled annotated image that is written out for the report				short num1ByteDeepImages = 1;	// For the threshold image												CEyeDxLongStringType hintString = (DisplayGraphics ? CommonStringLiteral_("Or, press Cancel, turn off animation, and run again.") : Str_Empty);								MessageT theMemoryMessage = DoCheckForMemory(this, 									DisplayGraphics,									IMAGE_HEIGHT,									IMAGE_WIDTH,									num3ByteDeepImages,									num1ByteDeepImages,									&hintString);				if (theMemoryMessage == msg_OK)				{								StCursor wait;	// Set the pointer to the stop watch while we are setting up					mSideSelected = true;					// If a file is already displayed, delete the old one					CleanupSideImage(mDiskSideView, mSideHandle);					// Save the last location for future loads					*mLastImageDirSpec = mSideFileSpec;										// Determine whether to copy files. First, default to the option the user					// has selected. Next, if the option is turned on, see if the source directory					// is the Pimages directory. If so, then there's no sense copying the file.										CEyeDxBooleanType copyFiles = mCameraPrefs->saveFiles;										if (copyFiles)					{						if ((mSideFileSpec.vRefNum == mPImagesSpec->vRefNum) &&					    	(mSideFileSpec.parID == mPImagesSpec->parID))					    	copyFiles = false;					}   										// Convert from Pascal to C string					strncpy(side_filename, (char *)&mSideFileSpec.name[1], (unsigned long)mSideFileSpec.name[0]);					side_filename[mSideFileSpec.name[0]] = '\0';					FInfo theFileFInfo;					FSpGetFInfo(&mSideFileSpec, &theFileFInfo);										FILE *fileptr = FSp_fopen((ConstFSSpecPtr)&mSideFileSpec, "rb");										if (!fileptr)					{						StopAlert(this, CommonStringLiteral_("Cannot open file."));					}					else									{						// Assume that the pictinfo member isn't set - which will happen						// if the image is JPEG						mSidePictInfoValid = false;							mDiskSideThermometerPane->Show();						mDiskSideProgressCaption->Show();						CEyeDxVariable *theSideImageVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGE));						CEyeDxVariable *theSessionNameVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));						if (ReadImageFromFile(fileptr, &mSideHandle,&SIDE_ROWS,&SIDE_COLS, side_filename, theSessionNameVariable, theSideImageVariable,												copyFiles,												theFileFInfo.fdCreator,												theFileFInfo.fdType,												&mSidePictInfo, &mSidePictInfoValid, 												(void *)NULL, mDiskSideThermometerPane, mDiskSideProgressCaption, mDiskSideCaption)  == 0)						{							mDiskSideThermometerPane->Hide();							mDiskSideProgressCaption->Hide();							mDiskSideCaption->Hide();							strcpy(side_filename,"");						}						else						{							mDiskSideThermometerPane->Hide();							mDiskSideProgressCaption->Hide();							mDiskSidePictureQualityIcon->Show();														// If the quality isn't what we should be using, warn the user							if (mSidePictInfoValid && mSidePictInfo.PictQuality != DC120BestQuality)							{							 	CautionAlert(this, CommonStringLiteral_("This image was not taken with the recommended 'Best' image quality setting,"),							 				 		CommonStringLiteral_("and analysis of this image may produce incorrect results."),							 						 CommonStringLiteral_("EyeDx recommends you retake this picture."));								mDiskSidePictureQualityIcon->SetIconID(kCautionQualityIconList);							}							else								mDiskSidePictureQualityIcon->SetIconID(kGoodQualityIconList);															::HLock(mSideHandle);							mDiskSideView->SetImageFromRaw24Bit((unsigned char *)*mSideHandle, SIDE_ROWS,SIDE_COLS);							::HUnlock(mSideHandle);						}					}				}			}		}		break;				// This handles the pressing of the Select Up Image button				case msg_DiskUpSelectImage:		{			// We build a temporary object listing the file types we are interested in - namely, KDC, JPEG and TEXT						PP_PowerPlant::LFileTypeList	theImageFileTypes(PP_PowerPlant::fileTypes_All);			// We also build temporary file chooser objects using the Standard File dialogs						PP_PowerPlant::PP_StandardDialogs::LFileChooser	theImageChooser;						// Set up the filter proc for theImageChooser to look for just kKDCType, 			// and files ending with extension ".kdc".						theImageChooser.SetPreviewProc((NavPreviewProcPtr) MyNavImagePreviewFilter);			theImageChooser.SetObjectFilterProc((NavObjectFilterProcPtr) MyNavImageObjectFilter);			NavDialogOptions	*options = theImageChooser.GetDialogOptions();			if (options != nil) 				LString::CopyPStr("\pEyeDx: Select Up Image", options->windowTitle);			theImageChooser.SetDefaultLocation(*mLastImageDirSpec, FALSE);						openOK = theImageChooser.AskChooseOneFile(theImageFileTypes, mUpFileSpec);			if (openOK)			{				// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 				// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.				// Actually, it's a bit more complicated. If we haven't selected either image, 3 or 4 is correct. If either image				// is selected (just one), it's 2 or 3, and if they've already selected both images and are just reselecting this				// one, it's 1 or 2.				// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.								short num3ByteDeepImages;								if (mUpSelected && mSideSelected)					num3ByteDeepImages = 1;		// For one pre-scaled annotated image that is written out for the report				else				if (mUpSelected || mSideSelected)					num3ByteDeepImages = 2;		// For the remaining input image and one pre-scaled annotated image that is written out for the report				else					num3ByteDeepImages = 3;		// For the two input images and one pre-scaled annotated image that is written out for the report				short num1ByteDeepImages = 1;	// For the threshold image								CEyeDxLongStringType hintString = (DisplayGraphics ? CommonStringLiteral_("Or, press Cancel, turn off animation, and run again.") : Str_Empty);								MessageT theMemoryMessage = DoCheckForMemory(this, 									DisplayGraphics,									IMAGE_HEIGHT,									IMAGE_WIDTH,									num3ByteDeepImages,									num1ByteDeepImages,									&hintString);				if (theMemoryMessage == msg_OK)				{												StCursor wait;	// Set the pointer to the stop watch while we are setting up					mUpSelected = true;										// If a file is already displayed, delete the old one				    CleanupUpImage(mDiskUpView, mUpHandle);					// Save the last location for future loads					*mLastImageDirSpec = mUpFileSpec;										// Determine whether to copy files. First, default to the option the user					// has selected. Next, if the option is turned on, see if the source directory					// is the Pimages directory. If so, then there's no sense copying the file.										CEyeDxBooleanType copyFiles = mCameraPrefs->saveFiles;										if (copyFiles)					{						if ((mUpFileSpec.vRefNum == mPImagesSpec->vRefNum) &&					    	(mUpFileSpec.parID == mPImagesSpec->parID))					    	copyFiles = false;					}   										// Convert from Pascal to C string					strncpy(up_filename, (char *)&mUpFileSpec.name[1], (unsigned long)mUpFileSpec.name[0]);					up_filename[mUpFileSpec.name[0]] = '\0';									FInfo theFileFInfo;					FSpGetFInfo(&mUpFileSpec, &theFileFInfo);										FILE *fileptr = FSp_fopen((ConstFSSpecPtr)&mUpFileSpec, "rb");										if (!fileptr)					{						StopAlert(this, CommonStringLiteral_("Cannot open file."));					}					else									{						// Assume that the pictinfo member isn't set - which will happen						// if the image is JPEG						mUpPictInfoValid = false;							mDiskUpThermometerPane->Show();						mDiskUpProgressCaption->Show();							// We save the Up Image filename here before it gets truncated by the read routine													CEyeDxVariable *theUpImageVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGE));						CEyeDxVariable *theSessionNameVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));								if (ReadImageFromFile(fileptr, &mUpHandle, &UP_ROWS,&UP_COLS, up_filename, theSessionNameVariable, theUpImageVariable,												copyFiles,												theFileFInfo.fdCreator,												theFileFInfo.fdType,												&mUpPictInfo, &mUpPictInfoValid,												(void *)NULL, mDiskUpThermometerPane, mDiskUpProgressCaption, mDiskUpCaption) == 0)						{							mDiskUpThermometerPane->Hide();							mDiskUpProgressCaption->Hide();							mDiskUpCaption->Hide();							strcpy(up_filename,"");						}						else						{							mDiskUpThermometerPane->Hide();							mDiskUpProgressCaption->Hide();							mDiskUpPictureQualityIcon->Show();														// If the quality isn't what we should be using, warn the user							if (mUpPictInfoValid && mUpPictInfo.PictQuality != DC120BestQuality)							{							 	CautionAlert(this, CommonStringLiteral_("This image was not taken with the recommended 'Best' image quality setting,"),							 				 		CommonStringLiteral_("and analysis of this image may produce incorrect results."),							 						CommonStringLiteral_("EyeDx recommends you retake this picture."));								mDiskUpPictureQualityIcon->SetIconID(kCautionQualityIconList);							}							else								mDiskUpPictureQualityIcon->SetIconID(kGoodQualityIconList);							::HLock(mUpHandle);							mDiskUpView->SetImageFromRaw24Bit((unsigned char *)*mUpHandle, UP_ROWS, UP_COLS);							::HUnlock(mUpHandle);						}					}				}			}		}		break;		case msg_DiskAnimate:		{			DisplayGraphics = (CEyeDxBooleanType) *(long*)ioParam;						// Make sure the items reflect the current setting						StopListening();			mDiskAnimate->SetValue(DisplayGraphics);			StartListening();		}		break;			default:		break;	}	// Always pass the message on to our base class		LGADialog::ListenToMessage(inMessage, ioParam);}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------voidCRunFromCardOrDiskDialog::SetupDialog(CDocumentApp *theParent, 										CEyeDxVariableList *theVariableList,										CameraPrefs	*theCameraPrefs,										ReportPrefs	*theReportPrefs,										PromptingPrefs *thePromptingPrefs,										FSSpec *theLastImageDirSpec,										FSSpec *thePImagesSpec,										CEyeDxLongStringType *theDefaultDatabaseReportName){	// Save a pointer to our parent window		mParent = theParent;		mVariableList = theVariableList;		mCameraPrefs = theCameraPrefs;		mReportPrefs = theReportPrefs;		mPromptingPrefs = thePromptingPrefs;		mLastImageDirSpec = theLastImageDirSpec;		mPImagesSpec = thePImagesSpec;		mDefaultDatabaseReportName = theDefaultDatabaseReportName;	// Objects in the Run From Disk Window			// Create an EraseAttachment and connect it to all of the captions so that they are	// automatically erased before they are redrawn.		mEraseAttachment = new LEraseAttachment(true);			mDiskUpView = dynamic_cast<CEyeDxViewType *> (this->FindPaneByID( kDiskUpMyGWorldView ));	ThrowIfNil_( mDiskUpView );	mDiskSideView = dynamic_cast<CEyeDxViewType *> (this->FindPaneByID( kDiskSideMyGWorldView ));	ThrowIfNil_( mDiskSideView );	// We also get the progress bars for the Run From Disk window so we can pass them to the ReadImage routine		mDiskUpThermometerPane = dynamic_cast<CEyeDxProgressType*> (this->FindPaneByID(kDiskUpThermometerPane));	ThrowIfNil_( mDiskUpThermometerPane );	mDiskSideThermometerPane = dynamic_cast<CEyeDxProgressType*> (this->FindPaneByID(kDiskSideThermometerPane));	ThrowIfNil_( mDiskSideThermometerPane );	mDiskUpProgressCaption = dynamic_cast<CEyeDxCaptionType*> (this->FindPaneByID(kDiskUpProgressCaption));	ThrowIfNil_( mDiskUpProgressCaption );	mDiskUpProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskSideProgressCaption = dynamic_cast<CEyeDxCaptionType*> (this->FindPaneByID(kDiskSideProgressCaption));	ThrowIfNil_( mDiskSideProgressCaption );	mDiskSideProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskAnimate = dynamic_cast<CEyeDxCheckBoxType*> (this->FindPaneByID(kDiskAnimate));	ThrowIfNil_( mDiskAnimate );		mDiskReportName = dynamic_cast<CEyeDxEditFieldType*> (this->FindPaneByID(kDiskReportName));	ThrowIfNil_( mDiskReportName );		mDiskUpCaption = dynamic_cast<CEyeDxCaptionType*> (this->FindPaneByID(kDiskUpCaption));	ThrowIfNil_( mDiskUpCaption );	mDiskUpCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskSideCaption = dynamic_cast<CEyeDxCaptionType*> (this->FindPaneByID(kDiskSideCaption));	ThrowIfNil_( mDiskSideCaption );	mDiskSideCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskUpPictureQualityIcon = dynamic_cast<CEyeDxIconType*> (this->FindPaneByID(kDiskUpQualityIcon));	ThrowIfNil_( mDiskUpPictureQualityIcon );	mDiskSidePictureQualityIcon = dynamic_cast<CEyeDxIconType*> (this->FindPaneByID(kDiskSideQualityIcon));	ThrowIfNil_( mDiskSidePictureQualityIcon );		mDiskLicenseStatusCaption = dynamic_cast<CEyeDxCaptionType*> (this->FindPaneByID(kDiskLicenseStatusCaption));	ThrowIfNil_( mDiskLicenseStatusCaption );	mDiskLicenseStatusCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskSessionCaption = dynamic_cast<CEyeDxCaptionType*> (this->FindPaneByID(kDiskSessionCaption));	ThrowIfNil_( mDiskSessionCaption );	mDiskSessionCaption->AddAttachment(mEraseAttachment, nil, false);	// Update the license status caption		mParent->SetLicenseStatusCaption(mDiskLicenseStatusCaption);		// And indicate the current session		CEyeDxVariable *theVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	UpdateSessionButtonAndCaption(theVariable, nil, mDiskSessionCaption);				// Reset whether the user has selected the files.		mUpSelected = false;	mSideSelected = false;		mUpHandle = mSideHandle = NULL;	mDiskUpPictureQualityIcon->Hide();	mDiskSidePictureQualityIcon->Hide();		mDiskUpCaption->SetDescriptor(Str_Empty);	mDiskSideCaption->SetDescriptor(Str_Empty);	mDiskUpView->ResetImage();	mDiskSideView->ResetImage();	mDiskReportName->SetDescriptor("\p");	// Set the maximum number of characters in the Name field to the legal length		int theMaxReportNameLength = kMaxReportNameLength;		// If the adjustName option is turned on, we have to account for the prefix length	// when testing the maximum report name length.		if (mReportPrefs->adjustName)		theMaxReportNameLength -= kPrefixLength;	mDiskReportName->SetMaxChars(theMaxReportNameLength);				RunInProgress = 2;	mDiskAnimate->SetValue(DisplayGraphics);} 