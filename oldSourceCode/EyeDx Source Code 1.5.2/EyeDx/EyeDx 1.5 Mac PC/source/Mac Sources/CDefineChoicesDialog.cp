// =================================================================================//	CDefineChoicesDialog.cp				©1995 Metrowerks Inc. All rights reserved.// =================================================================================//	CDefineChoicesDialog.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include <LStdControl.h>#include <PP_Messages.h>#include <UReanimator.h>#include "CEyeDxVariables.h"#include "CDefineChoicesDialog.h"const long kChoiceStringWidth = 182;// ---------------------------------------------------------------------------------//		¥ CDefineChoicesDialog(LStream *)// ---------------------------------------------------------------------------------CDefineChoicesDialog::CDefineChoicesDialog(	LStream *inStream )		: LGADialog( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CDefineChoicesDialog// ---------------------------------------------------------------------------------CDefineChoicesDialog::~CDefineChoicesDialog(){	delete mWorkingOptionStringList;	delete mSizer;	delete mTableSelector;	delete mTableGeometry;	delete mTableStorage;	delete mChoiceTable;}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCDefineChoicesDialog::FinishCreateSelf(){	// Call inherited. LDialogBox's FinishCreateSelf	// sets up the default and cancel buttons.	LGADialog::FinishCreateSelf();		// Link the dialog to the controls.	UReanimator::LinkListenerToControls( this, this, RidL_DefineChoicesDialog );	}voidCDefineChoicesDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	CEyeDxShortStringType *theString;	CEyeDxShortStringType theValueString;				TArrayIterator<CEyeDxShortStringType *> iterator(*mOptionStringList);	TArrayIterator<CEyeDxShortStringType *> iterator2(*mWorkingOptionStringList);					long theItem;		switch (inMessage) 	{				case msg_Cancel: 			// We need to delete our copied strings - the destructor will take care of the list itself				while (iterator2.Next(theString))			delete theString;										break;			case msg_OK:			if (mAllowEditing)		{			// We can't get here unless the user has actually defined at least one choice. The OK			// button is disabled, otherwise.						// All we have to do here is set the variable's list						// First, delete the items in the existing list						while (iterator.Next(theString))				delete theString;						// Copy the array - this will delete the items in the mOptionStringList first.						*mOptionStringList = *mWorkingOptionStringList;						// And we're done! We don't delete the strings, since they are used by the variable's list.			// The destructor will delete the list itself.		}		break;			case msg_DefineChoicesListSglClick:	case msg_DefineChoicesListDblClick:	// We don't do anything special for double clicks			// Look up the item that they clicked on				theItem = mTableSelector->GetFirstSelectedRow();				if (mAllowEditing && (theItem > 0))		{					TableIndexT numRows;			TableIndexT numCols;						mChoiceTable->GetTableSize(numRows, numCols);						mMoveUpButton->Disable();			mMoveDownButton->Disable();						// If they haven't clicked on the first item, then enable the Move Up Button						if (theItem > 1)										mMoveUpButton->Enable();							// And if they haven't clicked on the last item, enable the Move Down Button						if (theItem < numRows)				mMoveDownButton->Enable();							// Now get the text of the item and put it in the edit field													mWorkingOptionStringList->FetchItemAt(theItem, theString);						// Set the text of the edit field						mItemStringEditField->SetDescriptor(*theString);		}		else		{			// Nothing is selected, or they can't edit it anyway, so disable buttons and the edit field					mMoveUpButton->Disable();			mMoveDownButton->Disable();			mModifyItemButton->Disable();			mRemoveItemButton->Disable();								mItemStringEditField->SetDescriptor(Str_Empty);			}				break;	case msg_DefineChoicesMoveUp:				// Get the item selected, and move it up in the list		theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mWorkingOptionStringList->SwapItems(theItem, theItem - 1);						// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of		// items in the list						UpdateChoicesList(theItem - 1);				break;	case msg_DefineChoicesMoveDown:				// Get the item selected, and move it down in the list. 				theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mWorkingOptionStringList->SwapItems(theItem, theItem + 1);				// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of		// items in the list				UpdateChoicesList(theItem + 1);		break;			case msg_DefineChoicesNewItem:	case msg_DefineChoicesModifyItem:		// We get the value they typed in and validate it. It must be non-empty, and must not be the		// same as another choice string.				mItemStringEditField->GetDescriptor(theValueString);				short theStrLength = theValueString.Length();				if (theStrLength == 0)		{			::ParamText("\pYou must enter a string that represents the choice's value!", Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::CautionAlert(PPob_GeneralALRT);		}		else		{					// Check to see if the entry is all spaces. That's also a no-no										short i = 1;			while (i <= theStrLength)			{				if (theValueString[i] != char_Space)					break;				i++;			}						// If we got to the end of the string and found all spaces, or if the			// string length is zero, then they didn't enter a value. That may or may not			// be a problem - we check that next.						if (i > theStrLength)			{				::ParamText("\pYou must enter a string that represents the choice's value!", Str_Empty, Str_Empty, Str_Empty);				UModalAlerts::CautionAlert(PPob_GeneralALRT);			}			else			{					CEyeDxBooleanType found = false;								// Check to see if this string is already defined				CEyeDxShortStringType *theExistingString;								while (iterator2.Next(theExistingString))				{					if (*theExistingString == theValueString)					{						found = true;						break;					}				}								if (found)				{					::ParamText("\pSorry, that choice value is already defined!", Str_Empty, Str_Empty, Str_Empty);					UModalAlerts::CautionAlert(PPob_GeneralALRT);				}				else				{									// If they are creating a new item, we just update the currently select one										if (inMessage == msg_DefineChoicesModifyItem)					{						theItem = mTableSelector->GetFirstSelectedRow();												if (theItem > 0)						{													// We need to update the existing string for this item. Retrieve a pointer to it							// and copy in the edit field's value														CEyeDxShortStringType *theOldChoiceStr;														mWorkingOptionStringList->FetchItemAt(theItem, theOldChoiceStr);														theOldChoiceStr->Assign(theValueString);														// Since the list is just pointing at the string, we're finished.						}					}					else					{						// We will insert after the current row. If the last item is selected, we will end up						// appending to the list												theItem = mTableSelector->GetFirstSelectedRow() + 1;												// Make a copy of the string and insert it into the list												CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(theValueString);									mWorkingOptionStringList->InsertItemsAt(1, theItem, theStringCopy);						}							UpdateChoicesList(theItem);				}			}		}				break;						case msg_DefineChoicesRemoveItem:				theItem = mTableSelector->GetFirstSelectedRow();				// Remove the corresponding item from the working list. That means fetching the string and deleting it		// first, and then deleting the item in the list				CEyeDxShortStringType *theOldChoiceStr;				mWorkingOptionStringList->FetchItemAt(theItem, theOldChoiceStr);				delete theOldChoiceStr;								mWorkingOptionStringList->RemoveItemsAt(1, theItem);				// Update the list and also tell the routine to update the menu. We tell the routine to select		// the previous item in the list, if there is one.				theItem--;					// Note that if the last item was deleted, theItem will be zero, and the UpdateChoicesList		// routine will handle updating buttons correctly.					UpdateChoicesList(theItem);		break;						default:		break;	}	// Always pass the message on to our base class		LGADialog::ListenToMessage(inMessage, ioParam);}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------voidCDefineChoicesDialog::SetupDialog(CEyeDxVariable *theVariable, CEyeDxBooleanType allowEditing){	mVariable = theVariable;		mAllowEditing = allowEditing;		mChoiceTable = dynamic_cast<LTextTableView*> (this->FindPaneByID(kDefineChoices_ChoiceTable));	ThrowIfNil_( mChoiceTable );			mMoveUpButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kDefineChoices_MoveUpButton));	ThrowIfNil_( mMoveUpButton );		mMoveDownButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kDefineChoices_MoveDownButton));	ThrowIfNil_( mMoveDownButton );		mRemoveItemButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kDefineChoices_RemoveItem));	ThrowIfNil_( mRemoveItemButton );		mNewItemButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kDefineChoices_NewItem));	ThrowIfNil_( mNewItemButton );		mModifyItemButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kDefineChoices_ModifyItem));	ThrowIfNil_( mModifyItemButton );		mItemStringEditField = dynamic_cast<CEyeDxEditFieldType*> (this->FindPaneByID(kDefineChoices_ItemStringEditField));	ThrowIfNil_( mItemStringEditField );		mCancelButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kDefineChoices_Cancel));	ThrowIfNil_( mCancelButton );		mSaveButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kDefineChoices_OK));	ThrowIfNil_( mSaveButton );		mSizer = new LCellSizeToFit(false);		mChoiceTable->SetCellSizer(mSizer);	mTableSelector = new LTableSingleRowSelector(mChoiceTable);		mChoiceTable->SetTableSelector(mTableSelector);		mTableGeometry = new LTableMultiGeometry( mChoiceTable, kChoiceStringWidth, kVariableEntryHeight);	mChoiceTable->SetTableGeometry(mTableGeometry);	mTableStorage = new LTableArrayStorage( mChoiceTable, (UInt32)0 );	mChoiceTable->SetTableStorage(mTableStorage);	mChoiceTable->AddListener(this);	// Get the current list of options and put them in the list		mOptionStringList = theVariable->GetOptionStringsArray();			ThrowIfNil_(mOptionStringList);		// Make a copy of it and the associated strings. We need to do this so we don't change the original	// list while the user makes changes. That allows for the Cancel operation to leave the original list	// alone.		mWorkingOptionStringList = new CTemplateShortStrArray(CCEyeDxLongStringTypeComparator::GetComparator(), false);	TArrayIterator<CEyeDxShortStringType *> iterator(*mOptionStringList);		CEyeDxShortStringType *theString;		while (iterator.Next(theString))	{		CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(*theString);					mWorkingOptionStringList->AddItem(theStringCopy);	}		// Update the list and also tell the routine to select the first item if there are any items in the list		if (mWorkingOptionStringList->GetCount() == 0)		UpdateChoicesList(0);	else		UpdateChoicesList(1);	// In the case where we don't allow editing, we change the save button so that the user doesn't think they	// are saving anything.		if (!mAllowEditing)	{		mCancelButton->Disable();	// For consistency - we disable the Cancel and set the Save to say "OK"		mSaveButton->SetDescriptor("\pOK");			mNewItemButton->Disable();	}} voidCDefineChoicesDialog::UpdateChoicesList(long itemToSelect){	// Here we have to parse the variable list and add all of the prompted variables in the order in which they are	// supposed to be prompted.	StopListening();	// Set the list to allow only one item to be selected	// This will defer updating the table until we exit the routine, saving a lot of redraws		mChoiceTable->SetDeferAdjustment(true);		// Delete all of the existing rows		mChoiceTable->RemoveAllRows(true);		// Figure out how many choices there are	TableIndexT theNumberOfChoices = mWorkingOptionStringList->GetCount();		mChoiceTable->InsertRows(theNumberOfChoices, 0);	const UInt32 kNumChoiceColumns = 1;		mChoiceTable->InsertCols(kNumChoiceColumns, 0);		mChoiceTable->SetColWidth(kVariableListNameWidth, 1, 1);	STableCell	cell;		cell.col = 1;	cell.row = 1;			// Now,  loop through the list		TArrayIterator<CEyeDxShortStringType *> iterator(*mWorkingOptionStringList);		CEyeDxShortStringType *theString;		while (iterator.Next(theString))	{		mChoiceTable->SetCellData(cell, theString->TextPtr(), theString->Length());		cell.row++;	}				mChoiceTable->SetDeferAdjustment(false);		mChoiceTable->Draw(nil);		if (mAllowEditing && (itemToSelect > 0))	{		cell.col = 1;		cell.row = itemToSelect;				mTableSelector->SelectCell(cell);		mChoiceTable->ScrollCellIntoFrame(cell);	// Make sure it's visible		// Now update the Move Up and Down buttons				mMoveUpButton->Disable();		mMoveDownButton->Disable();				// If the the selected item isn't the first item, then enable the Move Up Button				if (itemToSelect > 1)									mMoveUpButton->Enable();					// And if the selected item isn't the last item, enable the Move Down Button				if (itemToSelect < theNumberOfChoices)			mMoveDownButton->Enable();					// Now, fetch the string associated with the chosen item and put it in the		// edit field				mWorkingOptionStringList->FetchItemAt(itemToSelect, theString);				mItemStringEditField->SetDescriptor(*theString);								}	else	{		mMoveUpButton->Disable();		mMoveDownButton->Disable();			}		// If there are items in the list, we allow the user to modify and remove items. Otherwise,	// All they can do is add items.		if (mAllowEditing && (theNumberOfChoices > 0))	{		mModifyItemButton->Enable();		mRemoveItemButton->Enable();		mSaveButton->Enable();		mItemStringEditField->Enable();	}	else	{		mModifyItemButton->Disable();		mRemoveItemButton->Disable();				// If not editing, we leave the OK button enabled, but we disable the New button and the edit field		if (!mAllowEditing)		{			mSaveButton->Enable();			mNewItemButton->Disable();			mItemStringEditField->Disable();		}				}	StartListening();}