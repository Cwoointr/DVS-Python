// =================================================================================//	CDocumentApp.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for a document PowerPlant project////  The Application is derived from LDocApplication.  New Windows are managed//  by CTextDocument which is derived from LSingleDoc.  Each document contains//  a smart text view that remembers if it has changed since it was last saved.#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <LIconPane.h>#include <LWindow.h>#include <LGroupBox.h>#include <LTextButton.h>#include "LProgressBar.h"#include "EyeDxMacConstants.h"#include "CMyGWorldView.h"#include "CEyeDxPrefs.h"#include "ABalloon.h"#include "DC120.h"#include "CSpaceClickDialog.h"MessageT CDocumentApp::HandleCameraSetup(CEyeDxBooleanType autoStartMode){	// This routine displays a dialog to tell the user to prepare the camera for use.		// Create the dialog handler. We choose which version of the dialog to use based on 	// whether we're doing auto start mode or not.		PP_PowerPlant::ResIDT thePPob;		if (autoStartMode)		thePPob = PPob_CameraSetupAutoModeDialog;	else		thePPob = PPob_CameraSetupDialog;		StDialogHandler theHandler( thePPob, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );			theDialog->Show();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage) 		{		case msg_CameraSetup_ManualButton:	// Not used in Auto Start Mode		case msg_OK:		case msg_Cancel:			return theMessage;						break;		}	}}CEyeDxBooleanType CDocumentApp::GetReportName(){	// This routine displays a dialog to prompt for the report name.	// If OK is pressed, the name is validated, and the user prompted if it is	// invalid. Otherwise, we return true.		// Create the dialog handler.	StDialogHandler theHandler( PPob_ReportNameDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		CEyeDxEditFieldType *theReportName = dynamic_cast<CEyeDxEditFieldType*> (theDialog->FindPaneByID(kReportNameField));	ThrowIfNil_( theReportName );		CEyeDxCaptionType *theReportCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kReportNamePrompt));	ThrowIfNil_( theReportCaption );		CEyeDxCaptionType *theLicenseStatusCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kReportNameLicenseCaption));	ThrowIfNil_( theLicenseStatusCaption );		CEyeDxCaptionType *theSessionCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kReportNameSessionCaption));	ThrowIfNil_( theSessionCaption );	theSessionCaption->AddAttachment(mEraseAttachment, nil, false);		CEyeDxButtonType *theSessionButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kReportNameSessionButton));	ThrowIfNil_( theSessionButton );		long theMaxReportNameLength = kMaxReportNameLength;		// If the adjustName option is turned on, we have to account for the prefix length	// when testing the maximum report name length.		if (mReportPrefs.adjustName)		theMaxReportNameLength -= kPrefixLength;		theReportName->SetMaxChars(theMaxReportNameLength);		LStr255 theReportPrompt = "\pPlease enter up to ";	theReportPrompt.Append(theMaxReportNameLength);	theReportPrompt.Append("\p characters for the report name or ID number:");	theReportCaption->SetDescriptor(theReportPrompt);		// Indicate the current session if it isn't the default, and also allow the user to	// end the current session. If it is the default, allow the	// user to Start a Session.		CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	if (theSessionNameVariable)		UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theSessionNameVariable, theSessionButton, theSessionCaption);					// We get the thumbnail from the camera, and picture information	SetLicenseStatusCaption(theLicenseStatusCaption);		theDialog->Show();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		if ( theMessage == msg_Cancel ) 		{			return false;						break;		} 		else if ( theMessage == msg_OK ) 		{			// Get the entered report name and see if it is valid.			// If it is, we return true. If not, the user is prompted and we			// continue looping.			CEyeDxLongStringType theReportNameString;						theReportName->GetDescriptor(theReportNameString);						// Note that this routine also sets the global report_filename variable			// if the entered value is ok.						if (CheckReportValidity(this, &theReportNameString, theSessionNameVariable, mReportPrefs.adjustName))				return true;		}		else if (theMessage ==  msg_AnotherSubject_SessionButton)		{			CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();						if (*theSessionName == CommonStringLiteral_(kDefaultSessionName))				HandleNewSession(this, &mVariableList, theSessionButton, theSessionCaption, mPromptingPrefs.promptingStyle);			else			{				::HLock(mReportCustomText[kReportLayoutSessionSummaryText]);						HandleEndOfSession(this, &mVariableList, theSessionButton, theSessionCaption, theSessionNameVariable, 									*mReportCustomText[kReportLayoutSessionSummaryText], 									::GetHandleSize(mReportCustomText[kReportLayoutSessionSummaryText]), 									mPromptingPrefs.promptingStyle);				::HUnlock(mReportCustomText[kReportLayoutSessionSummaryText]);			}							// The calls above will update the dialog's button and caption for the session. The main window's button			// is updated by its code after we exit Auto mode.						// Indicate the new session in the main Auto Camera window footer						UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theSessionNameVariable, nil, mAutoCameraSessionCaption);						// Create the subfolders in case the user changed the session						CreateFolders();		}	}	return false;}CEyeDxBooleanType CDocumentApp::OpenCamera(CEyeDxCaptionType *theStatusCaption){	StCursor wait;	// Set the pointer to the stop watch while we are setting up		theStatusCaption->SetDescriptor("\pLooking for camera...");	theStatusCaption->Draw(nil);		DCStatus			GenericStatus;	DC120Status 		FullDC120Status; // Structure of DC120Status	// Save the last picture count		LastNumOfPicts = NumOfPicts;	NumOfPicts = 0;	PictNamePtr = NULL;	DCPortNum thePortNum = (DCPortNum) mCameraPrefs.defaultPort;	if (OpenCameraDriver(&GenericStatus, &FullDC120Status, nil, theStatusCaption, &thePortNum, (DCBitRate) mCameraPrefs.portSpeed, true) == 0)  	{		theStatusCaption->SetDescriptor("\p");		theStatusCaption->Draw(nil);	    	return false;	}		// Save the preferences - this will record the last port used for the camera		mCameraPrefs.defaultPort = (long)thePortNum;	mPreferences->SaveCameraPrefs(&mCameraPrefs);		// TODO - We can check the generic status here to see if the camera is ready to take pictures	// and to warn the user if the battery is low		RunInProgress = 1;	// We return true if we successfully connected and false otherwise. 		theStatusCaption->SetDescriptor("\p");	theStatusCaption->Draw(nil);	return true;}extern long startTicks;CEyeDxBooleanType CDocumentApp::PromptForAndTakePicture(enum eOrientation theOrientation,											DCPictInfo *theGenericPictInfo,											DC120PictInfo *thePictInfo, 										    CEyeDxViewType *theMainWindowView, 										    CEyeDxCaptionType *theMainWindowCaption,										    EyeDxNextStepCode theResult){	// Create the dialog handler.	StDialogHandler theHandler( PPob_TakePictureDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		CEyeDxCaptionType *theTakePictureCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kTakePictureCaption));	ThrowIfNil_( theTakePictureCaption );	theTakePictureCaption->AddAttachment(mEraseAttachment, nil, false);		CEyeDxButtonType *theOkButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kTakePicture_OK));	ThrowIfNil_( theOkButton );		CEyeDxButtonType *theCancelButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kTakePicture_Cancel));	ThrowIfNil_( theCancelButton );		LPicture *theCameraPICT = dynamic_cast<LPicture*> (theDialog->FindPaneByID(kTakePicturePICT));	ThrowIfNil_( theCameraPICT );	CEyeDxIconType *theBatteryLevelIcon = dynamic_cast<CEyeDxIconType*> (theDialog->FindPaneByID(kTakePictureBatteryIcon));	ThrowIfNil_( theBatteryLevelIcon );	CEyeDxCaptionType *theBatteryLevelCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kTakePictureBatteryCaption));	ThrowIfNil_( theTakePictureCaption );	theBatteryLevelCaption->AddAttachment(mEraseAttachment, nil, false);		// Disable the buttons until we know we can take the picture		theOkButton->Disable();	theCancelButton->Disable();	// Show the dialog so that the user sees status updates		theDialog->Show();	short picturesNeeded; 	// Used to check the camera if it has enough memory for the required number of							// pictures at this particular step	LStr255 thePromptStr;		switch (theOrientation)	{	case kUpOrientation:		theCameraPICT->SetPictureID(kUpCameraPICT);		thePromptStr = "\pPrepare to take the 'Up' picture. Position subject the correct distance from the camera, and hold camera with the handle on the right side. Press Take Picture when ready.";				// Now we determine how many pictures are still required at this step. If the result code passed-in is either the Continue		// or Retake Both state, we need to take 2 pictures. Otherwise, we need to take just one (we're retaking just the Up or Side		// picture).		if (theResult == kNextStepRetakeBoth || theResult == kNextStepContinue)			picturesNeeded = 2;		else			picturesNeeded = 1;		break;			case kSideOrientation:		theCameraPICT->SetPictureID(kSideCameraPICT);		thePromptStr = "\pPrepare to take the 'Side' picture. Position subject the correct distance from the camera, and hold camera with the handle on the bottom. Press Take Picture when ready.";				// A count of 1 is always correct here - in the case of a new subject (kContinue) or retaking both (kNextStepRetakeBoth),		// we've already taken the Up picture. And if we're just retaking the Side picture, only one is required. If retaking the		// Up picture, we won't be in this case. Thus only one is required.				picturesNeeded = 1;		break;	}	// Force the dialog to refresh		theDialog->Draw(nil);		DC120BatteryStatus theBatteryLevel;	CEyeDxBooleanType theFlashStatus = false;	short picturesRemaining;		// For some reason, the camera doesn't report flash status properly. So we can't use this code.	#if FALSE	short flashCheckTries = kTriesToCheckFlash;		while ((theFlashStatus == false) && (flashCheckTries > 0))	{		if (!CheckCameraStatus(nil, picturesNeeded, &picturesRemaining, theTakePictureCaption, &theBatteryLevel, &theFlashStatus))			return false;				if (theFlashStatus == false)		{			//LStr255 theNum = flashCheckTries * kFlashRechargeTimeoutInSecs;			//LStr255 theTimeRemaining = "\pWaiting for flash to charge. " + theNum + "\pseconds till timeout.";						theTakePictureCaption->SetDescriptor("\pWaiting for flash to charge. ");			theTakePictureCaption->Draw(nil);			OSSleep(kFlashRechargeTimeout);		}		flashCheckTries--;	}		if (theFlashStatus == false)	{		StopAlert(nil, CommonStringLiteral_("The camera's flash has not recharged. Replace batteries or use AC Adaptor."));		return false;	}#else	if (!CheckCameraStatus(nil, picturesNeeded, &picturesRemaining, theTakePictureCaption, &theBatteryLevel, &theFlashStatus))		return false;#endif			// Wait for the flash to recharge. Only wait for a while, though		switch (theBatteryLevel)	{	case DC120BatteryOK:		theBatteryLevelIcon->SetIconID(kOKBatteryIconList);		theBatteryLevelCaption->SetDescriptor("\pOK");		break;			case DC120BatteryWeak:		theBatteryLevelIcon->SetIconID(kWeakBatteryIconList);		theBatteryLevelCaption->SetDescriptor("\pWeak");		break;			case DC120BatteryEmpty:		theBatteryLevelIcon->SetIconID(kEmptyBatteryIconList);		theBatteryLevelCaption->SetDescriptor("\pEmpty");		StopAlert(nil, CommonStringLiteral_("The camera does not have enough battery power to take another picture. Replace batteries or use AC Adaptor."));		break;	}		// Force the items to show up		theBatteryLevelIcon->Draw(nil);	theBatteryLevelCaption->Draw(nil);		// Set the camera parameters		if (!SetCameraPictureParams(theTakePictureCaption))		return false;			// Now, we finally draw the correct prompt, based on the current orientation (Up or Side)					theTakePictureCaption->SetDescriptor(thePromptStr);			theOkButton->Enable();	theCancelButton->Enable();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		if ( theMessage == msg_Cancel ) 		{			return false;						break;		} 		else if ( theMessage == msg_OK ) 		{			//startTicks = ::LMGetTicks();				StCursor wait;	// Set the pointer to the stop watch while we are getting the image						theOkButton->Disable();			theCancelButton->Disable();			if (!TakePicture(theOrientation, nil, theTakePictureCaption, theMainWindowCaption, theMainWindowView, theGenericPictInfo, thePictInfo))			{				return false;			}			return true;			break;		}	}	return false;	}// This routine will set up the camera with the standard parameters. If it gets an// error, it returns false. Otherwise, it returns trueCEyeDxBooleanType CDocumentApp::SetCameraPictureParams(CEyeDxCaptionType *theStatusCaption){	StCursor wait;	// Set the pointer to the stop watch while we are getting the image	// There's no need to handle the dialog, since it doesn't have any buttons.		if (!SetCameraConfiguration(mAutoCameraWindow, theStatusCaption))	{		return false;	}			return true;}void CDocumentApp::HandleVerifyZoom(enum eOrientation Location, 										    CEyeDxViewType *theMainWindowView, 										    CEyeDxCaptionType *theMainWindowCaption,										    CEyeDxBooleanType *theImageAlreadyDownloaded){	// Create the dialog handler.	StDialogHandler theHandler( PPob_VerifyPictureZoomDialog, this );	// Get the dialog.	CEyeDxDialogType *theDialog;	theDialog = dynamic_cast<CEyeDxDialogType*> (theHandler.GetDialog());	Assert_( theDialog != nil );		CEyeDxCaptionType *theFilenameCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kVerifyPictureZoomFileNameCaption));	ThrowIfNil_( theFilenameCaption );		theFilenameCaption->AddAttachment(mEraseAttachment, nil, false);	CEyeDxViewType *theMainView = dynamic_cast<CEyeDxViewType*> (theDialog->FindPaneByID(kVerifyPictureZoomMainView));	ThrowIfNil_( theMainView );		CEyeDxProgressType *theProgressThermometer = dynamic_cast<CEyeDxProgressType*> (theDialog->FindPaneByID(kVerifyPictureZoomThermometer));	ThrowIfNil_( theProgressThermometer );	CEyeDxButtonType *theDownloadButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kVerifyPictureZoom_Download));	ThrowIfNil_( theDownloadButton );		CEyeDxLongStringType theFilenameString;			theMainWindowCaption->GetDescriptor(theFilenameString);	theFilenameCaption->SetDescriptor(theFilenameString);		// Initially, we just copy the thumbnail data		if (*theImageAlreadyDownloaded)	{		if (Location == kUpOrientation)		{			::HLock(mUpHandle);			theMainView->SetImageFromRaw24Bit((unsigned char *)*mUpHandle,UP_ROWS,UP_COLS);			::HUnlock(mUpHandle);		}		else		{			::HLock(mSideHandle);			theMainView->SetImageFromRaw24Bit((unsigned char *)*mSideHandle,SIDE_ROWS,SIDE_COLS);			::HUnlock(mSideHandle);		}		theDownloadButton->Disable();	}	else		theMainView->CopyPixMapData(theMainWindowView->GetPixMapHandle());	// Make the dialog visible.	theDialog->Show();		MessageT theMessage;	CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_OK:			return;			break;		case msg_VerifyPictureZoom_Download:						// User has asked us to download the full image. Once we do this, we disable the button						CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));			SetThermometerValues(theProgressThermometer, 0L, 100L, 0L);			theProgressThermometer->Show();									theDialog->Draw(nil);										if (Location == kUpOrientation)			{				CEyeDxVariable *theUpImageVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGE));							// Cleanup any existing Up image, but we do not want to reset the image in the main window view, as it is still				// a valid thumbnail of the picture we are downloading.								CleanupUpImage(nil);								if (!DownloadImageFromCamera(1,&mUpHandle,&UP_ROWS,&UP_COLS,up_filename, theSessionNameVariable, theUpImageVariable,									nil, theProgressThermometer, theFilenameCaption, SaveFullImages))					StopAlert(this, CommonStringLiteral_("Unable to download full picture."));				else				{					::HLock(mUpHandle);					theMainView->SetImageFromRaw24Bit((unsigned char *)*mUpHandle,UP_ROWS,UP_COLS);					::HUnlock(mUpHandle);					*theImageAlreadyDownloaded = true;				}			}			else			{				CEyeDxVariable *theSideImageVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGE));							// Cleanup any existing Up image, but we do not want to reset the image in the main window view, as it is still				// a valid thumbnail of the picture we are downloading.								CleanupUpImage(nil);								if (!DownloadImageFromCamera(2,&mSideHandle,&SIDE_ROWS,&SIDE_COLS,side_filename, theSessionNameVariable, theSideImageVariable,									nil, theProgressThermometer, theFilenameCaption, SaveFullImages))					StopAlert(this, CommonStringLiteral_("Unable to download full picture."));				else				{					::HLock(mSideHandle);					theMainView->SetImageFromRaw24Bit((unsigned char *)*mSideHandle,SIDE_ROWS,SIDE_COLS);					::HUnlock(mSideHandle);					*theImageAlreadyDownloaded = true;				}			}								theProgressThermometer->Hide();									theDownloadButton->Disable();			theFilenameCaption->SetDescriptor(theFilenameString);			break;		}	}	}enum ePictureVerifyStatus CDocumentApp::VerifyPicture(enum eOrientation Location, 											DCPictInfo *theGenericPictInfo,											DC120PictInfo *thePictInfo, 										    CEyeDxViewType *theMainWindowView, 										    CEyeDxCaptionType *theMainWindowCaption,										    CEyeDxIconType *theMainWindowQualityIcon,										    CEyeDxBooleanType *theImageAlreadyDownloaded){	// Create the dialog handler.	StDialogHandler theHandler( PPob_VerifyPictureDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		CEyeDxCaptionType *theStatusCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kVerifyPictureNoteCaption));	ThrowIfNil_( theStatusCaption );	theStatusCaption->AddAttachment(mEraseAttachment, nil, false);		CEyeDxCaptionType *theFilenameCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kVerifyPictureImageCaption));	ThrowIfNil_( theFilenameCaption );		CEyeDxViewType *theView = dynamic_cast<CEyeDxViewType*> (theDialog->FindPaneByID(kVerifyPictureMyGWorldView));	ThrowIfNil_( theView );		CEyeDxButtonType *theOkButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kVerifyPicture_OK));	ThrowIfNil_( theOkButton );		LPicture *theTopPICT = dynamic_cast<LPicture*> (theDialog->FindPaneByID(kVerifyPictureTopPICT));	ThrowIfNil_( theTopPICT );	LPicture *theSidePICT = dynamic_cast<LPicture*> (theDialog->FindPaneByID(kVerifyPictureSidePICT));	ThrowIfNil_( theSidePICT );	CEyeDxLongStringType theFilenameString;			theMainWindowCaption->GetDescriptor(theFilenameString);	theFilenameCaption->SetDescriptor(theFilenameString);	theView->CopyPixMapData(theMainWindowView->GetPixMapHandle());	// If the location is "Side", then we change the Ok button to say "Run Analysis"		CEyeDxShortStringType theButtonName;	if (Location == kSideOrientation)	{		theSidePICT->Show();		theButtonName = "\pRun Analysis";	}	else	{		theTopPICT->Show();		theButtonName = "\pContinue";	}	theOkButton->SetDescriptor(theButtonName);			 		theMainWindowQualityIcon->Show();	// If the quality isn't what we should be using, warn the user		unsigned long thePictQuality;		thePictQuality = CheckPictInfo(thePictInfo);		if (thePictQuality != 0)	{			LStr255 theErrorString;				if (thePictQuality & kNotBestQuality)			theErrorString.Append( "\pThe picture was not taken with the recommended 'Best' image quality setting. ");				if (thePictQuality & kNoFlash)			theErrorString.Append("\pThe flash was not on. ");					if (thePictQuality & kNotZoomed)			theErrorString.Append("\pThe camera was not zoomed all the way in. ");					if (thePictQuality & kBadFocusMode) 			theErrorString.Append("\pThe camera focus mode was incorrect (should be multispot). ");					if (thePictQuality & kSubjectTooClose)			theErrorString.Append("\pSubject was too close to camera. ");					if (thePictQuality & kSubjectTooFar)			theErrorString.Append("\pSubject was too far from camera. ");		if (thePictQuality & kBadOrientation)			theErrorString.Append("\pPicture orientation setting not correct (should be no rotation). ");		theErrorString.Append("\p Analysis may produce incorrect results. EyeDx recommends you retake the picture.");		theMainWindowQualityIcon->SetIconID(kCautionQualityIconList);	 	theStatusCaption->SetDescriptor(theErrorString);	}	else	{		LStr255 thePromptString = "\pThe picture settings and distance appear to be OK. If the picture is oriented correctly and the subject is properly looking at the camera, press ";		thePromptString.Append(theButtonName);		thePromptString.Append("\p. Otherwise, retake the picture.");				theStatusCaption->SetDescriptor(thePromptString);		theMainWindowQualityIcon->SetIconID(kGoodQualityIconList);	}		//Handle theZoomedHandle = nil;	//int theZoomedRows, theZoomedCols;	//char theDummyFilename[256];	//CEyeDxBooleanType downloadedOK = false;	// Show the dialog early so we can use it for status display	theDialog->Show();			// Now handle the user's requests		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		if ( theMessage == msg_Cancel ) 		{			return kPictureVerifyCancel;						break;		} 		else if ( theMessage == msg_OK ) 		{			return kPictureVerifyOK;			break;		}		else if (theMessage == msg_VerifyPicture_Retake)		{			return kPictureVerifyRetake;			break;		}		else if (theMessage == msg_VerifyPicture_Zoom)		{			//if (theZoomedHandle == nil)			//{				// Download a temporary larger image for zooming if we haven't already				//if (!DownloadImageFromCamera(Location,&theZoomedHandle,&theZoomedRows,&theZoomedCols, theDummyFilename, nil, nil,									//nil, nil, nil, false, DC120OutputW320))					//StopAlert(this, CommonStringLiteral_("Unable to get zoomed picture."));				//else					//downloadedOK = true;			//}						//if (downloadedOK)				//HandleSummaryZoom(&theFilenameString, theZoomedHandle, theZoomedRows, theZoomedCols, nil, nil, 0, 0);											HandleVerifyZoom(Location, theMainWindowView, theMainWindowCaption, theImageAlreadyDownloaded);		}	}		// Free the memory		//if (theZoomedHandle != nil)		//::DisposeHandle(theZoomedHandle);			return kPictureVerifyCancel;}CEyeDxBooleanType CDocumentApp::DownloadPictures(EyeDxNextStepCode theResult, CEyeDxBooleanType upImageAlreadyDownloaded, CEyeDxBooleanType sideImageAlreadyDownloaded){	StCursor wait;	// Set the pointer to the stop watch while we are downloading	CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	// Force a redraw of the main window		// We download the Up image in all cases except when we are retaking the Side image		if ((theResult !=  kNextStepRetakeSide) && !upImageAlreadyDownloaded)	{		SetThermometerValues(mAutoCameraUpThermometerPane, 0L, 100L, 0L);		mAutoCameraUpThermometerPane->Show();		mAutoCameraUpProgressCaption->Show();							mAutoCameraWindow->Draw(nil);				CEyeDxVariable *theUpImageVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGE));			if (!DownloadImageFromCamera(1,&mUpHandle,&UP_ROWS,&UP_COLS,up_filename, theSessionNameVariable, theUpImageVariable,									nil, mAutoCameraUpThermometerPane, mAutoCameraUpProgressCaption, SaveFullImages))			return false;		mAutoCameraUpThermometerPane->Hide();		mAutoCameraUpProgressCaption->Hide();		mAutoCameraWindow->Draw(nil);	}		// Force a refresh of the window to get the thermometer and caption to hide properly		// We download the Side image in all cases except when we are retaking the Up image		if ((theResult !=  kNextStepRetakeUp) && !sideImageAlreadyDownloaded)	{		SetThermometerValues(mAutoCameraSideThermometerPane, 0L, 100L, 0L);		mAutoCameraSideThermometerPane->Show();		mAutoCameraSideProgressCaption->Show();		mAutoCameraWindow->Draw(nil);							CEyeDxVariable *theSideImageVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGE));			if (!DownloadImageFromCamera(2,&mSideHandle,&SIDE_ROWS,&SIDE_COLS,side_filename, theSessionNameVariable, theSideImageVariable,	 									nil, mAutoCameraSideThermometerPane, mAutoCameraSideProgressCaption, SaveFullImages))					return false;		mAutoCameraSideThermometerPane->Hide();		mAutoCameraSideProgressCaption->Hide();		mAutoCameraWindow->Draw(nil);	}				return true;}CEyeDxBooleanType CDocumentApp::CleanupCameraAutoMode(){	// ALWAYS close the camera!!		CloseCamera(nil);		// The user can cancel at any time. We just hide the Run From Disk Window and show	// the Control Window			CleanupImages(mAutoCameraUpView, mAutoCameraSideView);		RunInProgress = 0;	HideMoveShow(mAutoCameraWindow, mMainWindow);		return true;}MessageT CDocumentApp::HandleAnotherSubjectPrompt(){	// This routine displays a dialog to tell the user to prepare the camera for use.		// Create the dialog handler.	StDialogHandler theHandler( PPob_AnotherSubjectDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		CEyeDxCaptionType *theSessionCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kAnotherSubjectSessionCaption));	ThrowIfNil_( theSessionCaption );	theSessionCaption->AddAttachment(mEraseAttachment, nil, false);		CEyeDxButtonType *theSessionButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kAnotherSubjectSessionButton));	ThrowIfNil_( theSessionButton );		// Indicate the current session if it isn't the default, and also allow the user to	// end the current session. If it is the default, allow the	// user to Start a Session.		CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	if (theSessionNameVariable)		UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theSessionNameVariable, theSessionButton, theSessionCaption);			theDialog->Show();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage) 		{		case msg_OK:		case msg_Cancel:					return theMessage;						break;					case msg_AnotherSubject_SessionButton:						CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();						if (*theSessionName == CommonStringLiteral_(kDefaultSessionName))				HandleNewSession(this, &mVariableList, theSessionButton, theSessionCaption, mPromptingPrefs.promptingStyle);			else			{				::HLock(mReportCustomText[kReportLayoutSessionSummaryText]);						HandleEndOfSession(this, &mVariableList, theSessionButton, theSessionCaption, theSessionNameVariable, 									*mReportCustomText[kReportLayoutSessionSummaryText], 									::GetHandleSize(mReportCustomText[kReportLayoutSessionSummaryText]), 									mPromptingPrefs.promptingStyle);				::HUnlock(mReportCustomText[kReportLayoutSessionSummaryText]);			}							// The calls above will update the dialog's button and caption for the session. The main window's button			// is updated by its code after we exit Auto mode.						// Create the subfolders in case the user changed the session						CreateFolders();						// Set the default image and report directories to the current session's			// Pimages and reports directories since that is the logical location.							mLastImageDirSpec = mPImagesDirSpec;			mLastReportDirSpec = mReportDirSpec;			break;		}	}}CEyeDxBooleanType CDocumentApp::HandleDeleteImage(void *theWindow,										 CEyeDxCaptionType *theProgressCaption,				 						 DCPictInfo *theGenericPictInfo){	// This routine displays a dialog to tell the user to prepare the camera for use.		// Create the dialog handler.	StDialogHandler theHandler( PPob_DeletingImageDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		theDialog->Show();		theDialog->Draw(nil);		// We don't need to handle events as we are just warning the user not to turn off or	// unplug the camera		return(DeletePicture(theDialog, theProgressCaption, theGenericPictInfo));}// This routine returns a boolean which indicates whether we should continue looping, prompting for// the next subject (true), or exit the mode (false)CEyeDxBooleanType CDocumentApp::CameraAutoLoop(){	EyeDxNextStepCode theResult;	CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));		CEyeDxBooleanType anotherSubject = true;	// We will keep track of the total number of retakes for this subject	long totalRetakes = 0;		// These are the generic picture info structures that we use to delete images that the user	// retakes.	mAutoCameraUpProgressCaption->Show();		mAutoCameraUpView->ResetImage();	mAutoCameraUpCaption->SetDescriptor(Str_Empty);	mAutoCameraUpPictureQualityIcon->Hide();	mAutoCameraSideProgressCaption->Show();	mAutoCameraSideView->ResetImage();	mAutoCameraSideCaption->SetDescriptor(Str_Empty);	mAutoCameraSidePictureQualityIcon->Hide();	mAutoCameraReportName->SetDescriptor("\pNot specified yet.");			// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 	// three 3 byte deep images (since there's no graphics in Auto mode), plus about 10% overhead.	// Since we've already allocated the memory for the images, we don't include them in the counts here.		short num3ByteDeepImages = 3;	// For the two input images and one pre-scaled annotated image that is written out for the report	short num1ByteDeepImages = 1;	// For the threshold image		CEyeDxLongStringType hintString = Str_Empty;		MessageT theMemoryMessage = DoCheckForMemory(this, 						false,						IMAGE_HEIGHT,						IMAGE_WIDTH,						num3ByteDeepImages,						num1ByteDeepImages,						&hintString);	if (theMemoryMessage == msg_Cancel)		return false;	// Indicate the current session in the analysis window footer		UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theSessionNameVariable, nil, mAutoCameraSessionCaption);				// First, we prompt the user for the report name. If they cancel, we just return, as nothing	// was allocated or initiated yet.			if (!GetReportName())		return false;			// Now, prompt for additional variables, if any. Note that this will return true if no variables	// are present, so we will continue. A return value of false means that the user cancelled the	// dialog.		if (HandlePromptForVariables(this,  &mVariableList, mPromptingPrefs.promptingStyle, CEyeDxVariable::kPromptForSubject) == kEyeDxDialogCancelMessage)		return (HandleAnotherSubjectPrompt() != msg_Cancel);		// Default to the continue case		theResult = kNextStepContinue;		mUpSelected = false;	mSideSelected = false;		bool theUpImageDownloaded = false;		bool theSideImageDownloaded = false;					do	{		CEyeDxShortStringType theString(report_filename);			mAutoCameraReportName->SetDescriptor(theString);				// We next prompt the user to get ready to take the Up picture.		// This dialog allows the user to simply click the mouse anywhere to snap the shutter		// If the mUpSelected flag is already set, we skip this step					while (!mUpSelected)		{			mAutoCameraUpPictureQualityIcon->Show();			if (!PromptForAndTakePicture(kUpOrientation, &mUpGenericPictInfo, &mUpPictInfo,  mAutoCameraUpView, mAutoCameraUpCaption, theResult))			{				// We have to delete the side image if we are in the process of doing a retake								if (mSideSelected)					HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &mSideGenericPictInfo);									CleanupImages(mAutoCameraUpView, mAutoCameraSideView);									mAutoCameraWindow->Draw(nil);						return (HandleAnotherSubjectPrompt() != msg_Cancel);			}						enum ePictureVerifyStatus verifyStatus = VerifyPicture(kUpOrientation, 																		&mUpGenericPictInfo,																		&mUpPictInfo, 																		mAutoCameraUpView, 																		mAutoCameraUpCaption,																		mAutoCameraUpPictureQualityIcon,																		&theUpImageDownloaded);						switch (verifyStatus)			{			case kPictureVerifyCancel:				if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &mUpGenericPictInfo))					return false;				// We also have to delete the side image if we are in the process of doing a retake								if (mSideSelected)				{					// If the side image number is greater than the up image number, we have to decrement					// the side image number because the deletion of the up image changed the numbering in the					// camera									if (mSideGenericPictInfo.PictNumber > mUpGenericPictInfo.PictNumber)						mSideGenericPictInfo.PictNumber--;										HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &mSideGenericPictInfo);				}				CleanupImages(mAutoCameraUpView, mAutoCameraSideView);									mAutoCameraWindow->Draw(nil);						return (HandleAnotherSubjectPrompt() != msg_Cancel);				break;							case kPictureVerifyRetake:							totalRetakes++;				mAutoCameraUpView->ResetImage();				mAutoCameraUpPictureQualityIcon->Hide();								mAutoCameraWindow->Draw(nil);								// Delete the bad picture								if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &mUpGenericPictInfo))				{					// Failed during delete - all bets are off as to what to do!					return false;				}								break;							case kPictureVerifyOK:				mUpSelected = true;				mUpPictInfoValid = true;						break;			}		}				// We next prompt the user to get ready to take the Side picture.		// This dialog allows the user to simply click the mouse anywhere to snap the shutter		// If the mSideSelected flag is already set, we skip this step						while (!mSideSelected)		{			mAutoCameraSidePictureQualityIcon->Show();						if (!PromptForAndTakePicture(kSideOrientation, &mSideGenericPictInfo, &mSidePictInfo, mAutoCameraSideView, mAutoCameraSideCaption, theResult))			{				// Delete the Up image				HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &mUpGenericPictInfo);				CleanupImages(mAutoCameraUpView, mAutoCameraSideView);									mAutoCameraWindow->Draw(nil);						return (HandleAnotherSubjectPrompt() != msg_Cancel);			}						enum ePictureVerifyStatus verifyStatus = VerifyPicture(kSideOrientation, 																		&mSideGenericPictInfo,																		&mSidePictInfo, 																		mAutoCameraSideView,																		mAutoCameraSideCaption,																		mAutoCameraSidePictureQualityIcon,																		&theSideImageDownloaded);						switch (verifyStatus)			{			case kPictureVerifyCancel:				if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &mUpGenericPictInfo))					return false;							// If the side image number is greater than the up image number, we have to decrement				// the side image number because the deletion of the up image changed the numbering in the				// camera							if (mSideGenericPictInfo.PictNumber > mUpGenericPictInfo.PictNumber)					mSideGenericPictInfo.PictNumber--;								HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &mSideGenericPictInfo);				CleanupImages(mAutoCameraUpView, mAutoCameraSideView);									mAutoCameraWindow->Draw(nil);						return (HandleAnotherSubjectPrompt() != msg_Cancel);				break;							case kPictureVerifyRetake:				totalRetakes++;				mAutoCameraSideView->ResetImage();				mAutoCameraSidePictureQualityIcon->Hide();				// Delete the bad picture								mAutoCameraWindow->Draw(nil);								if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &mSideGenericPictInfo))					return false;				break;							case kPictureVerifyOK:				mSideSelected = true;				mSidePictInfoValid = true;						break;			}		}				// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 		// three 3 byte deep images (since animation isn't enabled in Auto mode), plus about 10% overhead.		// Since we've already allocated the memory for the images, we don't include them in the counts here.		// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.				short num3ByteDeepImages = 3;	// For the two input images and one pre-scaled annotated image that is written out for the report		short num1ByteDeepImages = 1;	// For the threshold image				CEyeDxLongStringType hintString = Str_Empty;				MessageT theMemoryMessage = DoCheckForMemory(this, 							false,							IMAGE_HEIGHT,							IMAGE_WIDTH,							num3ByteDeepImages,							num1ByteDeepImages,							&hintString);		if (theMemoryMessage == msg_Cancel)		{			// The user could not free-up memory. We DO NOT delete the images - that will allow them to			// run the images manually after Auto mode quits.						// The images should already be cleared, but we have this here to also clear the thumbnails.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						CleanupImages(mAutoCameraUpView, mAutoCameraSideView);								::ParamText("\pThe images you took will be left in the camera. Use Run From Camera Manual to analyze them after freeing memory.", Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::CautionAlert(PPob_GeneralALRT);			mAutoCameraWindow->Draw(nil);					return false;		}					// At this point, we have both the Up and Side pictures selected. We download the		// actual images, and analyze them using the standard analysis window. The result code is		// passed in, so we can skip downloading images we already have.					if (!DownloadPictures(theResult, theUpImageDownloaded, theSideImageDownloaded))		{			// Failure during download!			return false;		}				theUpImageDownloaded = true;		theSideImageDownloaded = true;		// If we are displaying the summary window, we tell the AnalyzeImages routine to not clean up		// the images. That allows us to retake specific images as needed. This means we are responsible		// for cleanup. However, if the Summary Window is not displayed, there are no retake options, and		// the Analyze Images routine will do the cleanup so that the memory is freed before the browser		// is invoked. Note that after the call to AnalyzeImages we may have to do cleanup regardless of		// the display option. So the cleanupImages option is there simply as a memory optimization when		// browser option is selected, so that the memory is freed before the browser is forked.				CEyeDxBooleanType cleanupImages = true;				if (mReportPrefs.displayOption == kDisplaySummary)			cleanupImages = false;				// We keep track of the total number of retakes for this subject. Set the variable here so it is available for		// the report generation and database output functions called by the AnalyzeImages routine.				CEyeDxVariable *theTotalRetakesVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTTOTALRETAKES));		theTotalRetakesVariable->SetValue(totalRetakes);		// Again, we see if there's enough temporary memory to run now that we've downloaded. The peak usage is 		// one 8 bit deep image and one 3 byte deep images (since animation isn't enabled in Auto mode), plus 		// about 10% overhead. We've already allocated the memory for the images, we don't include them in the 		// counts here, since we are checking for enough _additional_ memory to run.				num3ByteDeepImages = 1;	// For the pre-scaled annotated save image		num1ByteDeepImages = 1;	// For the threshold image				theMemoryMessage = DoCheckForMemory(this, 							false,							IMAGE_HEIGHT,							IMAGE_WIDTH,							num3ByteDeepImages,							num1ByteDeepImages,							&hintString);		if (theMemoryMessage == msg_Cancel)		{			// The user could not free-up memory. We DO NOT delete the images - that will allow them to			// run the images manually after Auto mode quits.						// The images should already be cleared, but we have this here to also clear the thumbnails.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						CleanupImages(mAutoCameraUpView, mAutoCameraSideView);								::ParamText("\pThe images you took will be left in the camera. Use Run From Camera Manual to analyze them after freeing memory.", Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::CautionAlert(PPob_GeneralALRT);			mAutoCameraWindow->Draw(nil);					return false;		}							// Indicate the current session in the analysis window footer				UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theSessionNameVariable, nil, mAutoCameraSessionCaption);					// We use the current value of theResult to determine if we are doing a retake. The AnalyzeImages routine uses the		// current value to determine which images to pass to the EyeDx routine for analysis.				theResult = AnalyzeImages(mAutoCameraWindow, mAutoCameraUpView, mAutoCameraSideView, SaveFullImages, true, cleanupImages, theResult);				// Hide the Analysis Window				HideMoveShow(mAnalysisWindow, mAutoCameraWindow);				// This is a kludge - we delay a bit so that if the Display Report preference is set,		// the browser window has a bit of a chance to come up. This is not ideal, since this is		// a fixed delay, and we have no idea when the actual report window appears (varies		// greatly based on processor speed, memory availability, browser chosen, etc.)				if (mReportPrefs.displayOption == kDisplayReport)		{			// We indicate in the window that we are waiting for the report to display						mAutoCameraUpProgressCaption->Show();			mAutoCameraUpProgressCaption->SetDescriptor("\pWaiting for browser...");			mAutoCameraWindow->Draw(nil);			OSSleep(CalculateDelay(5));			mAutoCameraUpProgressCaption->SetDescriptor(Str_Empty);		}		// Refresh the main window				mAutoCameraWindow->Draw(nil);				// If we told the AnalyzeImages routine to not cleanup. It is our responsibility to do		// so. Check the return status from AnalyzeImages, and do the appropriate thing				switch (theResult)		{		case kNextStepRetakeUp:					// Delete the Up picture in the camera since we are going to retake it					if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &mUpGenericPictInfo))				return false;						// If the side image number is greater than the up image number, we have to decrement			// the side image number because the deletion of the up image changed the numbering in the			// camera						if (mSideGenericPictInfo.PictNumber > mUpGenericPictInfo.PictNumber)				mSideGenericPictInfo.PictNumber--;							// The Up image was bad						mUpSelected = false;			theUpImageDownloaded = false;				// The image should already be cleared, but we have this here to also clear the thumbnail.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						CleanupUpImage(mAutoCameraUpView);			break;			case kNextStepRetakeSide:					// Delete the Side picture in the camera since we are going to retake it					if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &mSideGenericPictInfo))				return false;										// If the side image number is greater than the up image number, we have to decrement			// the side image number because the deletion of the up image changed the numbering in the			// camera						if (mUpGenericPictInfo.PictNumber > mSideGenericPictInfo.PictNumber)				mUpGenericPictInfo.PictNumber--;							// The Side image was bad						mSideSelected = false;						theSideImageDownloaded = false;			// The image should already be cleared, but we have this here to also clear the thumbnail.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						CleanupSideImage(mAutoCameraSideView);			break;			case kNextStepRetakeBoth:					// Delete both pictures in the camera since we are going to retake both					if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &mUpGenericPictInfo))				return false;						// If the side image number is greater than the up image number, we have to decrement			// the side image number because the deletion of the up image changed the numbering in the			// camera						if (mSideGenericPictInfo.PictNumber > mUpGenericPictInfo.PictNumber)				mSideGenericPictInfo.PictNumber--;							if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &mSideGenericPictInfo))				return false;						// Both images were bad, so clean up both images						mUpSelected = false;			mSideSelected = false;						theUpImageDownloaded = false;			theSideImageDownloaded = false;						// The image should already be cleared, but we have this here to also clear the thumbnail.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						CleanupImages(mAutoCameraUpView, mAutoCameraSideView);			break;			case kNextStepContinue:					// Everything was fine, so clean up the images			// The images should already be cleared, but we have this here to also clear the thumbnails.			// No harm, since the routine checks to see if the memory is already freed and doesn't do			// it again.						CleanupImages(mAutoCameraUpView, mAutoCameraSideView);								mAutoCameraWindow->Draw(nil);					// We prompt first, so the delete operation can take place after the			// user has answered and is presumably setting up the next subject.					anotherSubject = (HandleAnotherSubjectPrompt() != msg_Cancel);			// Delete both pictures in the camera since are done with them. We do this after the			// prompt for the next patient so the user can start preparing the next patient in			// parallel with deleting the images.					if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &mUpGenericPictInfo))				return false;			// If the side image number is greater than the up image number, we have to decrement			// the side image number because the deletion of the up image changed the numbering in the			// camera						if (mSideGenericPictInfo.PictNumber > mUpGenericPictInfo.PictNumber)				mSideGenericPictInfo.PictNumber--;							if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &mSideGenericPictInfo))				return false;									break;		}				// We stay in this loop, for the same subject, if the Summary Window says to do a start over.		// Note that the report_filename variable needs to be left alone for this to work.			} while ((theResult == kNextStepRetakeUp) || (theResult == kNextStepRetakeSide) || (theResult == kNextStepRetakeBoth));	// We're done with this subject - return the value returned by		return anotherSubject;}void CDocumentApp::HandleRunFromCameraAuto(){	// Hide the Main Window		HideMoveShow(mMainWindow, mAutoCameraWindow);		mAutoCameraUpProgressCaption->Show();		mAutoCameraUpView->Show();	mAutoCameraUpView->ResetImage();	mAutoCameraSideView->Show();	mAutoCameraSideView->ResetImage();	mAutoCameraUpPictureQualityIcon->Hide();	mAutoCameraSidePictureQualityIcon->Hide();	mAutoCameraReportName->SetDescriptor(Str_Empty);	mAutoCameraUpCaption->SetDescriptor(Str_Empty);	mAutoCameraSideCaption->SetDescriptor(Str_Empty);	mAutoCameraWindow->Draw(nil);		// First, we connect to the camera - put up a status window so that the user knows what is	// going on. We do this only once per loop to save time reopening it each time.		if (OpenCamera(mAutoCameraUpProgressCaption))	{			// Refresh the window				mAutoCameraWindow->Draw(nil);									// We loop in this mode until the user cancels any of the dialogs				CEyeDxBooleanType anotherSubject = true;				while (anotherSubject)		{									HandleStartOfSubject(&mVariableList);							anotherSubject = CameraAutoLoop();						// Now update the variables for the end of a subject			HandleEndOfSubject(&mVariableList, NULL, &mDefaultDatabaseReportName);									// We also want to save the current session status in case of crash								SaveSessionStatus();			// Clean up everything - thumbnails and memory since we finished one way or another						CleanupImages(mAutoCameraUpView, mAutoCameraSideView);			mAutoCameraWindow->Draw(nil);		}	}		CleanupCameraAutoMode();			return;}