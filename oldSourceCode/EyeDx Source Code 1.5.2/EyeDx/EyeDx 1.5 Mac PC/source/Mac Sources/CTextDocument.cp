// =================================================================================//	CTextDocument.cp				©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================#include <LFile.h>#include <LPlaceHolder.h>#include <LPrintout.h>#include <LString.h>#include <LWindow.h>#include <PP_Messages.h>#include <UMemoryMgr.h>#include <UWindows.h>#include "PrintingConstants.h"#include "CTextView.h"#include "CTextDocument.h"// ---------------------------------------------------------------------------------//		¥ CTextDocument(LCommander*, FSSpec*)// ---------------------------------------------------------------------------------CTextDocument::CTextDocument(	LCommander	*inSuper,	FSSpec		*inFileSpec )		: LSingleDoc( inSuper ){	// Create window for our document.	mWindow = nil;	mWindow = PP_PowerPlant::LWindow::CreateWindow( PPob_TextWindow, this );	ThrowIfNil_(mWindow);		// Specify that the text view should be the	// target when the window is activated.	mTextView = dynamic_cast<CTextView *>(mWindow->FindPaneByID( kTextView ));	ThrowIfNil_(mTextView);	mWindow->SetLatentSub( mTextView );		if ( inFileSpec == nil ) {		// Set the name of new window.		NameNewDoc();			} else {			// Display contents of file in window.		OpenFile( *inFileSpec );		}		// Make the window visible.	mWindow->Show();}// ---------------------------------------------------------------------------------//		¥ NameNewDoc// ---------------------------------------------------------------------------------voidCTextDocument::NameNewDoc(){	// Setup the window title. Start with the default title.	PP_PowerPlant::LStr255	theTitle( "\pUntitled" );	// Find the first available title. We could also check the window	// pane id if we wanted to make sure we didn't collide with other	// window types.	SInt32	theNumber = 0;	while ( PP_PowerPlant::UWindows::FindNamedWindow( theTitle ) != nil ) {		// An existing window has the current name		// Increment counter and try again.		++theNumber;		theTitle = "\pUntitled ";		theTitle += static_cast<SInt32>(theNumber);	}				// Finally, set window title.	mWindow->SetDescriptor( theTitle );}// ---------------------------------------------------------------------------------//		¥ OpenFile// ---------------------------------------------------------------------------------voidCTextDocument::OpenFile(	FSSpec	&inFileSpec ){	mFile = nil;		// Create a new file object.	PP_PowerPlant::StDeleter<PP_PowerPlant::LFile>					theFile( new PP_PowerPlant::LFile( inFileSpec ) );		// Open the data fork.	theFile->OpenDataFork( fsRdWrPerm );		// Read the entire file contents and close the file.	PP_PowerPlant::StHandleBlock	theTextH(theFile->ReadDataFork());	theFile->CloseDataFork();		// Put the contents in the text view	// and clear the dirty flag.	mTextView->SetTextHandle( theTextH );	mTextView->SetDirty( false );				// Set the window title to the name of the file and	// flag that the document has an associated file.	mWindow->SetDescriptor( inFileSpec.name );	mIsSpecified = true;	mFile = theFile.Release();}// ---------------------------------------------------------------------------------//		¥ IsModified// ---------------------------------------------------------------------------------BooleanCTextDocument::IsModified(){	// Document has changed if the text view is dirty.	mIsModified = mTextView->IsDirty();	return mIsModified;}// ---------------------------------------------------------------------------------//		¥ DoAESave// ---------------------------------------------------------------------------------voidCTextDocument::DoAESave(	FSSpec	&inFileSpec,	OSType	inFileType ){	// Delete the existing file object.	// Note: this does nothing to the actual file on disk.	delete mFile;	mFile = nil;		// Make a new file object.	mFile = new PP_PowerPlant::LFile( inFileSpec );		// Get the proper file type.	OSType	theFileType = 'TEXT';	if ( inFileType != PP_PowerPlant::fileType_Default ) {		theFileType = inFileType;	}		// Make new file on disk (we'll use	// SimpleText's creator for this example).	mFile->CreateNewDataFile( 'ttxt', theFileType );		// Write out the data.	DoSave();	// Change window title to reflect the new name.	mWindow->SetDescriptor( inFileSpec.name );	// Document now has a specified file.	mIsSpecified = true;}// ---------------------------------------------------------------------------------//		¥ DoSave// ---------------------------------------------------------------------------------voidCTextDocument::DoSave(){	// Open the data fork.	mFile->OpenDataFork( fsRdWrPerm );	// Get the text from the text view.	Handle	theTextH = mTextView->GetTextHandle();		// Lock the text handle.	PP_PowerPlant::StHandleLocker	theLock( theTextH );		// Write the text to the file.	mFile->WriteDataFork( *theTextH, ::GetHandleSize( theTextH ) );	// Close the data fork.	mFile->CloseDataFork();	// Saving makes doc un-dirty.	mTextView->SetDirty( false );}// ---------------------------------------------------------------------------------//		¥ DoRevert// ---------------------------------------------------------------------------------voidCTextDocument::DoRevert(){	// Open the data fork.	mFile->OpenDataFork( fsRdWrPerm );	// Read the entire file contents and close the file.	Handle	theTextH = mFile->ReadDataFork();	mFile->CloseDataFork();		// Put the contents in the text view	// and clear the dirty flag.	mTextView->SetTextHandle( theTextH );	mTextView->SetDirty( false );		// Dispose of the text.	::DisposeHandle( theTextH );	// Refresh the text view.	mTextView->Refresh();}// ---------------------------------------------------------------------------------//		¥ DoPrint// ---------------------------------------------------------------------------------voidCTextDocument::DoPrint(){	// Create the printout.	PP_PowerPlant::StDeleter<PP_PowerPlant::LPrintout>						thePrintout(PP_PowerPlant::LPrintout::CreatePrintout( PPob_TextPrintout ));	ThrowIfNil_(thePrintout.Get());		// Set the print record.		if (mPrintRecordH) {		thePrintout->SetPrintRecord( mPrintRecordH );	}		// Get the text placeholder.	PP_PowerPlant::LPlaceHolder	*thePlaceholder;	thePlaceholder = dynamic_cast<PP_PowerPlant::LPlaceHolder*>							(thePrintout->FindPaneByID( kTextPlaceholder ));	ThrowIfNil_(thePlaceholder);		// Install the text view in the placeholder.	thePlaceholder->InstallOccupant( mTextView, atNone );		// Set the frame size.	SetPrintFrameSize();		// Print.	thePrintout->DoPrintJob();		// Delete the printout (handled automatically by the	// StDeleter object). The text view is returned	// to the window when the placeholder is destroyed.}// ---------------------------------------------------------------------------------//		¥ SetPrintFrameSize// ---------------------------------------------------------------------------------voidCTextDocument::SetPrintFrameSize(){	// Get the frame size.	PP_PowerPlant::SDimension16	theFrameSize;	mTextView->GetFrameSize( theFrameSize );		// Get the text edit record handle.	TEHandle	theTextEditH = mTextView->GetMacTEH();		// Calculate the number of lines per page.	SInt16	theLinesPerPage;	theLinesPerPage = theFrameSize.height / (**theTextEditH).lineHeight;	// Resize the frame to an integral number of lines.	mTextView->ResizeFrameTo( theFrameSize.width,		(**theTextEditH).lineHeight * theLinesPerPage, false );}// ---------------------------------------------------------------------------//	¥ GetFileType													  [public]// ---------------------------------------------------------------------------//	Return the type (four character code) of the file used for saving//	the Document. Subclasses should override if they support saving files.OSTypeCTextDocument::GetFileType() const{	return FOUR_CHAR_CODE('TEXT');}