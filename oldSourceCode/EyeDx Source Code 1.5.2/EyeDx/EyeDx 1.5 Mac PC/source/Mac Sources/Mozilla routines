620 //-----------------------------------621 OSErr CFileMgr::FSSpecFromPathname(const char* inPathNamePtr, FSSpec* outSpec)622 // FSSpecFromPathname reverses PathNameFromFSSpec.623 // It returns a FSSpec given a c string which is a mac pathname.624 //-----------------------------------625 {626     // Simplify this routine to use FSMakeFSSpec if length < 255. Otherwise use the MoreFiles627     // routine FSpLocationFromFullPath, which allocates memory, to handle longer pathnames. 628     if (strlen(inPathNamePtr) < 255)629         return ::FSMakeFSSpec(0, 0, CStr255(inPathNamePtr), outSpec);630     return FSpLocationFromFullPath(strlen(inPathNamePtr), inPathNamePtr, outSpec);631 } // CFileMgr::FSSpecFromPathname756 void  SwapSlashColon(char * s)757 // Swaps ':' with '/'758 //-----------------------------------759 {760     while ( *s != 0)761     {762         if (*s == '/')763             *s++ = ':';764         else if (*s == ':')765             *s++ = '/';766         else767             *s++;768     }769 }770 849 //-----------------------------------850 char*  CFileMgr::MacPathFromUnixPath(const char* unixPath)851 //-----------------------------------852 {853     // Relying on the fact that the unix path is always longer than the mac path:854     size_t len = XP_STRLEN(unixPath);855     char* result = (char*)XP_ALLOC(len + 2); // ... but allow for the initial colon in a partial name856     if (result)857     {858         char* dst = result;859         const char* src = unixPath;860         if (*src == '/')            // ´ full path861             src++;862         else if (strchr(src, '/'))  // ´ partial path, and not just a leaf name863             *dst++ = ':';864         XP_STRCPY(dst, src);865         NET_UnEscape(dst);  // Hex Decode866         SwapSlashColon(dst);867     }868     return result;869 } // CFileMgr::MacPathFromUnixPath870 871 //-----------------------------------872 OSErr CFileMgr::FSSpecFromLocalUnixPath(873     const char * unixPath,874     FSSpec * inOutSpec,875     Boolean resolveAlias)876 // File spec from URL. Reverses GetURLFromFileSpec 877 // Its input is only the <path> part of the URL878 // JRM 97/01/08 changed this so that if it's a partial path (doesn't start with '/'),879 // then it is combined with inOutSpec's vRefNum and parID to form a new spec.880 //-----------------------------------881 {882     if (unixPath == NULL)883         return badFidErr;884     char* macPath = MacPathFromUnixPath(unixPath);885     if (!macPath)886         return memFullErr;887 888     OSErr err = noErr;889     if (*unixPath == '/' /*full path*/)890         err = FSSpecFromPathname(macPath, inOutSpec);891     else892         err = ::FSMakeFSSpec(inOutSpec->vRefNum, inOutSpec->parID, CStr255(macPath), inOutSpec);893     if (err == fnfErr)894         err = noErr;895     Boolean dummy, dummy2;  896     if (err == noErr && resolveAlias)   // Added 897         err = ::ResolveAliasFile(inOutSpec,TRUE,&dummy,&dummy2);898     XP_FREE(macPath);899     Assert_(err==noErr||err==fnfErr||err==dirNFErr||err==nsvErr);900     return err;901 } // CFileMgr::FSSpecFromLocalUnixPath