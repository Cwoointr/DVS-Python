#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>#include "globals.h"#include "CDocumentApp.h"#include <StandardFile.h>#include <NumberFormatting.h>#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <UTextTraits.h>#include <UStandardDialogs.h>#include "EyeDxMacConstants.h"#include "USubFolderFinder.h"#include <path2fss.h>#include "FileCopy.h"#include "MoreFiles.h"#include "MoreFilesExtras.h"#include "FullPath.h"#include "Mozilla.h"extern long DebugFeatures;extern long AdvancedFeatures;#define XP_ALLOC(x)			malloc(x)#define XP_FREE(x)			free(x)#define XP_STRCPY(x, y)		strcpy(x, y)#define XP_MEMCPY(d, s, n)  memcpy((d), (s), (n))#define	XP_STRLEN(x)		strlen(x)#define	XP_STRDUP(x)		strdup(x)#define URL_XALPHAS     (unsigned char) 1#define URL_XPALPHAS    (unsigned char) 2#define URL_PATH        (unsigned char) 4// beard:  brought over from mkparse.c to break dependency./* encode illegal characters into % escaped hex codes. * * mallocs and returns a string that must be freed */static int netCharType[256] =/*      Bit 0           xalpha          -- the alphas**      Bit 1           xpalpha         -- as xalpha but **                             converts spaces to plus and plus to %20**      Bit 3 ...       path            -- as xalphas but doesn't escape '/'*/    /*   0 1 2 3 4 5 6 7 8 9 A B C D E F */    {    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,       /* 0x */         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,       /* 1x */         0,0,0,0,0,0,0,0,0,0,7,4,0,7,7,4,       /* 2x   !"#$%&'()*+,-./  */         7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,       /* 3x  0123456789:;<=>?  */         0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,   /* 4x  @ABCDEFGHIJKLMNO  */        /* bits for '@' changed from 7 to 0 so '@' can be escaped   */        /* in usernames and passwords in publishing.                */         7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,7,   /* 5X  PQRSTUVWXYZ[\]^_  */         0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,   /* 6x  `abcdefghijklmno  */         7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,   /* 7X  pqrstuvwxyz{\}~  DEL */         0, };#define HEX_ESCAPE '%'#define IS_OK(C) (netCharType[((unsigned int) (C))] & (mask))#define int32 longchar *NET_EscapeBytes (const char * str, int32 len, int mask, int32 * out_len){    const unsigned char *src;    unsigned char *dst;    char        *result;    int32       i, extra = 0;    char        *hexChars = "0123456789ABCDEF";        if(!str)                return(0);        src = (unsigned char *) str;    for(i = 0; i < len; i++)          {        if (!IS_OK(src[i]))            extra+=2; /* the escape, plus an extra byte for each nibble */          }    if(!(result = (char *) XP_ALLOC(len + extra + 1)))        return(0);    dst = (unsigned char *) result;    for(i = 0; i < len; i++)          {                unsigned char c = src[i];                if (IS_OK(c))                  {                        *dst++ = c;                  }                else if(mask == URL_XPALPHAS && c == ' ')                  {                        *dst++ = '+'; /* convert spaces to pluses */                  }                else                   {                        *dst++ = HEX_ESCAPE;                        *dst++ = hexChars[c >> 4];              /* high nibble */                        *dst++ = hexChars[c & 0x0f];    /* low nibble */                  }          }    *dst = '\0';     /* tack on eos */        if(out_len)                *out_len = dst - (unsigned char *) result;    return result;}char *NET_Escape (const char * str, int mask){    if(!str)        return NULL;    return NET_EscapeBytes (str, (int32)XP_STRLEN(str), mask, NULL);}//-----------------------------------OSErr FSSpecFromPathname(const char* inPathNamePtr, FSSpec* outSpec)// FSSpecFromPathname reverses PathNameFromFSSpec.// It returns a FSSpec given a c string which is a mac pathname.//-----------------------------------{    // Simplify this routine to use FSMakeFSSpec if length < 255. Otherwise use the MoreFiles    // routine FSpLocationFromFullPath, which allocates memory, to handle longer pathnames.     if (strlen(inPathNamePtr) < 255)        return ::FSMakeFSSpec(0, 0, LStr255(inPathNamePtr), outSpec);    return FSpLocationFromFullPath(strlen(inPathNamePtr), inPathNamePtr, outSpec);} // FSSpecFromPathnamevoid  SwapSlashColon(char * s)// Swaps ':' with '/'//-----------------------------------{    while ( *s != 0)    {        if (*s == '/')            *s++ = ':';        else if (*s == ':')            *s++ = '/';        else            *s++;    }}//-----------------------------------char*  MacPathFromUnixPath(const char* unixPath)//-----------------------------------{    // Relying on the fact that the unix path is always longer than the mac path:    size_t len = XP_STRLEN(unixPath);    char* result = (char*)XP_ALLOC(len + 2); // ... but allow for the initial colon in a partial name    if (result)    {        char* dst = result;        const char* src = unixPath;        if (*src == '/')            // ´ full path            src++;        else if (strchr(src, '/'))  // ´ partial path, and not just a leaf name            *dst++ = ':';        XP_STRCPY(dst, src);        //NET_UnEscape(dst);  // Hex Decode        SwapSlashColon(dst);    }    return result;} // MacPathFromUnixPath//-----------------------------------char* EncodeMacPath( char* inPath, Boolean prependSlash = true)//  Transforms Macintosh style path into Unix one//  Method: Swap ':' and '/', hex escape the result//-----------------------------------{    if (inPath == NULL)        return NULL;    int pathSize = XP_STRLEN(inPath);        // XP code sometimes chokes if there's a final slash in the unix path.    // Since correct mac paths to folders and volumes will end in ':', strip this    // first.    char* c = inPath + pathSize - 1;    if (*c == ':')    {        *c = 0;        pathSize--;    }    char * newPath = NULL;    char * finalPath = NULL;         if (prependSlash)    {        newPath = (char*) XP_ALLOC(pathSize + 2);        newPath[0] = ':';   // It will be converted to '/'        XP_MEMCPY(&newPath[1], inPath, pathSize + 1);    }    else    {    	newPath = (char *)XP_ALLOC(strlen(inPath));    	strcpy(newPath, inPath);    }    if (newPath)    {        SwapSlashColon( newPath );        finalPath = NET_Escape(newPath, URL_PATH);        XP_FREE(newPath);           }    XP_FREE( inPath );    return finalPath;} // CFileMgr::EncodeMacPath //-----------------------------------char* PathNameFromFSSpec( const FSSpec& inSpec, Boolean wantLeafName )// Returns a full pathname to the given file// Returned value is allocated with XP_ALLOC, and must be freed with XP_FREE// This is taken from FSpGetFullPath in MoreFiles, except that we need to tolerate// fnfErr.//-----------------------------------{       char* result = nil;    FSSpec tempSpec;    OSErr err = noErr;        short fullPathLength = 0;    Handle fullPath = NULL;        /* Make a copy of the input FSSpec that can be modified */    BlockMoveData(&inSpec, &tempSpec, sizeof(FSSpec));        if ( tempSpec.parID == fsRtParID )    {        /* The object is a volume */                /* Add a colon to make it a full pathname */        ++tempSpec.name[0];        tempSpec.name[tempSpec.name[0]] = ':';                /* We're done */        err = PtrToHand(&tempSpec.name[1], &fullPath, tempSpec.name[0]);    }    else    {        /* The object isn't a volume */                CInfoPBRec  pb = { 0 };        Str63 dummyFileName = "\pGrippy Lives!";        /* Is the object a file or a directory? */        pb.dirInfo.ioNamePtr = (! tempSpec.name[0] ) ? (StringPtr)dummyFileName : tempSpec.name;        pb.dirInfo.ioVRefNum = tempSpec.vRefNum;        pb.dirInfo.ioDrDirID = tempSpec.parID;        pb.dirInfo.ioFDirIndex = 0;        err = PBGetCatInfoSync(&pb);        if ( err == noErr || err == fnfErr)        {            // if the object is a directory, append a colon so full pathname ends with colon            // Beware of the "illegal spec" case that Netscape uses (empty name string). In            // this case, we don't want the colon.            if ( err == noErr && tempSpec.name[0] && (pb.hFileInfo.ioFlAttrib & ioDirMask) != 0 )            {                ++tempSpec.name[0];                tempSpec.name[tempSpec.name[0]] = ':';            }                        /* Put the object name in first */            err = PtrToHand(&tempSpec.name[1], &fullPath, tempSpec.name[0]);            if ( err == noErr )            {                /* Get the ancestor directory names */                pb.dirInfo.ioNamePtr = tempSpec.name;                pb.dirInfo.ioVRefNum = tempSpec.vRefNum;                pb.dirInfo.ioDrParID = tempSpec.parID;                do  /* loop until we have an error or find the root directory */                {                    pb.dirInfo.ioFDirIndex = -1;                    pb.dirInfo.ioDrDirID = pb.dirInfo.ioDrParID;                    err = PBGetCatInfoSync(&pb);                    if ( err == noErr )                    {                        /* Append colon to directory name */                        ++tempSpec.name[0];                        tempSpec.name[tempSpec.name[0]] = ':';                                                /* Add directory name to beginning of fullPath */                        (void) Munger(fullPath, 0, NULL, 0, &tempSpec.name[1], tempSpec.name[0]);                        err = MemError();                    }                } while ( err == noErr && pb.dirInfo.ioDrDirID != fsRtDirID );            }        }    }    if ( err != noErr && err != fnfErr)        goto Clean;    fullPathLength = GetHandleSize(fullPath);    err = noErr;        int allocSize = 1 + fullPathLength;    // We only want the leaf name if it's the root directory or wantLeafName is true.    if (inSpec.parID != fsRtParID && !wantLeafName)        allocSize -= inSpec.name[0];    result = (char*)XP_ALLOC(allocSize);    if (!result)        goto Clean;    memcpy(result, *fullPath, allocSize - 1);    result[ allocSize - 1 ] = 0;Clean:    if (fullPath)        DisposeHandle(fullPath);    Assert_(result); // OOPS! very bad.    return result;} // CFileMgr::PathNameFromFSSpec// PathNameFromFSSpec + hex encoding// pass this in to netlib when specifying filesToPost, etchchar* EncodedPathNameFromFSSpec( const FSSpec& inSpec, Boolean wantLeafName ){    char* path = PathNameFromFSSpec( inSpec, wantLeafName );    path = EncodeMacPath( path );    return path;}//-----------------------------------OSErr FSSpecFromLocalUnixPath(    const char * unixPath,    FSSpec * inOutSpec,    Boolean resolveAlias)// File spec from URL. Reverses GetURLFromFileSpec // Its input is only the <path> part of the URL// JRM 97/01/08 changed this so that if it's a partial path (doesn't start with '/'),// then it is combined with inOutSpec's vRefNum and parID to form a new spec.//-----------------------------------{    if (unixPath == NULL)        return badFidErr;    char* macPath = MacPathFromUnixPath(unixPath);    if (!macPath)        return memFullErr;		Str255 theMacPath;		c2pstrcpy(theMacPath, macPath);	    OSErr err = noErr;    if (*unixPath == '/' /*full path*/)        err = FSSpecFromPathname(macPath, inOutSpec);    else        err = ::FSMakeFSSpec(inOutSpec->vRefNum, inOutSpec->parID, theMacPath, inOutSpec);    if (err == fnfErr)        err = noErr;    Boolean dummy, dummy2;      if (err == noErr && resolveAlias)   // Added         err = ::ResolveAliasFile(inOutSpec,TRUE,&dummy,&dummy2);    XP_FREE(macPath);    Assert_(err==noErr||err==fnfErr||err==dirNFErr||err==nsvErr);    return err;} // FSSpecFromLocalUnixPath//-----------------------------------char * GetURLFromFileSpec(const FSSpec& inSpec)//-----------------------------------/* GetURLFromFileSpec generates a local file URL given a file spec.    Requirements:        Unix-style file name (':' is replaced with '/')        url looks like file:///<path>        <path> is mac path, where all reserved characters (= | ; | / | # | ? | space)        have been escaped. (except :).        ':' is then changed to '/' for compatibility with UNIX style file names.        Input:        Valid FSSpec            Method:        Generate a full path name    Notes:        This does not guarantee that the filename will work. We may still need to        munge it later (if for example such a filename already existed)*/{    char * path = PathNameFromFSSpec( inSpec, TRUE );    char * unixPath = EncodeMacPath(path);    char * finalPath = (char*)XP_ALLOC(strlen(unixPath) + 8 + 1);   //  file:///<path>0    if ( finalPath == NULL )        return NULL;    finalPath[0] = 0;    if ( unixPath == NULL )        return NULL;    strcat(finalPath, "file://");    strcat(finalPath, unixPath);    XP_FREE(unixPath);    return finalPath;}