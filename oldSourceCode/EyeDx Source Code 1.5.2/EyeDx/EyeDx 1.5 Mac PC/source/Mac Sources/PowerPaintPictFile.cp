// ---------------------------------------------------------------------------------//	PowerPaintPictFile.cp				//// Author: Josh Luben [josh@hax.com]//// Copyright © 1997 Tree Star Software. // All rights reserved.//// ---------------------------------------------------------------------------------#include "PowerPaintPictFile.h"// ---------------------------------------------------------------------------------PowerPaintPictFile::PowerPaintPictFile( FSSpec &file ) : LFile( file ){	mFileHeader = nil;	mThePicture = nil;}// ---------------------------------------------------------------------------------PowerPaintPictFile::~PowerPaintPictFile(){	// ¥ Dispose our saved headers and picture.	if ( mFileHeader )		::DisposeHandle( mFileHeader );	if ( mThePicture )		::DisposeHandle( (Handle)mThePicture );}// ---------------------------------------------------------------------------------void			PowerPaintPictFile::GetFileType( OSType &type ){	OSErr			err;	FInfo			info;	FSSpec			file;		GetSpecifier( file );	err = ::FSpGetFInfo( &file, &info );	ThrowIfOSErr_( err );		type = info.fdType;}// ---------------------------------------------------------------------------------PicHandle		PowerPaintPictFile::ReadPicture(){		PicHandle		pict = nil;	Handle			data = nil;	Ptr				temp;	Uint32			size;		// ¥ Looks like we already loaded the picture so return a PicHandle.	if ( mThePicture )		return mThePicture;			SInt32 dataForkRefNum = OpenDataFork( fsRdPerm );		// We want to use temporary memory, not application memory, since the file may be huge		SInt32	fileLength;	OSErr	err = ::GetEOF(dataForkRefNum, &fileLength);	ThrowIfOSErr_(err);		data = ::TempNewHandle(fileLength, &err);	ThrowIfOSErr_(err);		err = ::SetFPos(dataForkRefNum, fsFromStart, 0);	ThrowIfOSErr_(err);		err = ::FSRead(dataForkRefNum, &fileLength, *data);	ThrowIfOSErr_(err);		CloseDataFork();	if ( !data )		return nil;		StHandleLocker	*dataLock = new StHandleLocker( data );		size = ::GetHandleSize( data );	size -= 512;		OSErr theResult;		// ¥ Copy the 512 byte header.	mFileHeader = ::TempNewHandle( 512, &theResult );	ThrowIfOSErr_( theResult );	StHandleLocker	hdrLock( mFileHeader );	::BlockMoveData( *data, *mFileHeader, 512 );	ThrowIfMemError_();		// ¥ Copy the rest of the picture.	pict = (PicHandle)TempNewHandle( size, &theResult );	ThrowIfOSErr_( theResult );	StHandleLocker	pictLock( (Handle)pict );	temp = (Ptr)(*data + 512);	::BlockMoveData( temp, *pict, size );	ThrowIfMemError_();		delete dataLock;	::DisposeHandle( data );	ThrowIfMemError_();		mBounds = (*pict)->picFrame;	mThePicture = pict;	return pict;}// ---------------------------------------------------------------------------------void			PowerPaintPictFile::WritePicture(PicHandle pict){	StHandleLocker	pictLock((Handle)pict);	Size			size = ::GetHandleSize((Handle)pict);	Handle			buffer;		// ¥ If we have saved the last PicHandle, then delete it, and	// copy the new one.	if ( mThePicture )	{		// ¥ Resize the handle to accomodate the new picture.		::SetHandleSize( (Handle)mThePicture, size );		ThrowIfMemError_();		StHandleLocker	pictLock((Handle)mThePicture);		// ¥ Now copy.		::BlockMoveData( *pict, *mThePicture, size );	}		OSErr theResult;	buffer = ::TempNewHandle( size+512, &theResult );	ThrowIfOSErr_(theResult);	StHandleLocker	*bufferLock = new StHandleLocker(buffer);		if ( mFileHeader )	{		StHandleLocker	pictLock( mFileHeader );			::BlockMoveData( *mFileHeader, *buffer, 512 );	}		::BlockMoveData( *pict, (*buffer+512), size );	ThrowIfMemError_();		OpenDataFork( fsRdWrPerm );	WriteDataFork( *buffer, size+512 );	CloseDataFork();		delete bufferLock;	::DisposeHandle(buffer);}// ---------------------------------------------------------------------------------void			PowerPaintPictFile::GetHeader( Handle &theHeader ) const{	if ( !mFileHeader )		return;			OSErr theResult;	theHeader = ::TempNewHandle( 512, &theResult );	ThrowIfOSErr_( theResult );		StHandleLocker	desthdrLock( theHeader );	StHandleLocker	hdrLock( mFileHeader );		::BlockMoveData( *mFileHeader, *theHeader, 512 );	ThrowIfMemError_();}// ---------------------------------------------------------------------------------void			PowerPaintPictFile::SetHeader( Handle theHeader ){	Uint32		theSize;		ThrowIfNil_( theHeader );		theSize = ::GetHandleSize( theHeader );	ThrowIf_( theSize != 512 );		StHandleLocker	hdrLock( theHeader );	StHandleLocker	desthdrLock( mFileHeader );		OSErr theResult;	mFileHeader = ::TempNewHandle( 512, &theResult );	ThrowIfOSErr_( theResult );		::BlockMoveData( *theHeader, *mFileHeader, 512 );	ThrowIfMemError_();}