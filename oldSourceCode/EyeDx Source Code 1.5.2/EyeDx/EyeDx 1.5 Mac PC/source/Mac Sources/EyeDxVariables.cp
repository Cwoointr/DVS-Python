// =================================================================================//	EyeDxVariables.cp// =================================================================================//	EyeDxVariables.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>#include <limits.h>#include "globals.h"#include "EyeDxVariables.h"// ===========================================================================//	¥ CLStr255Comparator// ===========================================================================//	Compares LStr255's namesCLStr255Comparator*	CLStr255Comparator::sCLStr255Comparator = nil;CLStr255Comparator::CLStr255Comparator(){}CLStr255Comparator::~CLStr255Comparator(){}SInt32CLStr255Comparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	LStr255 **OneString = (LStr255 **) inItemOne;	LStr255 **TwoString = (LStr255 **) inItemTwo;	return (LString::CompareBytes((*OneString)->TextPtr(), 							 	  (*TwoString)->TextPtr(), 							  	  (*OneString)->Length(),							  	  (*TwoString)->Length()));}BooleanCLStr255Comparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	LStr255 **OneString = (LStr255 **) inItemOne;	LStr255 **TwoString = (LStr255 **) inItemTwo;	return (LString::CompareBytes((*OneString)->TextPtr(), 							   	  (*TwoString)->TextPtr(), 							  	  (*OneString)->Length(),							   	  (*TwoString)->Length()) == 0);								  }CLStr255Comparator*CLStr255Comparator::GetComparator(){	if (sCLStr255Comparator == nil) 	{		sCLStr255Comparator = new CLStr255Comparator();		ThrowIfNil_(sCLStr255Comparator);	}	return sCLStr255Comparator;}LComparator*CLStr255Comparator::Clone(){	return new CLStr255Comparator();}// ---------------------------------------------------------------------------------//		¥ CEyeDxVariable()// ---------------------------------------------------------------------------------CEyeDxVariable::CEyeDxVariable(CEyeDxVariable::VariableClass theClass){	Init(theClass, 		 CEyeDxVariable::kFixed,		 "\pNew Variable",		 Str_Empty,		 CEyeDxVariable::kPromptNone,		 CEyeDxVariable::kTypeNone,		 false,		 Str_Empty,		 Str_Empty,		 kNoPromptOrder,		 kNoExportOrder,		 0,		 false);}CEyeDxVariable::CEyeDxVariable(){	Init(CEyeDxVariable::kEyeDx, 		 CEyeDxVariable::kFixed,		 "\pNew Variable",		 Str_Empty,		 CEyeDxVariable::kPromptNone,		 CEyeDxVariable::kTypeNone,		 false,		 Str_Empty,		 Str_Empty,		 kNoPromptOrder,		 kNoExportOrder,		 0,		 false);}CEyeDxVariable::CEyeDxVariable(const CEyeDxVariable &srcVariable){	Init(srcVariable.mVariableClass, 		 srcVariable.mVariableType,		 srcVariable.mName,		 srcVariable.mPromptString,		 srcVariable.mPromptType,		 srcVariable.mDataType,		 srcVariable.mValueMustBeEntered,		 srcVariable.mDefaultValue,		 srcVariable.mCommentString,		 srcVariable.mPromptOrder,		 srcVariable.mExportOrder,		 srcVariable.mExtraEntryLines,		 srcVariable.mIsHidden,		 srcVariable.mOptionStrings);}CEyeDxVariable& CEyeDxVariable::operator=(const CEyeDxVariable &srcVariable){	// This handles the case where the statement "var = var;" is written		if (this != &srcVariable)	{		 // We must copy the input's list of option strings, and the strings themselves.		 // First, we delete our own strings if they exist.		 		CEyeDxShortStringType *theString;				long numChoices = mOptionStrings->GetCount();				TArrayIterator<CEyeDxShortStringType *> iterator(*mOptionStrings);				while (iterator.Next(theString))			delete theString;					// Now we delete our option strings object - the Init function will create a new one				delete mOptionStrings;				Init(srcVariable.mVariableClass, 			 srcVariable.mVariableType,			 srcVariable.mName,			 srcVariable.mPromptString,			 srcVariable.mPromptType,			 srcVariable.mDataType,			 srcVariable.mValueMustBeEntered,			 srcVariable.mDefaultValue,			 srcVariable.mCommentString,			 srcVariable.mPromptOrder,			 srcVariable.mExportOrder,			 srcVariable.mExtraEntryLines,			 srcVariable.mIsHidden,			 srcVariable.mOptionStrings);	}		 	return *this;	}CEyeDxVariable::CEyeDxVariable(CEyeDxLongStringType *theName, EyeDxVariablePrefs *srcVariable){	Init((CEyeDxVariable::VariableClass) srcVariable->varClass, 		(CEyeDxVariable::VariableType) srcVariable->varType,		 *theName,		 srcVariable->promptString,		 (CEyeDxVariable::PromptType) srcVariable->promptType,		 (CEyeDxVariable::DataType) srcVariable->dataType,		 srcVariable->valueMustBeEntered,		 srcVariable->defaultValue,		 srcVariable->commentString,		 srcVariable->promptOrder,		 srcVariable->exportOrder,		 srcVariable->extraEntryLines,		 srcVariable->hidden);}CEyeDxVariable::CEyeDxVariable(CEyeDxVariable::VariableClass theClass,							 CEyeDxLongStringType theName,							 CEyeDxShortStringType thePromptString,							 CEyeDxVariable::PromptType thePromptType,							 CEyeDxVariable::DataType theDataType,							 CEyeDxBooleanType theValueMustBeEntered,							 CEyeDxShortStringType theDefaultValue,							 CEyeDxShortStringType theCommentString,							 short thePromptOrder,							 short theExportOrder,							 short theExtraEntryLines){	Init(theClass, 		 CEyeDxVariable::kPrompted,		 theName,		 thePromptString,		 thePromptType,		 theDataType,		 theValueMustBeEntered,		 theDefaultValue,		 theCommentString,		 thePromptOrder,		 theExportOrder,		 theExtraEntryLines,		 false);}CEyeDxVariable::CEyeDxVariable(CEyeDxVariable::VariableClass theClass,							 CEyeDxLongStringType theName,							 CEyeDxLongStringType theValue,							 CEyeDxShortStringType theCommentString,							 short theExportOrder){	Init(theClass, 		 CEyeDxVariable::kFixed,		 theName,		 Str_Empty,		 CEyeDxVariable::kPromptNone,		 CEyeDxVariable::kTypeNone,		 false,		 theValue,		 theCommentString,		 kNoPromptOrder,		 theExportOrder,		 0,		 false);}void CEyeDxVariable::Init(CEyeDxVariable::VariableClass theClass,						 CEyeDxVariable::VariableType theType,							 CEyeDxLongStringType theName,							 CEyeDxShortStringType thePromptString,							 CEyeDxVariable::PromptType thePromptType,							 CEyeDxVariable::DataType theDataType,							 CEyeDxBooleanType theValueMustBeEntered,							 CEyeDxShortStringType theDefaultValue,							 CEyeDxShortStringType theCommentString,							 short thePromptOrder,							 short theExportOrder,							 short theExtraEntryLines,							 CEyeDxBooleanType theIsHidden,							 CTemplateShortStrArray *theOptionsList){	mVariableClass = theClass;	mVariableType = theType;	mPromptType = thePromptType;	mDataType = theDataType;	LString::CopyPStr(theName, mName);	LString::CopyPStr(theDefaultValue, mDefaultValue);	LString::CopyPStr(mDefaultValue, mValue);	LString::CopyPStr(thePromptString, mPromptString);	LString::CopyPStr(theCommentString, mCommentString);	mPromptOrder = thePromptOrder;	mExportOrder = theExportOrder;	mValueMustBeEntered = theValueMustBeEntered;	mIsHidden = theIsHidden;	mExtraEntryLines = theExtraEntryLines;		// We always create the list - it simplifies things elsewhere (especially when editing variables)		mOptionStrings = new CTemplateShortStrArray(CLStr255Comparator::GetComparator(), false);	ThrowIfNil_(mOptionStrings);	if (theOptionsList && (GetDataType() == CEyeDxVariable::kMenu))	{		// Now we have an empty list - add the strings from the input variable, making copies of		// them as we go				CEyeDxShortStringType *theString;				TArrayIterator<CEyeDxShortStringType *> iterator(*theOptionsList);		 			 		while (iterator.Next(theString))		{			CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(*theString);							mOptionStrings->AddItem(theStringCopy);		}				// We also want to force the default value to be one of the values in the array. If not found,		// the default becomes the first value.				ValidateDefault();	}}// This routine will make sure that the default value in a menu type item is a member of the// Options List. If not, the first item in the list is made the default, overriding the previous// value. This can be called after the options list is manipulated by application code to make// sure everything is in sync.void CEyeDxVariable::ValidateDefault(){	if (mOptionStrings && (GetDataType() == CEyeDxVariable::kMenu))	{		CEyeDxShortStringType *theString;				TArrayIterator<CEyeDxShortStringType *> iterator(*mOptionStrings);		 			 		long theDefaultItem = 1;		long theItem = 1;		while (iterator.Next(theString))		{			if (*theString== *(GetDefaultValue()))				theDefaultItem = theItem;			theItem++;		}				// We also want to force the default value to be one of the values in the array. If not found,		// the default becomes the first value.				CEyeDxShortStringType *theDefaultItemStr;				mOptionStrings->FetchItemAt(theDefaultItem, theDefaultItemStr);		SetDefaultValue(*theDefaultItemStr);	}}void CEyeDxVariable::ResetValue(){#ifdef macintosh	Str255 theString;	unsigned long theDate;#else	CTime theCurrentTime;#endif			switch (mDataType)	{	case kTypeNone:			// For these we just use the default value	case kGeneralString:	case kPastDate:			// Not really any good value for this - just use default	case kCheckBox:	case kMenu:		SetValueToDefault();		break;			case kDate:#ifdef macintosh		::GetDateTime(&theDate);				::DateString(theDate, abbrevDate, theString, nil);				SetValue(theString);	#else		theCurrentTime = CTime::GetCurrentTime();				SetValue(theCurrentTime.Format("%x"));#endif								break;				case kTime:	// For time variables, we set the value to the current time#ifdef macintosh		::GetDateTime(&theDate);				::TimeString(theDate, true, theString, nil);			SetValue(theString);#else		theCurrentTime = CTime::GetCurrentTime();						SetValue(theCurrentTime.Format("%X"));#endif			break;	case kIntegerNumber:	// For integers and floats, we set the value to zero	case kFloatNumber:			SetValue(0);		break;			}					}// ---------------------------------------------------------------------------------//		¥ ~CEyeDxVariable// ---------------------------------------------------------------------------------CEyeDxVariable::~CEyeDxVariable(){	// Clean up the allocated option strings		if (mOptionStrings)	{		TArrayIterator<CEyeDxShortStringType *> iterator(*mOptionStrings);				CEyeDxShortStringType *theString;				// Deallocate the strings				while (iterator.Next(theString))			delete theString;	}		delete mOptionStrings;}// ===========================================================================//	¥ EyeDxVariableComparators// ===========================================================================//	Compares CEyeDxVariable namesEyeDxVariableNameComparator*	EyeDxVariableNameComparator::sEyeDxVariableNameComparator = nil;EyeDxVariableNameComparator::EyeDxVariableNameComparator(){}EyeDxVariableNameComparator::~EyeDxVariableNameComparator(){}SInt32EyeDxVariableNameComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;	OneString = (*One)->GetName();	TwoString = (*Two)->GetName();	return (LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length()));}BooleanEyeDxVariableNameComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;		OneString = (*One)->GetName();	TwoString = (*Two)->GetName();	return (LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length()) == 0);								  }EyeDxVariableNameComparator*EyeDxVariableNameComparator::GetComparator(){	if (sEyeDxVariableNameComparator == nil) 	{		sEyeDxVariableNameComparator = new EyeDxVariableNameComparator();		ThrowIfNil_(sEyeDxVariableNameComparator);	}	return sEyeDxVariableNameComparator;}LComparator*EyeDxVariableNameComparator::Clone(){	return new EyeDxVariableNameComparator();}// ===========================================================================//	¥ EyeDxVariablePromptComparator// ===========================================================================//	Compares CEyeDxVariable dialog prompt orderEyeDxVariablePromptComparator*	EyeDxVariablePromptComparator::sEyeDxVariablePromptComparator = nil;EyeDxVariablePromptComparator::EyeDxVariablePromptComparator(){}EyeDxVariablePromptComparator::~EyeDxVariablePromptComparator(){}SInt32EyeDxVariablePromptComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OnePromptOrder;	short TwoPromptOrder;		OnePromptOrder = (*One)->GetPromptOrder();	TwoPromptOrder = (*Two)->GetPromptOrder();		return (OnePromptOrder - TwoPromptOrder);}BooleanEyeDxVariablePromptComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OnePromptOrder;	short TwoPromptOrder;		OnePromptOrder = (*One)->GetPromptOrder();	TwoPromptOrder = (*Two)->GetPromptOrder();		return (OnePromptOrder == TwoPromptOrder);}EyeDxVariablePromptComparator*EyeDxVariablePromptComparator::GetComparator(){	if (sEyeDxVariablePromptComparator == nil) 	{		sEyeDxVariablePromptComparator = new EyeDxVariablePromptComparator();		ThrowIfNil_(sEyeDxVariablePromptComparator);	}	return sEyeDxVariablePromptComparator;}LComparator*EyeDxVariablePromptComparator::Clone(){	return new EyeDxVariablePromptComparator();}// ===========================================================================//	¥ EyeDxVariableExportComparator// ===========================================================================//	Compares CEyeDxVariable dialog prompt orderEyeDxVariableExportComparator*	EyeDxVariableExportComparator::sEyeDxVariableExportComparator = nil;EyeDxVariableExportComparator::EyeDxVariableExportComparator(){}EyeDxVariableExportComparator::~EyeDxVariableExportComparator(){}SInt32EyeDxVariableExportComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneExportOrder;	short TwoExportOrder;		OneExportOrder = (*One)->GetExportOrder();	TwoExportOrder = (*Two)->GetExportOrder();		return (OneExportOrder - TwoExportOrder);}BooleanEyeDxVariableExportComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneExportOrder;	short TwoExportOrder;		OneExportOrder = (*One)->GetExportOrder();	TwoExportOrder = (*Two)->GetExportOrder();		return (OneExportOrder == TwoExportOrder);}EyeDxVariableExportComparator*EyeDxVariableExportComparator::GetComparator(){	if (sEyeDxVariableExportComparator == nil) 	{		sEyeDxVariableExportComparator = new EyeDxVariableExportComparator();		ThrowIfNil_(sEyeDxVariableExportComparator);	}	return sEyeDxVariableExportComparator;}LComparator*EyeDxVariableExportComparator::Clone(){	return new EyeDxVariableExportComparator();}// ---------------------------------------------------------------------------------//		¥ EyeDxVariableList members// ---------------------------------------------------------------------------------EyeDxVariableList::EyeDxVariableList(EyeDxVariableList::SortOrder sortOrder){	switch (sortOrder)	{	case kSortByName:		mComparator = new EyeDxVariableNameComparator();		break;		case kSortByPromptOrder:		mComparator = new EyeDxVariablePromptComparator();		break;	case kSortByExportOrder:		mComparator = new EyeDxVariableExportComparator();		break;	}	ThrowIfNil_(mComparator);		mVariableList = new TArray<CEyeDxVariable*> (mComparator, true);	ThrowIfNil_(mVariableList);}EyeDxVariableList::~EyeDxVariableList(){	delete mComparator;	delete mVariableList;}CEyeDxBooleanType EyeDxVariableList::VariableExists(CEyeDxLongStringType Name){	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	CEyeDxVariable *theVariable;		while (iterator.Next(theVariable))	{		if (*(theVariable->GetName()) == Name)			return true;	}	return false;}	void EyeDxVariableList::AddVariable(CEyeDxVariable *theVariable){	mVariableList->AddItem(theVariable);}	void EyeDxVariableList::InsertVariableAt(CEyeDxArrayIndexType theIndex, CEyeDxVariable *theVariable){	mVariableList->InsertItemsAt(1, theIndex, theVariable);}	void EyeDxVariableList::DeleteVariable(CEyeDxVariable *theVariable){	mVariableList->Remove(theVariable);}void EyeDxVariableList::DeleteVariableByName(CEyeDxLongStringType Name){	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	CEyeDxVariable *theVariable;		while (iterator.Next(theVariable))	{		if (*(theVariable->GetName()) == Name)			mVariableList->Remove(theVariable);	}}void EyeDxVariableList::DeleteVariableByIndex(CEyeDxArrayIndexType theIndex){	mVariableList->RemoveItemsAt(1, theIndex);}CEyeDxVariable * EyeDxVariableList::GetVariableByName(CEyeDxLongStringType Name){	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	CEyeDxVariable *theVariable;		while (iterator.Next(theVariable))	{		if (*(theVariable->GetName()) == Name)			return theVariable;	}	return nil;}	CEyeDxVariable * EyeDxVariableList::GetVariableByIndex(long Index){	CEyeDxVariable *theVariable;	mVariableList->FetchItemAt(Index, theVariable);	return (theVariable);}	unsigned long EyeDxVariableList::GetCount(){	return mVariableList->GetCount(); }void EyeDxVariableList::SetAllVariablesToDefault(CEyeDxVariable::VariableType theType,												 CEyeDxVariable::PromptType thePromptType){	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	CEyeDxVariable *theVariable;		while (iterator.Next(theVariable))	{		if ((theVariable->GetVariableType() == theType) &&			(theVariable->GetWhenToPrompt() == thePromptType))			theVariable->SetValueToDefault();	}}// This routine is used to look up variables based on their dialog and prompt order. The first call requires that the// promptType be set, and the specific dialog (0...n) be set as well. The theAfterPromptOrder variable, if set to -1, indicates// that we want the very first variable in the specified dialog. In subsequent calls, we pass in the theAfterPromptOrder parameter// the promptOrder of the variable we have last processed, and the routine will find the next variable. If no variable is found// that meets the criteria, NULL is returned.CEyeDxVariable *EyeDxVariableList::GetNextPromptedVariable(CEyeDxVariable::PromptType promptType, short theAfterPromptOrder){	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	CEyeDxVariable *theVariable;	CEyeDxVariable *theReturnVariable = NULL;	// Look for the variable with the lowest promptOrder in the specified dialog and with the specified promptType that	// is also greater than the passed theAfterPromptOrder value. Note that for the case of theAfterPromptOrder == -1, this	// will find the first (lowest) number prompt in the dialog.		short lowestPromptOrder = SHRT_MAX;		while (iterator.Next(theVariable))	{		if (theVariable->GetWhenToPrompt() == promptType)		{			if ((theVariable->GetPromptOrder() < lowestPromptOrder) && (theVariable->GetPromptOrder() > theAfterPromptOrder))			{				lowestPromptOrder = theVariable->GetPromptOrder();				theReturnVariable = theVariable;			}		}	}	return theReturnVariable;}// This routine, given the promptType and dialog, will get the next unused promptOrder value after the highest// value found. Used to assign new values to variables, and to detect if there are any prompts for the specified dialog.// If not, kNoPromptOrder is returned.short EyeDxVariableList::GetNextAvailablePromptNumber(CEyeDxVariable::PromptType promptType){	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	CEyeDxVariable *theVariable;	// Look for the variable with the highest promptOrder in the specified dialog and with the specified promptType.	// Note that we find the highest - not necessarily the next available! There may be gaps if variables are deleted.		short highestPromptOrder = kNoPromptOrder;		while (iterator.Next(theVariable))	{		if (theVariable->GetWhenToPrompt() == promptType)		{			if ((theVariable->GetPromptOrder() > highestPromptOrder))			{				highestPromptOrder = theVariable->GetPromptOrder();			}		}	}	return highestPromptOrder;}// This routine will parse the current list of prompted variables. For each prompt type, it will// compress the list of prompt order numbers so that there are no gaps.void EyeDxVariableList::CompressPromptOrder(){	CEyeDxVariable *theVariable;	EyeDxVariableList *theSortedList = new EyeDxVariableList(EyeDxVariableList::kSortByPromptOrder);	ThrowIfNil_(theSortedList);	long theVarCount = GetCount();			// For each prompt type, look up all of that type of prompted variable and add them to the list.	// When we have the complete list, set the prompt order in sequential order, and then clear the	// entry from the list. Repeat for each prompt type.		for (short thePromptType = CEyeDxVariable::kPromptOnStart; thePromptType <= CEyeDxVariable::kPromptTypeLast; thePromptType++)	{		// We want to insert elements in sorted order				theSortedList->SetKeepSorted(true);				long promptedCount = 0;		for (long theVarNum = 1; theVarNum <= theVarCount; theVarNum++)		{			theVariable = GetVariableByIndex(theVarNum);						// If this variable is this prompt type, add it to our sorted list						if (theVariable->GetWhenToPrompt() == thePromptType)			{				theSortedList->AddVariable(theVariable);				promptedCount++;							}		}						// Ok, now we have a list of the prompted variables for this prompt type and this dialog.		// Now, renumber them starting at 0. Tell the list to not re-sort as we do this, though				theSortedList->SetKeepSorted(false);				short theNewPromptOrder = 0;		for (long theVarNum = 1; theVarNum <= promptedCount; theVarNum++)		{			theVariable = theSortedList->GetVariableByIndex(theVarNum);						theVariable->SetPromptOrder(theNewPromptOrder++);						}		for (long theVarNum = 1; theVarNum <= promptedCount; theVarNum++)		{			// Just delete the first one over and over till the list is empty						theSortedList->DeleteVariableByIndex(1);		}	}		// We're done with the sorted list - delete it		delete theSortedList;}// This routine is used to look up variables based on their export order. The theAfterExportOrder variable, if set to -1, indicates// that we want the very first variable in the specified dialog. In subsequent calls, we pass in the theAfterExportOrder parameter// the exportOrder of the variable we have last processed, and the routine will find the next variable. If no variable is found// that meets the criteria, NULL is returned.CEyeDxVariable *EyeDxVariableList::GetNextExportedVariable(short theAfterExportOrder){	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	CEyeDxVariable *theVariable;	CEyeDxVariable *theReturnVariable = NULL;	// Look for the variable with the lowest exportOrder that is also greater than the passed theAfterExportOrder 	// value. Note that for the case of theAfterExportOrder == -1, this	// will find the first (lowest) number exported variable.		short lowestExportOrder = SHRT_MAX;		while (iterator.Next(theVariable))	{		if (theVariable->GetExportOrder() != kNoExportOrder)		{			if ((theVariable->GetExportOrder() < lowestExportOrder) && (theVariable->GetExportOrder() > theAfterExportOrder))			{				lowestExportOrder = theVariable->GetExportOrder();				theReturnVariable = theVariable;			}		}	}	return theReturnVariable;}// This routine will parse the current list of exported variables. It will// compress the list of export order numbers so that there are no gaps.void EyeDxVariableList::CompressExportOrder(){	CEyeDxVariable *theVariable;	EyeDxVariableList *theSortedList = new EyeDxVariableList(EyeDxVariableList::kSortByExportOrder);	ThrowIfNil_(theSortedList);	long theVarCount = GetCount();					long exportedCount = 0;	for (long theVarNum = 1; theVarNum <= theVarCount; theVarNum++)	{		theVariable = GetVariableByIndex(theVarNum);				// If this variable is in this dialog, add it to our sorted list				if (theVariable->GetExportOrder() != kNoExportOrder)		{			theSortedList->AddVariable(theVariable);			exportedCount++;						}	}				// Ok, now we have a list of the exported variables.	// Now, renumber them starting at 0.		short theNewExportOrder = 0;	for (long theVarNum = 1; theVarNum <= exportedCount; theVarNum++)	{		theVariable = theSortedList->GetVariableByIndex(theVarNum);				theVariable->SetExportOrder(theNewExportOrder++);		}				// We're done with the sorted list - delete it		delete theSortedList;}