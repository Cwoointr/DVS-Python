// =================================================================================//	CPromptOrderDialog.cp				©1995 Metrowerks Inc. All rights reserved.// =================================================================================//	CPromptOrderDialog.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include <LStdControl.h>#include <PP_Messages.h>#include <UReanimator.h>#include "CPromptOrderDialog.h"// ---------------------------------------------------------------------------------//		¥ CPromptOrderDialog(LStream *)// ---------------------------------------------------------------------------------CPromptOrderDialog::CPromptOrderDialog(	LStream *inStream )		: LGADialog( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CPromptOrderDialog// ---------------------------------------------------------------------------------CPromptOrderDialog::~CPromptOrderDialog(){}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCPromptOrderDialog::FinishCreateSelf(){	// Call inherited. LDialogBox's FinishCreateSelf	// sets up the default and cancel buttons.	LGADialog::FinishCreateSelf();		// Link the dialog to the controls.	UReanimator::LinkListenerToControls( this, this, RidL_PromptOrderDialog );	}voidCPromptOrderDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	CEyeDxLongStringType theNameStr;			long theItem;		switch (inMessage) 	{				case msg_Cancel: 			// Don't have to do anything, since we didn't change the list at all						break;			case msg_OK:			// All we have to do here is iterate through the list, and set each variable's prompt order		// to an incrementing value				long numVariables = mSortedVariableList->GetCount();				for (long varNum = 1; varNum <= numVariables; varNum++)		{			CEyeDxVariable *theVariable = mVariableList->GetVariableByIndex(varNum);			ThrowIfNil_(theVariable);						// Set the prompt order						theVariable->SetPromptOrder(varNum);		}		break;			case msg_PromptOrderVarListSglClick:	case msg_PromptOrderVarListDblClick:	// We don't do anything special for double clicks			// Look up the variable that they clicked on				theItem = mTableSelector->GetFirstSelectedRow();				TableIndexT numRows;		TableIndexT numCols;				mVariableTable->GetTableSize(numRows, numCols);				mMoveUpButton->Disable();		mMoveDownButton->Disable();				// If they haven't clicked on the first item, then enable the Move Up Button				if (theItem > 1)									mMoveUpButton->Enable();					// And if they haven't clicked on the last item, enable the Move Down Button				if (theItem < numRows)			mMoveDownButton->Enable();								break;	case msg_ExportOrderMoveUp:				// Get the item selected, and move it up in the list		theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mSortedVariableList->SwapItems(theItem, theItem - 1);						// And just redisplay the list				UpdateVariableList();		break;	case msg_ExportOrderMoveDown:				// Get the item selected, and move it down in the list. 				theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mSortedVariableList->SwapItems(theItem, theItem + 1);				// And just redisplay the list				UpdateVariableList();		break;			default:		break;	}	// Always pass the message on to our base class		LGADialog::ListenToMessage(inMessage, ioParam);}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------voidCPromptOrderDialog::SetupDialog(CEyeDxVariableList *theVariableList, CEyeDxVariable::PromptType thePromptType){	mVariableList = theVariableList;		mVariableTable = dynamic_cast<LTextTableView*> (this->FindPaneByID(kPromptOrder_VariableTable));	ThrowIfNil_( mVariableTable );			mMoveUpButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kPromptOrder_MoveUpButton));	ThrowIfNil_( mMoveUpButton );		mMoveDownButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kPromptOrder_MoveDownButton));	ThrowIfNil_( mMoveDownButton );		mAllAtOnceButton = dynamic_cast<CEyeDxRadioButtonType*> (this->FindPaneByID(kPromptOrder_PromptInOne));	ThrowIfNil_( mAllAtOnceButton );		mSeparateDialogsButton = dynamic_cast<CEyeDxRadioButtonType*> (this->FindPaneByID(kPromptOrder_PromptInSeparate));	ThrowIfNil_( mSeparateDialogsButton );		mCancelButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kPromptOrder_Cancel));	ThrowIfNil_( mCancelButton );		mSaveButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kPromptOrder_OK));	ThrowIfNil_( mSaveButton );		mVariableTable->SetCellSizer(new LCellSizeToFit(false));	// Add the dialog to the list of listeners of the list box	mTableSelector = new LTableSingleRowSelector(mVariableTable);		mVariableTable->SetTableSelector(mTableSelector);		mTableGeometry = new LTableMultiGeometry( mVariableTable, 10, 14 );	mVariableTable->SetTableGeometry(mTableGeometry);	mTableStorage = new LTableArrayStorage( mVariableTable, (UInt32)0 );	mVariableTable->SetTableStorage(mTableStorage);	mVariableTable->AddListener(this);	// Create our own variable list, using the sort by prompt order comparator.		mSortedVariableList = new CEyeDxVariableList(CEyeDxVariableList::kSortByPromptOrder);	ThrowIfNil_(mSortedVariableList);		long numVariables = theVariableList->GetCount();		for (long varNum = 1; varNum <= numVariables; varNum++)	{		CEyeDxVariable *theVariable = theVariableList->GetVariableByIndex(varNum);		ThrowIfNil_(theVariable);				if (theVariable->GetWhenToPrompt() != thePromptType)						mSortedVariableList->AddVariable(theVariable);	}		// We don't want the list to resort while the user is tweeking it		mSortedVariableList->SetKeepSorted(false);		UpdateVariableList();} voidCPromptOrderDialog::UpdateVariableList(){	// Here we have to parse the variable list and add all of the prompted variables in the order in which they are	// supposed to be prompted.	StopListening();	// Set the list to allow only one item to be selected	// This will defer updating the table until we exit the routine, saving a lot of redraws		mVariableTable->SetDeferAdjustment(true);		mVariableTable->RemoveAllRows(true);		// Delete all of the existing rows		const UInt32 kNumVariableColumns = 1;		mVariableTable->InsertCols(kNumVariableColumns, 0);		// Figure out how many prompted variables there are	TableIndexT theNumberOfVariables = mSortedVariableList->GetCount();		mVariableTable->InsertRows(theNumberOfVariables, 0);	STableCell	cell;	CEyeDxLongStringType *theStr;		cell.col = 1;			for (cell.row = 1; cell.row <= theNumberOfVariables; cell.row++) 	{		// Get the variable - note that the array index is 1 based!				CEyeDxVariable *theVariable = mSortedVariableList->GetVariableByIndex(cell.row);				theStr = theVariable->GetName();				mVariableTable->SetCellData(cell, theStr->TextPtr(), theStr->Length());	}		mVariableTable->SetDeferAdjustment(false);		mVariableTable->Draw(nil);		StartListening();}