// =================================================================================//	CRunFromCameraManualDialog.cp				©1995 Metrowerks Inc. All rights reserved.// =================================================================================//	CRunFromCameraManualDialog.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include <LStdControl.h>#include <PP_Messages.h>#include <UReanimator.h>#include "CRunFromCameraManualDialog.h"#include <UStandardDialogs.h>// ---------------------------------------------------------------------------------//		¥ CRunFromCameraManualDialog(LStream *)// ---------------------------------------------------------------------------------CRunFromCameraManualDialog::CRunFromCameraManualDialog(	LStream *inStream )		: LGADialog( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CRunFromCameraManualDialog// ---------------------------------------------------------------------------------CRunFromCameraManualDialog::~CRunFromCameraManualDialog(){}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCRunFromCameraManualDialog::FinishCreateSelf(){	// Call inherited. LDialogBox's FinishCreateSelf	// sets up the default and cancel buttons.	LGADialog::FinishCreateSelf();		// Link the dialog to the controls.	UReanimator::LinkListenerToControls( this, this, RidL_RunFromCameraManualDialog );	}voidCRunFromCameraManualDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	// Indicates whether the file open call was successful		CEyeDxBooleanType	openOK = false;	switch (inMessage) 	{				case msg_Cancel: 				// ALWAYS close the camera!!				CloseCamera(nil);				// The user can cancel at any time. We just hide the Run From Camera Window and show		// the Control Window					CleanupImages(mCameraUpView, mUpHandle, mCameraSideView, mSideHandle);				break;			case msg_OK:			// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 		// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.		// Since we've already allocated the memory for the images, we don't include them in the counts here.		// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.				short num3ByteDeepImages = 3;	// For the two input images and one pre-scaled annotated image that is written out for the report		short num1ByteDeepImages = 1;	// For the threshold image				CEyeDxLongStringType hintString = (DisplayGraphics ? CommonStringLiteral_("Or, press Cancel, turn off animation, and run again.") : Str_Empty);								MessageT theMemoryMessage = DoCheckForMemory(this, 							DisplayGraphics,							IMAGE_HEIGHT,							IMAGE_WIDTH,							num3ByteDeepImages,							num1ByteDeepImages,							&hintString);		if (theMemoryMessage == msg_OK)		{						// Validate the report name _first_, so we don't waste time downloading 			// images in the case where the report name will cause us to fail. Saves			// the user's time.									CEyeDxShortStringType theReportNameString;						mCameraReportName->GetDescriptor(theReportNameString);						if (CheckReportValidity(&theReportNameString))			{				if (HandlePromptForVariables(this, &mVariableList, mPromptingPrefs.promptingStyle, CEyeDxVariable::kPromptForSubject) == kEyeDxDialogCancelMessage)				{					// ALWAYS close the camera!!										CloseCamera(nil);										// The user can cancel at any time. We just hide the Run From Disk Window and show					// the Control Window											CleanupImages(mCameraUpView, mUpHandle, mCameraSideView, mSideHandle);				}				else				{											StCursor wait;	// Set the pointer to the stop watch while we are setting up					// Force a refresh of the window to get the window elements to update properly.					// This is necessary here since we don't give the system any time to process events					// while we do the first download.										mCameraWindow->Draw(nil);					// If they pressed OK previously but a notice prevented them from continuing, delete the					// previous images										CleanupImages(nil, mUpHandle, nil, mSideHandle);										mCameraUpThermometerPane->Show();					mCameraUpProgressCaption->Show();										CEyeDxVariable *theUpImageVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGE));					CEyeDxVariable *theSessionNameVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));						if (!DownloadImageFromCamera(1,&mUpHandle,&UP_ROWS,&UP_COLS,up_filename, theSessionNameVariable, theUpImageVariable,												nil, mCameraUpThermometerPane, mCameraUpProgressCaption))					{						CloseCamera(nil);						CleanupImages(mCameraUpView, mUpHandle, mCameraSideView, mSideHandle);						break;					}					mCameraUpThermometerPane->Hide();										// Force a refresh of the window to get the thermometer and caption to hide properly										mCameraWindow->Draw(nil);													mCameraSideThermometerPane->Show();					mCameraSideProgressCaption->Show();										CEyeDxVariable *theSideImageVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGE));						if (!DownloadImageFromCamera(2,&mSideHandle,&SIDE_ROWS,&SIDE_COLS,side_filename, theSessionNameVariable, theSideImageVariable,				 									nil, mCameraSideThermometerPane, mCameraSideProgressCaption))											{						CloseCamera(nil);						CleanupImages(mCameraUpView, mUpHandle, mCameraSideView, mSideHandle);						break;					}					mCameraSideThermometerPane->Hide();										// Force a refresh of the window to get the thermometer and caption to hide properly										mCameraWindow->Draw(nil);																// ALWAYS close the camera!!!										CloseCamera(nil);										// First, we see if there's enough temporary memory to run. The peak usage is one 8 bit deep image and 					// one or two 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.					// We've already allocated the memory for the images, we don't include them in the counts here, since					// we are checking for enough _additional_ memory to run.					// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.										short num3ByteDeepImages = 1;	// For the one pre-scaled annotated image that is written out for the report											short num1ByteDeepImages = 1;	// For the threshold image										CEyeDxLongStringType hintString = (DisplayGraphics ? "\pOr, press Cancel, turn off animation, and run again." : Str_Empty);										MessageT theMessage = DoCheckForMemory(this, 										DisplayGraphics,										IMAGE_HEIGHT,										IMAGE_WIDTH,										num3ByteDeepImages,										num1ByteDeepImages,										&hintString);					if (theMessage == msg_OK)					{																mParent->AnalyzeImages(this, mCameraUpView, mCameraSideView, SaveFullImages);												// Now update the variables for the end of a subject												HandleEndOfSubject(&mVariableList, NULL, &mDefaultDatabaseReportName);					}				}			}		}			break;						case msg_CameraUpSelectImage:			HandleCameraImageSelect(msg_CameraUpSelectImage, mCameraUpView, mCameraUpCaption, &mUpPictInfo, mCameraUpPictureQualityIcon);		break;			case msg_CameraSideSelectImage:			HandleCameraImageSelect(msg_CameraSideSelectImage, mCameraSideView, mCameraSideCaption, &mSidePictInfo, mCameraSidePictureQualityIcon);		break;						default:		break;	}	// Always pass the message on to our base class		LGADialog::ListenToMessage(inMessage, ioParam);}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------voidCRunFromCameraManualDialog::SetupDialog(CDocumentApp *theParent, 										CEyeDxVariableList *theVariableList,										CameraPrefs	*theCameraPrefs,										ReportPrefs	*theReportPrefs,										PromptingPrefs *thePromptingPrefs,										FSSpec *theLastImageDirSpec,										FSSpec *thePImagesSpec,										CEyeDxLongStringType *theDefaultDatabaseReportName){	// Save a pointer to our parent window		mParent = theParent;		mVariableList = theVariableList;		mCameraPrefs = theCameraPrefs;		mReportPrefs = theReportPrefs;		mPromptingPrefs = thePromptingPrefs;		mLastImageDirSpec = theLastImageDirSpec;		mPImagesSpec = thePImagesSpec;		mDefaultDatabaseReportName = theDefaultDatabaseReportName;		// Objects in the Run From Camera Window			// Create an EraseAttachment and connect it to all of the captions so that they are	// automatically erased before they are redrawn.		mEraseAttachment = new LEraseAttachment(true);			mCameraUpView = dynamic_cast<CEyeDxViewType *> (mCameraWindow->FindPaneByID( kCameraUpMyGWorldView ));	ThrowIfNil_( mCameraUpView );	mCameraSideView = dynamic_cast<CEyeDxViewType *> (mCameraWindow->FindPaneByID( kCameraSideMyGWorldView ));	ThrowIfNil_( mCameraSideView );	// We also get the progress bars for the Run From Camera window so we can pass them to the ReadImage routine		mCameraUpThermometerPane = dynamic_cast<CEyeDxProgressType*> (mCameraWindow->FindPaneByID(kCameraUpThermometerPane));	ThrowIfNil_( mCameraUpThermometerPane );	mCameraSideThermometerPane = dynamic_cast<CEyeDxProgressType*> (mCameraWindow->FindPaneByID(kCameraSideThermometerPane));	ThrowIfNil_( mCameraSideThermometerPane );	mCameraUpProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraUpProgressCaption));	ThrowIfNil_( mCameraUpProgressCaption );	mCameraUpProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraSideProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraSideProgressCaption));	ThrowIfNil_( mCameraSideProgressCaption );	mCameraSideProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraAnimate = dynamic_cast<CEyeDxCheckBoxType*> (mCameraWindow->FindPaneByID(kCameraAnimate));	ThrowIfNil_( mCameraAnimate );		mCameraReportName = dynamic_cast<CEyeDxEditFieldType*> (mCameraWindow->FindPaneByID(kCameraReportName));	ThrowIfNil_( mCameraReportName );		mCameraUpCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraUpCaption));	ThrowIfNil_( mCameraUpCaption );	mCameraUpCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraSideCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraSideCaption));	ThrowIfNil_( mCameraSideCaption );	mCameraSideCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraUpPictureQualityIcon = dynamic_cast<CEyeDxIconType*> (mCameraWindow->FindPaneByID(kCameraUpQualityIcon));	ThrowIfNil_( mCameraUpPictureQualityIcon );	mCameraSidePictureQualityIcon = dynamic_cast<CEyeDxIconType*> (mCameraWindow->FindPaneByID(kCameraSideQualityIcon));	ThrowIfNil_( mCameraSidePictureQualityIcon );	mCameraLicenseStatusCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraLicenseStatusCaption));	ThrowIfNil_( mCameraLicenseStatusCaption );	mCameraLicenseStatusCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraSessionCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraSessionCaption));	ThrowIfNil_( mCameraSessionCaption );	mCameraSessionCaption->AddAttachment(mEraseAttachment, nil, false);		// Update the license status caption		mParent->SetLicenseStatusCaption(mCameraLicenseStatusCaption);		// And indicate the current session		CEyeDxVariable *theVariable = mVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	UpdateSessionButtonAndCaption(theVariable, nil, mCameraSessionCaption);				// Reset whether the user has selected the files.		mUpSelected = false;	mSideSelected = false;		mUpHandle = mSideHandle = NULL;	mCameraUpPictureQualityIcon->Hide();	mCameraSidePictureQualityIcon->Hide();		mCameraUpCaption->SetDescriptor(Str_Empty);	mCameraSideCaption->SetDescriptor(Str_Empty);	mCameraUpView->ResetImage();	mCameraSideView->ResetImage();	mCameraReportName->SetDescriptor(Str_Empty);	// Set the maximum number of characters in the Name field to the legal length		int theMaxReportNameLength = kMaxReportNameLength;		// If the adjustName option is turned on, we have to account for the prefix length	// when testing the maximum report name length.		if (mReportPrefs->adjustName)		theMaxReportNameLength -= kPrefixLength;	mCameraReportName->SetMaxChars(theMaxReportNameLength);				RunInProgress = 2;	mCameraAnimate->SetValue(DisplayGraphics);		// We show ourselves and force a refresh		Show(nil);		Draw(nil);	// Here we attempt to connect to the camera. If that is successful,	// we load in the first two images if available as the Up and Side images.	// Then we wait for user input.		mCameraUpProgressCaption->SetDescriptor("\pConnecting to camera...");	mCameraUpProgressCaption->Draw(nil);	// Force a refresh of the window to get the window elements to update properly		mCameraWindow->Draw(nil);		DCPortNum thePortNum = (DCPortNum) mCameraPrefs->defaultPort;	if (!ConnectToCamera(this, mCameraUpProgressCaption, mCameraSideProgressCaption, 							mCameraUpView, mCameraUpCaption, 							mCameraSideView, mCameraSideCaption,							&mUpPictInfo, &mSidePictInfo, &thePortNum, (DCBitRate) mCameraPrefs->portSpeed))	{		CloseCamera(nil);		HideMoveShow(mCameraWindow, mMainWindow);	}	else	{		mCameraPrefs->defaultPort = (long) thePortNum;		mCameraUpPictureQualityIcon->Show();		mCameraSidePictureQualityIcon->Show();				// We handle three separate cases here, so that the user sees only one notice, rather than		// possibly two successive ones.				// If the quality isn't what we should be using, warn the user		if ((mUpPictInfo.PictQuality != DC120BestQuality) || (mSidePictInfo.PictQuality != DC120BestQuality))		{			Str255 thePrompt;			Str255 theEndPrompt;						// Default to the singular case						LString::CopyPStr("\pthe picture.", theEndPrompt);						// One, or the other or both images are not Best quality. Create an appropriate message						if ((mUpPictInfo.PictQuality != DC120BestQuality) && (mSidePictInfo.PictQuality != DC120BestQuality))			{				LString::CopyPStr("\pNeither image was", thePrompt);				LString::CopyPStr("\pboth pictures.", theEndPrompt);				mCameraUpPictureQualityIcon->SetIconID(kCautionQualityIconList);				mCameraSidePictureQualityIcon->SetIconID(kCautionQualityIconList);			}			else if (mUpPictInfo.PictQuality != DC120BestQuality)			{				LString::CopyPStr("\pThe Up image was not", thePrompt);				mCameraUpPictureQualityIcon->SetIconID(kCautionQualityIconList);				mCameraSidePictureQualityIcon->SetIconID(kGoodQualityIconList);			}			else if (mSidePictInfo.PictQuality != DC120BestQuality)			{				LString::CopyPStr("\pThe Side image was not", thePrompt);				mCameraUpPictureQualityIcon->SetIconID(kGoodQualityIconList);				mCameraSidePictureQualityIcon->SetIconID(kCautionQualityIconList);			}					 	::ParamText(thePrompt,		 				"\ptaken with the recommended 'Best' image quality setting,",		 				"\pand analysis may produce incorrect results. EyeDx recommends you retake",		 				theEndPrompt);			UModalAlerts::CautionAlert(PPob_GeneralALRT);		}		else		{			mCameraUpPictureQualityIcon->SetIconID(kGoodQualityIconList);			mCameraSidePictureQualityIcon->SetIconID(kGoodQualityIconList);		}				mCameraUpProgressCaption->SetDescriptor(Str_Empty);		mCameraUpProgressCaption->Draw(nil);		mCameraSideProgressCaption->SetDescriptor(Str_Empty);		mCameraSideProgressCaption->Draw(nil);				// Set the maximum number of characters in the Name field to the legal length				int theMaxReportNameLength = kMaxReportNameLength;				// If the adjustName option is turned on, we have to account for the prefix length		// when testing the maximum report name length.				if (mReportPrefs.adjustName)			theMaxReportNameLength -= kPrefixLength;		mCameraReportName->SetMaxChars(theMaxReportNameLength);				// Force a refresh of the window to get the thermometer and caption to hide properly			Draw(nil);		RunInProgress = 1;	}}}