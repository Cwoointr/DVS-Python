// =================================================================================//	ReportFunctions.cp// =================================================================================//	This file contains the code that handles the Report Functions//#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <limits.h>#include <fcntl.h>#include <ctype.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <StandardFile.h>#include <NumberFormatting.h>#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <UTextTraits.h>#include <UStandardDialogs.h>#include "LProgressDialog.h"//#include "LThermometerPane.h"#include "EyeDxMacConstants.h"#include "USubFolderFinder.h"#include <path2fss.h>#include "FileCopy.h"#include "MoreFiles.h"#include "MoreFilesExtras.h"#include "Mozilla.h"#include "USubfolderFinder.h"extern long DebugFeatures;extern long AdvancedFeatures;#define errInvalidHTML	-31416extern pascal Boolean MyNavReportObjectFilter(AEDesc* inItem, void *info, void* inUserData, NavFilterModes);// ---------------------------------------------------------------------------------//		¥ MyNavObjectFilter// ---------------------------------------------------------------------------------// This routine is called by the File Chooser to filter folders for display. In this// implementation, we do not display the reports folder that is the same as the source// folder. Note that this routine works with both the Standard File dialog and the// new Navigation Services dialogs under 8.5 and beyond. The FSSpec for the source folder// is stored in the static variable below, since we have no other way of getting it into// this routine.//// For StdFile, returning false used to mean that the folder SHOULD be displayed. For NavServices,// returning true means that the folder should be displayed. Since this routine is used for// both, it follows the NavServices convention.static FSSpec sReportDirSpec;static pascal Boolean MyReportFolderNavObjectFilter(AEDesc* inItem, void *info, void* inUserData, NavFilterModes){	LStr255 theFolderName = sReportDirSpec.name;		if (inItem != nil) 	{				// NavServices Callback			NavFileOrFolderInfo *theInfo = (NavFileOrFolderInfo *) info;				// Get info about item from inItem and inInfo  - note that by default		// invisible files are not displayed by Navigation Services.		if (inItem->descriptorType == typeFSS)		{			if (theInfo->isFolder)			{				// Get the name from the input Apple Event Descriptor								FSSpec theFSSpec;								BlockMoveData(*inItem->dataHandle,&theFSSpec,sizeof(FSSpec));								if ((sReportDirSpec.vRefNum == theFSSpec.vRefNum) &&				    (sReportDirSpec.parID == theFSSpec.parID) &&				    (theFolderName.CompareTo(theFSSpec.name) == 0))					return false;				else					return true;		// Return true for folders			}			else					return false;		}	} 	else if (inUserData != nil) 	{		// StandardFile Callback		CInfoPBPtr thePB = (CInfoPBPtr) inUserData;				// If it's invisible, say no				if (thePB->hFileInfo.ioFlFndrInfo.fdFlags & kIsInvisible)			return false;		// If it's a directory, say yes if it's NOT the reports folder!				if (thePB->hFileInfo.ioFlAttrib & ioDirMask)		{			if ((sReportDirSpec.vRefNum == thePB->dirInfo.ioVRefNum) &&				(sReportDirSpec.parID == thePB->dirInfo.ioDrParID))				return false;			else				return true;		}		else			return false;	}	return false;}static void ReportCopyError(OSErr theErr, Str255 theActionString, Str255 theFileString){	Str255 theErrorPrefixStr;	Str255 theErrorNumStr;	Str255 theErrorStr;		LString::CopyPStr("\pCouldn't ", theErrorPrefixStr);	LString::AppendPStr(theErrorPrefixStr, theActionString);	LString::AppendPStr(theErrorPrefixStr, "\p '");	LString::AppendPStr(theErrorPrefixStr, theFileString);	LString::AppendPStr(theErrorPrefixStr, "\p' because");	switch (theErr)	{	case vLckdErr:		LString::CopyPStr("\pthe destination volume is locked.", theErrorStr);		break;			case fLckdErr:	case wPrErr:		LString::CopyPStr("\pthe destination file is locked.", theErrorStr);		break;			case dirFulErr:	case dskFulErr:		LString::CopyPStr("\pthe destination volume or folder is full.", theErrorStr);		break;			case memFullErr:		LString::CopyPStr("\pmemory is full.", theErrorStr);		break;			case errInvalidHTML:		LString::CopyPStr("\pinput file has invalid HTML statements.", theErrorStr);		break;			default:		LString::CopyPStr("\pof error number ", theErrorStr);		::NumToString(theErr, theErrorNumStr);		LString::AppendPStr(theErrorStr, theErrorNumStr);		LString::AppendPStr(theErrorStr, "\p.");	}			::ParamText(theErrorPrefixStr, theErrorStr, "\pCancelling Export Report operation.", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);}struct FSSpecPairList{	FSSpec	theSrcSpec;	FSSpec	theDstSpec;};					const char *theSRCTokenString = "SRC";// The buffer we are passed in ptr is NULL-terminated. So we can just parse the entire buffer as// one big string. Note that if the flattenReport flag is turned on, we also output the file as the// destination report, with all of the links modified to remove the folder hierarchy.					static OSErr ParseForSRCTags(short theCopyReportRefNum, char *ptr, FSSpecPairList **theFSSpecPairList, long *theFSSpecListCount, 						FSSpec *theSourceReportsSpec, 						FSSpec *theDestinationSImagesSpec, FSSpec *theDestinationEyesSpec,						bool flattenReport){	long theCount;		// Scan through the provided buffer, looking for patterns that look like 'SRC[ ]=[ ]"string"'		// Save the pointer and the length of the entire buffer		char *p = ptr;		long bufLength = strlen(ptr);		// NULL the pointer to the FSSpecPairList, and set the count to zero		*theFSSpecPairList = NULL;		*theFSSpecListCount = 0;			// Get the first token		char *theSRCToken = strstr(p, theSRCTokenString);		while (theSRCToken)	{		// We want to write out the source file from where we left off last time to this point.				theCount = (theSRCToken - p);				FSWrite(theCopyReportRefNum, &theCount, p);		p = theSRCToken + 1;			// We found a token. Now look for an equals sign, a double quote, a newline, or a return		// Any of these are terminations for the SRC token. Only the equals sign is valid. Note		// That we may have just found a "SRC" string embedded in the report name, so we do not		// consider this an error. We just move on to the next token.				char *theFollowingToken = strpbrk(p, "=\n\r\"");		if ((theFollowingToken == NULL) || (*theFollowingToken != '='))		{			// Now get the next SRC token. First, if we are outputting the modified report, output			// the 'S' that we skipped over.						theCount = 1;			FSWrite(theCopyReportRefNum, &theCount, theSRCToken);			theSRCToken = strstr(p, theSRCTokenString);			continue;		}				p = theFollowingToken + 1;				// Ok, we've found the '='. Now look for an opening double quote		// In this case, if it is not found, we have a string that looks like		// "SRC=" but is not an HTML tag. This could be a valid string in the		// report name, for example. So, we just move on. Since double quotes are		// illegal in report names, from this point on we must be dealing with an HTML		// tag, and handle invalid cases as errors.				theFollowingToken = strpbrk(p, "\n\r\"");		if ((theFollowingToken == NULL) || (*theFollowingToken != '"'))		{			// Now get the next SRC token. First, output the 'SRC=' that we skipped over.			// Do not output the character after the =, since we didn't find a double quote,			// that's where we'll output from (from p) when we loop again.						theCount = 4;			FSWrite(theCopyReportRefNum, &theCount, theSRCToken);						// And look for the next token			theSRCToken = strstr(p, theSRCTokenString);			continue;		}					// We output the SRC=" string to the output file.				theCount = (theFollowingToken - theSRCToken + 1);		FSWrite(theCopyReportRefNum, &theCount, theSRCToken);		p = theFollowingToken + 1;				// Now we are pointing at the opening double quote. We bump the pointer		// up, and save the starting pointer for the URL (which should be a file reference -		// if not, we ignore it				char *theStartOfURL = p;				// Now, look for a valid terminating double quote. If we don't find it before hitting		// the end of the buffer or a newline or carriage return, its an error		theFollowingToken = strpbrk(p, "\n\r\"");		if ((theFollowingToken == NULL) || (*theFollowingToken != '"'))		{			if (*theFSSpecPairList)				free(*theFSSpecPairList);			return errInvalidHTML;		}		// We can now calculate the length of the URL string. It is theFollowingToken - theStartofURL		// We use this to copy the URL into an allocated string, and tack-on a terminating NULL.				long theURLSize = theFollowingToken - theStartOfURL;		char *theURL = new char [theURLSize + 1];				strncpy(theURL, theStartOfURL, theURLSize);		theURL[theURLSize] = '\0';				p = theFollowingToken + 1;		// Finally, we have extracted the URL from the text. We attempt to convert it into a FSSpec.		// We have to determine the directory portion. It should be either "Simages" or "eyes". If		// neither of these strings exist in the URL, we simply ignore it. This takes care of the		// logo file. Of course, it breaks if new directories are added to the EyeDx hierarchy, but		// so does other portions of the EyeDx code that deal only with the know directories.				// Note that the input FSSpec for the conversion routine is the reports directory. It will		// resolve the actual directory based on the UNIX path.				CEyeDxBooleanType theCreateFlag = false;		FSSpec theInSpec = *theSourceReportsSpec;		FSSpec theOutSpec;				if (strstr(theURL, "Simages") != NULL)		{			theOutSpec = *theDestinationSImagesSpec;			theCreateFlag = true;		}		else		if (strstr(theURL, "eyes") != NULL)		{			theOutSpec = *theDestinationEyesSpec;			theCreateFlag = true;		}					char *theURLptr = theURL;					if (theCreateFlag)		{			// It's an SImages file. So we build the FSSpec using the passed-in 						// Skip over any leading "../" or "./" strings, so that the URL is relative to			// the application directory, not the reports directory.						while (*theURLptr == '.' || *theURLptr == '/')				theURLptr++;							FSSpecFromLocalUnixPath(theURLptr, &theInSpec, true);						// We now have the FSSpec for the source file. Copy the name to the destination			// spec.						LString::CopyPStr(theInSpec.name, theOutSpec.name);						// Now we have the in and out spec. Create another element in the output list.			// First, bump the count of elements. The tack on space on the end of the array,			// and then copy in the FSSpecs we just created.						(*theFSSpecListCount)++;						FSSpecPairList *theList = *theFSSpecPairList;						theList = (FSSpecPairList *)realloc(theList, sizeof(struct FSSpecPairList) * (*theFSSpecListCount));						*theFSSpecPairList = theList;						theList[*theFSSpecListCount - 1].theSrcSpec = theInSpec;			theList[*theFSSpecListCount - 1].theDstSpec = theOutSpec;		}		// Now, we either output the truncated file name (no ../ strings) if we are flattening,		// or we just output the whole URL. Note that this assumes that ALL SRC URLs in the file		// are image files.				if (flattenReport)		{			// This will output just the last component of the URL and the terminating double quote			// Find the last "/" in the buffer, as we want to copy from that point on to the end			char *lastSlash = strrchr(theURL, '/');						// If lastSlash is not NULL, that means we found the last slash. If it is NULL, no slash			// exists in the string, so we want to output the entire string.						if (lastSlash)			{				theCount = theURLSize - ((lastSlash + 1) - theURL);				FSWrite(theCopyReportRefNum, &theCount, (lastSlash + 1));			}			else			{				theCount = theURLSize;				FSWrite(theCopyReportRefNum, &theCount, theURL);			}						// Now output the terminating double quote from the input buffer			theCount = 1;			FSWrite(theCopyReportRefNum, &theCount, theFollowingToken);		}		else		{			// This will output the entire URL and the terminating double quote from the input buffer			theCount = (theFollowingToken - theStartOfURL + 1);			FSWrite(theCopyReportRefNum, &theCount, theStartOfURL);		}									// We don't need the string anymore, so delete it				delete theURL;				// Now get the next SRC token		theSRCToken = strstr(p, theSRCTokenString);		}		// Finally, we have to output the rest of the file. Calculate the buffer length based	// on the current pointer minus the beginning pointer (the amount we've already handled)	// and then subtract that from the original buffer length. Output from p to the end.		theCount = (bufLength - (p - ptr));	FSWrite(theCopyReportRefNum, &theCount, p);		return noErr;}					void CDocumentApp::HandleExportReports(bool flattenReports){	OSErr makeErr;		// Create the subfolders in case the user renamed them		CreateFolders();				// First, have the user choose one or more reports to export		PP_PowerPlant::LFileTypeList	theTEXTFileTypes('TEXT');	// We also build temporary file chooser objects using the Standard File dialogs		PP_PowerPlant::PP_StandardDialogs::LFileChooser	theReportChooser;	PP_PowerPlant::PP_StandardDialogs::LFileChooser	theDestinationChooser;	FSSpec theReportSpec;		theReportChooser.SetDefaultLocation(mReportDirSpec, FALSE);		theReportChooser.SetObjectFilterProc((NavObjectFilterProcPtr) MyNavReportObjectFilter);	// Set the local static 'global' so that the call back can compare the folders to be	// displayed with the source files. They should not be the same!	makeErr = ::FSMakeFSSpec(mApplSpec.vRefNum, mApplSpec.parID, Str_Empty, &sReportDirSpec);			// Don't filter just the files created by the current browser selection! We will accept any	// text files.	// Turn off the option to display previews, since previewing HTML doesn't make sense		NavDialogOptions	*options = theReportChooser.GetDialogOptions();	if (options != nil) 	{		options->dialogOptionFlags =	kNavDontAddTranslateItems +		/* don't add translation choices on Open/Save */												kNavSelectAllReadableItem +			/* allow saving of stationery files */												kNavAllowMultipleFiles +												kNavNoTypePopup;				LString::CopyPStr("\pEyeDx: Choose Reports", options->windowTitle);		LString::CopyPStr("\pChoose", options->actionButtonLabel);	}		// Note that we allow multiple files to be selected if using Navigation Services. That's	// why we use AskChooseFile. We will ask the chooser the count and then retrieve the list in the	// loop below. If StdFile is used, we will only get one item.												 	CEyeDxBooleanType openOK = theReportChooser.AskOpenFile(theTEXTFileTypes);					if (openOK)	{		// Next, if the user chose a report, ask them to select a destination. This		// should be a folder or volume.				SInt32 theFolderID;		FSSpec theDestinationSpec;				// Unfortunately, there isn't really a good default location. We don't want them to 		// choose the reports folder in the application's directory. However, Standard File		// doesn't really allow us to do that. It doesn't call the filter proc for an empty		// directory, for example. So perhaps the best place to default to is the Desktop.				short foundVRefNum;		long foundDirID;				makeErr = ::FindFolder(mApplSpec.vRefNum, kDesktopFolderType, false, &foundVRefNum, &foundDirID);										FSSpec theDefaultDestination;				makeErr = ::FSMakeFSSpec(foundVRefNum, foundDirID, Str_Empty, &theDefaultDestination);					theDestinationChooser.SetDefaultLocation(theDefaultDestination, FALSE);			// If we are running with Navigation Services, we use the Chooser dialog strings to		// inform the user what we are doing. Otherwise, with StdFile, we put up a prompt.		NavDialogOptions	*options = theDestinationChooser.GetDialogOptions();		if (options != nil) 		{			LString::CopyPStr("\pEyeDx: Choose export folder", options->windowTitle);		}#if	PP_StdDialogs_Option == PP_StdDialogs_Conditional		if (!UConditionalDialogs::UseNavServices())#endif#if PP_StdDialogs_Option != PP_StdDialogs_NavServicesOnly 		{			 ::ParamText("\pSelect the export folder where report will be written.", Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::NoteAlert(PPob_GeneralALRT);		}#endif		// Set up the filter proc for theImageChooser to filter-out the source reports folder.				theDestinationChooser.SetObjectFilterProc((NavObjectFilterProcPtr) MyReportFolderNavObjectFilter);		openOK = theDestinationChooser.AskChooseFolder(theDestinationSpec, theFolderID);								if (openOK)		{			// If a folder or volume is chosen, then we process each report that was chosen.			// The first step is to copy the EyeDxLogo.jpg file into the root directory of the destination			// folder.						// Note that we MUST copy something into the destination folder, so that, in turn, we can call the			// USubFolderFinder class. The class creates an alias of something that resides in the folder, so			// if it is empty, it doesn't work. Argh.						// We modify the destination spec so that we get the spec of an actual file within the folder itself. This is necessary			// because the USubFolderFinder class needs a file in the folder to create an alias. An empty folder doesn't			// cut it. So, we use the EyeDxLogo.jpg file, since that is what we want to create right now.			makeErr = ::FSMakeFSSpec(theDestinationSpec.vRefNum, theFolderID, "\pEyeDxLogo.jpg", &theDestinationSpec);			// Try to delete the destination file. If it already exists, the FileCopy routine will complain and not			// overwrite it. So, we try to delete it whether or not exists, and ignore the result of the delete.						makeErr = ::FSpDelete(&theDestinationSpec);						makeErr = FileCopy(mApplSpec.vRefNum, mApplSpec.parID, "\pEyeDxLogo.jpg",							   theDestinationSpec.vRefNum, theFolderID, nil, nil, nil, 0L, true);			if (makeErr != noErr)			{				ReportCopyError(makeErr, "\pcopy", "\pEyeDxLogo.jpg");				return;			}									FSSpec theDestinationReportsSpec;			FSSpec theDestinationSImagesSpec;			FSSpec theDestinationEyesSpec;			if (!flattenReports)			{				// Next, create the subfolders (reports, Simages, eyes) if necessary							USubfolderFinder theFolderFinder;							theFolderFinder.Initialize(&theDestinationSpec);	// We pass in the destination directory to use as the root							// Create an FSSpec for each of the subdirectories (where the application lives). If the specified				// folder doesn't exit, the Folder Finder object will create it.								LString::CopyPStr("\preports", theDestinationReportsSpec.name);							if ((makeErr = theFolderFinder.FindFolderNamed(theDestinationReportsSpec.name, theDestinationReportsSpec.parID, theDestinationReportsSpec.vRefNum)) != noErr)					ThrowOSErr_(makeErr);				LString::CopyPStr("\pSimages", theDestinationSImagesSpec.name);								if ((makeErr = theFolderFinder.FindFolderNamed(theDestinationSImagesSpec.name, theDestinationSImagesSpec.parID, theDestinationSImagesSpec.vRefNum)) != noErr)					ThrowOSErr_(makeErr);				LString::CopyPStr("\peyes", theDestinationEyesSpec.name);								if ((makeErr = theFolderFinder.FindFolderNamed(theDestinationEyesSpec.name, theDestinationEyesSpec.parID, theDestinationEyesSpec.vRefNum)) != noErr)					ThrowOSErr_(makeErr);				mFolderFinder.Initialize(&mApplSpec);	// We reinitialize the folder finder object because our														// init above changed the default location						}			else			{				// We're going to copy everything into the same folder. So, we just copy the destination folder spec into				// the spec for all of the eyes, reports, and Simages.								theDestinationReportsSpec = theDestinationSpec;				theDestinationSImagesSpec = theDestinationSpec;				theDestinationEyesSpec = theDestinationSpec;			}			// Next, for each file that was selected, copy the file into the reports folder. Then, 			// look into the file for all SRC tags. Error handling consists of making a list of the files			// associated with each report that are copied. If an error occurs, such as running out of disk			// space, the program will remove the last report and the lartial list of associated files from			// the destination. This is so that partial reports are not accidentally exported.						SInt32 theNumReports = theReportChooser.GetNumberOfFiles();						// Create a LProgressDialog to show progress as we copy						LStr255 theLabel;						if (flattenReports)				theLabel = "\pExport Reports for Emailing";			else				theLabel = "\pExport Reports";							LProgressDialog *theProgressDialog = LProgressDialog::newLProgressDialog(this);			theProgressDialog->SetTitle(theLabel);			// Now, show the progress dialog						theProgressDialog->SetValues(0, theNumReports, 0);			theProgressDialog->Show();						// Note that the reports are numbered started at 1			for (SInt32 theReportNum = 1; theReportNum <= theNumReports; theReportNum++)			{							FSSpec theReportCopySpec;								// Get the file, and copy it, first confirming overwrite if the destination exists								theReportChooser.GetFileSpec(theReportNum, theReportSpec);								// Show progress in the dialog as we copy								Str255 theActionStr;				Str255 theCountStr;				Str255 theStepStr;				Str255 theNumStr;								LString::CopyPStr("\pExporting ", theActionStr);				LString::AppendPStr(theActionStr, theReportSpec.name);				theProgressDialog->SetActionDescriptor(theActionStr);								LString::CopyPStr("\pCopying ", theStepStr);				LString::AppendPStr(theStepStr, theReportSpec.name);				theProgressDialog->SetStepDescriptor(theStepStr);								::NumToString(theReportNum, theCountStr);				LString::AppendPStr(theCountStr, "\p of ");				::NumToString(theNumReports, theNumStr);				LString::AppendPStr(theCountStr, theNumStr);				theProgressDialog->SetCountDescriptor(theCountStr);								ProcessNextEvent();				// Copy the file into the reports folder in the destination. First, check if it already exists.				// If it does, prompt the user to overwrite or skip this file.								makeErr = ::FSMakeFSSpec(theDestinationReportsSpec.vRefNum, 										 theDestinationReportsSpec.parID, 										 theReportSpec.name, 										 &theReportCopySpec);								FInfo theFInfo;								makeErr = FSpGetFInfo(&theReportCopySpec, &theFInfo);				// Assume that the default is yes.				DialogItemIndex item_hit = PPob_YesNoALRT_Yes;				if (makeErr == noErr)				{					Str255 theQuotedNameStr;					LString::CopyPStr("\p'", theQuotedNameStr);					LString::AppendPStr(theQuotedNameStr, theReportSpec.name);					LString::AppendPStr(theQuotedNameStr, "\p'");					 ::ParamText("\pA report named", theQuotedNameStr, "\palready exists in the export folder.", "\pOverwrite?");					item_hit = UModalAlerts::CautionAlert(PPob_YesNoALRT);					if (item_hit == PPob_YesNoALRT_Yes)					{														makeErr = ::FSpDelete(&theReportCopySpec);						if (makeErr != noErr)						{							ReportCopyError(makeErr, "\pdelete", theReportSpec.name);							delete theProgressDialog;							return;						}					}				}				else				if (makeErr != fnfErr)				{					ReportCopyError(makeErr, "\paccess", "\pthe export folder");					delete theProgressDialog;					return;				}				// else the file didn't exist, and that's just swell. 						if (item_hit == PPob_YesNoALRT_Yes)				{						// This is a bit of a kludge. We use the FileCopy routine to initially copy the source to the					// destination. This routine preserves all of the associated attributes, including finder creator					// and type, comments, permissions. Rather than reproducing all of that, we just copy the file.					// Then, we re-open the file, and rewrite it from the start, possibly modifying the URLs if we					// are flattening it. Not the most efficient way to do this, but since the file size is relatively					// small, it's better than having to duplicate 99% of the code in the FileCopy routine!										makeErr = FileCopy(theReportSpec.vRefNum, theReportSpec.parID, theReportSpec.name,							  		   theReportCopySpec.vRefNum, theReportCopySpec.parID, nil, nil, nil, 0L, true);										   					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pcopy", theReportSpec.name);						delete theProgressDialog;						return;					}					// Now parse the report file looking for SRC tags.										// To simplify things, we just read the entire report file into temporary memory. Since report					// files are small (or should be!), this shouldn't be a problem. Note that we check to make sure					// that there is sufficient memory available to do this.										long theFileDataSize;					long theFileRsrcSize;										makeErr = FSpGetFileSize(&theReportSpec, &theFileDataSize, &theFileRsrcSize);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pread", theReportSpec.name);						delete theProgressDialog;						return;					}										// We will NULL-terminate the read buffer, so bump its size up by one byte										Handle theMemoryHandle = ::TempNewHandle((theFileDataSize + 1), &makeErr);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pread", theReportSpec.name);						delete theProgressDialog;						return;					}																// Lock the handle so we can dereference it										::HLock(theMemoryHandle);												char *thePointer = *theMemoryHandle;										// Open the input report file										short inRefNum;					makeErr = FSpOpenDF(&theReportSpec, fsCurPerm, &inRefNum);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pread", theReportSpec.name);						delete theProgressDialog;						return;					}										// Open the output report file - it was created above, so we shouldn't get an error here										short outRefNum;					makeErr = FSpOpenDF(&theReportCopySpec, fsWrPerm, &outRefNum);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pwrite", theReportSpec.name);						delete theProgressDialog;						return;					}										// Truncate the file at the beginning so that we aren't left with stuff at the					// end if we flatten (remove path characters) it.										makeErr = SetEOF(outRefNum, 0L);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\ptruncate", theReportSpec.name);						delete theProgressDialog;						return;					}										// Read the file, looking for the SRC = "URL" tags.					makeErr = FSRead(inRefNum, &theFileDataSize, thePointer);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pread", theReportSpec.name);						delete theProgressDialog;						return;					}										// NULL terminate the buffer, so that the string functions we use in the					// parse function won't run off the end.										thePointer[theFileDataSize] = '\0';					// Parse the memory, and build a list of FSSpecs that represent					// image files that need to be copied, minus the logo file. We pass					// in the FSSpecs for the destination SImages and eyes folder.										FSSpecPairList *theFSSpecPairList;					long theFSSpecListCount;										// We have to pass this the FSSpec of the parent of the reports folder, not the					// FSSpec of the report file. That's because the input file list will be based on					// the folder that contains the eyes and Simages folders.										FSSpec theSourceParentFolder = theReportSpec;					GetParentID(theReportSpec.vRefNum, theReportSpec.parID, nil, &theSourceParentFolder.parID);										makeErr = ParseForSRCTags(outRefNum, thePointer, &theFSSpecPairList, &theFSSpecListCount, 											&theSourceParentFolder,											&theDestinationSImagesSpec, &theDestinationEyesSpec,											flattenReports);										if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pparse", theReportSpec.name);						delete theProgressDialog;						if (theFSSpecPairList != nil)							free((void *)theFSSpecPairList);						return;					}					// Close the input file										makeErr = FSClose(inRefNum);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pclose", theReportSpec.name);						delete theProgressDialog;						if (theFSSpecPairList != nil)							free((void *)theFSSpecPairList);						return;					}										// Close the output file										makeErr = FSClose(outRefNum);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pclose", theReportSpec.name);						delete theProgressDialog;						if (theFSSpecPairList != nil)							free((void *)theFSSpecPairList);						return;					}					// Unlock the handle and release the temporary memory, since we are done parsing.										::HUnlock(theMemoryHandle);					::DisposeHandle(theMemoryHandle);										// For each SRC tag found, convert the path into a file reference, and copy the 					// file into the appropriate subfolder in the destination folder.										// Point to the first element in the list										FSSpecPairList *theImagePairSpec = theFSSpecPairList;										// We have two choices for handling any existing files in the destination folder.					// Since the current naming scheme doesn't tie an image to a report, if we delete the					// images we may be changing the contents of other reports that also used this image					// previously. The alternative is to prompt the user to tell them that these images					// exist, and if they say to overwrite, we do so. If they say to skip, then we presumably					// remove the report file that we just copied.															// However, the alternative is to just delete any existing duplicate names in the destination					// and tell the user that we had to do that.										// Neither is ideal. The image naming scheme should really use the name of the report in the					// file name so that if we see a duplicate, we know that we are replacing images for the					// report that the user just confirmed overwriting. 										// Right now, we take the easy way out, and just delete the offending files.										// Assume that the answer is yes.					DialogItemIndex item_hit = PPob_YesNoALRT_Yes;					if (item_hit == PPob_YesNoALRT_Yes)					{								// Point back to the start of the list												theImagePairSpec = theFSSpecPairList;															for (long theImageFile = 0; theImageFile < theFSSpecListCount; theImageFile++)						{							FInfo theFInfo;												makeErr = FSpGetFInfo(&theImagePairSpec->theDstSpec, &theFInfo);														// For each file that is actually a duplicate in the destination folder,							// try to delete it. noErr means that the destination file exists. We							// ignore other errors, as they will be caught by the attempt to delete							// the file.														if (makeErr == noErr)							{								LString::CopyPStr("\pDeleting ", theStepStr);								LString::AppendPStr(theStepStr, theImagePairSpec->theDstSpec.name);								LString::AppendPStr(theStepStr, "\p in the export folder");								theProgressDialog->SetStepDescriptor(theStepStr);								ProcessNextEvent();																makeErr = ::FSpDelete(&theImagePairSpec->theDstSpec);								if (makeErr != noErr)								{									ReportCopyError(makeErr, "\pdelete", theImagePairSpec->theDstSpec.name);									delete theProgressDialog;									if (theFSSpecPairList != nil)										free((void *)theFSSpecPairList);									return;								}							}													LString::CopyPStr("\pCopying ", theStepStr);							LString::AppendPStr(theStepStr, theImagePairSpec->theSrcSpec.name);							theProgressDialog->SetStepDescriptor(theStepStr);							ProcessNextEvent();														makeErr = FileCopy(theImagePairSpec->theSrcSpec.vRefNum, theImagePairSpec->theSrcSpec.parID, theImagePairSpec->theSrcSpec.name,							  		   		theImagePairSpec->theDstSpec.vRefNum, theImagePairSpec->theDstSpec.parID, nil, nil, nil, 0L, true);									   											   							if (makeErr != noErr)							{								ReportCopyError(makeErr, "\pcopy", theImagePairSpec->theSrcSpec.name);								delete theProgressDialog;								if (theFSSpecPairList != nil)									free((void *)theFSSpecPairList);								return;							}										// Move to the next image pair														theImagePairSpec++;												}					}					// Delete the memory allocated for the image list										if (theFSSpecPairList != nil)						free((void *)theFSSpecPairList);				}				// Otherwise, indicate that we completed yet another report									theProgressDialog->CompletedThisMuchMore(1);												if (theProgressDialog->CancelClicked())				{					LString::CopyPStr("\pCanceling...", theStepStr);					theProgressDialog->SetStepDescriptor(theStepStr);					ProcessNextEvent();									// No cleanup for the last report since we complete each report before checking for Cancel										delete theProgressDialog;					return;				}							}						delete theProgressDialog;				if (flattenReports)			{				::ParamText("\pTo email reports, attach the files in the destination folder to the email message. Do not try to attach the destination folder itself.", Str_Empty,							"\pUse MIME encoding (see your email program's instructions) for best compatibility with the receiver's email program.", Str_Empty);				UModalAlerts::NoteAlert(PPob_GeneralALRT);			}		}			}}// This routine will check the passed filename string for any of the illegal// filename characters. We use a common set of illegal characters for both// platforms, so that files can easily be exchanged between systems.static CEyeDxBooleanType LegalFilename(const CEyeDxLongStringType *theString){	unsigned char theFilename[256];	CopyEyeDxStringToCString(theString, theFilename);		if (strpbrk((char *)theFilename, ILLEGAL_FILENAME_CHARS) != NULL)		return FALSE;	// The file name cannot be all blanks!		short theStrLength = theString->Length();		short i = 1;	while (i <= theStrLength)	{		if ((*theString)[i] != char_Space)			return TRUE;		i++;	}		return FALSE;}// This routine checks if the specified report exists, and prompts the user// for what to do. It also checks the report string for length and illegal// characters, and displays a notice if appropriate.// Returns true if the operation should continue, and false if not.// It also updates the global report_filename variable.CEyeDxBooleanType CheckReportValidity(CEyeDxWindowType *, CEyeDxLongStringType *theReportNameString, CEyeDxVariable *theSessionNameVariable, CEyeDxBooleanType adjustName){	// Make a copy		CEyeDxLongStringType anotherReportString = *theReportNameString;			CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();	// Convert into a C string for use in the open statements below		unsigned char sessionName[256];	CopyEyeDxStringToCString(theSessionName, sessionName);							// Perform some validity checks on the report name		long theReportNameLength = (*theReportNameString)[0];	unsigned char *theReportNameBuffer = &(*theReportNameString)[1];	int theMaxReportNameLength = kMaxReportNameLength;		// If the adjustName option is turned on, we have to account for the prefix length	// when testing the maximum report name length.		if (adjustName)		theMaxReportNameLength -= kPrefixLength;		if (theReportNameLength < kMinReportNameLength)	{				Str255 theLengthStr;		::NumToString(kMinReportNameLength, theLengthStr);		::ParamText("\pPlease enter a report name that is at least ", theLengthStr, "\p characters long.", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else if (theReportNameLength > theMaxReportNameLength)	{		Str255 theLengthStr;		::NumToString(theMaxReportNameLength, theLengthStr);				::ParamText("\pThe report name cannot be longer than ", theLengthStr, "\p characters.", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else if (!LegalFilename(theReportNameString))	{			::ParamText("\pThe report name cannot contain any of the characters ", CommonStringLiteral_(ILLEGAL_FILENAME_CHARS), "\p and must not be blank.", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else	{		CopyEyeDxStringToCString(theReportNameString, (unsigned char *)report_filename);				// Check if this report already exists. If it does, prompt the user whether to continue		// If the adjustName feature is enabled, we have to loop through the possible prefixes, and		// warn the user that a possible conflict exists. Otherwise, just check for the same exact name.				if (adjustName)		{			char *prefixes[] = {kYesReferralIndicator, 								kNoReferralIndicator,								kSecondImageReferralIndicator,								kUnclearReferralIndicator };						char theFileList[200];			strcpy(theFileList, "");			int existingReports = 0;			for (int prefixNum = 0; prefixNum < kNumValidPrefixes; prefixNum++)			{								char reportpath[100];				sprintf(reportpath, ":%s:reports:%s%s.htm", (char *) sessionName, prefixes[prefixNum], report_filename);				int fp;				// Default to the "yes" condition				DialogItemIndex item_hit = PPob_YesNoALRT_Yes;							if ((fp = open(reportpath, O_EXCL | O_RDONLY)) != -1)				{					close(fp);					existingReports++;					if (strlen(theFileList) != 0)						strcat(theFileList, ", ");					strcat(theFileList, "'");					strcat(theFileList, prefixes[prefixNum]);					strcat(theFileList, report_filename);					strcat(theFileList, "'");				}			}						if (existingReports > 0)			{				LStr255 thePrompt(theFileList);				thePrompt.Append("\p.");								if (existingReports == 1)					::ParamText("\pA report with this name and a referral prefix exists in this session: ", thePrompt,							"\pShould the program overwrite it if necessary?", Str_Empty);				else					::ParamText("\pReports with this name and referral prefixes exist in this session: ", thePrompt,							"\pShould the program overwrite one of these if necessary?", Str_Empty);								DialogItemIndex item_hit = UModalAlerts::CautionAlert(PPob_YesNoALRT);				if (item_hit == PPob_YesNoALRT_Yes)					return true;				else					return false;			}			return true;		}		else		{					char reportpath[100];			sprintf(reportpath, ":%s:reports:%s.htm", (char *) sessionName, report_filename);			int fp;			// Default to the "yes" condition			DialogItemIndex item_hit = PPob_YesNoALRT_Yes;						if ((fp = open(reportpath, O_EXCL | O_RDONLY)) != -1)			{				close(fp);				 ::ParamText("\pA report with this name already exists in this session.", "\pOverwrite?", Str_Empty, Str_Empty);				item_hit = UModalAlerts::CautionAlert(PPob_YesNoALRT);			}			if (item_hit == PPob_YesNoALRT_Yes)				return true;			else				return false;		}	}	return false;		}OSErr CDocumentApp::OpenReport(FSSpec *theReportSpec){		OSErr openErr = OpenSpecifiedDocument(theReportSpec, mBrowserCreatorCode);	if (openErr != noErr)	{		switch (openErr)		{		case memFullErr:		case appMemFullErr:	 		::ParamText("\pNot enough memory available to start the browser.", 	 					"\pExit the EyeDx program and open the report by double clicking on the report file icon", 	 					Str_Empty, Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);					break;					default:	 		::ParamText("\pCould not start the browser.", 	 					"\pIs it installed?", "\pIs there sufficient memory available to run the browser?", 	 					Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);		}	}		return (openErr);}OSErr OpenFile(FSSpec *theFileSpec){		OSErr openErr = OpenSpecifiedDocument(theFileSpec, kUnknownType);	if (openErr != noErr)	{		switch (openErr)		{		case memFullErr:		case appMemFullErr:	 		::ParamText("\pNot enough memory available to start the viewer application.", 	 					"\pExit the EyeDx program and open the file by double clicking on the file icon", 	 					Str_Empty, Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);					break;					default:	 		::ParamText("\pCould not start the viewer application.", 	 					"\pIs it installed?", "\pIs there sufficient memory available to run it?", 	 					Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);		}	}		return (openErr);}// This routine checks if the specified session exists, and prompts the user// if so. It also checks the session name string for length and illegal// characters, and displays a notice if appropriate.// Returns true if the operation should continue, and false if not.CEyeDxBooleanType CheckSessionValidity(CEyeDxWindowType *theWindow, CEyeDxLongStringType *theSessionNameString){	// Convert into a C string for use in the open statements below		unsigned char sessionName[256];		CopyEyeDxStringToCString(theSessionNameString, sessionName);		// Perform some validity checks on the session name		if (theSessionNameString->Length() < kMinSessionNameLength)	{				Str255 theLengthStr;		::NumToString(kMinSessionNameLength, theLengthStr);		::ParamText("\pPlease enter a session name that is at least ", theLengthStr, "\p characters long.", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else if (theSessionNameString->Length() > kMaxSessionNameLength)	{		Str255 theLengthStr;		::NumToString(kMaxSessionNameLength, theLengthStr);				::ParamText("\pThe session name cannot be longer than ", theLengthStr, "\p characters.", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else if (!LegalFilename(theSessionNameString))	{			::ParamText("\pThe session name cannot contain any of the characters ", CommonStringLiteral_(ILLEGAL_FILENAME_CHARS), "\p and must not be blank.", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else	{		// Check if this session already exists. If it does, prompt the user whether to continue		// If the adjustName feature is enabled, we have to loop through the possible prefixes, and		// warn the user that a possible conflict exists. Otherwise, just check for the same exact name.				CEyeDxLongStringType theSessionPath = LEADINGPATHSEPARATOR;		theSessionPath += *theSessionNameString;				if (USubfolderFinder::DoesFolderNamedExist(theSessionPath) == noErr)		{			::ParamText("\pA session with this name already exists.", Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);			return false;		}		return true;	}	return false;		}// This routine will parse the specified session folder, generating a list of report names. It then sorts the// list alphabetically, and returns it and the number of elements to the caller. The list must be a C String// list because it is called by cross-platform common code. The caller is responsible for freeing the allocated// memoryCTemplateShortStrArray *GetReportList(CEyeDxLongStringType *theSessionName){	// We use the MoreFiles routine GetDirItems routine. It generates a list	// of FSSpecs for the items in the directory we specify. We then transfer this	// list over to a list of C strings.		CEyeDxLongStringType theReportsFolder = "\p:";	theReportsFolder += *theSessionName;	theReportsFolder += "\p:reports";		CTemplateShortStrArray *tmpStringArray = nil;	OSErr theErr;		FSSpec			spec;	Boolean			wasChanged;	Assert_(USubfolderFinder::sApplicationAliasH != nil);		if (( theErr = ::ResolveAlias(nil, USubfolderFinder::sApplicationAliasH, &spec, &wasChanged)) == noErr) 	{		short theNextItem = 1;	// Start with item 1, and let the routine increment this for us		FSSpec theReportSpec;		short numFiles;				// First, we create a sorted string array which will automatically sort as we insert the strings.				tmpStringArray = new CTemplateShortStrArray(nil, true);				// Note that setting the comparator in the constructor was failing for some reason - the constructor		// was always using the default LongComparator, which was definitely not what we wanted!				tmpStringArray->SetComparator(CCEyeDxLongStringTypeComparator::GetComparator(), false);		while (GetDirItems(spec.vRefNum,							spec.parID,							theReportsFolder,		// The name of the session folder							true,					// We are interested in files only							false,					// Shouldn't be any subdirectories but don't request them anyway							&theReportSpec,				// Pointer to the FSSpec structure							1,						// We want to just get one at a time							&numFiles,				// We'll get the count here							&theNextItem) == noErr)	// Start with the first item		{			CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(theReportSpec.name);								// We strip-off the ".htm" extension						const short kLengthOfHTMExtension = 4;						short startPos = theStringCopy->ReverseFind("\p.htm");						if (startPos != 0)				theStringCopy->Remove(startPos, kLengthOfHTMExtension);							tmpStringArray->AddItem(theStringCopy);		}			// Now, we have a sorted list! 	}	return tmpStringArray;}short *GetReportDuplicateList(CTemplateShortStrArray *theReportList, 							  CEyeDxBooleanType *duplicatesFound){	// First, we allocate an array of shorts that has one more element	// as in the passed-in report list. The dummy zeroth element allows accessing	// the array in the calling routine using the same Mac array indexes as the	// report list array. We initialize it to zero as we iterate through the list.		short *theCountList = new short [theReportList->GetCount() + 1];		// Compare each item against every other item. This will produce a count for each item of how	// many of the items in the list contain the current item as a substring. This is not fullproof,	// since a short report name, such as "a", will probably show up in just about every other report.		// We have to initialize the counts outside the loop, since within the loop we access the	// elements in a somewhat random fashion.		for (long item = 1; item <= theReportList->GetCount(); item++)		theCountList[item] = 0;			for (long item = 1; item <= theReportList->GetCount(); item++)	{		// Grab the current report name				CEyeDxShortStringType *theCurrentItem;		theReportList->FetchItemAt(item, theCurrentItem);		// Make a copy of the string so we can modify it for comparisons				CEyeDxShortStringType theCurrentItemCopy = *theCurrentItem;				// Now we strip off any prefix that might exist, since we want to compare report names		// that may share the same base name.				if (theCurrentItemCopy.BeginsWith(CommonStringLiteral_(kYesReferralIndicator))          ||			theCurrentItemCopy.BeginsWith(CommonStringLiteral_(kNoReferralIndicator))           ||			theCurrentItemCopy.BeginsWith(CommonStringLiteral_(kSecondImageReferralIndicator))  ||			theCurrentItemCopy.BeginsWith(CommonStringLiteral_(kUnclearReferralIndicator)))			theCurrentItemCopy.Remove(1, kLengthOfReferralPrefix);					// Strip-off leading spaces				while (theCurrentItemCopy.BeginsWith(' '))			theCurrentItemCopy.Remove(1, 1);					// We convert the string to lowercase to compare, since filenames are not distinguished by case				::LowercaseText((char *)theCurrentItemCopy.TextPtr(), theCurrentItemCopy.Length(), smSystemScript);		// Now that we have the base string, we loop through all of the members of the list.		// We compare each (sans the prefix and after making it all lowercase) to the current item.		// If the current item is a substring of this second item, we bump the current item's count.		// Once we have finished, the count should be at least 2 (since we will at some point match		// the string in both directions) the current item. Any items that have counts > 2 may have 		// reports that could be repeat runs of the same subject.		for (long item2 = 1; item2 <= theReportList->GetCount(); item2++)		{			CEyeDxShortStringType *theSecondItem;			theReportList->FetchItemAt(item2, theSecondItem);			// Make a copy of the string so we can modify it for comparisons					CEyeDxShortStringType theSecondItemCopy = *theSecondItem;						// Now we strip off any prefix that might exist, since we want to compare report names			// that may share the same base name.						if (theSecondItemCopy.BeginsWith(CommonStringLiteral_(kYesReferralIndicator))          ||				theSecondItemCopy.BeginsWith(CommonStringLiteral_(kNoReferralIndicator))           ||				theSecondItemCopy.BeginsWith(CommonStringLiteral_(kSecondImageReferralIndicator))  ||				theSecondItemCopy.BeginsWith(CommonStringLiteral_(kUnclearReferralIndicator)))				theSecondItemCopy.Remove(1, kLengthOfReferralPrefix);						// Strip-off leading spaces						while (theSecondItemCopy.BeginsWith(' '))				theSecondItemCopy.Remove(1, 1);						// We convert the string to lowercase to compare, since filenames are not distinguished by case						::LowercaseText((char *)theSecondItemCopy.TextPtr(), theSecondItemCopy.Length(), smSystemScript);			// Ok. Does the second item contain the first as a substring?						if (theSecondItemCopy.BeginsWith(theCurrentItemCopy))			{				// We bump the counters of _both_ items, to show the two-way relationship between the substring				// and the longer string that it was found inside.								theCountList[item]++;				theCountList[item2]++;			}		}	}		// Now go through the list to see if any duplicates exist		for (long item = 1; item <= theReportList->GetCount(); item++)	{		if (theCountList[item] > 2)		{			*duplicatesFound = true;			break;		}	}		// We return the list of counters to the caller, who must delete it when done. The count list is in the	// same order as the input report list.		return theCountList;}