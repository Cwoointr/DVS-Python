// =================================================================================//	CEditVariableDialog.cp				©1995 Metrowerks Inc. All rights reserved.// =================================================================================//	CEditVariableDialog.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include <LStdControl.h>#include <PP_Messages.h>#include <UReanimator.h>#include "CEditVariableDialog.h"#include "CDefineChoicesDialog.h"// This is a lookup table that is index by a variable's type to get the associated Type Menu item indexstatic short kVariableTypeToMenuIndex[] ={	1,			// kGeneralString	4,			// kDate	3,			// kTime	2,			// kIntegerNumber	5,			// kPastDate	0,			// kFloatNumber - not implemented yet	6,			// kCheckBox	7			// kMenu};// And this is the inverse lookupstatic CEyeDxVariable::DataType kMenuIndexToVariableType[] ={	CEyeDxVariable::kTypeNone,		// No menu item 0 - they start at 1	CEyeDxVariable::kGeneralString,	CEyeDxVariable::kIntegerNumber,  	CEyeDxVariable::kTime, 	CEyeDxVariable::kDate, 	CEyeDxVariable::kPastDate, 	CEyeDxVariable::kCheckBox,	CEyeDxVariable::kMenu };	// kFloatNumber not yet supported// This is a lookup table that is index by a variable's WhenToPrompt value to get the associated Type Menu item indexstatic short kVariableWhenToPromptToMenuIndex[] ={	1,			// kPromptOnStart	2,			// kPromptForSubject	3,			// kPromptForSession	0,			// kPromptForEndOfSession	// Not currently used	4,			// kPromptDisabled};// And this is the inverse lookupstatic CEyeDxVariable::PromptType kMenuIndexToVariableWhenToPrompt[] ={	CEyeDxVariable::kPromptNone,		// No menu item 0 - they start at 1	CEyeDxVariable::kPromptOnStart,	CEyeDxVariable::kPromptForSubject, 	CEyeDxVariable::kPromptForSession, 	CEyeDxVariable::kPromptDisabled};	// ---------------------------------------------------------------------------------//		¥ CEditVariableDialog(LStream *)// ---------------------------------------------------------------------------------CEditVariableDialog::CEditVariableDialog(	LStream *inStream )		: CEyeDxDialogType( inStream ){	mValidInput = false;}// ---------------------------------------------------------------------------------//		¥ ~CEditVariableDialog// ---------------------------------------------------------------------------------CEditVariableDialog::~CEditVariableDialog(){}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCEditVariableDialog::FinishCreateSelf(){	// Call inherited. LDialogBox's FinishCreateSelf	// sets up the default and cancel buttons.	CEyeDxDialogType::FinishCreateSelf();		// Link the dialog to the controls.	UReanimator::LinkListenerToControls( this, this, RidL_EditVariableDialog );	}// ---------------------------------------------------------------------------//	¥ AlphaNumericSpaceField// ---------------------------------------------------------------------------//	Key Filter for AlphaNumeric and Space characters////		> Identify delete and cursor keys//		> Accept numbers (0 to 9) and letters (a to z, and A to Z)//		> Reject all other printing characters//		> PassUp all other charactersstatic EKeyStatus AlphaNumericSpaceField(	TEHandle		/* inMacTEH */,	UInt16			inKeyCode,	UInt16&			ioCharCode,	EventModifiers	/* inModifiers */){	EKeyStatus	theKeyStatus = keyStatus_PassUp;		if (UKeyFilters::IsTEDeleteKey(inKeyCode)) {		theKeyStatus = keyStatus_TEDelete;			} else if (UKeyFilters::IsTECursorKey(inKeyCode)) {		theKeyStatus = keyStatus_TECursor;			} else if (UKeyFilters::IsExtraEditKey(inKeyCode)) {		theKeyStatus = keyStatus_ExtraEdit;			} else if (UKeyFilters::IsPrintingChar(ioCharCode)) {			if (UKeyFilters::IsNumberChar(ioCharCode)  ||  UKeyFilters::IsLetterChar(ioCharCode) || ioCharCode == char_Space) {			theKeyStatus = keyStatus_Input;					} else {			theKeyStatus = keyStatus_Reject;		}	}		return theKeyStatus;}voidCEditVariableDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	CEyeDxLongStringType theNameStr;	CEyeDxShortStringType theCommentStr;	CEyeDxShortStringType theDefaultValueStr;	CEyeDxShortStringType thePromptStr;	CEyeDxShortStringType theCurrentPromptStr;					mValidInput = false;		// Assume inputs are invalid		MessageT theMessageToSend = inMessage;	switch (inMessage) 	{				case msg_Cancel: 		break;			case msg_EditVariablePromptForValue:		// Change the temporary variable's type and change all of the window options				if ( *(Int32 *) ioParam == Button_On ) 		{						mTempVariable.SetVariableType(CEyeDxVariable::kPrompted);						// Set some defaults if not initialized						if (mTempVariable.GetWhenToPrompt() == CEyeDxVariable::kPromptNone)				mTempVariable.SetWhenToPrompt(CEyeDxVariable::kPromptForSubject);						if (mTempVariable.GetDataType() == CEyeDxVariable::kTypeNone)				mTempVariable.SetDataType(CEyeDxVariable::kGeneralString);						// If the prompt order hasn't been set, then set it. This would normally happen on a brand new			// Fixed type variable that the user is converting to a prompted type.						if (mTempVariable.GetPromptOrder() == kNoPromptOrder)			{				short nextAvailablePrompt = mVariableList->GetNextAvailablePromptNumber(mTempVariable.GetWhenToPrompt());				mTempVariable.SetPromptOrder(nextAvailablePrompt);			}						SetOptionsForVariable();		}		break;			case msg_EditVariableUseFixedValue:		// Change the temporary variable's type and change all of the window options				if ( *(Int32 *) ioParam == Button_On ) 		{						mTempVariable.SetVariableType(CEyeDxVariable::kFixed);			mTempVariable.SetWhenToPrompt(CEyeDxVariable::kPromptNone);			mTempVariable.SetDataType(CEyeDxVariable::kGeneralString);					SetOptionsForVariable();		}		break;			case msg_EditVariableVariableType:		// The user is changing the variable type. We need to change the type and update the controls				CEyeDxVariable::DataType theOldVariableType = mTempVariable.GetDataType();		CEyeDxVariable::DataType theNewVariableType = kMenuIndexToVariableType[*(Int32 *) ioParam];				// If the old variable type was either the CheckBox or Menu type and we are changing to		// another type, we reset the default string to a blank. If going in the opposite direction,		// we set Menu types to the first item (value 1) and CheckBoxes to Checked (kCheckBoxOnStr)				if (theNewVariableType == CEyeDxVariable::kCheckBox)				mTempVariable.SetDefaultValue(kCheckBoxOnStr);		else if(theNewVariableType == CEyeDxVariable::kMenu)				mTempVariable.SetDefaultValue(1);		else				mTempVariable.SetDefaultValue(Str_Empty);									mTempVariable.SetDataType(theNewVariableType);				// We want to preserve the user's entered prompt, as it may not be the same as stored in the		// temp variable. So grab its value here, and then restore it after the call to SetOptionsForVariable				mPromptField->GetDescriptor(theCurrentPromptStr);				SetOptionsForVariable();		mPromptField->SetDescriptor(theCurrentPromptStr);				break;			case msg_EditVariableDefineValues:			HandleChoiceValueDefinition();		SetOptionsForVariable();		break;			case msg_OK:		// We do some validation here.				// The name must be set, and if a new variable, must not match an existing variable				// First, assume an error will occur - we will pass msg_Nothing in the case where we don't want the normal		// processing of msg_OK to occur				// Note that EyeDx-defined variables cannot be changed by the dialog, as we have disabled editing the		// fields associated with the variable type. The only thing that can be changed is the value of the		// Hidden attribute, and we allow that only if we are allowing display of hidden variables.				if (mTempVariable.GetVariableClass() == CEyeDxVariable::kEyeDx)		{			// Save whether the variable is hidden - we don't have to check whether the control			// is visible because we always set its value appropriately on startup						mTempVariable.SetVariableIsHidden(mHideCheckBox->GetValue());						// We also allow the user to change the Must Enter checkbox, even for EyeDx variables					mTempVariable.SetValueMustBeEntered(mRequiredEntryCheckBox->GetValue());												// Now save the results						*mTheVariable = mTempVariable;			theMessageToSend = inMessage;			mValidInput = true;		}		else		{					theMessageToSend = msg_Nothing;						mVariableNameField->GetDescriptor(theNameStr);			mVariableCommentField->GetDescriptor(theCommentStr);			if (theNameStr.Length() == 0)			{				::ParamText("\pYou must enter the name of the variable!", Str_Empty, Str_Empty, Str_Empty);				UModalAlerts::CautionAlert(PPob_GeneralALRT);			}			else			{				if (mNewVariable && mVariableList->VariableExists(theNameStr))				{					::ParamText("\pThat variable name is already taken. Please use another name!", Str_Empty, Str_Empty, Str_Empty);					UModalAlerts::CautionAlert(PPob_GeneralALRT);				}				else				{										// See if the user changed the name of an existing variable										if (!mNewVariable && (*mThePreviousName != theNameStr) && mVariableList->VariableExists(theNameStr))					{						::ParamText("\pThat variable name is already taken. Please use another name!", Str_Empty, Str_Empty, Str_Empty);						UModalAlerts::CautionAlert(PPob_GeneralALRT);					}					else					{						// Save the variable name													mTempVariable.SetName(theNameStr);													mTempVariable.SetCommentString(theCommentStr);													// Save whether the variable is hidden - we don't have to check whether the control						// is visible because we always set its value appropriately on startup												mTempVariable.SetVariableIsHidden(mHideCheckBox->GetValue());						switch (mTempVariable.GetVariableType())						{						case CEyeDxVariable::kFixed:																		mFixedValueField->GetDescriptor(theDefaultValueStr);														if (theDefaultValueStr.Length() == 0)							{								::ParamText("\pYou must enter a value for the variable!", Str_Empty, Str_Empty, Str_Empty);								UModalAlerts::CautionAlert(PPob_GeneralALRT);							}							else							{								mTempVariable.SetDefaultValue(theDefaultValueStr);								mTempVariable.SetPromptString(Str_Empty);								// We don't change the other values in case the user later decides to change the variable type																// Now save the results																*mTheVariable = mTempVariable;								theMessageToSend = inMessage;								mValidInput = true;							}														break;													case CEyeDxVariable::kPrompted:													mPromptField->GetDescriptor(thePromptStr);														if (thePromptStr.Length() == 0)							{								::ParamText("\pYou must enter a prompt for the variable!", Str_Empty, Str_Empty, Str_Empty);								UModalAlerts::CautionAlert(PPob_GeneralALRT);							}							else							{								// From here, the variable mValidInput is used to indicate at the end whether the								// variable should be updated. Assume true for now.																mValidInput = true;								mTempVariable.SetPromptString(thePromptStr);																if (mTempVariable.GetDataType() == CEyeDxVariable::kCheckBox)								{									if (mCheckedButton->GetValue())										mTempVariable.SetDefaultValue(kCheckBoxOnStr);									else										mTempVariable.SetDefaultValue(kCheckBoxOffStr);								}								else								if (mTempVariable.GetDataType() == CEyeDxVariable::kMenu)								{									// Get the list of choices. If there is at least one choice, everything is fine																		CTemplateShortStrArray *theOptionStringList = mTempVariable.GetOptionStringsArray();																		if (theOptionStringList->GetCount() == 0)									{										::ParamText("\pYou must enter at least one menu choice for the variable!", Str_Empty, Str_Empty, Str_Empty);										UModalAlerts::CautionAlert(PPob_GeneralALRT);										mValidInput = false;									}									else									{										// We also have to save the default value																				short theChoice = mDefaultMenuItemMenu->GetValue();																				CEyeDxShortStringType *theChoiceString;																				theOptionStringList->FetchItemAt(theChoice, theChoiceString);																				mTempVariable.SetDefaultValue(*theChoiceString);									}								}								else								{									mDefaultValueField->GetDescriptor(theDefaultValueStr);																	// Note that the default value can be left empty - that means that no value will be									// filled-in when the user is prompted.																		mTempVariable.SetDefaultValue(theDefaultValueStr);										short theMaxNumLines = mEntryLinesMenu->GetValue();													mTempVariable.SetExtraEntryLines(theMaxNumLines - 1);								}																	if (mValidInput)								{																// Now just get the values of the menus and radio buttons and set the appropriate variable fields																		mTempVariable.SetWhenToPrompt(kMenuIndexToVariableWhenToPrompt[mWhenToPromptMenu->GetValue()]);																		mTempVariable.SetDataType(kMenuIndexToVariableType[mVariableTypeMenu->GetValue()]);									mTempVariable.SetValueMustBeEntered(mRequiredEntryCheckBox->GetValue());																		// Now save the results																		*mTheVariable = mTempVariable;								}								theMessageToSend = inMessage;							}							break;													case CEyeDxVariable::kCalculated:																									// Since this is a type defined at runtime, we don't change anything here. Actually,							// we shouldn't get here at all, since calculated variables are EyeDx-defined, and thus							// the first test after the case statement should bypass this whole section.																					theMessageToSend = inMessage;							mValidInput = true;														break;													}					}				}			}		}		break;			default:		break;	}	// Always pass the message on to our base class		CEyeDxDialogType::ListenToMessage(theMessageToSend, ioParam);}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------voidCEditVariableDialog::SetupDialog(CEyeDxVariableList *theVariableList, CEyeDxVariable *theVariable, CEyeDxBooleanType newVariable, CEyeDxBooleanType showHidden){	// Make a copy of the variable that we can modify		mTempVariable = *theVariable;		// Also save the pointer to the original so we can modify it		mTheVariable = theVariable;		// Save the flag indicating whether this is a new variable or not	mNewVariable = newVariable;		mShowHidden = showHidden;		// Save the name of the variable in the case the user changes the name of an existing	// variable - we can then verify that no conflict exists. 		mThePreviousName = theVariable->GetName();		mVariableList = theVariableList;		mVariableNameField = dynamic_cast<CEyeDxEditFieldType*> (this->FindPaneByID(kEditVariable_NameEdit));	ThrowIfNil_( mVariableNameField );	mVariableCommentField = dynamic_cast<CEyeDxEditFieldType*> (this->FindPaneByID(kEditVariable_CommentEdit));	ThrowIfNil_( mVariableCommentField );	mVariableTypeCaption = dynamic_cast<CEyeDxCaptionType*> (this->FindPaneByID(kEditVariable_TypeCaption));	ThrowIfNil_( mVariableTypeCaption );	mHideCheckBox = dynamic_cast<CEyeDxCheckBoxType*> (this->FindPaneByID(kEditVariable_HideCheckBox));	ThrowIfNil_( mHideCheckBox );		mUseFixedValueButton = dynamic_cast<CEyeDxRadioButtonType*> (this->FindPaneByID(kEditVariable_UseFixedValueButton));	ThrowIfNil_( mUseFixedValueButton );		mFixedValueField = dynamic_cast<CEyeDxEditFieldType*> (this->FindPaneByID(kEditVariable_FixedValueEdit));	ThrowIfNil_( mFixedValueField );	mPromptForValueButton = dynamic_cast<CEyeDxRadioButtonType*> (this->FindPaneByID(kEditVariable_PromptForValueButton));	ThrowIfNil_( mPromptForValueButton );		mWhenToPromptMenu = dynamic_cast<CEyeDxPopupMenuType*> (this->FindPaneByID(kEditVariable_WhenToPromptMeny));	ThrowIfNil_( mWhenToPromptMenu );		mPromptField = dynamic_cast<CEyeDxEditFieldType*> (this->FindPaneByID(kEditVariable_PromptEdit));	ThrowIfNil_( mPromptField );	mDefaultValueField = dynamic_cast<CEyeDxEditFieldType*> (this->FindPaneByID(kEditVariable_DefaultValueEdit));	ThrowIfNil_( mDefaultValueField );	mVariableTypeMenu = dynamic_cast<CEyeDxPopupMenuType*> (this->FindPaneByID(kEditVariable_TypeMenu));	ThrowIfNil_( mVariableTypeMenu );		mDefineValuesButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kEditVariable_DefineValuesButton));	ThrowIfNil_( mDefineValuesButton );		mCheckedButton = dynamic_cast<CEyeDxRadioButtonType*> (this->FindPaneByID(kEditVariable_CheckedButton));	ThrowIfNil_( mCheckedButton );	mUncheckedButton = dynamic_cast<CEyeDxRadioButtonType*> (this->FindPaneByID(kEditVariable_UncheckedButton));	ThrowIfNil_( mUncheckedButton );		mRequiredEntryCheckBox = dynamic_cast<CEyeDxCheckBoxType*> (this->FindPaneByID(kEditVariable_RequiredEntryCheck));	ThrowIfNil_( mRequiredEntryCheckBox );		mEntryLinesMenu = dynamic_cast<CEyeDxPopupMenuType*> (this->FindPaneByID(kEditVariable_EntryLinesMenu));	ThrowIfNil_( mEntryLinesMenu );		mDefaultItemCaption = dynamic_cast<CEyeDxCaptionType*> (this->FindPaneByID(kEditVariable_DefaultValueCaption));	ThrowIfNil_( mDefaultItemCaption );	mDefaultMenuItemMenu = dynamic_cast<CEyeDxPopupMenuType*> (this->FindPaneByID(kEditVariable_DefaultValueMenu));	ThrowIfNil_( mDefaultMenuItemMenu );			mCancelButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kEditVariable_Cancel));	ThrowIfNil_( mCancelButton );		mSaveButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kEditVariable_OK));	ThrowIfNil_( mSaveButton );		mVariableNameField->SetDescriptor(*(mTempVariable.GetName()));		mVariableCommentField->SetDescriptor(*(mTempVariable.GetCommentString()));		// We accept alphanumeric characters and spaces in variable names		mVariableNameField->SetKeyFilter(AlphaNumericSpaceField);		SetOptionsForVariable();} voidCEditVariableDialog::SetOptionsForVariable(){	// Temporarily stop listening so we don't get messages when we set the values		StopListening();		// Initially, just disable everything till we figure out what to enable			mUseFixedValueButton->SetValue(false);	mUseFixedValueButton->Disable();	mFixedValueField->Disable();	mFixedValueField->SetDescriptor("\p");		mPromptForValueButton->SetValue(false);	mPromptForValueButton->Disable();	mWhenToPromptMenu->Disable();		mPromptField->Disable();	mDefaultValueField->Disable();	mDefaultValueField->Hide();	mPromptField->SetDescriptor("\p");	mDefaultValueField->SetDescriptor("\p");	mDefaultMenuItemMenu->Hide();	mDefaultMenuItemMenu->Disable();	mDefaultItemCaption->Show();					mVariableTypeMenu->Disable();	mDefineValuesButton->Disable();	mCheckedButton->Disable();	mUncheckedButton->Disable();		mCheckedButton->Hide();	mUncheckedButton->Hide();		mEntryLinesMenu->Disable();	mEntryLinesMenu->Hide();		mRequiredEntryCheckBox->Disable();		// If advanced features are enabled, allow the user to hide the variable		if (mShowHidden)		mHideCheckBox->Show();			mHideCheckBox->SetValue(mTempVariable.GetVariableIsHidden());		if (mTempVariable.GetDataType() == CEyeDxVariable::kMenu)	{		// Now, we update the Insert Variable menu to reflect the current list		MenuHandle theDefaultMenuItemPopupMenu = mDefaultMenuItemMenu->GetMacMenuH();		ThrowIfNil_( theDefaultMenuItemPopupMenu );		// Delete the current items in the list, except for the first, which is just used as a		// heading.		long nMenuItems = ::CountMItems(theDefaultMenuItemPopupMenu);		for (UInt16 theItemToRemove = 1; theItemToRemove <= nMenuItems; theItemToRemove++)		{			::DeleteMenuItem(theDefaultMenuItemPopupMenu, 1);	// Always delete the first item, which will shrink the																// menu down to nothing when we are done.		}		CTemplateShortStrArray *theOptionStringList = mTempVariable.GetOptionStringsArray();				ThrowIfNil_(theOptionStringList);			TArrayIterator<CEyeDxShortStringType *> iterator(*theOptionStringList);				CEyeDxShortStringType *theString;				short theSelectedItem = 1;		short theItem = 1;				while (iterator.Next(theString))		{			::AppendMenu(theDefaultMenuItemPopupMenu, *theString);						if (*theString == *(mTempVariable.GetDefaultValue()))				theSelectedItem = theItem;			theItem++;		}		// According to the PowerPlant Book, if I change the number of items in the menu		// I have to set the Max Value properly.				mDefaultMenuItemMenu->SetMaxValue(theItem);				mDefaultMenuItemMenu->SetValue(theSelectedItem);	}		if (mTempVariable.GetVariableClass() == CEyeDxVariable::kEyeDx)	{		// Can't change the name or the comment!				mVariableNameField->Disable();				mVariableCommentField->Disable();					// Now, user can change some attributes of EyeDx variables, so we have to leave the buttons alone.#if FALSE		// If hidden variables are displayed, the user can change whether they are displayed or not				if (!mShowHidden)		{			mSaveButton->SetDescriptor("\pOK");	// Just say OK, since they can't save any changes				mCancelButton->Disable();	// No sense cancelling, since they can't change anything		}#endif				switch (mTempVariable.GetVariableType())		{		case CEyeDxVariable::kFixed:					mVariableTypeCaption->SetDescriptor("\pEyeDx-defined Fixed Variable");					// Set the options for the Fixed style of variable					mFixedValueField->SetDescriptor(*(mTempVariable.GetDefaultValue()));									break;					case CEyeDxVariable::kPrompted:					mVariableTypeCaption->SetDescriptor("\pEyeDx-defined Prompted Variable");					// Set the options for the Prompted style of variable						// The main radio button						mPromptForValueButton->SetValue(true);						mWhenToPromptMenu->SetValue(kVariableWhenToPromptToMenuIndex[mTempVariable.GetWhenToPrompt()]);						// The prompt and default value fields						mPromptField->SetDescriptor(*(mTempVariable.GetPromptString()));						// The variable validation type menu						mVariableTypeMenu->SetValue(kVariableTypeToMenuIndex[mTempVariable.GetDataType()]);						switch (mTempVariable.GetDataType())			{			case CEyeDxVariable::kGeneralString:				// Since it's a general string entry type, we set the number of lines in the entry field pop-up								short theMaxNumLines = mEntryLinesMenu->GetMaxValue();								short theExtraEntryLines = mTempVariable.GetExtraEntryLines();				if (theExtraEntryLines > (theMaxNumLines - 1))					theExtraEntryLines = theMaxNumLines - 1;				else				if (theExtraEntryLines < 0)					theExtraEntryLines = 0;									mEntryLinesMenu->SetValue(theExtraEntryLines + 1);	// There's always at least one line				mEntryLinesMenu->Show();					// Fall through to common stuff							case CEyeDxVariable::kDate:			case CEyeDxVariable::kTime:			case CEyeDxVariable::kIntegerNumber:			case CEyeDxVariable::kFloatNumber:			case CEyeDxVariable::kPastDate:							mDefaultValueField->Show();				mDefaultValueField->SetDescriptor(*(mTempVariable.GetDefaultValue()));				// Indicate whether it's a required entry item								mRequiredEntryCheckBox->SetValue(mTempVariable.GetValueMustBeEntered());				// We allow the user to change this, even for EyeDx variables								mRequiredEntryCheckBox->Enable();				break;							case CEyeDxVariable::kCheckBox:				mCheckedButton->Show();				mUncheckedButton->Show();								if (*(mTempVariable.GetDefaultValue()) == kCheckBoxOnStr)					mCheckedButton->SetValue(1);				else					mUncheckedButton->SetValue(1);								mRequiredEntryCheckBox->SetValue(1);				break;			case CEyeDxVariable::kMenu:							mDefineValuesButton->SetDescriptor("\pDisplay ChoicesÉ");							mDefineValuesButton->Enable();								mRequiredEntryCheckBox->SetValue(1);				mDefaultItemCaption->Hide();								mDefaultMenuItemMenu->Show();	// We show the menu, but don't enable it.				break;			}						break;		case CEyeDxVariable::kCalculated:					mVariableTypeCaption->SetDescriptor("\pEyeDx-defined Calculated Variable");					break;					}	}	else	// It's a user-defined variable - so enable various fields	{		mUseFixedValueButton->Enable();		mPromptForValueButton->Enable();		switch (mTempVariable.GetVariableType())		{		case CEyeDxVariable::kFixed:					mVariableTypeCaption->SetDescriptor("\pUser-defined Fixed Variable");					// Enable the options for the Fixed style of variable					mUseFixedValueButton->SetValue(true);			mFixedValueField->Enable();			mFixedValueField->SetDescriptor(*(mTempVariable.GetDefaultValue()));						break;					case CEyeDxVariable::kPrompted:					mVariableTypeCaption->SetDescriptor("\pUser-defined Prompted Variable");					// Enable the options for the Prompted style of variable						// The main radio button						mPromptForValueButton->SetValue(true);						// The when to prompt radio buttons						mWhenToPromptMenu->Enable();						// The prompt and default value fields						mPromptField->Enable();			mPromptField->SetDescriptor(*(mTempVariable.GetPromptString()));						mWhenToPromptMenu->SetValue(kVariableWhenToPromptToMenuIndex[mTempVariable.GetWhenToPrompt()]);						// The prompt and default value fields						mPromptField->SetDescriptor(*(mTempVariable.GetPromptString()));			mDefaultValueField->SetDescriptor(*(mTempVariable.GetDefaultValue()));						// The variable validation type menu						mVariableTypeMenu->Enable();						mVariableTypeMenu->SetValue(kVariableTypeToMenuIndex[mTempVariable.GetDataType()]);						switch (mTempVariable.GetDataType())			{			case CEyeDxVariable::kGeneralString:				// Since it's a general string entry type, we set the number of lines in the entry field pop-up								short theMaxNumLines = mEntryLinesMenu->GetMaxValue();								short theExtraEntryLines = mTempVariable.GetExtraEntryLines();				if (theExtraEntryLines > (theMaxNumLines - 1))					theExtraEntryLines = theMaxNumLines - 1;				else				if (theExtraEntryLines < 0)					theExtraEntryLines = 0;									mEntryLinesMenu->SetValue(theExtraEntryLines + 1);	// There's always at least one line				mEntryLinesMenu->Show();					mEntryLinesMenu->Enable();					// Fall through to common stuff							case CEyeDxVariable::kDate:			case CEyeDxVariable::kTime:			case CEyeDxVariable::kIntegerNumber:			case CEyeDxVariable::kFloatNumber:			case CEyeDxVariable::kPastDate:				mDefaultValueField->Enable();				mDefaultValueField->Show();				mDefaultValueField->SetDescriptor(*(mTempVariable.GetDefaultValue()));				// Indicate whether it's a required entry item								mRequiredEntryCheckBox->SetValue(mTempVariable.GetValueMustBeEntered());				// We allow the user to change this								mRequiredEntryCheckBox->Enable();				break;							case CEyeDxVariable::kCheckBox:				mCheckedButton->Enable();				mCheckedButton->Show();				mUncheckedButton->Enable();				mUncheckedButton->Show();								if (*(mTempVariable.GetDefaultValue()) == kCheckBoxOnStr)					mCheckedButton->SetValue(1);				else					mUncheckedButton->SetValue(1);								mRequiredEntryCheckBox->SetValue(1);				break;			case CEyeDxVariable::kMenu:							mDefineValuesButton->SetDescriptor("\pDefine ChoicesÉ");							mDefineValuesButton->Enable();				mRequiredEntryCheckBox->SetValue(1);				mDefaultItemCaption->Hide();								mDefaultMenuItemMenu->Show();				mDefaultMenuItemMenu->Enable();								break;			}						break;		}	}	StartListening();}Boolean CEditVariableDialog::HandleChoiceValueDefinition(){	// Create the dialog handler.	StDialogHandler theHandler( PPob_DefineChoicesDialog, this );	// Get the dialog.	CDefineChoicesDialog *theDialog;	theDialog = dynamic_cast<CDefineChoicesDialog *>(theHandler.GetDialog());	ThrowIfNil_(theDialog);		// Set up the dialog and specify whether to allow editing of the values, or just allow displaying them		theDialog->SetupDialog(&mTempVariable, (mTempVariable.GetVariableClass() == CEyeDxVariable::kUser));		// Make the dialog visible.	theDialog->Show();		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_Cancel:			return false;			break;		case msg_OK:			return true;			break;		}	}	return false;}