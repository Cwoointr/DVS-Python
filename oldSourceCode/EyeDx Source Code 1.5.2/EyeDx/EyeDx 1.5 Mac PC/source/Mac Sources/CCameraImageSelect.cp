// =================================================================================//	CDocumentApp.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for a document PowerPlant project////  The Application is derived from LDocApplication.  New Windows are managed//  by CTextDocument which is derived from LSingleDoc.  Each document contains//  a smart text view that remembers if it has changed since it was last saved.#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>extern "C"{#include <FSp_fopen.h>}// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <StandardFile.h>#include <NumberFormatting.h>#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <PPobClasses.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <URegistrar.h>#include <UTextTraits.h>#include <LIconPane.h>#include <UStandardDialogs.h>#include <LWindow.h>#include <LGroupBox.h>#include <LTextButton.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CMyGWorldView.h"#include "USubFolderFinder.h"#include <path2fss.h>#include "CEyeDxPrefs.h"#include "CAboutDialog.h"#include "ABalloon.h"#include "FileCopy.h"#include "CSingleClickListBox.h"#include "DC120.h"#include "CSpaceClickDialog.h"#include <OSUtils.h>// ---------------------------------------------------------------------------------//		¥ HandleCameraImageSelect// ---------------------------------------------------------------------------------// This routine handles display of the select dialog for camera images. Returns true// if a new selection is made.Boolean CDocumentApp::HandleCameraImageSelect(MessageT	inMessage, 										   CEyeDxViewType *theMainWindowView, 										   CEyeDxCaptionType *theMainWindowCaption,										   DCPictInfo *theMainWindowGenericPictInfo,										   DC120PictInfo *theMainWindowPictInfo,										   CEyeDxIconType *theMainWindowQualityIcon){	UInt16 theItem;	int theLastItem;	UInt16 theCurrentItem;	int	*theItemPtr;	DCPictInfo theGenericPictInfo;	DC120PictInfo thePictInfo;		// Create the dialog handler.	StDialogHandler theHandler( PPob_CameraImageDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		CSingleClickListBox *theListBox = dynamic_cast<CSingleClickListBox*> (theDialog->FindPaneByID(kCameraImageListBox));	ThrowIfNil_( theListBox );		// Tell the List Box to send us specific messages		theListBox->SetSingleClickMessage(msg_CameraImageSingleClick);	theListBox->SetDoubleClickMessage(msg_CameraImageDoubleClick);		// Add the dialog to the list of listeners of the list box	theListBox->AddListener(&theHandler);	// Set the list to allow only one item to be selected	ListHandle theListBoxList = theListBox->GetMacListH();		(**theListBoxList).selFlags = lOnlyOne;	CEyeDxViewType *theThumbnail = dynamic_cast<CEyeDxViewType*> (theDialog->FindPaneByID(kCameraImageMyGWorldView));	ThrowIfNil_( theThumbnail );		CEyeDxCaptionType *theCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kCameraImageCaption));	ThrowIfNil_( theCaption );	theCaption->AddAttachment(mEraseAttachment, nil, false);	CEyeDxCaptionType *theQualityCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kCameraImageQualityCaption));	ThrowIfNil_( theQualityCaption );	theQualityCaption->AddAttachment(mEraseAttachment, nil, false);	CEyeDxButtonType *theCancelButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kCameraImage_Cancel));	CEyeDxButtonType *theOKButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kCameraImage_OK));			// Make the dialog visible early so the user knows something is happening	theDialog->Show();	theDialog->Draw(nil);		theCaption->SetDescriptor("\pBuilding image list...");	theCaption->Draw(nil);	// Temporarily stop listening so we don't get messages when we set the values		StopListening();	// When we first queried the camera, we got the list of available images.	// We fill in the list box here with those images		// Note that the list was defined in Constructor with a dummy item so that the	// list is set up properly. So, we delete it here.		::LDelRow(0, 0, theListBoxList);		const int thePictNameLength = 7;			char *p = PictNamePtr;	Point cIndex;		for (int i = 0; i < NumOfPicts; i++)	{		// Add a row to the list box				int rowNum = ::LAddRow(1, i, theListBoxList);				::SetPt(&cIndex, 0, i);				::LSetCell(p, thePictNameLength, cIndex, theListBoxList);		// Advance the pointer to the next item				p += DC120AlbumPictureSize;			}		// Set up some variables based on the Up or Side image to be selected		int theSide;	switch (inMessage)	{	case msg_CameraUpSelectImage:		theSide = 1;		theCurrentItem = UpPictNum;		theItemPtr = &UpPictNum;		theDialog->SetDescriptor("\pSelect Up Image");		break;	case msg_CameraSideSelectImage:		theSide = 2;		theCurrentItem = SidePictNum;		theItemPtr = &SidePictNum;		theDialog->SetDescriptor("\pSelect Side Image");		break;	}	// Now, we select the the previously-selected item in the list		if (NumOfPicts > 0)	{		// Since the main window caption and view are already set, we just copy		// them instead of downloading - MUCH faster!		theLastItem = *theItemPtr;				Str255 theString;				theMainWindowCaption->GetDescriptor(theString);		theCaption->SetDescriptor(theString);		theThumbnail->CopyPixMapData(theMainWindowView->GetPixMapHandle());		switch (theMainWindowPictInfo->PictQuality)		{		case DC120NoCompression:			theQualityCaption->SetDescriptor("\pQuality: No Compression");			break;		case DC120BestQuality:			theQualityCaption->SetDescriptor("\pQuality: Best (recommended)");			break;		case DC120BetterQuality:			theQualityCaption->SetDescriptor("\pQuality: Better");			break;		case DC120GoodQuality:			theQualityCaption->SetDescriptor("\pQuality: Good");			break;		}				    		}		// Remember to save the item's current information, in case they just hit Select	// without clicking in the list box		theGenericPictInfo = *theMainWindowGenericPictInfo;	thePictInfo = *theMainWindowPictInfo;	StartListening();	// Select the current item		::SetPt(&cIndex, 0, (theCurrentItem - 1));		theListBox->SetValue(theCurrentItem - 1);	theListBox->MakeCellVisible(cIndex);				// Turn on automatic drawing mode		::LSetDrawingMode(true, theListBoxList);	// Activate the list box so it immediately accepts keystrokes	theDialog->SetLatentSub(theListBox);		// Make the dialog visible.	theDialog->Show();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		if ( theMessage == msg_Cancel ) 		{			// Restore the previously selected item						*theItemPtr = theCurrentItem;						return false;		} 		else if ( theMessage == msg_OK ) 		{			// We just update the captions, and copy the already-downloaded thumbnail data into the			// main window's view - no sense re-downloading it!						theItem = theListBox->GetValue();			if (theItem >= 0)			{											StCursor wait;	// Set the pointer to the stop watch while we are setting up				*theItemPtr = theItem + 1;					Str255 theString;						theCaption->GetDescriptor(theString);				theMainWindowCaption->SetDescriptor(theString);				theMainWindowView->CopyPixMapData(theThumbnail->GetPixMapHandle());								theMainWindowQualityIcon->Show();								// If the quality isn't what we should be using, warn the user				if (thePictInfo.PictQuality != DC120BestQuality)				{				 	::ParamText("\pThis image was not taken with the recommended 'Best' image quality setting,",				 				"\pand analysis of this image may produce incorrect results.",				 				"\pEyeDx recommends you retake this picture.", Str_Empty);					UModalAlerts::CautionAlert(PPob_GeneralALRT);					theMainWindowQualityIcon->SetIconID(kCautionQualityIconList);				}				else					theMainWindowQualityIcon->SetIconID(kGoodQualityIconList);								// We also update the caller's pict info structure								*theMainWindowGenericPictInfo = theGenericPictInfo;				*theMainWindowPictInfo = thePictInfo;							}						return true;		}		else if ( theMessage == msg_CameraImageSingleClick ) 		{			// This causes us to just download the thumbnail						// Get the selection, and copy the thumbnail			// The camera interface starts counting at 1, whereas the list starts at 0			theLastItem = theItem;			theItem = theListBox->GetValue();			if (theItem >= 0 && theLastItem != theItem)					{				StCursor wait;	// Set the pointer to the stop watch while we are setting up				theListBox->Disable();					theCancelButton->Disable();							theOKButton->Disable();											theCaption->SetDescriptor("\pDownloading image...");				theCaption->Draw(nil);				*theItemPtr = theItem + 1;							GetIconFromCamera(*theItemPtr, theSide, &theGenericPictInfo, &thePictInfo, nil, theThumbnail, theCaption);								switch (thePictInfo.PictQuality)				{				case DC120NoCompression:					theQualityCaption->SetDescriptor("\pQuality: No Compression");					break;				case DC120BestQuality:					theQualityCaption->SetDescriptor("\pQuality: Best (recommended)");					break;				case DC120BetterQuality:					theQualityCaption->SetDescriptor("\pQuality: Better");					break;				case DC120GoodQuality:					theQualityCaption->SetDescriptor("\pQuality: Good");					break;				}											// Note that we do not update anything in the main window. We wait for the				// Select button to be pressed, so that a Cancel doesn't require any special handling				// to restore the main window values.	    			    					// Now enable everything again								theListBox->Enable();					theCancelButton->Enable();							theOKButton->Enable();										}			// No break here - we want to continue looping		}		else if ( theMessage == msg_CameraImageDoubleClick ) 		{			// This is the same as selecting the object, downloading the thumbnail, and hitting the Select button						// Get the selection, and copy the thumbnail to the main window's view, and also update its caption			// The camera interface starts counting at 1, whereas the list starts at 0						theItem = theListBox->GetValue();							if (theItem >= 0)			{				StCursor wait;	// Set the pointer to the stop watch while we are setting up				theListBox->Disable();					theCancelButton->Disable();							theOKButton->Disable();											theCaption->SetDescriptor("\pDownloading image...");				theCaption->Draw(nil);				*theItemPtr = theItem + 1;							GetIconFromCamera(*theItemPtr, theSide, &theGenericPictInfo, &thePictInfo, nil, theMainWindowView, theMainWindowCaption);				theMainWindowQualityIcon->Show();				// If the quality isn't what we should be using, warn the user				if (thePictInfo.PictQuality != DC120BestQuality)				{				 	::ParamText("\pThis image was not taken with the recommended 'Best' image quality setting,",				 				"\pand analysis of this image may produce incorrect results.",				 				"\pEyeDx recommends you retake this picture.", Str_Empty);					UModalAlerts::CautionAlert(PPob_GeneralALRT);					theMainWindowQualityIcon->SetIconID(kCautionQualityIconList);				}				else					theMainWindowQualityIcon->SetIconID(kGoodQualityIconList);				// We also update the caller's pict info structure								*theMainWindowGenericPictInfo = theGenericPictInfo;				*theMainWindowPictInfo = thePictInfo;			}			return true;		}	}}