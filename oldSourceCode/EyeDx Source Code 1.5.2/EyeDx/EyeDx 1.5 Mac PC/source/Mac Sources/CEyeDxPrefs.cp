// ===========================================================================//	CEyeDxPrefs.cp - based on UWindowState by  ©1994 J. Rodden, DD/MF & Associates// ===========================================================================// Utilities for saving and restoring the EyeDx application's preferences.//// All rights reserved. You may use this code in any application, recognition// would be appreciated but is not required.#include <string.h>#include <stdio.h>#include <stdlib.h>#include "globals.h"#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "CEyeDxVariables.h"#include <limits.h>// ===========================================================================CEyeDxPrefs::CEyeDxPrefs(ConstStringPtr inFileName,				Boolean		   inCreateFolder)				: LPreferencesFile(inFileName, inCreateFolder){	LPreferencesFile::OpenOrCreateResourceFork(fsWrPerm, kEyeDxCreator, kEyeDxPrefsType, smSystemScript);}voidCEyeDxPrefs::SaveBrowserPref(OSType inBrowserCode, short inResID){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		BrowserPref theBrowserPref;	theBrowserPref.version = kBROWVers1;	theBrowserPref.typeCode = inBrowserCode;		// -----------------------------------------	// Store the browser preference		BrowserPref	**theHandle = 					(BrowserPref**) ::Get1Resource( kBrowserPref, inResID);		if ( theHandle != nil )		{		// a browser pref resource already exists -- update it		**theHandle = theBrowserPref;	  ::ChangedResource(Handle(theHandle));	} 	else 	{		// no data has yet been saved -- add resource		theHandle = (BrowserPref**) (NewHandle(sizeof(theBrowserPref)));		if ( theHandle != nil ) {			**theHandle = theBrowserPref;		  ::AddResource( Handle(theHandle), kBrowserPref, inResID, nil);		}	}		if ( theHandle != nil ) 	{	  ::UpdateResFile(LPreferencesFile::GetResourceForkRefNum());	  ::ReleaseResource(Handle(theHandle));	}		// Restore the previous resource file		::UseResFile(curResFile);	}// ===========================================================================voidCEyeDxPrefs::LoadBrowserPref(OSType *inBrowserCode, short inResID){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		BrowserPref	theBrowserPref;	BrowserPref	**theHandle;		// -----------------------------------------	// Get saved preference			theHandle = (BrowserPref**) ::Get1Resource( kBrowserPref, inResID);			// Default to unknown value		*inBrowserCode = kUnknownType;		// -----------------------------------------	// Restore preference	if ( theHandle != nil )		{	// handle to data succeeded -- retrieve saved user state		theBrowserPref = **theHandle;		if (theBrowserPref.version == kBROWVers1)			*inBrowserCode = theBrowserPref.typeCode;			}	 	::ReleaseResource(Handle(theHandle));	// Restore the previous resource file		::UseResFile(curResFile); }voidCEyeDxPrefs::SaveCameraPrefs(CameraPrefs *inCameraPrefs, short inResID){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		// Make sure it's the current version		inCameraPrefs->version = kCAMPVers1;		// -----------------------------------------	// Store the browser preference		CameraPrefs	**theHandle = 					(CameraPrefs**) ::Get1Resource( kCameraPrefs, inResID);		if ( theHandle != nil )		{		// a camera pref resource already exists -- update it		**theHandle = *inCameraPrefs;	  ::ChangedResource(Handle(theHandle));	} 	else 	{		// no data has yet been saved -- add resource		theHandle = (CameraPrefs**) (NewHandle(sizeof(CameraPrefs)));		if ( theHandle != nil ) {			**theHandle = *inCameraPrefs;		  ::AddResource( Handle(theHandle), kCameraPrefs, inResID, nil);		}	}		if ( theHandle != nil ) 	{	  ::UpdateResFile(LPreferencesFile::GetResourceForkRefNum());	  ::ReleaseResource(Handle(theHandle));	}		// Restore the previous resource file		::UseResFile(curResFile);	}// ===========================================================================voidCEyeDxPrefs::LoadCameraPrefs(CameraPrefs *inCameraPrefs, short inResID){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		CameraPrefs	theCameraPrefs;	CameraPrefs	**theHandle;		// -----------------------------------------	// Get saved preference			theHandle = (CameraPrefs**) ::Get1Resource(kCameraPrefs, inResID);			// Clear the structure and set defaults		memset(inCameraPrefs, 0, sizeof(CameraPrefs));		inCameraPrefs->version = kCAMPVers1;	inCameraPrefs->saveFiles = true;	inCameraPrefs->defaultPort = DCPortNum1;	inCameraPrefs->defaultPort = DCPortNum1;	inCameraPrefs->autoStartAutoCameraMode = false;	// -----------------------------------------	// Restore preference	if ( theHandle != nil )		{	// handle to data succeeded -- retrieve saved user state		theCameraPrefs = **theHandle;		if (theCameraPrefs.version == kCAMPVers1)			*inCameraPrefs = theCameraPrefs;			// Copy the structure		}		// We make sure that the default port is valid. Old versions of the camera	// preferences structure are set to zero, which for the DC120 constants means	// "AutoDetect". We don't want to use that value for now.		if (inCameraPrefs->defaultPort == DCPortAuto)		inCameraPrefs->defaultPort = DCPortNum1;	 	::ReleaseResource(Handle(theHandle));	// Restore the previous resource file		::UseResFile(curResFile); }voidCEyeDxPrefs::SaveReportPrefs(ReportPrefs *inReportPrefs, short inResID){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		// Make sure it's the current version		inReportPrefs->version = kRPTDVers1;		// -----------------------------------------	// Store the browser preference		ReportPrefs	**theHandle = 					(ReportPrefs**) ::Get1Resource( kReportPrefs, inResID);		if ( theHandle != nil )		{		// a camera pref resource already exists -- update it		**theHandle = *inReportPrefs;	  ::ChangedResource(Handle(theHandle));	} 	else 	{		// no data has yet been saved -- add resource		theHandle = (ReportPrefs**) (NewHandle(sizeof(ReportPrefs)));		if ( theHandle != nil ) {			**theHandle = *inReportPrefs;		  ::AddResource( Handle(theHandle), kReportPrefs, inResID, nil);		}	}		if ( theHandle != nil ) 	{	  ::UpdateResFile(LPreferencesFile::GetResourceForkRefNum());	  ::ReleaseResource(Handle(theHandle));	}		// Restore the previous resource file		::UseResFile(curResFile);	}// ===========================================================================voidCEyeDxPrefs::LoadReportPrefs(ReportPrefs *inReportPrefs, short inResID){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		ReportPrefs	theReportPrefs;	ReportPrefs	**theHandle;		// -----------------------------------------	// Get saved preference			theHandle = (ReportPrefs**) ::Get1Resource(kReportPrefs, inResID);			// Clear the structure and set defaults		memset(inReportPrefs, 0, sizeof(ReportPrefs));		inReportPrefs->version = kRPTDVers1;	inReportPrefs->displayOption = kDisplaySummary;	inReportPrefs->formatOption = kStandardReportFormat;	inReportPrefs->adjustName= kAdjustName;	inReportPrefs->allowLetterHead = kNoLetterHead;	inReportPrefs->useSessions = kNoSessions;	// -----------------------------------------	// Restore preference	if ( theHandle != nil )		{	// handle to data succeeded -- retrieve saved user state		theReportPrefs = **theHandle;		if (theReportPrefs.version == kRPTDVers1)			*inReportPrefs = theReportPrefs;			// Copy the structure		}	 	::ReleaseResource(Handle(theHandle));	// Restore the previous resource file		::UseResFile(curResFile); }voidCEyeDxPrefs::SaveReportTextPrefs(Handle inHandle, short inResID){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		// -----------------------------------------	// Store the browser preference		Handle theHandle = ::Get1Resource(kReportTextPrefs, inResID);		if ( theHandle != nil )		{		// a report text resource already exists -- update it				::SetHandleSize(theHandle, ::GetHandleSize(inHandle));		::HLock(inHandle);		::PtrToXHand(*inHandle, theHandle, ::GetHandleSize(inHandle));		::HUnlock(inHandle);			  	::ChangedResource(theHandle);	} 	else 	{		if ( inHandle != nil ) 		{		  ::AddResource( inHandle, kReportTextPrefs, inResID, nil);		}	}		if ( theHandle != nil ) 	{	  ::UpdateResFile(LPreferencesFile::GetResourceForkRefNum());	  ::ReleaseResource(Handle(theHandle));	}		// Restore the previous resource file		::UseResFile(curResFile);	}// ===========================================================================HandleCEyeDxPrefs::LoadReportTextPrefs(Handle sampleHandle, short inResID){	Handle retHandle;		// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		// -----------------------------------------	// Get saved text preference			Handle theHandle = ::Get1Resource(kReportTextPrefs, inResID);		if (theHandle != nil)	{		// Make a copy of the resource				retHandle = theHandle;		HandToHand(&retHandle);	}	else	{		if (sampleHandle)		{			// Make a copy of the sample text						retHandle = sampleHandle;			HandToHand(&retHandle);		}		else			retHandle = nil;	}		 	::ReleaseResource(Handle(theHandle));	// Restore the previous resource file		::UseResFile(curResFile);		return retHandle;}// =========================================================================== static Handle CreateNewSTR() {	Handle theHandle = nil;	short *thePtr; 	theHandle = NewHandle(2);   		// Make a new handle the size of an integer.	if (::MemError() == 0)					   	// The memory was successfully allocated, so go ahead.	{		::HLock(theHandle);		thePtr = (short *) *theHandle;		*thePtr = 0;					// Set the count to zero		::HUnlock(theHandle);	}		return (theHandle);}// This function adds a new string to the end of a STR# and returns its index.  If memory is// insufficient, we return -1.static short AddToSTR(Handle theSTR, CEyeDxShortStringType *theString){	short OldNumberOfStrings, NewNumberOfStrings;    short NewStringLength, StringLength;        unsigned char *ptr;        // Figure out how big the old handle and the new string are.    	NewStringLength = theString->Length() + 1;  // +1 for size byte		long OldSize = ::GetHandleSize(theSTR);		// Set the size of the handle and check for errors.		::SetHandleSize(theSTR, OldSize + NewStringLength);		// If everything is OK, then copy the new string into the handle.		if (::MemError() == 0)	{	 	::HLock(theSTR);		// Figure out where the current end of the block is.		::BlockMove(*theSTR, &OldNumberOfStrings, sizeof(short));				ptr = (unsigned char *)((*theSTR) + sizeof(short));	// Set up the pointer to be the first string positoon				for (short counter = 1; counter <= OldNumberOfStrings; counter ++)		{			StringLength = (short) *ptr;			ptr = (unsigned char *)(ptr + StringLength + 1); // include the length byte and skip to beyond this string		}			// Copy the string into there. We copy the length byte and the characters. Note that the StringPtr operator		// of the LString class doesn't always appear to work. So we use a temporary Str255 that we reference in the		// BlockMove operation.				Str255 theRealStr;		LString::CopyPStr(*theString, theRealStr);				::BlockMove(theRealStr, ptr, NewStringLength);		// Update the count of strings.				NewNumberOfStrings = OldNumberOfStrings + 1;				::BlockMove(&NewNumberOfStrings, *theSTR, sizeof(short));		::HUnlock(theSTR);		return (NewNumberOfStrings);	}	else		return (-1);}Handle CreateSTRListHandle(CTemplateShortStrArray *theStringArray){	// Create a new handle to a STR object, and initialize it		Handle theSTRHandle = CreateNewSTR();		// Now,  loop through the list		TArrayIterator<CEyeDxShortStringType *> iterator(*theStringArray);		CEyeDxShortStringType *theString;		while (iterator.Next(theString))		AddToSTR(theSTRHandle, theString);			// Return the filled-in STR resource		return (theSTRHandle);	}voidCEyeDxPrefs::SaveVariablePrefs(CEyeDxVariableList *theVariableList){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		// -----------------------------------------	// We take the brute force method here to update the variable list. Just nuke all of	// the existing variables, and recreate them. Since usually the number of variables will	// be small, this won't take long, and is easier than syncronizing the input list to the	// resource list.		long numVariables = ::Count1Resources(kVariablePrefs);		for (long resourceNum = 1; resourceNum <= numVariables; resourceNum++)	{		// -----------------------------------------		// Get saved variable preference - note the use of resource "1" - we are deleting the resources		// in the loop, so the index "1" is the only index that is always valid!				CEyeDxVariablePrefs **theHandle = (CEyeDxVariablePrefs **)::Get1IndResource(kVariablePrefs, 1);			if (theHandle != nil)		{			// Before deleting the resource, we also need to delete any associated STR# resource that holds			// the variable's option strings. That takes care of the case where we will re-create the list from			// the current array of option strings, and the case where the variable was previously a menu type			// and the user changed it to some other type. We want to get rid of the old option sting list in			// that case.						if ((*theHandle)->optionStrListID != 0)			{				Handle theSTRListHandle = ::Get1IndResource(kVariableOptionSTRListPrefs, (*theHandle)->optionStrListID);				if (theSTRListHandle)				{					::RemoveResource(Handle(theSTRListHandle));					::DisposeHandle(Handle(theSTRListHandle));								}			}			// Now we can delete the existing variable resource						::RemoveResource(Handle(theHandle));			::DisposeHandle(Handle(theHandle));		}	}		// Make sure our changes are written out so that the existing resources are deleted		::UpdateResFile(LPreferencesFile::GetResourceForkRefNum());		numVariables = ::Count1Resources(kVariablePrefs);		long numListVariables = theVariableList->GetCount();		// Always compress the prompting and export order when saving		// Broken in Windows and not really needed		//theVariableList->CompressPromptOrder();	//theVariableList->CompressExportOrder();		// Now, we add all of the User variables as resources.	for (long varNum = 1; varNum <= numListVariables; varNum++)	{		CEyeDxVariable *theVariable = theVariableList->GetVariableByIndex(varNum);				// no data has yet been saved -- add resource				CEyeDxVariablePrefs theVarPrefs;				// Clear the structure and set defaults				memset(&theVarPrefs, 0, sizeof(CEyeDxVariablePrefs));			// We now save version two variables				theVarPrefs.version = kEvarVers2;		theVarPrefs.extraEntryLines = theVariable->GetExtraEntryLines();		theVarPrefs.valueMustBeEntered = theVariable->GetValueMustBeEntered();		theVarPrefs.varClass = theVariable->GetVariableClass();		theVarPrefs.varType = theVariable->GetVariableType();		theVarPrefs.promptType = theVariable->GetWhenToPrompt();		theVarPrefs.dataType = theVariable->GetDataType();		theVarPrefs.promptOrder = theVariable->GetPromptOrder();		theVarPrefs.exportOrder = theVariable->GetExportOrder();		theVarPrefs.hidden = theVariable->GetVariableIsHidden();				// This will be set to the Resource ID for a string list we create to hold the option		// strings for this variable (if the variable is a menu type).		theVarPrefs.optionStrListID = 0;				CEyeDxShortStringType *theStr;		CEyeDxLongStringType *theLongStr;				theStr = theVariable->GetDefaultValue();		LString::CopyPStr(*theStr, theVarPrefs.defaultValue);				theStr = theVariable->GetPromptString();		LString::CopyPStr(*theStr, theVarPrefs.promptString);				theStr = theVariable->GetCommentString();		LString::CopyPStr(*theStr, theVarPrefs.commentString);		theLongStr = theVariable->GetValue();		LString::CopyPStr(*theLongStr, theVarPrefs.value);		// Assign a unique ID for the associated name STR# and set the resource ID inside the variable		// resource to the appropriate value.				ResID theSTRId = ::Unique1ID(kVariableOptionSTRListPrefs);					CTemplateShortStrArray *theOptionStringList = theVariable->GetOptionStringsArray();				if (theOptionStringList->GetCount() > 0)			theVarPrefs.optionStrListID = theSTRId;		else			theVarPrefs.optionStrListID = 0;					CEyeDxVariablePrefs **theHandle = (CEyeDxVariablePrefs**) (NewHandle(sizeof(CEyeDxVariablePrefs)));				if ( theHandle != nil ) 		{			// Copy the variable structure into the handle memory						::HLock(Handle(theHandle));			**theHandle = theVarPrefs;			::HUnlock(Handle(theHandle));						// Create a unique ID for the resource						short theID = ::Unique1ID(kVariablePrefs);						// Add the resource					 	::AddResource(Handle(theHandle), kVariablePrefs, theID, nil);		 			 	// Set the resource name from the variable name		 			 	CEyeDxLongStringType *theVarName = theVariable->GetName();		 	Str255 theName;			LString::CopyPStr(*theVarName, theName);		 			 	::SetResInfo(Handle(theHandle), theID, theName);		 				// Now we are done with the 		 	::ChangedResource(Handle(theHandle));		  	::ReleaseResource(Handle(theHandle));			// Now, if the variable has an associated list of option strings, we need to create a STR# resource to			// hold them. We call a routine that takes a pointer to a TArray that holds LStr255 objects, and			// creates a new STR# object. It passes back the handle to that object to us, and we save it.					if (theOptionStringList->GetCount() > 0)			{				// This routine will take the parameter, create a STR# list from the array of				// strings, and pass back the handle to the new structure.				Handle theSTRHandle = CreateSTRListHandle(theOptionStringList);								::AddResource(theSTRHandle, kVariableOptionSTRListPrefs, theSTRId, nil);				// We also name the resource to match the variable name							 	::SetResInfo(Handle(theSTRHandle), theSTRId, theName);	 				 	::ChangedResource(Handle(theSTRHandle));			  	::ReleaseResource(Handle(theSTRHandle));			}					}			}		// Make sure our changes are written out		::UpdateResFile(LPreferencesFile::GetResourceForkRefNum());		// Restore the previous resource file		::UseResFile(curResFile);	}// This routines will copy the STR# identified by the passed-in ID into the passed-in array,// allocating and copying the stringsvoid LoadStringArrayFromSTR(CEyeDxVariable *theVariable, short theSTRId){	// For some reason the support for STR# resources in the OS is very lacking. You can read an individual string	// by index, but you can't tell how many strings there are in the resource! However, we can just increment the	// index from 1 till we get Str_Empty back (that's what GetIndString returns for an invalid index. Of course, that	// means that the strings in the list can't be empty, but for our application that is ok.		// Get the options array pointer that should have been created by the variable if it thought	// it was supposed to have an associated STR# resource (e.g. menu types)		CTemplateShortStrArray *theOptionStringArray = theVariable->GetOptionStringsArray();		if (theOptionStringArray != NULL)	{		short count = 1; 		CEyeDxBooleanType done = false;				while (!done)		{			Str255 theString;			::GetIndString(theString, theSTRId, count++);						CEyeDxShortStringType theStringLStr = theString;						if (theStringLStr != Str_Empty)			{				CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(theString);								theOptionStringArray->AddItem(theStringCopy);			}			else				done = true;		}				// Now, we have to make sure that the default value in the variable matches one of the 		// menu choices. If not, we just select the first choice.				theVariable->ValidateDefault();	}}// ===========================================================================voidCEyeDxPrefs::LoadVariablePrefs(CEyeDxVariableList *theVariableList){		// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		// We load all of the resources that we find into the provided resource list.		long numVariables = ::Count1Resources(kVariablePrefs);		for (long resourceNum = 1; resourceNum <= numVariables; resourceNum++)	{		// -----------------------------------------		// Get saved variable preference				CEyeDxVariablePrefs **theHandle = (CEyeDxVariablePrefs **)::Get1IndResource(kVariablePrefs, resourceNum);			if (theHandle != nil)		{			// We have to look up the name of the variable from the resource name						Str255 theName;			short theID;			OSType theType;						::GetResInfo(Handle(theHandle), &theID, &theType, theName);						// if the resource exists in the passed-in table already, that means that			// EyeDx provided it as a template for the user to use. We delete the EyeDx			// template, since the user has already defined a variable of the same name.						if (theVariableList->GetVariableByName(theName) != nil)				theVariableList->DeleteVariableByName(theName);						// Lock the handle so we can dereference it						::HLock(Handle(theHandle));						LStr255 theStrObj(theName);						CEyeDxVariable *newVariable = new CEyeDxVariable(&theStrObj, *theHandle);						// If this isn't zero, we attempt to load the specified STR# list, and add it to the			// variable's option strings list						short theSTRId = (*theHandle)->optionStrListID;						if (theSTRId != 0)					LoadStringArrayFromSTR(newVariable, theSTRId);								::HUnlock(Handle(theHandle));		 	::ReleaseResource(Handle(theHandle));						theVariableList->AddVariable(newVariable);		}	}			// Always compress and renumber the prompting and export order when loading		// Broken in Windows and not really needed		//theVariableList->CompressPromptOrder();	//theVariableList->CompressExportOrder();		// Restore the previous resource file		::UseResFile(curResFile);}voidCEyeDxPrefs::SavePromptingPrefs(PromptingPrefs *inPromptingPrefs, short inResID){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		// Make sure it's the current version		inPromptingPrefs->version = kPrmtVers1;		// -----------------------------------------	// Store the browser preference		PromptingPrefs	**theHandle = 					(PromptingPrefs**) ::Get1Resource( kPromptingPrefs, inResID);		if ( theHandle != nil )		{		// a Prompting pref resource already exists -- update it		**theHandle = *inPromptingPrefs;	  ::ChangedResource(Handle(theHandle));	} 	else 	{		// no data has yet been saved -- add resource		theHandle = (PromptingPrefs**) (NewHandle(sizeof(PromptingPrefs)));		if ( theHandle != nil ) {			**theHandle = *inPromptingPrefs;		  ::AddResource( Handle(theHandle), kPromptingPrefs, inResID, nil);		}	}		if ( theHandle != nil ) 	{	  ::UpdateResFile(LPreferencesFile::GetResourceForkRefNum());	  ::ReleaseResource(Handle(theHandle));	}		// Restore the previous resource file		::UseResFile(curResFile);	}// ===========================================================================voidCEyeDxPrefs::LoadPromptingPrefs(PromptingPrefs *inPromptingPrefs, short inResID){	// Get the current resource file, which is usually the application, so we can restore it later		short curResFile = ::CurResFile();		::UseResFile(LFile::GetResourceForkRefNum());		PromptingPrefs	thePromptingPrefs;	PromptingPrefs	**theHandle;		// -----------------------------------------	// Get saved preference			theHandle = (PromptingPrefs**) ::Get1Resource(kPromptingPrefs, inResID);			// Clear the structure and set defaults		memset(inPromptingPrefs, 0, sizeof(PromptingPrefs));		inPromptingPrefs->version = kPrmtVers1;	inPromptingPrefs->promptingStyle = kPromptOneAtATime;	// -----------------------------------------	// Restore preference	if ( theHandle != nil )		{	// handle to data succeeded -- retrieve saved user state		thePromptingPrefs = **theHandle;		if (thePromptingPrefs.version == kPrmtVers1)			*inPromptingPrefs = thePromptingPrefs;			// Copy the structure		}	 	::ReleaseResource(Handle(theHandle));	// Restore the previous resource file		::UseResFile(curResFile); }