// =================================================================================//	CDocumentApp.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for a document PowerPlant project////  The Application is derived from LDocApplication.  New Windows are managed//  by CTextDocument which is derived from LSingleDoc.  Each document contains//  a smart text view that remembers if it has changed since it was last saved.#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>extern "C"{#include <FSp_fopen.h>}// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <StandardFile.h>#include <NumberFormatting.h>#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <PPobClasses.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <URegistrar.h>#include <UTextTraits.h>#include <LIconPane.h>#include <UStandardDialogs.h>#include <LWindow.h>#include <LGroupBox.h>#include <LTextButton.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CMyGWorldView.h"#include "USubFolderFinder.h"#include <path2fss.h>#include "CEyeDxPrefs.h"#include "CAboutDialog.h"#include "ABalloon.h"#include "FileCopy.h"#include "CSingleClickListBox.h"#include "DC120.h"#include "CSpaceClickDialog.h"#include <OSUtils.h>// This routine handles previewing thumbnails from the KDC files in the file selector//pascal Boolean MyNavImagePreviewFilter(NavCBRecPtr callBackParms, void * ){	OSErr 			theErr = noErr;	Boolean			previewShowing = false;	AEDesc			resultDesc;	FSSpec			previewFileSpec;	Boolean			result = false;	DCPictInfo		theGenericPictInfo;	DC120PictInfo	thePictInfo;	CEyeDxBooleanType	KDCfile = false;		theErr = NavCustomControl(callBackParms->context, kNavCtlIsPreviewShowing, &previewShowing);		if (theErr == noErr && previewShowing)	{			if ((theErr = AECoerceDesc((AEDesc *)callBackParms->eventData.eventDataParms.param,								typeFSS, &resultDesc)) == noErr)		{			BlockMoveData(*resultDesc.dataHandle,&previewFileSpec,sizeof(FSSpec));						FInfo Info;			if ((theErr = FSpGetFInfo(&previewFileSpec, &Info)) == noErr)			{				// We know it's a valid file. Now grab other parameters we need				Rect theRect = callBackParms->previewRect;				WindowPtr theWindow = callBackParms->window;								// Next, call the routine to get the thumbnail data from the file				// The routine just grabs the thumbnail data and puts it into an				// allocated memory buffer. We copy it to the preview area.								FILE *fileptr = FSp_fopen((ConstFSSpecPtr)&previewFileSpec, "rb");				if (fileptr == NULL)					return false;									unsigned char *theThumbData;				int thumb_width = THUMB_WIDTH;				int thumb_height = THUMB_HEIGHT;								// First, we see if it's a JPEG file by trying to get a thumbnail image				// The routine will close the file, so we may have to reopen it.								StCursor wait;	// Set the pointer to the stop watch while we are setting up				if (CreateJPEGThumbnail(fileptr, &theThumbData,	&thumb_height, &thumb_width) == FALSE)				{					// It wasn't a JPEG image - try KDC										fileptr = FSp_fopen((ConstFSSpecPtr)&previewFileSpec, "rb");										// Note that the ReadIconFromFile routine will close the file. Remember to					// tell the routine to NOT display notices! Otherwise, the display of an					// error notice may cause a repaint of the preview area, and we get into an					// endless cycle with this routine being called over and over again!					// If this returns FALSE, we can't display a thumbnail, so we return false															if (ReadIconFromFile(fileptr, &theThumbData, &thumb_height, &thumb_width, &theGenericPictInfo, &thePictInfo, nil, false) == FALSE)						return false;											// Set a flag to indicate that we can display the pictinfo data										KDCfile = true;				}				// We first create a temporary offscreen GWorld, into which we				// will write the thumbnail data. We cannot assume here that the current				// port is the window port. So, that makes using a StOffscreenGWorld				// difficult, because we have to save the current port, set the window				// port and then restore the port after drawing. Problem is, the stack-based				// GWorld object restores what it thinks is the current port in its destructor.				// The system goes barf when that happens. So we use a LGWorld instead.				// Get the current RGB background color, which we will pass to the				// LGWorld. It will fill the area with it before drawing the thumbnail.								RGBColor theBackgroundColor;								::GetBackColor(&theBackgroundColor);				LGWorld *theLGWorld = new LGWorld(theRect, 32, useTempMem, nil, nil, &theBackgroundColor);															// Now that we have the thumbnail data, copy it to the preview area.								GWorldPtr theMacGWorld = theLGWorld->GetMacGWorld();										theLGWorld->BeginDrawing();	// Draw in GWorld		  		PixMapHandle thePix = GetGWorldPixMap(theMacGWorld);		    	long rowBytes = (**thePix).rowBytes & 0x3FFF;		    	Ptr imageBaseAddr = GetPixBaseAddr(thePix); 		        Ptr base = imageBaseAddr;		         			    	long frame_height = theRect.bottom - theRect.top;		    	long frame_width = theRect.right - theRect.left;		    			    	long element_size;		    			    	if (KDCfile)		    		element_size = 4;		    	else		    		element_size = 3;		    	long srcRowBytes = thumb_width * element_size;				long srcY = 0;								// We will scale the data to the smaller of the width or height								double theXscale = (double) thumb_width / (double) frame_width;				double theYscale = (double) thumb_height / (double) frame_height;								if (theYscale > theXscale)				{					frame_width = thumb_width / theYscale;					theXscale = theYscale;				}				else				{					frame_height = thumb_height / theXscale;					theYscale = theXscale;				}									// We use long-word transfer to speed things up for KDC mode				// but we have to special handling for JPEG mode								unsigned long *srcPtr;				unsigned long *dstPtr;		    	for (long y = 0; y < frame_height; y++)		    	{		    		long srcX = 0;		    	    dstPtr = (unsigned long *) ((Ptr)base + (rowBytes * y));		    		for (long x = 0; x < frame_width; x++)		    		{		    			srcPtr = (unsigned long *) &theThumbData[(srcY * srcRowBytes) + srcX];						if (KDCfile)		    				// We load _four_ bytes from the source (ARGB). 			    			*dstPtr++ = *srcPtr;						else			    			// We load _four_ bytes from the source (RGBr). We shift them down			    			// so we have only the RGB values in the low 24 bits, and the shift			    			// will zero-fill the top byte					    		*dstPtr++ = (*srcPtr >> 8);		               	srcX = (double) x * theXscale;		               	srcX *= element_size; // Account for bytes per pixel in the raw source image		    		}		    		srcY = (double) y * theYscale;		    	}		    			    	// Now, annotate below the picture the quality setting		    			    	::MoveTo(theRect.left + 4, theRect.top + frame_height + 15);		    			    	// Save the current text settings		    			    	StTextState saveText;		    			    	::TextSize(9);		    	::TextFont(applFont);		    			    	if (KDCfile)		    	{					switch (thePictInfo.PictQuality)					{					case DC120NoCompression:						::DrawString("\pQuality: No Compression");						break;					case DC120BestQuality:						::DrawString("\pQuality: Best (recommended)");						break;					case DC120BetterQuality:						::DrawString("\pQuality: Better");						break;					case DC120GoodQuality:						::DrawString("\pQuality: Good");						break;					}				    			    	}		    	else		    		::DrawString("\pJPEG: No quality information.");		    		    			theLGWorld->EndDrawing();    			    			// Now copy the GWorld to the screen    							StColorState	saveColors;				StColorState::Normalize();	// CopyBits wants this    			theLGWorld->CopyImage(theWindow, theRect);    			    			// And nuke it    			    			delete theLGWorld;				free(theThumbData);								result = true;			}		}	}	return result;}// ---------------------------------------------------------------------------------//		¥ MyNavObjectFilter// ---------------------------------------------------------------------------------// This routine is called by the File Chooser to filter files for display. In this// implementation, we display files of type kKDCType, and those with extension ".kdc".// Note that this routine works with both the Standard File dialog and the// new Navigation Services dialogs under 8.5 and beyond.//// For StdFile, returning false used to mean that the file SHOULD be displayed. For NavServices,// returning true means that the file should be displayed. Since this routine is used for// both, it follows the NavServices convention.pascal Boolean MyNavImageObjectFilter(AEDesc* inItem, void *info, void* inUserData, NavFilterModes){	DC120PictInfo	thePictInfo;	if (inItem != nil) 	{				// NavServices Callback			NavFileOrFolderInfo *theInfo = (NavFileOrFolderInfo *) info;				// Get info about item from inItem and inInfo  - note that by default		// invisible files are not displayed by Navigation Services.		if (inItem->descriptorType == typeFSS)		{			if (theInfo->isFolder)				return true;		// Return true for folders			else			{				// Get the name from the input Apple Event Descriptor								FSSpec theFSSpec;				BlockMoveData(*inItem->dataHandle,&theFSSpec,sizeof(FSSpec));				// else, see if it's a file we want to display				Str255 theFilename;				LString::CopyPStr(theFSSpec.name, theFilename);				// Convert to lower case so comparisons are easier				::LowercaseText((char *)&theFilename[1], theFilename[0], smSystemScript);				LStr255 theImprovedString = theFilename;								if (theImprovedString.EndsWith("\p.kdc") ||					theImprovedString.EndsWith("\p.ppm") || 					theImprovedString.EndsWith("\p.jpg") || 		         	theImprovedString.EndsWith("\p.jpeg"))					return true;					#if FALSE 				// All these tests just slow down the browser. We let the open routine complain if				// the images are the wrong format or the wrong size				if (theImprovedString.EndsWith("\p.kdc"))				{					// We have to actually check the contents of the file to make sure it's					// a KDC file. We do this by calling the ReadIconFromFile routine with 					// a flag to tell it not to display notices. We simply use the return code										FILE *fileptr = FSp_fopen((ConstFSSpecPtr)&theFSSpec, "rb");					if (fileptr == NULL)						return false;											unsigned char *theThumbData;					int thumb_width;					int thumb_height;										// Note that the ReadIconFromFile routine will close the file. Remember to					// tell the routine to NOT display notices! Otherwise, the display of an					// error notice may cause a repaint of the preview area, and we get into an					// endless cycle with this routine being called over and over again!										if (ReadIconFromFile(fileptr, &theThumbData, &thumb_height, &thumb_width, &thePictInfo, nil, false))					{										free (theThumbData);						return true;					}					else						return false;				}				else if (theImprovedString.EndsWith("\p.jpg") || 		         		  theImprovedString.EndsWith("\p.jpeg"))				{					// We have to actually check the contents of the file to make sure it's					// a JPEG file of the correct size. 										FILE *fileptr = FSp_fopen((ConstFSSpecPtr)&theFSSpec, "rb");					if (fileptr == NULL)						return false;											int image_depth;					int image_width;					int image_height;										// Note that the GetJPEGImageInfo routine will close the file. 										// Note that the JPEG image must be the expected size										if (GetJPEGImageInfo(fileptr, &image_depth, &image_height, &image_width))					{							if ((image_height == IMAGE_WIDTH) && 						    (image_width  == IMAGE_HEIGHT))									return true;						else							return false;					}					else						return false;				}#endif								// FInally, if the filename doesn't end with an extension, but it is the right				// file type, display it								if (theInfo->fileAndFolder.fileInfo.finderInfo.fdType == kKDCType || 		            theInfo->fileAndFolder.fileInfo.finderInfo.fdType == kJPEGType)					return true;			}		}	} 	else if (inUserData != nil) 	{		// StandardFile Callback		CInfoPBPtr thePB = (CInfoPBPtr) inUserData;				// If it's invisible, say no				if (thePB->hFileInfo.ioFlFndrInfo.fdFlags & kIsInvisible)			return false;		// If it's a directory, say yes				if (thePB->hFileInfo.ioFlAttrib & ioDirMask)			return true;					// else, see if it's a file we want to display		Str255 theFilename;		LString::CopyPStr(thePB->hFileInfo.ioNamePtr, theFilename);		// Convert to lower case so comparisons are easier		::LowercaseText((char *)&theFilename[1], theFilename[0], smSystemScript);		LStr255 theImprovedString = theFilename;				         		if (theImprovedString.EndsWith("\p.kdc") || 		          theImprovedString.EndsWith("\p.ppm") || 				  theImprovedString.EndsWith("\p.jpg") || 		          theImprovedString.EndsWith("\p.jpeg"))		{			// We don't do anything special here, since we don't support previews			// under older Open File dialogs. We just let the open routine complain.						return true;		}		if (thePB->hFileInfo.ioFlFndrInfo.fdType == kKDCType || 		    thePB->hFileInfo.ioFlFndrInfo.fdType == kJPEGType)			return true;	}	return false;}// ---------------------------------------------------------------------------------//		¥ MyNavReportObjectFilter// ---------------------------------------------------------------------------------// This routine is called by the File Chooser to filter report files. In this// implementation, we display files of type TEXT, and those with extension ".htm".// Note that this routine works with both the Standard File dialog and the// new Navigation Services dialogs under 8.5 and beyond.//// For StdFile, returning false used to mean that the file SHOULD be displayed. For NavServices,// returning true means that the file should be displayed. Since this routine is used for// both, it follows the NavServices convention.pascal Boolean MyNavReportObjectFilter(AEDesc* inItem, void *info, void* inUserData, NavFilterModes){	DC120PictInfo	thePictInfo;	if (inItem != nil) 	{				// NavServices Callback			NavFileOrFolderInfo *theInfo = (NavFileOrFolderInfo *) info;				// Get info about item from inItem and inInfo  - note that by default		// invisible files are not displayed by Navigation Services.		if (inItem->descriptorType == typeFSS)		{			if (theInfo->isFolder)				return true;		// Return true for folders			else			{				// Get the name from the input Apple Event Descriptor								FSSpec theFSSpec;				BlockMoveData(*inItem->dataHandle,&theFSSpec,sizeof(FSSpec));				// else, see if it's a file we want to display				Str255 theFilename;				LString::CopyPStr(theFSSpec.name, theFilename);				// Convert to lower case so comparisons are easier				::LowercaseText((char *)&theFilename[1], theFilename[0], smSystemScript);				LStr255 theImprovedString = theFilename;								if (theImprovedString.EndsWith("\p.htm"))					return true;			}		}	} 	else if (inUserData != nil) 	{		// StandardFile Callback		CInfoPBPtr thePB = (CInfoPBPtr) inUserData;				// If it's invisible, say no				if (thePB->hFileInfo.ioFlFndrInfo.fdFlags & kIsInvisible)			return false;		// If it's a directory, say yes				if (thePB->hFileInfo.ioFlAttrib & ioDirMask)			return true;					// else, see if it's a file we want to display		Str255 theFilename;		LString::CopyPStr(thePB->hFileInfo.ioNamePtr, theFilename);		// Convert to lower case so comparisons are easier		::LowercaseText((char *)&theFilename[1], theFilename[0], smSystemScript);		LStr255 theImprovedString = theFilename;				         		if (theImprovedString.EndsWith("\p.htm"))		{			// We don't do anything special here, since we don't support previews			// under older Open File dialogs. We just let the open routine complain.						return true;		}	}	return false;}