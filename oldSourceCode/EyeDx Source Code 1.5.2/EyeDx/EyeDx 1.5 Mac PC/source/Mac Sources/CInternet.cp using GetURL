// ===========================================================================//	CInternet.cp				   ©1996 Sumware P/L. All rights reserved.// ===========================================================================#include "CInternet.h"CInternet::CInternet(OSType inBrowserType){	mBrowserType = inBrowserType;	}CInternet::~CInternet() {}BooleanCInternet::LaunchBrowser(void){	OSErr err;	Boolean browserIsRunning = BrowserIsRunning();		// if the browser is running there is no need to launch it	if (browserIsRunning)		err = ::SetFrontProcess(&mBrowserPSN);	else	{		mBrowserSpec.vRefNum = 0;	// else if the browser is not running, find it on disk and launch it		HParamBlockRec		volumeParamBlock;		HVolumeParamPtr		pb = &volumeParamBlock.volumeParam;		short  ioVolIndex = 1;		pb->ioCompletion = nil;		Str31  volumeName;		// debugging		pb->ioNamePtr = volumeName;			pb->ioVRefNum = 0;		pb->ioVolIndex = ioVolIndex;		while (::PBHGetVInfoSync(&volumeParamBlock) == noErr)	// loop over all mounted volumes		{			if (pb->ioVDrvInfo > 0) // volume is online				if (pb->ioVDRefNum < 0) // again, volume is online				{					DTPBRec	dtppb;					dtppb.ioCompletion = nil;					dtppb.ioNamePtr = nil;					dtppb.ioVRefNum = pb->ioVRefNum;					err = ::PBDTGetPath(&dtppb);	// fills in dtppb.ioDTRefNum					if (err)		goto Bail;					dtppb.ioFileCreator = mBrowserType;					dtppb.ioNamePtr = mBrowserSpec.name;					dtppb.ioIndex = 0;  // most recent					err = ::PBDTGetAPPLSync(&dtppb);	// find the browser					if (err)		if (err != afpItemNotFound)			goto Bail;					if (err == noErr)					{						mBrowserSpec.vRefNum = pb->ioVRefNum;						mBrowserSpec.parID = dtppb.ioAPPLParID;												LaunchParamBlockRec	launchParams;						// fill in the launch parameter block and make the launch call						launchParams.launchAppParameters = nil;						launchParams.launchBlockID		= extendedBlock;						launchParams.launchEPBLength	= extendedBlockLen;						launchParams.launchFileFlags	= nil;						launchParams.launchControlFlags	= launchContinue + launchNoFileFlags;						launchParams.launchAppSpec	= &mBrowserSpec;												err = ::LaunchApplication(&launchParams);						if (err)		goto Bail;						unsigned long delay;						::Delay(120, &delay);						browserIsRunning = BrowserIsRunning();						if (browserIsRunning)							(void)::SetFrontProcess(&mBrowserPSN);						goto Bail;					}				}			pb->ioVRefNum = 0;			pb->ioVolIndex = ++ioVolIndex;		}	}Bail:	return browserIsRunning;}//----------------------------------------------------------------------------// BuildGetURLAEEvent////----------------------------------------------------------------------------OSErrCInternet::BuildGetURLAEEvent(AppleEvent& outGetURLAppleEvent, const Str255 inURL){	OSErr			err;	AEDesc			targetAddrDesc;	AEDesc			textDesc;	AEDesc			flagsDesc;	AEDescList		textDescList;	// to simplify cleanup, ensure that handles are nil to start	targetAddrDesc.dataHandle		= nil;	outGetURLAppleEvent.dataHandle	= nil;	textDescList.dataHandle			= nil;	textDesc.dataHandle				= nil;	flagsDesc.dataHandle			= nil;	// create an address descriptor based on the serial number of	// the target process	err = ::AECreateDesc(typeProcessSerialNumber, (Ptr)&mBrowserPSN,					sizeof(ProcessSerialNumber), &targetAddrDesc);	if (err)	goto Bail;		// make a descriptor list containing just a descriptor	err = ::AECreateList(nil, 0, false, &textDescList);	if (err)	goto Bail;		err = ::AECreateDesc(typeChar, &inURL[1], *inURL, &textDesc);	if (err)	goto Bail;		// Value of index is 0, descriptor record is added to end of list.	err = ::AEPutDesc(&textDescList, 0, &textDesc);	if (err)	goto Bail;	// the textDesc is now in the AE document list, so dispose of it	err = ::AEDisposeDesc(&textDesc);	textDesc.dataHandle = nil;	if (err)	goto Bail;	// now make the 'GURL' 'OURL' descriptor and insert the 	// text descriptor list as the direct object#define		kGetURL_AEEventClass	'WWW!'#define		kGetURL_AEEventID			'OURL'	err = ::AECreateAppleEvent(kGetURL_AEEventClass, kGetURL_AEEventID,						&targetAddrDesc, kAutoGenerateReturnID, kAnyTransactionID,							&outGetURLAppleEvent);	if (err)	goto Bail;		err = ::AEPutParamDesc(&outGetURLAppleEvent, keyDirectObject, &textDescList);	if (err)	goto Bail;		// We add the flags parameter		long flagsLong = 0x3; // Tell the browser to not use the cached values		err = ::AEPutParamPtr(&outGetURLAppleEvent, 'FLGS', typeLongInteger, &flagsLong, sizeof(flagsLong));	if (err)	goto Bail;		// We add the window parameter		long windowID = 0xffffffff; // Tell the browser to reuse the front window		err = ::AEPutParamPtr(&outGetURLAppleEvent, 'WIND', typeLongInteger, &windowID, sizeof(windowID));	if (err)	goto Bail;	Bail:	// dispose of everything that was allocated	if (targetAddrDesc.dataHandle)  (void)::AEDisposeDesc(&targetAddrDesc);	if (textDescList.dataHandle)  (void)::AEDisposeDesc(&textDescList);	if (textDesc.dataHandle)  (void)::AEDisposeDesc(&textDesc);		return err;}BooleanCInternet::BrowserIsRunning(void){	Boolean	foundRunningBrowser = false;	// check the current processes to see if the creator app is already	// running, and get its process serial number (as searchPSN)	ProcessInfoRec currProcessInfo;	currProcessInfo.processInfoLength = sizeof(ProcessInfoRec);	currProcessInfo.processName = nil;	FSSpec		searchSpec;	currProcessInfo.processAppSpec = &searchSpec;		foundRunningBrowser = false;	ProcessSerialNumber		searchPSN;	searchPSN.lowLongOfPSN = searchPSN.highLongOfPSN = kNoProcess;	while (::GetNextProcess(&searchPSN) == noErr)		if (::GetProcessInformation(&searchPSN, &currProcessInfo) == noErr)			if (currProcessInfo.processSignature == mBrowserType)	// Browser			{				mBrowserPSN = searchPSN;				mBrowserSpec = searchSpec;				foundRunningBrowser = true;				break;			}	return foundRunningBrowser;}OSErrCInternet::SendBrowserURL(Str255 url){	OSErr		err;	FSSpec  launchAppSpec;	AppleEvent theAppleEvent;	AppleEvent theReplyEvent;	// to simplify cleanup, ensure that handles are nil to start	theAppleEvent.dataHandle = nil;	theReplyEvent.dataHandle = nil;		Boolean browserIsRunning = BrowserIsRunning();	err = browserIsRunning ? noErr: fnfErr; // MUST BE RUNNING	if (err)	{		SysBeep(1);		goto StopProcess;	}		// build a "GetURL" event with the url	err = BuildGetURLAEEvent(theAppleEvent, url);	if (err)	{		SysBeep(1);		goto StopProcess;	}	// the creator is running, send it an scpt event#define  WaitForReply	0#if  WaitForReply	err = ::AESend(&theAppleEvent, &theReplyEvent, kAEWaitReply + kAECanSwitchLayer, 						kAEHighPriority, 600, nil, nil);	if (err)	{		SysBeep(1);		goto StopProcess;	}	AEDescList theAEDescList;	err = AEGetParamDesc(&theReplyEvent, keyDirectObject, typeAEList, &theAEDescList);	if (err)	{		SysBeep(1);		goto StopProcess;	}	err = GetAEAttribute(theReplyEvent);	if (err)	{		SysBeep(1);		goto StopProcess;	}	long theCount;	err = AECountItems(&theAEDescList, &theCount);	if (err)	{		SysBeep(1);		goto StopProcess;	}	AEKeyword theAEKeyword;	DescType	typeCode;	Size 			actualSize;	short  answer  = 0;	err = AEGetNthPtr(&theAEDescList, 1, typeShortInteger, &theAEKeyword, &typeCode, &answer, sizeof(short), &actualSize);	if (err)	{		SysBeep(1);		goto StopProcess;	}	#else // DONT WaitForReply	err = ::AESend(&theAppleEvent, &theReplyEvent, kAENoReply, 						 kAENormalPriority, kAEDefaultTimeout, nil, nil);						 	if (err)	{		SysBeep(1);		goto StopProcess;	}#endif // WaitForReply	err = ::SetFrontProcess(&mBrowserPSN);StopProcess:	// dispose of the AppleEvent if it was allocated		if (theAppleEvent.dataHandle)  		(void)::AEDisposeDesc(&theAppleEvent);	if (theReplyEvent.dataHandle)  		(void)::AEDisposeDesc(&theReplyEvent);	if (err)		::SysBeep(1);	return err;}voidCInternet::GetURL(Str255 url){	if (LaunchBrowser())	{		OSErr  err = SendBrowserURL(url);	}}voidCInternet::GetMailTo(Str255 url){	if (LaunchBrowser())	{		TString<Str255>  mailTo("\pmailto:");		mailTo.Append(url);		OSErr  err = SendBrowserURL(mailTo);	}}