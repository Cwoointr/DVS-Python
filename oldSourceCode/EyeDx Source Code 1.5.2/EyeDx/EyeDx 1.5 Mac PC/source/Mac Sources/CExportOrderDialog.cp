// =================================================================================//	CExportOrderDialog.cp				©1995 Metrowerks Inc. All rights reserved.// =================================================================================//	CExportOrderDialog.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include <LStdControl.h>#include <PP_Messages.h>#include <UReanimator.h>#include "CExportOrderDialog.h"// ---------------------------------------------------------------------------------//		¥ CExportOrderDialog(LStream *)// ---------------------------------------------------------------------------------CExportOrderDialog::CExportOrderDialog(	LStream *inStream )		: LGADialog( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CExportOrderDialog// ---------------------------------------------------------------------------------CExportOrderDialog::~CExportOrderDialog(){	delete mFieldVariableList;	delete mSizer;	delete mTableSelector;	delete mTableGeometry;	delete mTableStorage;}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCExportOrderDialog::FinishCreateSelf(){	// Call inherited. LDialogBox's FinishCreateSelf	// sets up the default and cancel buttons.	LGADialog::FinishCreateSelf();		// Link the dialog to the controls.	UReanimator::LinkListenerToControls( this, this, RidL_ExportOrderDialog );	}const long kVariableMenuHeadingOffset = 1;voidCExportOrderDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	CEyeDxLongStringType theNameStr;			long theItem;		switch (inMessage) 	{				case msg_Cancel: 			// Don't have to do anything, since we didn't change the list at all						break;			case msg_OK:			// First, we have to iterate through the complete list and turn off export order for all		// variables. Then, we turn export order on for those that are in the list				long numVariables = mVariableList->GetCount();				for (long varNum = 1; varNum <= numVariables; varNum++)		{			CEyeDxVariable *theVariable = mVariableList->GetVariableByIndex(varNum);			ThrowIfNil_(theVariable);						// Set the export order						theVariable->SetExportOrder(kNoExportOrder);	// Set them all to no export		}		// Now we have to do here is iterate through the list, and set each variable's export order		// to an incrementing value				numVariables = mFieldVariableList->GetCount();				for (long varNum = 1; varNum <= numVariables; varNum++)		{			CEyeDxVariable *theVariable = mFieldVariableList->GetVariableByIndex(varNum);			ThrowIfNil_(theVariable);						// Set the export order						theVariable->SetExportOrder(varNum - 1);	// Order starts at 0		}				if (mOrderChanged)		{			::ParamText("\pYou have changed the list of exported variables. EyeDx suggests you save your existing database export file before running another subject.", Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::CautionAlert(PPob_GeneralALRT);		}				break;			case msg_ExportOrderVarListSglClick:	case msg_ExportOrderVarListDblClick:	// We don't do anything special for double clicks			// Look up the variable that they clicked on				theItem = mTableSelector->GetFirstSelectedRow();				TableIndexT numRows;		TableIndexT numCols;				mVariableTable->GetTableSize(numRows, numCols);				mRemoveItemButton->Disable();		mMoveUpButton->Disable();		mMoveDownButton->Disable();				// If they haven't clicked on the first item, then enable the Move Up Button				if (theItem > 1)		{								mMoveUpButton->Enable();			mRemoveItemButton->Enable();		}					// And if they haven't clicked on the last item, enable the Move Down Button				if (theItem < numRows)		{			mMoveDownButton->Enable();			mRemoveItemButton->Enable();		}								break;	case msg_ExportOrderMoveUp:				// Get the item selected, and move it up in the list		theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mFieldVariableList->SwapItems(theItem, theItem - 1);						// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of		// items in the list						UpdateVariableList(false, theItem - 1);				mOrderChanged = true;		break;	case msg_ExportOrderMoveDown:				// Get the item selected, and move it down in the list. 				theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mFieldVariableList->SwapItems(theItem, theItem + 1);				// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of		// items in the list				UpdateVariableList(false, theItem + 1);		mOrderChanged = true;		break;			case msg_ExportOrderInsertVariable:		// We have to get the name of the variable from the menu. Then format it and insert it into		// the list. We insert after the current item. This is the more likely operation - appending		// items to the list, rather than inserting items before the current one.				long theItem = mVariableMenu->GetValue();				if (theItem > kVariableMenuHeadingOffset)		{			// We look up the variable by name, by retrieving the menu item text, and then			// looking up the variable. We can't just index into the variable list by index, since the			// menu changes size as the user inserts variables.						Str255 theItemStr;						MenuHandle theVariablePopupMenu = mVariableMenu->GetMacMenuH();			ThrowIfNil_( theVariablePopupMenu );			::GetMenuItemText(theVariablePopupMenu, theItem, theItemStr);						CEyeDxVariable *theVariable = mVariableList->GetVariableByName(theItemStr);						// We will insert after the current row. If the last item is selected, we will end up			// appending to the list						theItem = mTableSelector->GetFirstSelectedRow() + 1;						mFieldVariableList->InsertVariableAt(theItem, theVariable);					}				// We also set the value to the first item, which is really just a heading. We get notification		// from the menu only if the user changes the selection. Thus, we use the fake first item as a 		// placeholder - each time the user makes a selection, we process the selection and then set the		// menu value back to the first item. That ensures that we will always get notification, even if		// the user selects the same variable for insertion twice in a row.		mVariableMenu->SetValue(kVariableMenuHeadingOffset);		// Update the list and also tell the routine to update the menu. We also tell the routine to		// select the just-inserted item				UpdateVariableList(true, theItem);		mOrderChanged = true;		break;						case msg_ExportOrderRemoveItem:				theItem = mTableSelector->GetFirstSelectedRow();				mFieldVariableList->DeleteVariableByIndex(theItem);				// Update the list and also tell the routine to update the menu. We tell the routine to select		// the previous item in the list, if there is one.				if (mFieldVariableList->GetCount() > 0)		{			// We have a special case here - if the first item was deleted, we want to just select the first			// item in the list.						theItem--;			if (theItem == 0)				theItem = 1;		}		else			theItem = 0;					UpdateVariableList(true, theItem);		mOrderChanged = true;		break;						default:		break;	}	// Always pass the message on to our base class		LGADialog::ListenToMessage(inMessage, ioParam);}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------voidCExportOrderDialog::SetupDialog(CEyeDxVariableList *theVariableList){	mVariableList = theVariableList;		mVariableTable = dynamic_cast<LTextTableView*> (this->FindPaneByID(kExportOrder_VariableTable));	ThrowIfNil_( mVariableTable );			mMoveUpButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kExportOrder_MoveUpButton));	ThrowIfNil_( mMoveUpButton );		mMoveDownButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kExportOrder_MoveDownButton));	ThrowIfNil_( mMoveDownButton );		mRemoveItemButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kExportOrder_RemoveItem));	ThrowIfNil_( mRemoveItemButton );		mVariableMenu = dynamic_cast<CEyeDxPopupMenuType*> (this->FindPaneByID(kExportOrder_VariableMenu));	ThrowIfNil_( mVariableMenu );		mCancelButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kExportOrder_Cancel));	ThrowIfNil_( mCancelButton );		mSaveButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kExportOrder_OK));	ThrowIfNil_( mSaveButton );		mSizer = new LCellSizeToFit(false);		mVariableTable->SetCellSizer(mSizer);	mTableSelector = new LTableSingleRowSelector(mVariableTable);		mVariableTable->SetTableSelector(mTableSelector);		mTableGeometry = new LTableMultiGeometry( mVariableTable, kVariableListNameWidth, kVariableEntryHeight);	mVariableTable->SetTableGeometry(mTableGeometry);	mTableStorage = new LTableArrayStorage( mVariableTable, (UInt32)0 );	mVariableTable->SetTableStorage(mTableStorage);	mVariableTable->AddListener(this);	// Create our own empty variable list, using the sort by name order comparator.	// This list will hold the variables that will be output		mFieldVariableList = new CEyeDxVariableList(CEyeDxVariableList::kSortByExportOrder);	ThrowIfNil_(mFieldVariableList);		long numVariables = theVariableList->GetCount();		long numInList = 0;		for (long varNum = 1; varNum <= numVariables; varNum++)	{		CEyeDxVariable *theVariable = theVariableList->GetVariableByIndex(varNum);		ThrowIfNil_(theVariable);				if (theVariable->GetExportOrder() != kNoExportOrder)		{			mFieldVariableList->AddVariable(theVariable);			numInList++;		}	}		// We don't want the list to resort while the user is tweeking it		mFieldVariableList->SetKeepSorted(false);		// Update the list and also tell the routine to update the menu, plus select the last item		UpdateVariableList(true, numInList);		// This flag indicates whether the list has changed, so we can warn the user		mOrderChanged = false;} voidCExportOrderDialog::UpdateVariableList(CEyeDxBooleanType updateMenuAsWell, long itemToSelect){	// Here we have to parse the variable list and add all of the prompted variables in the order in which they are	// supposed to be prompted.	StopListening();	// Set the list to allow only one item to be selected	// This will defer updating the table until we exit the routine, saving a lot of redraws		mVariableTable->SetDeferAdjustment(true);		// Delete all of the existing rows		mVariableTable->RemoveAllRows(true);		// Figure out how many prompted variables there are	TableIndexT theNumberOfVariables = mFieldVariableList->GetCount();		mVariableTable->InsertRows(theNumberOfVariables, 0);	const UInt32 kNumVariableColumns = 1;		mVariableTable->InsertCols(kNumVariableColumns, 0);		mVariableTable->SetColWidth(kVariableListNameWidth, 1, 1);	STableCell	cell;	CEyeDxLongStringType *theStr;		cell.col = 1;			for (cell.row = 1; cell.row <= theNumberOfVariables; cell.row++) 	{		// Get the variable - note that the array index is 1 based!				CEyeDxVariable *theVariable = mFieldVariableList->GetVariableByIndex(cell.row);				theStr = theVariable->GetName();				mVariableTable->SetCellData(cell, theStr->TextPtr(), theStr->Length());	}		mVariableTable->SetDeferAdjustment(false);		if (theNumberOfVariables == 0)		mRemoveItemButton->Disable();		if (itemToSelect > 0)	{		cell.row = itemToSelect;				mTableSelector->SelectCell(cell);		mVariableTable->ScrollCellIntoFrame(cell);	// Make sure it's visible		// Now update the Move Up and Down buttons				mMoveUpButton->Disable();		mMoveDownButton->Disable();				// If the the selected item isn't the first item, then enable the Move Up Button				if (itemToSelect > 1)									mMoveUpButton->Enable();					// And if the selected item isn't the last item, enable the Move Down Button				if (itemToSelect < theNumberOfVariables)			mMoveDownButton->Enable();					mRemoveItemButton->Enable();								}	else	{		mMoveUpButton->Disable();		mMoveDownButton->Disable();			}		mVariableTable->Draw(nil);		if (updateMenuAsWell)	{			// Now, we update the Insert Variable menu to reflect the current list, which is the list of available		// variables minus the variables already selected		MenuHandle theVariablePopupMenu = mVariableMenu->GetMacMenuH();		ThrowIfNil_( theVariablePopupMenu );		// Delete the current items in the list, except for the first, which is just used as a		// heading.		long nMenuItems = ::CountMItems(theVariablePopupMenu);		for (UInt16 theItemToRemove = 2; theItemToRemove <= nMenuItems; theItemToRemove++)		{			::DeleteMenuItem(theVariablePopupMenu, 2);	// Always delete the second item, which will shrink the														// menu down to just one item when we are done.		}		long theNumberOfVariables = mVariableList->GetCount();				long theActualNumberOfItems = 0;		// Now add the list of variables, but only if each variable isn't already in the mFieldVariableList		for (long theItemToAdd = 1; theItemToAdd <= theNumberOfVariables; theItemToAdd++)		{			CEyeDxVariable *theVariable = mVariableList->GetVariableByIndex(theItemToAdd);						theStr = theVariable->GetName();						if (mFieldVariableList->GetVariableByName(*theStr) == NULL)			{				::AppendMenu(theVariablePopupMenu, *theStr);				theActualNumberOfItems++;			}		}		// According to the PowerPlant Book, if I change the number of items in the menu		// I have to set the Max Value properly.				mVariableMenu->SetMaxValue(theActualNumberOfItems + kVariableMenuHeadingOffset);				// We also set the value to the first item, which is really just a heading. We get notification		// from the menu only if the user changes the selection. Thus, we use the fake first item as a 		// placeholder - each time the user makes a selection, we process the selection and then set the		// menu value back to the first item. That ensures that we will always get notification, even if		// the user selects the same variable for insertion twice in a row.				mVariableMenu->SetValue(kVariableMenuHeadingOffset);	}		StartListening();}