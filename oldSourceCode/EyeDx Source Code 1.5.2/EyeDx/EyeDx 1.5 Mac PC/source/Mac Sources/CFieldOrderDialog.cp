// =================================================================================//	CExportOrderDialog.cp				©1995 Metrowerks Inc. All rights reserved.// =================================================================================//	CExportOrderDialog.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include <LStdControl.h>#include <PP_Messages.h>#include <UReanimator.h>#include "CExportOrderDialog.h"// ---------------------------------------------------------------------------------//		¥ CExportOrderDialog(LStream *)// ---------------------------------------------------------------------------------CExportOrderDialog::CExportOrderDialog(	LStream *inStream )		: LDialogBox( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CExportOrderDialog// ---------------------------------------------------------------------------------CExportOrderDialog::~CExportOrderDialog(){}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCExportOrderDialog::FinishCreateSelf(){	// Call inherited. LDialogBox's FinishCreateSelf	// sets up the default and cancel buttons.	LDialogBox::FinishCreateSelf();		// Link the dialog to the controls.	UReanimator::LinkListenerToControls( this, this, RidL_ExportOrderDialog );	}voidCExportOrderDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	EYEDX_STRING_TYPE theNameStr;			long theItem;		switch (inMessage) 	{				case msg_Cancel: 			// Don't have to do anything, since we didn't change the list at all						break;			case msg_OK:			// All we have to do here is iterate through the list, and set each variable's prompt order		// to an incrementing value				long numVariables = mFieldVariableList->GetCount();				for (long varNum = 1; varNum <= numVariables; varNum++)		{			EyeDxVariable *theVariable = mVariableList->GetVariableByIndex(varNum);			ThrowIfNil_(theVariable);						// Set the export order						theVariable->SetExportOrder(varNum);		}		break;			case msg_ExportOrderVarListSglClick:	case msg_ExportOrderVarListDblClick:	// We don't do anything special for double clicks			// Look up the variable that they clicked on				theItem = mTableSelector->GetFirstSelectedRow();				TableIndexT numRows;		TableIndexT numCols;				mVariableTable->GetTableSize(numRows, numCols);				mMoveUpButton->Disable();		mMoveDownButton->Disable();				// If they haven't clicked on the first item, then enable the Move Up Button				if (theItem > 1)									mMoveUpButton->Enable();					// And if they haven't clicked on the last item, enable the Move Down Button				if (theItem < numRows)			mMoveDownButton->Enable();								break;	case msg_ExportOrderMoveUp:				// Get the item selected, and move it up in the list		theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mFieldVariableList->SwapItems(theItem, theItem - 1);						// And just redisplay the list				UpdateVariableList();		break;	case msg_ExportOrderMoveDown:				// Get the item selected, and move it down in the list. 				theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mFieldVariableList->SwapItems(theItem, theItem + 1);				// And just redisplay the list				UpdateVariableList();		break;			default:		break;	}	// Always pass the message on to our base class		LDialogBox::ListenToMessage(inMessage, ioParam);}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------voidCExportOrderDialog::SetupDialog(EyeDxVariableList *theVariableList){	mVariableList = theVariableList;		mVariableTable = dynamic_cast<LTextTableView*> (this->FindPaneByID(kExportOrder_VariableTable));	ThrowIfNil_( mVariableTable );			mMoveUpButton = dynamic_cast<LStdButton*> (this->FindPaneByID(kExportOrder_MoveUpButton));	ThrowIfNil_( mMoveUpButton );		mMoveDownButton = dynamic_cast<LStdButton*> (this->FindPaneByID(kExportOrder_MoveDownButton));	ThrowIfNil_( mMoveDownButton );		mRemoveItemButton = dynamic_cast<LStdButton*> (this->FindPaneByID(kExportOrder_RemoveItem));	ThrowIfNil_( mRemoveItemButton );		mVariableMenu = dynamic_cast<LStdPopupMenu*> (this->FindPaneByID(kExportOrder_VariableMenu));	ThrowIfNil_( mVariableMenu );		mCancelButton = dynamic_cast<LStdButton*> (this->FindPaneByID(kExportOrder_Cancel));	ThrowIfNil_( mCancelButton );		mSaveButton = dynamic_cast<LStdButton*> (this->FindPaneByID(kExportOrder_OK));	ThrowIfNil_( mSaveButton );		mVariableTable->SetCellSizer(new LCellSizeToFit(false));	mTableSelector = new LTableSingleRowSelector(mVariableTable);		mVariableTable->SetTableSelector(mTableSelector);		mTableGeometry = new LTableMultiGeometry( mVariableTable, 10, 14 );	mVariableTable->SetTableGeometry(mTableGeometry);	mTableStorage = new LTableArrayStorage( mVariableTable, (UInt32)0 );	mVariableTable->SetTableStorage(mTableStorage);	mVariableTable->AddListener(this);	// Create our own empty variable list, using the sort by name order comparator.	// This list will hold the variables that will be output		mFieldVariableList = new EyeDxVariableList(EyeDxVariableList::kSortByExportOrder);	ThrowIfNil_(mFieldVariableList);		long numVariables = theVariableList->GetCount();		for (long varNum = 1; varNum <= numVariables; varNum++)	{		EyeDxVariable *theVariable = theVariableList->GetVariableByIndex(varNum);		ThrowIfNil_(theVariable);				if (theVariable->GetExportOrder() != kNoExportOrder)						mFieldVariableList->AddVariable(theVariable);	}		// We don't want the list to resort while the user is tweeking it		mFieldVariableList->SetKeepSorted(false);		UpdateVariableList();} voidCExportOrderDialog::UpdateVariableList(){	// Here we have to parse the variable list and add all of the prompted variables in the order in which they are	// supposed to be prompted.	StopListening();	// Set the list to allow only one item to be selected	// This will defer updating the table until we exit the routine, saving a lot of redraws		mVariableTable->SetDeferAdjustment(true);		mVariableTable->RemoveAllRows(true);		// Delete all of the existing rows		const UInt32 kNumVariableColumns = 1;		mVariableTable->InsertCols(kNumVariableColumns, 0);		// Figure out how many prompted variables there are	TableIndexT theNumberOfVariables = mFieldVariableList->GetCount();		mVariableTable->InsertRows(theNumberOfVariables, 0);	STableCell	cell;	EYEDX_STRING_TYPE *theStr;		cell.col = 1;			for (cell.row = 1; cell.row <= theNumberOfVariables; cell.row++) 	{		// Get the variable - note that the array index is 1 based!				EyeDxVariable *theVariable = mFieldVariableList->GetVariableByIndex(cell.row);				theStr = theVariable->GetName();				mVariableTable->SetCellData(cell, theStr->TextPtr(), theStr->Length());	}		mVariableTable->SetDeferAdjustment(false);		mVariableTable->Draw(nil);		StartListening();}