// =================================================================================//	CPromptForVariableDialog.cp				©1995 Metrowerks Inc. All rights reserved.// =================================================================================//	CPromptForVariableDialog.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UDrawingState.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include <LStdControl.h>#include <PP_Messages.h>#include <UReanimator.h>#include "CPromptForVariableDialog.h"// ---------------------------------------------------------------------------------//		¥ CPromptForVariableDialog(LStream *)// ---------------------------------------------------------------------------------CPromptForVariableDialog::CPromptForVariableDialog(	LStream *inStream )		: LGADialog( inStream ){	mValidInput = false;}// ---------------------------------------------------------------------------------//		¥ ~CPromptForVariableDialog// ---------------------------------------------------------------------------------CPromptForVariableDialog::~CPromptForVariableDialog(){	CEyeDxCaptionType *theCaption;	CEyeDxEditFieldType *theEditField;	CEyeDxCheckBoxType *theCheckBox;	CEyeDxPopupMenuType *thePopupMenu;		delete mSortedVariables;		// create iterators for the caption and edit field arrays and delete the	// objects!	TArrayIterator<CEyeDxCaptionType *> iterator(mLabelCaptions);		while (iterator.Next(theCaption))	{		if (theCaption)			delete theCaption;	}		TArrayIterator<CEyeDxCaptionType *> iterator2(mRequiredCaptions);		while (iterator2.Next(theCaption))	{		if (theCaption)			delete theCaption;	}		TArrayIterator<CEyeDxEditFieldType *> iterator3(mEditFields);		while (iterator3.Next(theEditField))	{		if (theEditField)			delete theEditField;	}		TArrayIterator<CEyeDxCheckBoxType *> iterator4(mCheckBoxes);		while (iterator4.Next(theCheckBox))	{		if (theCheckBox)			delete theCheckBox;	}		TArrayIterator<CEyeDxPopupMenuType *> iterator5(mPopupMenus);		while (iterator5.Next(thePopupMenu))	{		if (thePopupMenu)			delete thePopupMenu;	}		delete mTabGroup;}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCPromptForVariableDialog::FinishCreateSelf(){	// Call inherited. LDialogBox's FinishCreateSelf	// sets up the default and cancel buttons.	LGADialog::FinishCreateSelf();		// Link the dialog to the controls.	UReanimator::LinkListenerToControls( this, this, RidL_PromptForVariableDialog );	}static CEyeDxBooleanType checkAndDisplayTimeDateStatus(CEyeDxLongStringType *theNameStr, CEyeDxBooleanType lookingForTime, StringToDateStatus stdStatus){	CEyeDxLongStringType theErrString;		// The input stdStatus value is a bit map, and not all of the bit values indicate true	// error conditions.		// We first delete the longDatFound bit, since it's not an error status;		stdStatus &= ~longDateFound;	if (stdStatus == 0)		return false;			// We don't check the fatalDateTimeError or tokenErr status, since one of the items below should be more specific		if ((stdStatus & cantReadUtilities) == cantReadUtilities)		theErrString.Append("\pThe resources needed to parse the date or time value could not be read. ");	if ((stdStatus & dateTimeNotFound) == dateTimeNotFound)	{		if (lookingForTime)			theErrString.Append("\pA valid time value could not be found. ");		else			theErrString.Append("\pA valid date value could not be found. ");	}			if ((stdStatus & dateTimeInvalid) == dateTimeInvalid)	{		if (lookingForTime)			theErrString.Append("\pInvalid time value. ");		else			theErrString.Append("\pInvalid date value. ");	}			if ((stdStatus & leftOverChars) == leftOverChars)	{		if (lookingForTime)			theErrString.Append("\pYou typed too many characters for a valid time. ");		else			theErrString.Append("\pYou typed too many characters for a valid date. ");	}		if ((stdStatus & sepNotIntlSep) == sepNotIntlSep)		theErrString.Append("\pUnexpected separator character. ");			if ((stdStatus & fieldOrderNotIntl) == fieldOrderNotIntl)		theErrString.Append("\pThe order of the fields did not match the expected order. ");			if ((stdStatus & extraneousStrings) == extraneousStrings)		theErrString.Append("\pInput was not a valid string. ");			if ((stdStatus & tooManySeps) == tooManySeps)		theErrString.Append("\pToo many separator characters. ");			if ((stdStatus & sepNotConsistent) == sepNotConsistent)		theErrString.Append("\pInvalid separator characters. ");			CEyeDxLongStringType thePromptStr = "\pError for variable ";	thePromptStr.Append(*theNameStr);	thePromptStr.Append("\p: ");	::ParamText(thePromptStr, theErrString, Str_Empty, Str_Empty);	UModalAlerts::StopAlert(PPob_GeneralALRT);		return true;}CEyeDxBooleanType CPromptForVariableDialog::ValidateEntry(CEyeDxEditFieldType *theEditField,											 CEyeDxVariable *theVariable)	{	CEyeDxLongStringType *theNameStr = theVariable->GetName();	CEyeDxLongStringType theCurrentValue;		// Assume the entry is valid for now		CEyeDxBooleanType entryValid = true;		// The following is used as part of the date and time validation operations		::InitDateCache(&mDateCache);			long lengthUsed;	LongDateRec dateTime;	StringToDateStatus stdStatus;	// Indicate by default that a value was entered		CEyeDxBooleanType valueEntered = true;		// Check to see if the entry is all spaces. That's also a no-no		theEditField->GetDescriptor(theCurrentValue);			short theStrLength = theCurrentValue.Length();		short i = 1;	while (i <= theStrLength)	{		if (theCurrentValue[i] != char_Space)			break;		i++;	}		// If we got to the end of the string and found all spaces, or if the	// string length is zero, then they didn't enter a value. That may or may not	// be a problem - we check that next.		if (i > theStrLength)		valueEntered = false;			if (theVariable->GetValueMustBeEntered())	{		if (valueEntered == false)		{				CEyeDxLongStringType thePrompt = "\pSorry, you must enter a value for the '";			thePrompt.Append(*theNameStr);			thePrompt.Append("\p' variable!");									::ParamText(thePrompt, Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);			entryValid = false;		}	}		// If they passed the above tests, now validate the field based on the field	// type. We do this only if a value is entered. That handles the case for optional	// variables as well as required variables.		if (valueEntered)	{		switch (theVariable->GetDataType())		{		case CEyeDxVariable::kTypeNone:		case CEyeDxVariable::kGeneralString:		case CEyeDxVariable::kCheckBox:			// No validation necessary for these			break;					case CEyeDxVariable::kDate:		case CEyeDxVariable::kPastDate:			// Use the international utilities to check the inputs			stdStatus = ::StringToDate(theCurrentValue.TextPtr(), theStrLength, &mDateCache, &lengthUsed, &dateTime);			if (checkAndDisplayTimeDateStatus(theNameStr, false, stdStatus))				entryValid = false;			// If the date has to be in the past, then also check that!						if (theVariable->GetDataType() == CEyeDxVariable::kPastDate)			{				// Convert the current date in long format				LongDateCvt theCurrentDateTime;				theCurrentDateTime.hl.lHigh = 0L;				::GetDateTime(&theCurrentDateTime.hl.lLow);								// Now, convert the entered date into long format				LongDateCvt theEnteredDate;									// Make sure we clear the time values so they don't influence the calculation									dateTime.ld.hour = 0;				dateTime.ld.minute = 0;				dateTime.ld.second = 0;				dateTime.ld.pm = 0;								::LongDateToSeconds(&dateTime, &theEnteredDate.c);								if (theCurrentDateTime.c < theEnteredDate.c)				{					CEyeDxLongStringType thePrompt = "\pSorry, the date you enter for the '";					thePrompt.Append(*theNameStr);					thePrompt.Append("\p' variable must be before today's date!");													::ParamText(thePrompt, Str_Empty, Str_Empty, Str_Empty);					UModalAlerts::StopAlert(PPob_GeneralALRT);					entryValid = false;				}			}			break;					case CEyeDxVariable::kTime:			// Use the international utilities to check the inputs			stdStatus = ::StringToTime(theCurrentValue.TextPtr(), theStrLength, &mDateCache, &lengthUsed, &dateTime);			if (checkAndDisplayTimeDateStatus(theNameStr, true, stdStatus))				entryValid = false;						break;					case CEyeDxVariable::kIntegerNumber:			// The key filter should handle this - it allows only an optional negative sign followed by digits			break;		}	}		return(entryValid);}voidCPromptForVariableDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	CEyeDxVariable 	*theVariable;	CEyeDxEditFieldType		*theEditField;	CEyeDxCheckBoxType	*theCheckBox;	CEyeDxPopupMenuType	*thePopupMenu;			mValidInput = true;		// Assume inputs are ok		switch (inMessage) 	{				case msg_Cancel: 	case msg_PromptForVariableDialog_GoBack: 		mValidInput = false;		break;			case msg_OK:		// We do some validation here.			// For each prompt, see if it is a required value. If so, then get the		// length of the text - if empty, then complain, and refuse to continue!				for (long numPrompt = 1; numPrompt <= mNumPrompts; numPrompt++)		{			theVariable = mSortedVariables->GetVariableByIndex(numPrompt);						if ((theVariable->GetDataType() != CEyeDxVariable::kCheckBox) && (theVariable->GetDataType() != CEyeDxVariable::kMenu))			{				mEditFields.FetchItemAt(numPrompt, theEditField);							if (ValidateEntry(theEditField, theVariable) == false)					mValidInput = false;			}						}					// If we passed the above tests, then we can get the values and save them		if (mValidInput)		{			CEyeDxLongStringType theCurrentValue;						// For each prompt, read the current value and save it in the variable						for (long numPrompt = 1; numPrompt <= mNumPrompts; numPrompt++)			{				theVariable = mSortedVariables->GetVariableByIndex(numPrompt);								if (theVariable->GetDataType() == CEyeDxVariable::kCheckBox)				{					mCheckBoxes.FetchItemAt(numPrompt, theCheckBox);					if (theCheckBox->GetValue())						theVariable->SetValue(kCheckBoxOnStr);					else						theVariable->SetValue(kCheckBoxOffStr);				}				else if (theVariable->GetDataType() == CEyeDxVariable::kMenu)				{					mPopupMenus.FetchItemAt(numPrompt, thePopupMenu);					short theValue = thePopupMenu->GetValue();										CTemplateShortStrArray	*theOptionStrings = theVariable->GetOptionStringsArray();					ThrowIfNil_( theOptionStrings );					CEyeDxShortStringType *theMenuChoiceString;										theOptionStrings->FetchItemAt(theValue, theMenuChoiceString);					LString::CopyPStr(*theMenuChoiceString, theCurrentValue);					theVariable->SetValue(theCurrentValue);				}				else				{					mEditFields.FetchItemAt(numPrompt, theEditField);					theEditField->GetDescriptor(theCurrentValue);					theVariable->SetValue(theCurrentValue);				}							}			}		break;			default:		break;	}	// Always pass the message on to our base class		LGADialog::ListenToMessage(inMessage, ioParam);}static long CalcTextWidth(char *ptr, short length){	// Save the current text state		StTextState theTextState;		// See how big the text is in the system font		::TextFont(0);	::TextSize(0);	::TextFace(normal);	return (::TextWidth(ptr, 0, length));}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------const long kDialogXGap = 13;const long kDialogYGap = 13;const long kDialogMaxCaptionWidth = 220;const long kDialogRequiredCaptionWidth = 75;const long kDialogInputFieldWidth = 200;const long kDialogCaptionHeight = 16;const long kDialogInputFieldHeight = 26;// This routine handles both single and multiple prompts for variables. If thePromptOrder is set to "kNoPromptOrder",// that means that all variables that should be prompted in the current dialog should be prompted in a single// dialog. Otherwise, just the single variable that is specified by the thePromptOrder should be requested.voidCPromptForVariableDialog::SetupDialog(CEyeDxVariableList *theVariableList, CEyeDxVariable::PromptType thePromptType, 									  short thePromptOrder, CEyeDxBooleanType allowGoBack, CEyeDxBooleanType reloadValue){	long theLongestCaptionWidth = 0;	long theLongestInputWidth = 0;	long theRequiredCaptionWidth = 0;		// Save the input list so we can update it. Note that since the lists work with pointers to the	// variables, changes we make to our sorted list will be reflected in the main list.		mVariableList = theVariableList;	ThrowIfNil_(mVariableList);		// For each variable that is in this dialog, create a caption and an edit field. We first search for	// all prompted variables, adding them to our local sorted list. 	// Once we have that, we look for the longest prompt string. Based on that, we establish the longest 	// caption field. Once we have the longest caption field, we truncate it to no more than 	// kLongestAllowedCaption. Finally, we start building objects.		// As objects are created, the captions are right-aligned, and positioned kDialogXGap pixels away 	// from the edit field. The edit fields are all created with the same kInputFieldWidth, and each is 	// initialized with the variable's default value.		// Finally, once we have created all of the objects, we position the Cancel and OK buttons, and resize the	// dialog window to the appropriate size.		// Create our own variable list, using the sort by prompt order comparator		mSortedVariables = new CEyeDxVariableList(CEyeDxVariableList::kSortByPromptOrder);	ThrowIfNil_(mSortedVariables);		long numVariables = theVariableList->GetCount();		for (long varNum = 1; varNum <= numVariables; varNum++)	{		CEyeDxVariable *theVariable = theVariableList->GetVariableByIndex(varNum);		ThrowIfNil_(theVariable);				// If this variable is in this dialog, add it to our sorted list				if (theVariable->GetWhenToPrompt() == thePromptType)		{			// If passed kNoPromptOrder, we add all of the variables for this prompt type and dialog			if (thePromptOrder == kNoPromptOrder)				mSortedVariables->AddVariable(theVariable);			// Otherwise, we add it only if it's the one we're looking for			else if (thePromptOrder == theVariable->GetPromptOrder())				mSortedVariables->AddVariable(theVariable);					}			}		// Now we save the number of prompts and calculate the longest prompt string			mNumPrompts = mSortedVariables->GetCount();		for (long numPrompt = 1; numPrompt <= mNumPrompts; numPrompt++)	{		CEyeDxVariable *theVariable = mSortedVariables->GetVariableByIndex(numPrompt);		ThrowIfNil_(theVariable);		CEyeDxShortStringType *thePromptStr = theVariable->GetPromptString();		long theCaptionWidth = CalcTextWidth(thePromptStr->TextPtr(), thePromptStr->Length());				// The item is not a checkbox type, we use the prompt string as the caption. For check boxes, the		// prompt string is the checkbox title, and there is no caption				if ((theCaptionWidth > theLongestCaptionWidth) && (theVariable->GetDataType() != CEyeDxVariable::kCheckBox))		{			// At least one variable will have the required indicator			theRequiredCaptionWidth = kDialogRequiredCaptionWidth;			theLongestCaptionWidth = theCaptionWidth;						// If the widest input area width isn't an edit field width yet (all previous items were checkboxes),			// then bump up the width to the edit field width.						if (theLongestInputWidth < kDialogInputFieldWidth)				theLongestInputWidth = kDialogInputFieldWidth;		}				// For checkbox types, we figure out the larger of the largest checkbox title (prompt) string and the		// edit field width.				if ((theCaptionWidth > theLongestInputWidth) && (theVariable->GetDataType() == CEyeDxVariable::kCheckBox))		{			// At least one checkbox has a string longer than this and longer than the edit field width			// We set the width to the width of the string plus some extra space to account for the checkbox			theLongestInputWidth = theCaptionWidth + kDialogXGap + kDialogXGap + kDialogXGap;			}				if ((theVariable->GetDataType() != CEyeDxVariable::kCheckBox) && (theVariable->GetDataType() != CEyeDxVariable::kMenu))		{			// At least one variable will have the required indicator, so change the size from zero			theRequiredCaptionWidth = kDialogRequiredCaptionWidth;		}	}		// Restrict the caption width to a maximum size after making it a bit larger than the widest string		theLongestCaptionWidth += kDialogXGap;		if (theLongestCaptionWidth > kDialogMaxCaptionWidth)		theLongestCaptionWidth = kDialogMaxCaptionWidth;			if (theLongestInputWidth > kDialogInputFieldWidth)		theLongestInputWidth = kDialogInputFieldWidth;			SPaneInfo thePaneInfo;		// Set the common values for all panes		thePaneInfo.visible = true;	thePaneInfo.enabled = true;	thePaneInfo.bindings.left = false;	thePaneInfo.bindings.top = false;	thePaneInfo.bindings.bottom = false;	thePaneInfo.bindings.right = false;		long yPos = kDialogYGap;	long xCaptionPos = kDialogXGap;	long xInputFieldPos = (kDialogXGap + theLongestCaptionWidth + kDialogXGap);	long xRequiredCaptionPos = (xInputFieldPos + theLongestInputWidth + kDialogXGap);		long theFrameHeight;	long theFrameWidth = (kDialogXGap + theLongestCaptionWidth + 						  kDialogXGap + theLongestInputWidth + 						  kDialogXGap + theRequiredCaptionWidth + 						  kDialogXGap);	// Create a tab group for the dialog			ResID thePopupMenuID = kBasePopupDummyMenuID;		mTabGroup = new LTabGroup;		for (long numPrompt = 1; numPrompt <= mNumPrompts; numPrompt++)	{		CEyeDxShortStringType theIDStr;				CEyeDxVariable *theVariable = mSortedVariables->GetVariableByIndex(numPrompt);				CEyeDxShortStringType *thePromptStr = theVariable->GetPromptString();		// For check boxes, we use the prompt string as the title of the item, and create 				CEyeDxCaptionType *theCaption = NULL;				if (theVariable->GetDataType() != CEyeDxVariable::kCheckBox)		{			// Calculate the size and position of the caption object						theIDStr = "\ppc";			theIDStr.Append(numPrompt/10);			theIDStr.Append(numPrompt % 10);						thePaneInfo.paneID = FourCharCode(theIDStr);			thePaneInfo.width = theLongestCaptionWidth;			thePaneInfo.height = kDialogCaptionHeight;			thePaneInfo.left = xCaptionPos;			thePaneInfo.top = yPos + (kDialogInputFieldHeight - kDialogCaptionHeight) / 2; // Since the caption is shorter, offset it			thePaneInfo.userCon = 0;			thePaneInfo.superView = this;						// This takes a C string for the label - why I don't know... It's just easier to set the			// caption to an empty string, and set the Descriptor below using the CEyeDxShortStringType						theCaption = new CEyeDxCaptionType(thePaneInfo, (unsigned char *)"", kTextAttr_SystemRightAligned);			ThrowIfNil_(theCaption);						theCaption->PutInside(this);			theCaption->FinishCreate();			theCaption->SetDescriptor(ConstStringPtr(*thePromptStr));		}		// Add either a real object or NULL to the list							mLabelCaptions.AddItem(theCaption);							TEKeyFilterFunc theKeyFilter;				switch (theVariable->GetDataType())		{		case CEyeDxVariable::kTypeNone:		case CEyeDxVariable::kGeneralString:		case CEyeDxVariable::kDate:		case CEyeDxVariable::kPastDate:		case CEyeDxVariable::kTime:			theKeyFilter = UKeyFilters::PrintingCharField;			break;					case CEyeDxVariable::kIntegerNumber:			theKeyFilter = UKeyFilters::NegativeIntegerField; // TODO - should allow for floating point as well!			break;					case CEyeDxVariable::kCheckBox:		case CEyeDxVariable::kMenu:			// No key filter for check boxes or menu items			break;		}				// Calculate the size and position of the input field object				theIDStr = "\ppi";		theIDStr.Append(numPrompt/10);		theIDStr.Append(numPrompt % 10);				thePaneInfo.paneID = FourCharCode(theIDStr);		thePaneInfo.width = theLongestInputWidth;				thePaneInfo.left = xInputFieldPos;		thePaneInfo.top = yPos;		thePaneInfo.userCon = 0;		thePaneInfo.superView = this;					CEyeDxShortStringType *theDefaultStr = theVariable->GetDefaultValue();		CEyeDxEditFieldType *theEditField = NULL;		CEyeDxCheckBoxType *theCheckBox = NULL;		CEyeDxPopupMenuType *theChoiceMenu = NULL;				switch (theVariable->GetDataType())		{		case CEyeDxVariable::kCheckBox:			short theValue = 0;									if (*theDefaultStr == kCheckBoxOnStr)				theValue = 1;			thePaneInfo.height = kDialogInputFieldHeight;						theCheckBox = new CEyeDxCheckBoxType(thePaneInfo, 										  	-(numPrompt * 10),  	// Set arbitrary message number										  	theValue,				// Use standard Text Traits											*thePromptStr,			// Use the prompt string for the title											(short)nil);				ThrowIfNil_(theCheckBox);						theCheckBox->PutInside(this);			theCheckBox->FinishCreate();						break;					case CEyeDxVariable::kMenu:			thePaneInfo.height = kDialogInputFieldHeight;						// We allow only a certain number of pop-ups per dialog						if (thePopupMenuID <= kMaxPopupDummyMenuID)			{								theChoiceMenu = new CEyeDxPopupMenuType(thePaneInfo,												 	0,					// No message needed												  	popupTitleNoStyle,	// No titleOptions													thePopupMenuID++,	// Use a placeholder menu definition													0,					// No title width - we use the caption instead													kControlPopupButtonProc,		// Standard pop-up menu but we display a list of resources													nil,				// Use standard Text Traits													(unsigned char *) Str_Empty,			// No title													0,					// No resource type													1);					// Item 1 is the default																				ThrowIfNil_(theChoiceMenu);								// Get the empty menu associated with the pop-up								MenuHandle theChoicePopupMenu = theChoiceMenu->GetMacMenuH();				ThrowIfNil_( theChoicePopupMenu );								// Delete the existing items								long nMenuItems = ::CountMItems(theChoicePopupMenu);				for (UInt16 theItemToRemove = 1; theItemToRemove <= nMenuItems; theItemToRemove++)				{					::DeleteMenuItem(theChoicePopupMenu, 1);	// Always delete the first item, which will shrink the																// menu down to just zero items when we are done.				}							// Get the choice string list								CTemplateShortStrArray	*theOptionStrings = theVariable->GetOptionStringsArray();				ThrowIfNil_( theOptionStrings );				// Now, loop through the list, adding the choice to the menu								TArrayIterator<CEyeDxShortStringType *> iterator(*theOptionStrings);								CEyeDxShortStringType *theOptionString;								short theSelectedItem = 1;				short theNumberOfChoices = 0;				while (iterator.Next(theOptionString))				{					::AppendMenu(theChoicePopupMenu, *theOptionString);					if (*theOptionString == *(theVariable->GetDefaultValue()))						theSelectedItem = theNumberOfChoices + 1;					theNumberOfChoices++;				}								// According to the PowerPlant Book, if I change the number of items in the menu				// I have to set the Max Value properly.								theChoiceMenu->SetMaxValue(theNumberOfChoices);								// We also set the value to the first item.								theChoiceMenu->SetValue(theSelectedItem);				theChoiceMenu->PutInside(this);				theChoiceMenu->FinishCreate();			}			break;					default:					UInt8 theAttributes = (editAttr_Box | editAttr_AutoScroll);									// We make the text entry field larger if the user has requested more room be given			short theExtraEntryLines = theVariable->GetExtraEntryLines();			thePaneInfo.height = kDialogInputFieldHeight * (theExtraEntryLines + 1);						if (theExtraEntryLines > 0)			{				theAttributes |= editAttr_WordWrap;				theKeyFilter = UKeyFilters::PrintingCharAndCRField;	// We also allow Carriage Returns in this type of field			}			// This takes a real Str255, not a C string.						// However, if we are going back to a variable they already entered, we reload the value they just saved					if (reloadValue)			{				CEyeDxLongStringType *theValue = theVariable->GetValue();								theEditField = new CEyeDxEditFieldType(thePaneInfo,												mTabGroup, 											  	*theValue, 											  	(short)nil,											  	0,											  	(short)kCEyeDxVariableValueLength,												theAttributes, 												theKeyFilter);			}			else			{				theEditField = new CEyeDxEditFieldType(thePaneInfo,												mTabGroup, 											  	ConstStringPtr(*theDefaultStr), 											  	(short)nil,											  	0,											  	(short)kCEyeDxVariableValueLength,												theAttributes, 												theKeyFilter);			}							ThrowIfNil_(theEditField);						theEditField->PutInside(this);			theEditField->FinishCreate();						// This crashes it: AddSubCommander(theEditField);						// Set the latest sub commander to the first edit item					if (numPrompt == 1)			{				SetLatentSub(theEditField);				SwitchTarget(theEditField);			}			break;		}				// Save the height so we can position the next line correctly				short saveInputHeight = thePaneInfo.height;		// Keep the two lists in sync with the same number of items!					// Add either a real object or NULL to the list							mEditFields.AddItem(theEditField);					mCheckBoxes.AddItem(theCheckBox);		mPopupMenus.AddItem(theChoiceMenu);				// Since check boxes and menus force the user to make a selection, there's no sense telling them that the		// entry is required!				theCaption = NULL;				if ((theVariable->GetDataType() != CEyeDxVariable::kCheckBox) && (theVariable->GetDataType() != CEyeDxVariable::kMenu))		{			theIDStr = "\ppr";			theIDStr.Append(numPrompt/10);			theIDStr.Append(numPrompt % 10);						thePaneInfo.paneID = FourCharCode(theIDStr);			thePaneInfo.width = kDialogRequiredCaptionWidth;			thePaneInfo.height = kDialogCaptionHeight;			thePaneInfo.left = xRequiredCaptionPos;			thePaneInfo.top = yPos + (kDialogInputFieldHeight - kDialogCaptionHeight) / 2; // Since the caption is shorter, offset it			thePaneInfo.userCon = 0;			thePaneInfo.superView = this;							// This takes a C string for the label - why I don't know... It's just easier to set the			// caption to an empty string, and set the Descriptor below using the CEyeDxShortStringType						theCaption = new CEyeDxCaptionType(thePaneInfo, (unsigned char *)"", kTextAttr_SystemRightAligned);			ThrowIfNil_(theCaption);						theCaption->PutInside(this);			theCaption->FinishCreate();			if (theVariable->GetValueMustBeEntered())				theCaption->SetDescriptor("\p(Required)");			else				theCaption->SetDescriptor("\p(Optional)");		}				// Add either a real object or NULL to the list							mRequiredCaptions.AddItem(theCaption);				// Get ready to position the next item - account for larger text entry fields if need be				yPos = yPos + saveInputHeight + kDialogYGap;	}		// Finally, we get the Go Back, Cancel, and OK buttons for the dialog.		// Calculate the position of the Go Back, Cancel, and Save buttons based on their width and the center	// point of the window.		mGoBackButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kPromptForVariable_GoBack));	ThrowIfNil_( mGoBackButton );		mCancelButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kPromptForVariable_Cancel));	ThrowIfNil_( mCancelButton );		mSaveButton = dynamic_cast<CEyeDxButtonType*> (this->FindPaneByID(kPromptForVariable_OK));	ThrowIfNil_( mSaveButton );		// If this is a prompt on start dialog, change the Cancel button to indicate that we are	// going to exit.		if (thePromptType == CEyeDxVariable::kPromptOnStart)		mCancelButton->SetDescriptor("\pExit");			// If we are told to allow the user to request to go "Go Back", enable and show the button		if (allowGoBack)	{		mGoBackButton->Enable();		mGoBackButton->Show();	}		SDimension16 theGoBackButtonSize;	SDimension16 theCancelButtonSize;	SDimension16 theSaveButtonSize;		mGoBackButton->GetFrameSize(theGoBackButtonSize);	mCancelButton->GetFrameSize(theCancelButtonSize);	mSaveButton->GetFrameSize(theSaveButtonSize);		// We have to account for the extra height of the Save button since it has the default ring around it.	short theExtraSaveHeight = theSaveButtonSize.height - theCancelButtonSize.height;		long theGroupWidth = theCancelButtonSize.width + kDialogXGap + theSaveButtonSize.width;		// Make sure the dialog is at least wide enough to hold the buttons. This might occur if the	// dialog holds only a checkbox (no label and no "Optional" string)		if (allowGoBack)	{		theGroupWidth = theGroupWidth + kDialogXGap + theGoBackButtonSize.width;		if (theFrameWidth < theGroupWidth)			theFrameWidth = kDialogXGap + theGroupWidth + kDialogXGap;			mGoBackButton->PlaceInSuperFrameAt((theFrameWidth / 2) - (theGroupWidth / 2), yPos, true);			mCancelButton->PlaceInSuperFrameAt((theFrameWidth / 2) - (theCancelButtonSize.width / 2), yPos, true);			mSaveButton->PlaceInSuperFrameAt(  (theFrameWidth / 2) + (theCancelButtonSize.width / 2) + kDialogXGap, (yPos - (theExtraSaveHeight / 2)), true);		}	else	{		if (theFrameWidth < theGroupWidth)			theFrameWidth = kDialogXGap + theGroupWidth + kDialogXGap;			mCancelButton->PlaceInSuperFrameAt((theFrameWidth / 2) - (theGroupWidth / 2), yPos, true);			mSaveButton->PlaceInSuperFrameAt((theFrameWidth / 2) + (kDialogXGap / 2), (yPos - (theExtraSaveHeight / 2)), true);		}	theFrameHeight = yPos + theCancelButtonSize.height + kDialogXGap;		// And now resize the frame		ResizeWindowTo(theFrameWidth, theFrameHeight);		// Finally, set the Save button to be the default		SetDefaultButton(kPromptForVariable_OK);		SetCancelButton(kPromptForVariable_Cancel);		// Finally, we indicate in the window label what the user should do		switch (thePromptType)	{	case CEyeDxVariable::kPromptOnStart:		this->SetDescriptor("\pEnter startup values:");		break;	case CEyeDxVariable::kPromptForSubject:		this->SetDescriptor("\pEnter values for this subject:");		break;	case CEyeDxVariable::kPromptForSession:		this->SetDescriptor("\pEnter values for this session:");		break;	case CEyeDxVariable::kPromptForEndOfSession:		this->SetDescriptor("\pEnter values for the end of this session:");		break;	}	//LCommander::SetDefaultCommander(defaultCommander);	} 