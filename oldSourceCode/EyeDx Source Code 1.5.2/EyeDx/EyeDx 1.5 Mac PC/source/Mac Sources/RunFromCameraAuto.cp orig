// =================================================================================//	CDocumentApp.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for a document PowerPlant project////  The Application is derived from LDocApplication.  New Windows are managed//  by CTextDocument which is derived from LSingleDoc.  Each document contains//  a smart text view that remembers if it has changed since it was last saved.#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <LIconPane.h>#include <LWindow.h>#include <LGroupBox.h>#include <LTextButton.h>#include "LThermometerPane.h"#include "EyeDxMacConstants.h"#include "CMyGWorldView.h"#include "CEyeDxPrefs.h"#include "ABalloon.h"#include "LProgressDialog.h"#include "DC120.h"#include "CSpaceClickDialog.h"MessageT CDocumentApp::HandleCameraSetup(){	// This routine displays a dialog to tell the user to prepare the camera for use.		// Create the dialog handler.	StDialogHandler theHandler( PPob_CameraSetupDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		theDialog->Show();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage) 		{		case msg_CameraSetup_ManualButton:		case msg_OK:		case msg_Cancel:			return theMessage;						break;		}	}}bool CDocumentApp::GetReportName(){	// This routine displays a dialog to prompt for the report name.	// If OK is pressed, the name is validated, and the user prompted if it is	// invalid. Otherwise, we return true.		// Create the dialog handler.	StDialogHandler theHandler( PPob_ReportNameDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		LEditField *theReportName = dynamic_cast<LEditField*> (theDialog->FindPaneByID(kReportNameField));	ThrowIfNil_( theReportName );		LCaption *theReportCaption = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kReportNamePrompt));	ThrowIfNil_( theReportCaption );		LCaption *theLicenseStatusCaption = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kReportNameLicenseCaption));	ThrowIfNil_( theLicenseStatusCaption );		long theMaxReportNameLength = kMaxReportNameLength;		// If the adjustName option is turned on, we have to account for the prefix length	// when testing the maximum report name length.		if (mReportPrefs.adjustName)		theMaxReportNameLength -= kPrefixLength;		LStr255 theReportPrompt = "\pPlease enter up to ";	theReportPrompt.Append(theMaxReportNameLength);	theReportPrompt.Append("\p characters for the subject's name:");	theReportCaption->SetDescriptor(theReportPrompt);		// We get the thumbnail from the camera, and picture information	SetLicenseStatusCaption(theLicenseStatusCaption);		theDialog->Show();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		if ( theMessage == msg_Cancel ) 		{			return false;						break;		} 		else if ( theMessage == msg_OK ) 		{			// Get the entered report name and see if it is valid.			// If it is, we return true. If not, the user is prompted and we			// continue looping.			Str255 theReportNameString;						theReportName->GetDescriptor(theReportNameString);						// Note that this routine also sets the global report_filename variable			// if the entered value is ok.						if (CheckReportValidity(&theReportNameString))				return true;		}	}	return false;}bool CDocumentApp::OpenCamera(LCaption *theStatusCaption){	StCursor wait;	// Set the pointer to the stop watch while we are setting up		theStatusCaption->SetDescriptor("\pLooking for camera...");	theStatusCaption->Draw(nil);		DCStatus			GenericStatus;	DC120Status 		FullDC120Status; // Structure of DC120Status	// Save the last picture count		LastNumOfPicts = NumOfPicts;	NumOfPicts = 0;	PictNamePtr = NULL;	DCPortNum thePortNum = (DCPortNum) mCameraPrefs.defaultPort;	if (OpenCameraDriver(&GenericStatus, &FullDC120Status, nil, theStatusCaption, &thePortNum) == 0)  	{		theStatusCaption->SetDescriptor("\p");		theStatusCaption->Draw(nil);	    	return false;	}		// Save the preferences - this will record the last port used for the camera		mCameraPrefs.defaultPort = (long)thePortNum;	mPreferences->SaveCameraPrefs(&mCameraPrefs);		// TODO - We can check the generic status here to see if the camera is ready to take pictures	// and to warn the user if the battery is low		RunInProgress = 1;	// We return true if we successfully connected and false otherwise. 		theStatusCaption->SetDescriptor("\p");	theStatusCaption->Draw(nil);	return true;}extern long startTicks;bool CDocumentApp::PromptForAndTakePicture(enum eOrientation theOrientation,											DCPictInfo *theGenericPictInfo,											DC120PictInfo *thePictInfo, 										    CMyGWorldView *theMainWindowView, 										    LCaption *theMainWindowCaption){	// Create the dialog handler.	StDialogHandler theHandler( PPob_TakePictureDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		LCaption *theTakePictureCaption = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kTakePictureCaption));	ThrowIfNil_( theTakePictureCaption );	theTakePictureCaption->AddAttachment(mEraseAttachment, nil, false);		LStdButton *theOkButton = dynamic_cast<LStdButton*> (theDialog->FindPaneByID(kTakePicture_OK));	ThrowIfNil_( theOkButton );		LStdButton *theCancelButton = dynamic_cast<LStdButton*> (theDialog->FindPaneByID(kTakePicture_Cancel));	ThrowIfNil_( theCancelButton );		LPicture *theCameraPICT = dynamic_cast<LPicture*> (theDialog->FindPaneByID(kTakePicturePICT));	ThrowIfNil_( theCameraPICT );	LIconPane *theBatteryLevelIcon = dynamic_cast<LIconPane*> (theDialog->FindPaneByID(kTakePictureBatteryIcon));	ThrowIfNil_( theBatteryLevelIcon );	LCaption *theBatteryLevelCaption = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kTakePictureBatteryCaption));	ThrowIfNil_( theTakePictureCaption );	theBatteryLevelCaption->AddAttachment(mEraseAttachment, nil, false);		// Disable the buttons until we know we can take the picture		theOkButton->Disable();	theCancelButton->Disable();	// Show the dialog so that the user sees status updates		theDialog->Show();	short picturesNeeded; 	// Used to check the camera if it has enough memory for the required number of							// pictures at this particular step	LStr255 thePromptStr;		switch (theOrientation)	{	case kUpOrientation:		theCameraPICT->SetPictureID(kUpCameraPICT);		thePromptStr = "\pPrepare to take the 'Up' picture. Position subject the correct distance from the camera, and hold camera with the handle on the right side. Press Take Picture when ready.";		picturesNeeded = 2;		break;			case kSideOrientation:		theCameraPICT->SetPictureID(kSideCameraPICT);		thePromptStr = "\pPrepare to take the 'Side' picture. Position subject the correct distance from the camera, and hold camera with the handle on the bottom. Press Take Picture when ready.";		picturesNeeded = 1;		break;	}	// Force the dialog to refresh		theDialog->Draw(nil);		DC120BatteryStatus theBatteryLevel;	BOOL theFlashStatus = false;		// For some reason, the camera doesn't report flash status properly. So we can't use this code.	#if FALSE	short flashCheckTries = kTriesToCheckFlash;		while ((theFlashStatus == false) && (flashCheckTries > 0))	{		if (!CheckCameraStatus(nil, picturesNeeded, theTakePictureCaption, &theBatteryLevel, &theFlashStatus))		{			CleanupCameraAutoMode();			return false;		}				if (theFlashStatus == false)		{			//LStr255 theNum = flashCheckTries * kFlashRechargeTimeoutInSecs;			//LStr255 theTimeRemaining = "\pWaiting for flash to charge. " + theNum + "\pseconds till timeout.";						theTakePictureCaption->SetDescriptor("\pWaiting for flash to charge. ");			theTakePictureCaption->Draw(nil);			OSSleep(kFlashRechargeTimeout);		}		flashCheckTries--;	}		if (theFlashStatus == false)	{		StopAlert(nil, CommonStringLiteral_("The camera's flash has not recharged. Replace batteries or use AC Adaptor."));		CleanupCameraAutoMode();		return false;	}#else	if (!CheckCameraStatus(nil, picturesNeeded, theTakePictureCaption, &theBatteryLevel, &theFlashStatus))	{		CleanupCameraAutoMode();		return false;	}#endif			// Wait for the flash to recharge. Only wait for a while, though		switch (theBatteryLevel)	{	case DC120BatteryOK:		theBatteryLevelIcon->SetIconID(kOKBatteryIconList);		theBatteryLevelCaption->SetDescriptor("\pOK");		break;			case DC120BatteryWeak:		theBatteryLevelIcon->SetIconID(kWeakBatteryIconList);		theBatteryLevelCaption->SetDescriptor("\pWeak");		break;			case DC120BatteryEmpty:		theBatteryLevelIcon->SetIconID(kEmptyBatteryIconList);		theBatteryLevelCaption->SetDescriptor("\pEmpty");		StopAlert(nil, CommonStringLiteral_("The camera does not have enough battery power to take another picture. Replace batteries or use AC Adaptor."));		break;	}		// Force the items to show up		theBatteryLevelIcon->Draw(nil);	theBatteryLevelCaption->Draw(nil);		// Set the camera parameters		if (!SetCameraPictureParams(theTakePictureCaption))	{		CleanupCameraAutoMode();		return false;	}			// Now, we finally draw the correct prompt, based on the current orientation (Up or Side)					theTakePictureCaption->SetDescriptor(thePromptStr);			theOkButton->Enable();	theCancelButton->Enable();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		if ( theMessage == msg_Cancel ) 		{			return false;						break;		} 		else if ( theMessage == msg_OK ) 		{			//startTicks = ::LMGetTicks();				StCursor wait;	// Set the pointer to the stop watch while we are getting the image						theOkButton->Disable();			theCancelButton->Disable();			if (!TakePicture(theOrientation, nil, theTakePictureCaption, theMainWindowCaption, theMainWindowView, theGenericPictInfo, thePictInfo))			{				return false;			}			return true;			break;		}	}	return false;	}// This routine will set up the camera with the standard parameters. If it gets an// error, it returns false. Otherwise, it returns truebool CDocumentApp::SetCameraPictureParams(LCaption *theStatusCaption){	StCursor wait;	// Set the pointer to the stop watch while we are getting the image	// There's no need to handle the dialog, since it doesn't have any buttons.		if (!SetCameraConfiguration(mAutoCameraWindow, theStatusCaption))	{		return false;	}			return true;}enum ePictureVerifyStatus CDocumentApp::VerifyPicture(enum eOrientation Location, 											DCPictInfo *theGenericPictInfo,											DC120PictInfo *thePictInfo, 										    CMyGWorldView *theMainWindowView, 										    LCaption *theMainWindowCaption,										    LIconPane *theMainWindowQualityIcon){	// Create the dialog handler.	StDialogHandler theHandler( PPob_VerifyPictureDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		LCaption *theStatusCaption = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kVerifyPictureNoteCaption));	ThrowIfNil_( theStatusCaption );	theStatusCaption->AddAttachment(mEraseAttachment, nil, false);		LCaption *theFilenameCaption = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kVerifyPictureImageCaption));	ThrowIfNil_( theFilenameCaption );		CMyGWorldView *theView = dynamic_cast<CMyGWorldView*> (theDialog->FindPaneByID(kVerifyPictureMyGWorldView));	ThrowIfNil_( theView );		LStdButton *theOkButton = dynamic_cast<LStdButton*> (theDialog->FindPaneByID(kVerifyPicture_OK));	ThrowIfNil_( theOkButton );		LCaption *theTopCaption = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kVerifyPictureTopCaption));	ThrowIfNil_( theTopCaption );		LCaption *theSideCaption = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kVerifyPictureSideCaption));	ThrowIfNil_( theSideCaption );		Str255 theString;			theMainWindowCaption->GetDescriptor(theString);	theFilenameCaption->SetDescriptor(theString);	theView->CopyPixMapData(theMainWindowView->GetPixMapHandle());	// If the location is "Side", then we change the Ok button to say "Run Analysis"		LStr255 theButtonName;	if (Location == kSideOrientation)	{		theSideCaption->Show();		theButtonName = "\pRun Analysis";	}	else	{		theTopCaption->Show();		theButtonName = "\pContinue";	}	theOkButton->SetDescriptor(theButtonName);			 		theMainWindowQualityIcon->Show();	// If the quality isn't what we should be using, warn the user		unsigned long thePictQuality;		thePictQuality = CheckPictInfo(thePictInfo);		if (thePictQuality != 0)	{			LStr255 theErrorString;				if (thePictQuality & kNotBestQuality)			theErrorString.Append( "\pThe picture was not taken with the recommended 'Best' image quality setting. ");				if (thePictQuality & kNoFlash)			theErrorString.Append("\pThe flash was not on. ");					if (thePictQuality & kNotZoomed)			theErrorString.Append("\pThe camera was not zoomed all the way in. ");					if (thePictQuality & kBadFocusMode) 			theErrorString.Append("\pThe camera focus mode was incorrect (should be multispot). ");					if (thePictQuality & kSubjectTooClose)			theErrorString.Append("\pSubject was too close to camera. ");					if (thePictQuality & kSubjectTooFar)			theErrorString.Append("\pSubject was too far from camera. ");		if (thePictQuality & kBadOrientation)			theErrorString.Append("\pPicture orientation setting not correct (should be no rotation). ");		theErrorString.Append("\p Analysis may produce incorrect results. EyeDx recommends you retake the picture.");		theMainWindowQualityIcon->SetIconID(kCautionQualityIconList);	 	theStatusCaption->SetDescriptor(theErrorString);	}	else	{		LStr255 thePromptString = "\pThe picture settings and distance appear to be OK. If the picture is oriented correctly and the subject is properly looking at the camera, press ";		thePromptString.Append(theButtonName);		thePromptString.Append("\p. Otherwise, retake the picture.");				theStatusCaption->SetDescriptor(thePromptString);		theMainWindowQualityIcon->SetIconID(kGoodQualityIconList);	}	// Show the dialog early so we can use it for status display	theDialog->Show();			// Now handle the user's requests		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		if ( theMessage == msg_Cancel ) 		{			return kPictureVerifyCancel;						break;		} 		else if ( theMessage == msg_OK ) 		{			return kPictureVerifyOK;			break;		}		else if (theMessage == msg_VerifyPicture_Retake)		{			return kPictureVerifyRetake;			break;		}	}	return kPictureVerifyCancel;}bool CDocumentApp::DownloadPictures(EyeDxNextStepCode theResult){	StCursor wait;	// Set the pointer to the stop watch while we are downloading	// Force a redraw of the main window		// We download the Up image in all cases except when we are retaking the Side image		if (theResult !=  kNextStepRetakeSide)	{		mAutoCameraUpThermometerPane->Show();		mAutoCameraUpProgressCaption->Show();							mAutoCameraWindow->Draw(nil);				if (!DownloadImageFromCamera(1,&mUpHandle,&UP_ROWS,&UP_COLS,up_filename, 									nil, mAutoCameraUpThermometerPane, mAutoCameraUpProgressCaption))			return false;		mAutoCameraUpThermometerPane->Hide();		mAutoCameraUpProgressCaption->Hide();		mAutoCameraWindow->Draw(nil);	}		// Force a refresh of the window to get the thermometer and caption to hide properly		// We download the Side image in all cases except when we are retaking the Up image		if (theResult !=  kNextStepRetakeUp)	{		mAutoCameraSideThermometerPane->Show();		mAutoCameraSideProgressCaption->Show();		mAutoCameraWindow->Draw(nil);							if (!DownloadImageFromCamera(2,&mSideHandle,&SIDE_ROWS,&SIDE_COLS,side_filename, 	 									nil, mAutoCameraSideThermometerPane, mAutoCameraSideProgressCaption))					return false;		mAutoCameraSideThermometerPane->Hide();		mAutoCameraSideProgressCaption->Hide();		mAutoCameraWindow->Draw(nil);	}				return true;}bool CDocumentApp::CleanupCameraAutoMode(){	// ALWAYS close the camera!!		CloseCamera(nil);		// The user can cancel at any time. We just hide the Run From Disk Window and show	// the Control Window			CleanupImages(mCameraUpView, mCameraSideView);		RunInProgress = 0;	HideMoveShow(mAutoCameraWindow, mMainWindow);		return true;}MessageT CDocumentApp::HandleAnotherSubjectPrompt(){	// This routine displays a dialog to tell the user to prepare the camera for use.		// Create the dialog handler.	StDialogHandler theHandler( PPob_AnotherSubjectDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		theDialog->Show();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage) 		{		case msg_OK:		case msg_Cancel:			return theMessage;						break;		}	}}bool CDocumentApp::HandleDeleteImage(void *theWindow,										 LCaption *theProgressCaption,				 						 DCPictInfo *theGenericPictInfo){	// This routine displays a dialog to tell the user to prepare the camera for use.		// Create the dialog handler.	StDialogHandler theHandler( PPob_DeletingImageDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		theDialog->Show();		theDialog->Draw(nil);		// We don't need to handle events as we are just warning the user not to turn off or	// unplug the camera		return(DeletePicture(theDialog, theProgressCaption, theGenericPictInfo));}void CDocumentApp::HandleRunFromCameraAuto(){	EyeDxNextStepCode theResult;	// These are the generic picture info structures that we use to delete images that the user	// retakes.	DCPictInfo theUpPictInfo;	DCPictInfo theSidePictInfo;		// Hide the Main Window		HideMoveShow(mMainWindow, mAutoCameraWindow);		mAutoCameraUpProgressCaption->Show();		mAutoCameraUpView->Show();	mAutoCameraUpView->ResetImage();	mAutoCameraSideView->Show();	mAutoCameraSideView->ResetImage();	mAutoCameraUpPictureQualityIcon->Hide();	mAutoCameraSidePictureQualityIcon->Hide();	mAutoCameraReportName->SetDescriptor(Str_Empty);	mAutoCameraUpCaption->SetDescriptor(Str_Empty);	mAutoCameraSideCaption->SetDescriptor(Str_Empty);	mAutoCameraWindow->Draw(nil);		// First, we connect to the camera - put up a status window so that the user knows what is	// going on. We do this only once per loop to save time reopening it each time.		if (!OpenCamera(mAutoCameraUpProgressCaption))	{			CleanupCameraAutoMode();		return;	}		// Refresh the window		mAutoCameraWindow->Draw(nil);							// We loop in this mode until the user cancels any of the dialogs		while (true)	{		mAutoCameraUpProgressCaption->Show();			mAutoCameraUpView->ResetImage();		mAutoCameraUpCaption->SetDescriptor(Str_Empty);		mAutoCameraUpPictureQualityIcon->Hide();		mAutoCameraSideProgressCaption->Show();		mAutoCameraSideView->ResetImage();		mAutoCameraSideCaption->SetDescriptor(Str_Empty);		mAutoCameraSidePictureQualityIcon->Hide();			mAutoCameraReportName->SetDescriptor("\pNot specified yet.");					// First, we prompt the user for the report name. If they cancel, we just return, as nothing		// was allocated or initiated yet.					if (!GetReportName())		{			CleanupCameraAutoMode();			return;		}				// Default to the continue case				theResult = kNextStepContinue;				mUpSelected = false;		mSideSelected = false;								do		{			LStr255 theString(report_filename);					mAutoCameraReportName->SetDescriptor(theString);						// We next prompt the user to get ready to take the Up picture.			// This dialog allows the user to simply click the mouse anywhere to snap the shutter			// If the mUpSelected flag is already set, we skip this step							while (!mUpSelected)			{				mCameraUpPictureQualityIcon->Show();				if (!PromptForAndTakePicture(kUpOrientation, &theUpPictInfo, &mUpPictInfo,  mAutoCameraUpView, mAutoCameraUpCaption))				{					CleanupCameraAutoMode();					return;				}								enum ePictureVerifyStatus verifyStatus = VerifyPicture(kUpOrientation, 																			&theUpPictInfo,																			&mUpPictInfo, 																			mAutoCameraUpView, 																			mAutoCameraUpCaption,																			mAutoCameraUpPictureQualityIcon);								switch (verifyStatus)				{				case kPictureVerifyCancel:					HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &theUpPictInfo);					CleanupCameraAutoMode();					return;					break;									case kPictureVerifyRetake:					mAutoCameraUpView->ResetImage();					mAutoCameraUpPictureQualityIcon->Hide();										mAutoCameraWindow->Draw(nil);										// Delete the bad picture										if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &theUpPictInfo))					{						CleanupCameraAutoMode();						return;					}									break;									case kPictureVerifyOK:					mUpSelected = true;					break;				}			}						// We next prompt the user to get ready to take the Side picture.			// This dialog allows the user to simply click the mouse anywhere to snap the shutter			// If the mSideSelected flag is already set, we skip this step								while (!mSideSelected)			{				mCameraSidePictureQualityIcon->Show();								if (!PromptForAndTakePicture(kSideOrientation, &theSidePictInfo, &mSidePictInfo, mAutoCameraSideView, mAutoCameraSideCaption))				{					CleanupCameraAutoMode();					return;				}								enum ePictureVerifyStatus verifyStatus = VerifyPicture(kSideOrientation, 																			&theSidePictInfo,																			&mSidePictInfo, 																			mAutoCameraSideView,																			mAutoCameraSideCaption,																			mAutoCameraSidePictureQualityIcon);								switch (verifyStatus)				{				case kPictureVerifyCancel:					if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &theUpPictInfo))					{						CleanupCameraAutoMode();						return;					}									// If the side image number is greater than the up image number, we have to decrement					// the side image number because the deletion of the up image changed the numbering in the					// camera									if (theSidePictInfo.PictNumber > theUpPictInfo.PictNumber)						theSidePictInfo.PictNumber--;										HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &theSidePictInfo);					CleanupCameraAutoMode();					return;					break;									case kPictureVerifyRetake:					mAutoCameraSideView->ResetImage();					mAutoCameraSidePictureQualityIcon->Hide();					// Delete the bad picture										mAutoCameraWindow->Draw(nil);										if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &theSidePictInfo))					{						CleanupCameraAutoMode();						return;					}									break;									case kPictureVerifyOK:					mSideSelected = true;					break;				}			}						// At this point, we have both the Up and Side pictures selected. We download the			// actual images, and analyze them using the standard analysis window. The result code is			// passed in, so we can skip downloading images we already have.							if (!DownloadPictures(theResult))			{				CleanupCameraAutoMode();				return;			}						// If we are displaying the summary window, we tell the AnalyzeImages routine to not clean up			// the images. That allows us to retake specific images as needed. This means we are responsible			// for cleanup. However, if the Summary Window is not displayed, there are no retake options, and			// the Analyze Images routine will do the cleanup so that the memory is freed before the browser			// is invoked. Note that after the call to AnalyzeImages we may have to do cleanup regardless of			// the display option. So the cleanupImages option is there simply as a memory optimization when			// browser option is selected, so that the memory is freed before the browser is forked.						bool cleanupImages = true;						if (mReportPrefs.displayOption == kDisplaySummary)				cleanupImages = false;						theResult = AnalyzeImages(mAutoCameraWindow, mAutoCameraUpView, mAutoCameraSideView, SaveFullImages, true, cleanupImages);						// Hide the Analysis Window						HideMoveShow(mAnalysisWindow, mAutoCameraWindow);						// This is a kludge - we delay a bit so that if the Display Report preference is set,			// the browser window has a bit of a chance to come up. This is not ideal, since this is			// a fixed delay, and we have no idea when the actual report window appears (varies			// greatly based on processor speed, memory availability, browser chosen, etc.)						if (mReportPrefs.displayOption == kDisplayReport)			{				// We indicate in the window that we are waiting for the report to display								mAutoCameraUpProgressCaption->Show();				mAutoCameraUpProgressCaption->SetDescriptor("\pWaiting for browser...");				mAutoCameraWindow->Draw(nil);				OSSleep(CalculateDelay(5));				mAutoCameraUpProgressCaption->SetDescriptor(Str_Empty);			}			// Refresh the main window						mAutoCameraWindow->Draw(nil);						// If we told the AnalyzeImages routine to not cleanup. It is our responsibility to do			// so. Check the return status from AnalyzeImages, and do the appropriate thing						switch (theResult)			{			case kNextStepRetakeUp:							// Delete the Up picture in the camera since we are going to retake it							if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &theUpPictInfo))				{					CleanupCameraAutoMode();					return;				}												// If the side image number is greater than the up image number, we have to decrement				// the side image number because the deletion of the up image changed the numbering in the				// camera								if (theSidePictInfo.PictNumber > theUpPictInfo.PictNumber)					theSidePictInfo.PictNumber--;									// The Up image was bad								mUpSelected = false;						// The image should already be cleared, but we have this here to also clear the thumbnail.				// No harm, since the routine checks to see if the memory is already freed and doesn't do				// it again.								CleanupUpImage(mAutoCameraUpView);				break;					case kNextStepRetakeSide:							// Delete the Side picture in the camera since we are going to retake it							if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &theSidePictInfo))				{					CleanupCameraAutoMode();					return;				}												// If the side image number is greater than the up image number, we have to decrement				// the side image number because the deletion of the up image changed the numbering in the				// camera								if (theUpPictInfo.PictNumber > theSidePictInfo.PictNumber)					theUpPictInfo.PictNumber--;									// The Side image was bad								mSideSelected = false;							// The image should already be cleared, but we have this here to also clear the thumbnail.				// No harm, since the routine checks to see if the memory is already freed and doesn't do				// it again.								CleanupSideImage(mAutoCameraSideView);				break;					case kNextStepRetakeBoth:							// Delete both pictures in the camera since we are going to retake both							if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &theUpPictInfo))				{					CleanupCameraAutoMode();					return;				}												// If the side image number is greater than the up image number, we have to decrement				// the side image number because the deletion of the up image changed the numbering in the				// camera								if (theSidePictInfo.PictNumber > theUpPictInfo.PictNumber)					theSidePictInfo.PictNumber--;									if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &theSidePictInfo))				{					CleanupCameraAutoMode();					return;				}												// Both images were bad, so clean up both images								mUpSelected = false;				mSideSelected = false;											// The image should already be cleared, but we have this here to also clear the thumbnail.				// No harm, since the routine checks to see if the memory is already freed and doesn't do				// it again.								CleanupImages(mAutoCameraUpView, mAutoCameraSideView);				break;					case kNextStepContinue:							// Ask the user whether we should go on to the next subject. If they hit No (Cancel),				// we clean up (including deleting the camera images, and then return to the caller.				// If they hit yes, we delete the images, and then continue with the loop.								MessageT theMessage = HandleAnotherSubjectPrompt();				// Delete both pictures in the camera since are done with them. We do this after the				// prompt for the next patient so the user can start preparing the next patient in				// parallel with deleting the images.							if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraUpProgressCaption, &theUpPictInfo))				{					CleanupCameraAutoMode();					return;				}								// If the side image number is greater than the up image number, we have to decrement				// the side image number because the deletion of the up image changed the numbering in the				// camera								if (theSidePictInfo.PictNumber > theUpPictInfo.PictNumber)					theSidePictInfo.PictNumber--;									if (!HandleDeleteImage(mAutoCameraWindow, mAutoCameraSideProgressCaption, &theSidePictInfo))				{					CleanupCameraAutoMode();					return;				}												// Everything was fine, so clean up the images				// The images should already be cleared, but we have this here to also clear the thumbnails.				// No harm, since the routine checks to see if the memory is already freed and doesn't do				// it again.								CleanupImages(mAutoCameraUpView, mAutoCameraSideView);								// Now we can exit if that's what the user wanted to do.								if (theMessage == msg_Cancel)				{					CleanupCameraAutoMode();					return;				}												break;			}						// We stay in this loop, for the same subject, if the Summary Window says to do a start over.			// Note that the report_filename variable needs to be left alone for this to work.					} while ((theResult == kNextStepRetakeUp) || (theResult == kNextStepRetakeSide) || (theResult == kNextStepRetakeBoth));	}		CleanupCameraAutoMode();		return;}