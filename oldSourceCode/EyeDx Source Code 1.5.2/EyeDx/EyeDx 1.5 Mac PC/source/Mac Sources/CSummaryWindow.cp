// =================================================================================//	CDocumentApp.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for a document PowerPlant project////  The Application is derived from LDocApplication.  New Windows are managed//  by CTextDocument which is derived from LSingleDoc.  Each document contains//  a smart text view that remembers if it has changed since it was last saved.#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>extern "C"{#include <FSp_fopen.h>}// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <StandardFile.h>#include <NumberFormatting.h>#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <PPobClasses.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <URegistrar.h>#include <UTextTraits.h>#include <LIconPane.h>#include <UStandardDialogs.h>#include <LWindow.h>//#include <LPrintout.h>//#include <LPlaceHolder.h>#include <LGroupBox.h>#include <LTextButton.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"//#include "CTextDocument.h"//#include "CTextView.h"#include "CMyGWorldView.h"#include "USubFolderFinder.h"#include <path2fss.h>#include "CEyeDxPrefs.h"#include "CAboutDialog.h"#include "ABalloon.h"#include "FileCopy.h"#include "CSingleClickListBox.h"#include "DC120.h"#include "CSpaceClickDialog.h"#include <OSUtils.h>// This structure maps the eye images to the corresponding window elementsstatic PaneIDT eyeImages[kNumEyeImages] ={	kAnalysisResultsEye0View,	kAnalysisResultsEye1View,	kAnalysisResultsEye2View,	kAnalysisResultsEye3View,	kAnalysisResultsEye4View,	kAnalysisResultsEye5View,	kAnalysisResultsEye6View,	kAnalysisResultsEye7View};void CDocumentApp::HandleSummaryZoom(CEyeDxLongStringType *theName, 							  CEyeDxHandleType theImage, 							  int theMainImageRows,							  int theMainImageCols,							  CEyeDxHandleType theRightEyeImage,							  CEyeDxHandleType theLeftEyeImage,							  int theEyeImageRows,							  int theEyeImageCols){	// Create the dialog handler.	StDialogHandler theHandler( PPob_ZoomImageDialog, this );	// Get the dialog.	CEyeDxDialogType *theDialog;	theDialog = dynamic_cast<CEyeDxDialogType*> (theHandler.GetDialog());	Assert_( theDialog != nil );		CEyeDxCaptionType *theNameCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kZoomImageFileNameCaption));	ThrowIfNil_( theNameCaption );	CEyeDxViewType *theMainView = dynamic_cast<CEyeDxViewType*> (theDialog->FindPaneByID(kZoomImageMainView));	ThrowIfNil_( theMainView );		CEyeDxViewType *theRightEyeView = dynamic_cast<CEyeDxViewType*> (theDialog->FindPaneByID(kZoomImageRightEyeView));	ThrowIfNil_( theRightEyeView );		CEyeDxViewType *theLeftEyeView = dynamic_cast<CEyeDxViewType*> (theDialog->FindPaneByID(kZoomImageLeftEyeView));	ThrowIfNil_( theLeftEyeView );		CEyeDxButtonType *theOKButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kZoomImage_OK));	ThrowIfNil_( theOKButton );		theNameCaption->SetDescriptor(*theName);		if (theImage)	{		::HLock(theImage);		theMainView->SetImageFromRaw24Bit((unsigned char *)*theImage, theMainImageRows, theMainImageCols);		::HUnlock(theImage);	}	if (theRightEyeImage)	{		::HLock(theRightEyeImage);		theRightEyeView->SetImageFromRaw24Bit((unsigned char *)*theRightEyeImage, theEyeImageRows, theEyeImageCols);		::HUnlock(theRightEyeImage);		theRightEyeView->Show();	}	if (theLeftEyeImage)	{		::HLock(theLeftEyeImage);		theLeftEyeView->SetImageFromRaw24Bit((unsigned char *)*theLeftEyeImage, theEyeImageRows, theEyeImageCols);		::HUnlock(theLeftEyeImage);		theLeftEyeView->Show();	}		// If no eye images are provided, we want to shrink the dialog and move the OK button	if ((theRightEyeImage == nil) && (theLeftEyeImage == nil))	{		theRightEyeView->Hide();		theLeftEyeView->Hide();				SDimension16 theEyeImageSize;				theRightEyeView->GetFrameSize(theEyeImageSize);		// And now resize the frame				theDialog->ResizeWindowBy(0, -theEyeImageSize.height);			theOKButton->MoveBy(0, -theEyeImageSize.height, true);		}	// Make the dialog visible.	theDialog->Show();		MessageT theMessage;	CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_OK:			return;			break;		}	}	}EyeDxNextStepCode CDocumentApp::HandleSummaryDisplay(AnalysisResults *theAnalysisResults,													 FSSpec *theReportFSSpec, 													 CEyeDxBooleanType showRetakeOptions){	// Create the dialog handler.	StDialogHandler theHandler( PPob_AnalysisResultsDialog, this );	// Get the dialog.	CEyeDxDialogType *theDialog;	theDialog = dynamic_cast<CEyeDxDialogType*> (theHandler.GetDialog());	Assert_( theDialog != nil );		CEyeDxCaptionType *theResultsCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kAnalysisResultsNoteCaption));	ThrowIfNil_( theResultsCaption );	CEyeDxCaptionType *theNameCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kAnalysisResultsNameCaption));	ThrowIfNil_( theNameCaption );	CEyeDxCaptionType *theUpCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kAnalysisResultsUpCaption));	ThrowIfNil_( theUpCaption );	CEyeDxCaptionType *theSideCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kAnalysisResultsSideCaption));	ThrowIfNil_( theSideCaption );	CEyeDxCaptionType *theUpTopCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kAnalysisResultsUpTopResults));	ThrowIfNil_( theUpTopCaption );	CEyeDxCaptionType *theSideTopCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kAnalysisResultsSideTopResults));	ThrowIfNil_( theSideTopCaption );	CEyeDxCaptionType *theBottomCaption1 = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kAnalysisResultsBottomCaption1));	ThrowIfNil_( theBottomCaption1 );	CEyeDxCaptionType *theBottomCaption2 = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kAnalysisResultsBottomCaption2));	ThrowIfNil_( theBottomCaption2 );	CEyeDxButtonType *theRetakeSideButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kAnalysisResults_Retake_Side));	ThrowIfNil_( theRetakeSideButton );	CEyeDxButtonType *theRetakeUpButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kAnalysisResults_Retake_Up));	ThrowIfNil_( theRetakeUpButton );	CEyeDxButtonType *theStartOverButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kAnalysisResults_StartOver));	ThrowIfNil_( theStartOverButton );	CEyeDxButtonType *theDoneButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kAnalysisResults_OK));	ThrowIfNil_( theDoneButton );	CEyeDxViewType *theUpThumbnail = dynamic_cast<CEyeDxViewType*> (theDialog->FindPaneByID(kAnalysisResultsUpView));	ThrowIfNil_( theUpThumbnail );		CEyeDxViewType *theSideThumbnail = dynamic_cast<CEyeDxViewType*> (theDialog->FindPaneByID(kAnalysisResultsSideView));	ThrowIfNil_( theSideThumbnail );		CEyeDxLongStringType theReportName(theAnalysisResults->ReportName);		theNameCaption->SetDescriptor(theReportName);		switch (theAnalysisResults->ReferralCode)	{	case kYesReferralCode:		theResultsCaption->SetDescriptor("\pRefer");		break;			case kNoReferralCode:		theResultsCaption->SetDescriptor("\pPass");			break;			case kSecondImageReferralCode:		theResultsCaption->SetDescriptor("\pSecond image required.");			break;			case kUnclearReferralCode:		theResultsCaption->SetDescriptor("\pImage(s) unclear. Please repeat.");		break;			}	// If the caller doesn't want us to provide the retake options, hide a couple buttons	// And change the label on the default button		if (!showRetakeOptions)	{		theRetakeUpButton->Hide();		theRetakeSideButton->Hide();		theStartOverButton->Hide();		theDoneButton->SetDescriptor("\pExit to Main Window");	}	// Due to refresh problems if the default button is changed, in Constructor we specify no default	// button, and always set one of the buttons to be the default at runtime. Previously, the OK button	// was the default in the PPob, and in cases where it was changed from being the default, the AM	// implementation was not redrawing properly.		switch (theAnalysisResults->ResultsCode)	{	case kNoErrors:		if (showRetakeOptions)		{			theBottomCaption1->SetDescriptor("\pFinal Check: Do the eyes appear to be captured properly?");			theBottomCaption2->SetDescriptor("\pYes: Press 'Done With Subject'    No: Press 'Retake Both'.");		}		else		{			theBottomCaption1->SetDescriptor("\pFinal Check: Be sure the eyes are captured properly.");			theBottomCaption2->SetDescriptor("\pIf not, retake picture(s) and rerun.");		}				theDialog->SetDefaultButton(kAnalysisResults_OK);				// Since we don't need the images anymore - delete them now to minimize memory usage				//CleanupImages(nil, nil); - Can't if we want to support user override retakes!				break;			case kRetakeUp:		if (showRetakeOptions)		{			theBottomCaption1->SetDescriptor("\pEyeDx recommends you press the Retake Up Picture button.");			theDialog->SetDefaultButton(kAnalysisResults_Retake_Up);		}		else		{			theBottomCaption1->SetDescriptor("\pEyeDx recommends you retake the Up picture.");			theDialog->SetDefaultButton(kAnalysisResults_OK);		}				// Since we don't need the Up image anymore - delete it now to minimize memory usage. We		// keep the Side image in case they want to retake the Up image and reanalyze.				//CleanupUpImage(nil); - Can't if we want to support user override retakes!				break;			case kRetakeSide:		if (showRetakeOptions)		{			theBottomCaption1->SetDescriptor("\pEyeDx recommends you press the Retake Side Picture button.");			theDialog->SetDefaultButton(kAnalysisResults_Retake_Side);		}		else		{			theBottomCaption1->SetDescriptor("\pEyeDx recommends you retake the Side picture.");			theDialog->SetDefaultButton(kAnalysisResults_OK);		}		// Since we don't need the Side image anymore - delete it now to minimize memory usage. We		// keep the Up image in case they want to retake the Side image and reanalyze.				//CleanupSideImage(nil); - Can't if we want to support user override retakes!				break;			case kRetakeBoth:		if (showRetakeOptions)		{			theRetakeUpButton->Hide(); // No need for this, since the Start Over button does this			theRetakeSideButton->Hide(); // No need for this, since the Start Over button does this			theBottomCaption1->SetDescriptor("\pEyeDx recommends you press the Retake Both button.");			theDialog->SetDefaultButton(kAnalysisResults_StartOver);		}		else		{			theBottomCaption1->SetDescriptor("\pEyeDx recommends you retake both pictures.");			theDialog->SetDefaultButton(kAnalysisResults_OK);		}					// Since we don't need the images anymore - delete them now to minimize memory usage.		// If the user decides to retake the images, they get thrown away anyway.				// NOPE - not if we want to support displaying zoomed versions of the input images. Argh.				//CleanupImages(nil, nil); // We can do this, since we throw away both pictures either way				break;			}	CEyeDxLongStringType theUpFilename;	CEyeDxLongStringType theSideFilename;		c2pstrcpy(theUpFilename, theAnalysisResults->UpName);	theUpCaption->SetDescriptor(theUpFilename);	theUpCaption->Draw(nil);		c2pstrcpy(theSideFilename, theAnalysisResults->SideName);	theSideCaption->SetDescriptor(theSideFilename);	theSideCaption->Draw(nil);	// Open the Simages and display them in the thumbnails		int rows, cols;	Handle rawdata;	Handle	rawEyeData[kNumEyeImages];	FILE *fileptr = fopen(theAnalysisResults->Simage_path[kUpSimage], "rb");		if (!fileptr)	{		::ParamText("\pCannot open scaled image file.", Str_Empty, Str_Empty, Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else					{		if (ReadImage(fileptr, &rawdata, &rows, &cols, theAnalysisResults->Simage_path[kUpSimage], NULL, NULL, NULL, TRUE))		{			::HLock(rawdata);			theUpThumbnail->SetImageFromRaw24Bit((unsigned char *)*rawdata, rows, cols);			::HUnlock(rawdata);			::DisposeHandle(rawdata);			theUpThumbnail->Show();		}	}	fileptr = fopen(theAnalysisResults->Simage_path[kSideSimage], "rb");		if (!fileptr)	{		::ParamText("\pCannot open scaled image file.", Str_Empty, Str_Empty, Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else					{		if (ReadImage(fileptr, &rawdata, &rows, &cols, theAnalysisResults->Simage_path[kSideSimage], NULL, NULL, NULL, TRUE))		{			::HLock(rawdata);			theSideThumbnail->SetImageFromRaw24Bit((unsigned char *)*rawdata, rows, cols);			::HUnlock(rawdata);			::DisposeHandle(rawdata);			theUpThumbnail->Show();		}	}	// Now, we read in the eye images. If a particular image file doesn't exist, we skip it.	// Also, we display only the annotated images, which are the last 4 in the table		for (short i = kUpRightAnnotEye; i < kNumEyeImages; i++)	{		CEyeDxViewType *theEyeThumbnail = dynamic_cast<CEyeDxViewType*> (theDialog->FindPaneByID(eyeImages[i]));		ThrowIfNil_( theEyeThumbnail );			rawEyeData[i] = NULL;	// Make sure the handle is null in case there's no associated image					// We get the path of the eye image. If it is an empty string, we skip it. Otherwise, we open the		// file, and set the corresponding thumbnail to the image data.				if (strlen(theAnalysisResults->eye_image_path[i]) > 0)		{			fileptr = fopen(theAnalysisResults->eye_image_path[i], "rb");						if (!fileptr)			{				::ParamText("\pCannot open eye image file.", Str_Empty, Str_Empty, Str_Empty);				UModalAlerts::StopAlert(PPob_GeneralALRT);			}			else							{				if (ReadImage(fileptr, &rawEyeData[i], &rows, &cols, theAnalysisResults->eye_image_path[i], NULL, NULL, NULL, TRUE))				{					::HLock(rawEyeData[i]);					theEyeThumbnail->SetImageFromRaw24Bit((unsigned char *)*(rawEyeData[i]), rows, cols);					::HUnlock(rawEyeData[i]);					theEyeThumbnail->Show();				}			}		}	}		LStr255 theAnnotation;	LStr255 theTempAnnotation;	CEyeDxBooleanType append = false;		// Now that the images are set up, we show the necessary captions		// If this string is set, we append it to the top annotation		if (strlen(theAnalysisResults->eye_image_annot[kUpBottomResult]) > 0)	{		// Remove any newlines - replace with spaces		char *p = theAnalysisResults->eye_image_annot[kUpBottomResult];		while (*p)		{			if (*p == '\n' || *p == '\r')				*p = ' ';			p++;		}		c2pstrcpy(theTempAnnotation, theAnalysisResults->eye_image_annot[kUpBottomResult]);		append = true;	}		if (strlen(theAnalysisResults->eye_image_annot[kUpTopResult]) > 0)	{		// Remove any newlines - replace with spaces		char *p = theAnalysisResults->eye_image_annot[kUpTopResult];		while (*p)		{			if (*p == '\n' || *p == '\r')				*p = ' ';			p++;		}				c2pstrcpy(theAnnotation, theAnalysisResults->eye_image_annot[kUpTopResult]);		if (append)		{			theAnnotation.Append("\p ");			theAnnotation.Append(theTempAnnotation);			append = false;		}		theUpTopCaption->SetDescriptor(theAnnotation);		theUpTopCaption->Show();	}		if (strlen(theAnalysisResults->eye_image_annot[kSideBottomResult]) > 0)	{		// Remove any newlines - replace with spaces		char *p = theAnalysisResults->eye_image_annot[kSideBottomResult];		while (*p)		{			if (*p == '\n' || *p == '\r')				*p = ' ';			p++;		}		c2pstrcpy(theTempAnnotation, theAnalysisResults->eye_image_annot[kSideBottomResult]);		append = true;	}		if (strlen(theAnalysisResults->eye_image_annot[kSideTopResult]) > 0)	{		// Remove any newlines - replace with spaces		char *p = theAnalysisResults->eye_image_annot[kSideTopResult];		while (*p)		{			if (*p == '\n' || *p == '\r')				*p = ' ';			p++;		}		c2pstrcpy(theAnnotation, theAnalysisResults->eye_image_annot[kSideTopResult]);		if (append)		{			theAnnotation.Append("\p ");			theAnnotation.Append(theTempAnnotation);			append = false;		}		theSideTopCaption->SetDescriptor(theAnnotation);		theSideTopCaption->Show();	}	// Make the dialog visible.	theDialog->Show();		MessageT theMessage;	EyeDxNextStepCode nextStep;		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		theMessage = theHandler.DoDialog();		switch (theMessage)		{		case cmd_AnalysisResults_Report:			OSErr openErr = OpenReport(theReportFSSpec);			break;					case cmd_AnalysisResults_Zoom_Up:			HandleSummaryZoom(&theUpFilename, mUpHandle, UP_ROWS, UP_COLS, rawEyeData[kUpRightAnnotEye], rawEyeData[kUpLeftAnnotEye], rows, cols);			break;					case cmd_AnalysisResults_Zoom_Side:			HandleSummaryZoom(&theSideFilename, mSideHandle, SIDE_ROWS, SIDE_COLS, rawEyeData[kSideRightAnnotEye], rawEyeData[kSideLeftAnnotEye], rows, cols);			break;					case cmd_AnalysisResults_Retake_Up:			nextStep = kNextStepRetakeUp;			done = true;			break;					case cmd_AnalysisResults_Retake_Side:			nextStep = kNextStepRetakeSide;			done = true;			break;					case cmd_AnalysisResults_StartOver:			nextStep = kNextStepRetakeBoth;			done = true;			break;					case msg_OK: 			nextStep = kNextStepContinue;			done = true;			break;		}	}		// Free the eye image data		for (short i = kUpRightAnnotEye; i < kNumEyeImages; i++)		::DisposeHandle(rawEyeData[i]);			return nextStep;}