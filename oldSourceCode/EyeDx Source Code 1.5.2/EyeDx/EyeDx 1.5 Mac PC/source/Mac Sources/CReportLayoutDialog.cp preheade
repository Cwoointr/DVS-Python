// =================================================================================//	CReportLayoutDialog.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for the Report Layout window// members of CDocumentApp//#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include "CEditVariableDialog.h"#include "CExportOrderDialog.h"#include <LTextTableView.h>#include <LCellSizeToFit.h>#include <LTableSingleRowSelector.h>#include <LTableMultiGeometry.h>#include <LTableArrayStorage.h>static void SetDefineTextCaption(LTextEditView *theTextEdit, CEyeDxCaptionType *theCaption, long selectedTextType){	switch (selectedTextType)	{	case kReportLayoutHeaderText:		theCaption->SetDescriptor("\pDisplayed as bold, centered, large font");		theTextEdit->SetTextTraitsID(kBoldTimesCenteredTextTraits);		break;	case kReportLayoutIntroductionText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kReportLayoutPassResultText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kReportLayoutReferResultText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kReportLayoutRetakeResultText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kReportLayoutFooterText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kReportLayoutSessionSummaryText:		theCaption->SetDescriptor("\pSaved in summary file as monospaced font");		theTextEdit->SetTextTraitsID(kNormalMonospacedTextTraits);		break;	}}const long kNumFrozenRows = 1;const long kVariableMenuHeadingOffset = 1;void CDocumentApp::UpdateVariableList(LTextTableView *theTable, CEyeDxVariableList *theVariableList, CEyeDxPopupMenuType *theVariableMenu){	StopListening();	// Set the list to allow only one item to be selected	// This will defer updating the table until we exit the routine, saving a lot of redraws		theTable->SetDeferAdjustment(true);		theTable->RemoveAllRows(true);		// Delete all of the existing rows		TableIndexT theNumberOfVariables = theVariableList->GetCount();		const UInt32 kNumVariableColumns = 5;		theTable->InsertRows((theNumberOfVariables + kNumFrozenRows), 0);	theTable->InsertCols(kNumVariableColumns, 0);	// We do not use the Frozen Rows feature, as they do not scroll horizontally! That seems to be insane,	// but that's the way it works...		//theTable->SetNumFrozenRows(1);			theTable->SetColWidth(kVariableListNameWidth, 1, 1);	theTable->SetColWidth(kVariableListClassWidth, 2, 2);	theTable->SetColWidth(kVariableListTypeWidth, 3, 3);	theTable->SetColWidth(kVariableListDataTypeWidth, 4, 4);	theTable->SetColWidth(kVariableListRequiredWidth, 5, 5);	STableCell	cell;	CEyeDxLongStringType *theStr;	CEyeDxShortStringType theTypeStr;			CEyeDxShortStringType theDataTypeStr;			// Insert the header row which is frozen		cell.row = 1;	theTypeStr = "\pName";		cell.col = 1;		theTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());	theTypeStr = "\pClass";		cell.col = 2;		theTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());	theTypeStr = "\pType";		cell.col = 3;		theTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());	theTypeStr = "\pData Type";			cell.col = 4;		theTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());	theTypeStr = "\p";			// The cell will indicate this			cell.col = 5;		theTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());	for (cell.row = (1 + kNumFrozenRows); cell.row <= (theNumberOfVariables + kNumFrozenRows); cell.row++) 	{		// Get the variable - note that the array index is 1 based!				CEyeDxVariable *theVariable = theVariableList->GetVariableByIndex(cell.row - kNumFrozenRows);				cell.col = 1;				theStr = theVariable->GetName();				theTable->SetCellData(cell, theStr->TextPtr(), theStr->Length());		cell.col = 2;				// If the variable is hidden, display that instead of the class				if (theVariable->GetVariableIsHidden())			theTypeStr = "\pHidden";		else		{			switch (theVariable->GetVariableClass())			{			case CEyeDxVariable::kUser:				theTypeStr = "\pUser";				break;							case CEyeDxVariable::kEyeDx:				theTypeStr = "\pEyeDx";				break;			}			}		theTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());		cell.col = 3;				switch (theVariable->GetVariableType())		{		case CEyeDxVariable::kFixed:			theTypeStr = "\pFixed";			break;					case CEyeDxVariable::kPrompted:			switch (theVariable->GetWhenToPrompt())			{			case CEyeDxVariable::kPromptNone:				theTypeStr = "\pNo Prompt";				break;							case CEyeDxVariable::kPromptOnStart:				theTypeStr = "\pPrompt: On Startup";				break;			case CEyeDxVariable::kPromptForSubject:				theTypeStr = "\pPrompt: Each Subject";				break;						case CEyeDxVariable::kPromptForSession:				theTypeStr = "\pPrompt: Each Session";				break;						case CEyeDxVariable::kPromptForEndOfSession:				theTypeStr = "\pPrompt: End of Session";				break;			case CEyeDxVariable::kPromptDisabled:				theTypeStr = "\pPrompt: Disabled";				break;			}								break;					case CEyeDxVariable::kCalculated:			theTypeStr = "\pCalculated";			break;		}		theTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());				cell.col = 4;						switch (theVariable->GetDataType())		{		case CEyeDxVariable::kTypeNone:		case CEyeDxVariable::kGeneralString:			theTypeStr = "\pString";			break;					case CEyeDxVariable::kDate:			theTypeStr = "\pDate";			break;		case CEyeDxVariable::kPastDate:			theTypeStr = "\pPast Date";			break;				case CEyeDxVariable::kTime:			theTypeStr = "\pTime";			break;				case CEyeDxVariable::kIntegerNumber:			theTypeStr = "\pNumber";			break;		case CEyeDxVariable::kCheckBox:			theTypeStr = "\pCheck Box";			break;		case CEyeDxVariable::kMenu:			theTypeStr = "\pMenu";			break;		}							theTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());				// If the variable is prompted, then indicate whether it is required or not		// If a fixed value, show the value in quotes. Otherwise, just display a blank.		cell.col = 5;						theTypeStr = "\p";				switch (theVariable->GetVariableType())		{		case CEyeDxVariable::kPrompted:			// We only show optional/required if the prompted variable isn't disabled (it would			// be confusing to say it's required if it's disabled!).						if (theVariable->GetWhenToPrompt() != CEyeDxVariable::kPromptDisabled)			{				if (theVariable->GetValueMustBeEntered())					theTypeStr = "\p(Required Entry)";				else					theTypeStr = "\p(Optional Entry)";			}			break;		case CEyeDxVariable::kFixed:			theTypeStr = "\p\"";			theStr = theVariable->GetValue();			theTypeStr += *theStr;			theTypeStr += "\p\"";			break;		}				theTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());	}	cell.row = 1 + kNumFrozenRows;	cell.col = 1;	theTable->SetDeferAdjustment(false);		theTable->Draw(nil);		// Now, we update the Insert Variable menu to reflect the current list	MenuHandle theVariablePopupMenu = theVariableMenu->GetMacMenuH();	ThrowIfNil_( theVariablePopupMenu );	// Delete the current items in the list, except for the first, which is just used as a	// heading.	long nMenuItems = ::CountMItems(theVariablePopupMenu);	for (UInt16 theItemToRemove = 2; theItemToRemove <= nMenuItems; theItemToRemove++)	{		::DeleteMenuItem(theVariablePopupMenu, 2);	// Always delete the second item, which will shrink the													// menu down to just one item when we are done.	}	nMenuItems = ::CountMItems(theVariablePopupMenu);	// Now add the sorted items	for (long theItemToAdd = 1; theItemToAdd <= theNumberOfVariables; theItemToAdd++)	{		CEyeDxVariable *theVariable = theVariableList->GetVariableByIndex(theItemToAdd);				theStr = theVariable->GetName();				::AppendMenu(theVariablePopupMenu, *theStr);	}	// According to the PowerPlant Book, if I change the number of items in the menu	// I have to set the Max Value properly.		theVariableMenu->SetMaxValue(theNumberOfVariables + kVariableMenuHeadingOffset);		// We also set the value to the first item, which is really just a heading. We get notification	// from the menu only if the user changes the selection. Thus, we use the fake first item as a 	// placeholder - each time the user makes a selection, we process the selection and then set the	// menu value back to the first item. That ensures that we will always get notification, even if	// the user selects the same variable for insertion twice in a row.		theVariableMenu->SetValue(kVariableMenuHeadingOffset);	StartListening();}// This routine will hide all of the controls for the current tab in preparation for // enabling the controls for the newly-clicked tabvoid CDocumentApp::ReportLayoutHideControls(){		switch (mReportLayoutCurrentTab)	{		// Nothing shown, nothing to do		case kNoTab:		break;			// The Variables Pane		case kVariablesTab:		mReportLayoutVariableScroller->Hide();				mReportLayoutNewVariableButton->Hide();			mReportLayoutEditVariableButton->Hide();			mReportLayoutDeleteVariableButton->Hide();			mReportLayoutPromptStyleCheckBox->Hide();		break;			// The Define Text Pane		case kReportTextTab:		mReportLayoutDefineTextMenu->Hide();		mReportLayoutDefineTextCaption->Hide();		mReportLayoutTextEditScroller->Hide();			mReportLayoutTextEdit->Disable();			mReportLayoutRevertButton->Hide();			mReportLayoutDefaultButton->Hide();			mReportLayoutVariableMenu->Hide();			break;		// The Database Export Pane	case kDatabaseExportTab:			mReportLayoutDefineOrderButton->Hide();		break;	}}void CDocumentApp::ReportLayoutUpdateControls(ResID tabClicked){	if (tabClicked != mReportLayoutCurrentTab)	{		ReportLayoutHideControls();				switch (tabClicked)		{		case kVariablesTab:			mReportLayoutVariableScroller->Show();					mReportLayoutNewVariableButton->Show();				mReportLayoutEditVariableButton->Show();				mReportLayoutDeleteVariableButton->Show();				mReportLayoutPromptStyleCheckBox->Show();			break;					case kReportTextTab:			mReportLayoutDefineTextMenu->Show();			mReportLayoutDefineTextCaption->Show();			mReportLayoutTextEditScroller->Show();				mReportLayoutTextEdit->Enable();				mReportLayoutRevertButton->Show();				mReportLayoutDefaultButton->Show();				mReportLayoutVariableMenu->Show();				break;					case kDatabaseExportTab:			mReportLayoutDefineOrderButton->Show();			break;		}				mReportLayoutCurrentTab = tabClicked;	}}Boolean CDocumentApp::HandleReportLayout(){	Boolean theResult = false;		Handle theTemporaryTextHandles[kReportLayoutNumText];	// Create the dialog handler.	StDialogHandler theHandler( PPob_ReportLayoutDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );#if FALSE		CEyeDxCheckBoxType *mReportLayoutAllowSpaceCheckbox = dynamic_cast<CEyeDxCheckBoxType*> (theDialog->FindPaneByID(kReportLayout_AllowSpace));	ThrowIfNil_( mReportLayoutAllowSpaceCheckbox );		CEyeDxPopupMenuType *mReportLayoutSpaceSizeMenu;		// Display the proper size menu based on the measurement system	if (::IsMetric())		mReportLayoutSpaceSizeMenu = dynamic_cast<CEyeDxPopupMenuType*> (theDialog->FindPaneByID(kReportLayout_SpaceSizeMetric));	else		mReportLayoutSpaceSizeMenu = dynamic_cast<CEyeDxPopupMenuType*> (theDialog->FindPaneByID(kReportLayout_SpaceSizeEnglish));	ThrowIfNil_( mReportLayoutSpaceSizeMenu );	mReportLayoutSpaceSizeMenu->Show();#endif		// Common controls		mReportLayoutTabs = dynamic_cast<CEyeDxTabsControlType*> (theDialog->FindPaneByID(kReportLayout_Tabs));	ThrowIfNil_( mReportLayoutTabs );	mReportLayoutCancelButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kReportLayout_Cancel));	ThrowIfNil_( mReportLayoutCancelButton );		mReportLayoutVariableMultiPanelView = dynamic_cast<LMultiPanelView*> (theDialog->FindPaneByID(kReportLayout_PanelView));	ThrowIfNil_(mReportLayoutVariableMultiPanelView);				mReportLayoutVariableMultiPanelView->CreateAllPanels();		// Variable controls		mReportLayoutVariablePanel = mReportLayoutVariableMultiPanelView->GetPanel(kReportLayout_VariablesPanel);	ThrowIfNil_(mReportLayoutVariablePanel);		mReportLayoutVariableScroller = dynamic_cast<LScrollerView*> (mReportLayoutVariablePanel->FindPaneByID(kReportLayout_VariableScroller));	ThrowIfNil_( mReportLayoutVariableScroller );		mReportLayoutVariableTable = dynamic_cast<LTextTableView*> (mReportLayoutVariablePanel->FindPaneByID(kReportLayout_VariableTable));	ThrowIfNil_( mReportLayoutVariableTable );			mReportLayoutNewVariableButton = dynamic_cast<CEyeDxButtonType*> (mReportLayoutVariablePanel->FindPaneByID(kReportLayout_VariableNew));	ThrowIfNil_( mReportLayoutNewVariableButton );		mReportLayoutEditVariableButton = dynamic_cast<CEyeDxButtonType*> (mReportLayoutVariablePanel->FindPaneByID(kReportLayout_VariableEdit));	ThrowIfNil_( mReportLayoutEditVariableButton );		mReportLayoutDeleteVariableButton = dynamic_cast<CEyeDxButtonType*> (mReportLayoutVariablePanel->FindPaneByID(kReportLayout_VariableDelete));	ThrowIfNil_( mReportLayoutDeleteVariableButton );		mReportLayoutPromptStyleCheckBox = dynamic_cast<CEyeDxCheckBoxType*> (mReportLayoutVariablePanel->FindPaneByID(kReportLayout_PromptStyle));	ThrowIfNil_( mReportLayoutPromptStyleCheckBox );		// Define Text Controls		mReportLayoutDefineTextPanel = mReportLayoutVariableMultiPanelView->GetPanel(kReportLayout_DefineTextPanel);	ThrowIfNil_(mReportLayoutDefineTextPanel);		mReportLayoutDefineTextMenu = dynamic_cast<CEyeDxPopupMenuType*> (mReportLayoutDefineTextPanel->FindPaneByID(kReportLayout_DefineText));	ThrowIfNil_( mReportLayoutDefineTextMenu );	mReportLayoutDefineTextCaption = dynamic_cast<CEyeDxCaptionType*> (mReportLayoutDefineTextPanel->FindPaneByID(kReportLayout_DefineTextCaption));	ThrowIfNil_( mReportLayoutDefineTextCaption );	mReportLayoutTextEditScroller = dynamic_cast<LScrollerView*> (mReportLayoutDefineTextPanel->FindPaneByID(kReportLayout_TextEditScroller));	ThrowIfNil_( mReportLayoutTextEditScroller );		mReportLayoutTextEdit = dynamic_cast<LTextEditView*> (mReportLayoutDefineTextPanel->FindPaneByID(kReportLayout_TextEdit));	ThrowIfNil_( mReportLayoutTextEdit );		mReportLayoutRevertButton = dynamic_cast<CEyeDxButtonType*> (mReportLayoutDefineTextPanel->FindPaneByID(kReportLayout_Revert));	ThrowIfNil_( mReportLayoutRevertButton );		mReportLayoutDefaultButton = dynamic_cast<CEyeDxButtonType*> (mReportLayoutDefineTextPanel->FindPaneByID(kReportLayout_Default));	ThrowIfNil_( mReportLayoutDefaultButton );		mReportLayoutVariableMenu = dynamic_cast<CEyeDxPopupMenuType*> (mReportLayoutDefineTextPanel->FindPaneByID(kReportLayout_InsertVariable));	ThrowIfNil_( mReportLayoutVariableMenu );		// TODO CEyeDxButtonType *mReportLayoutDisplaySampleButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kReportLayout_DisplaySample));	// TODO ThrowIfNil_( mReportLayoutDisplaySampleButton );		// Database Export Controls		mReportLayoutDatabasePanel = mReportLayoutVariableMultiPanelView->GetPanel(kReportLayout_DatabasePanel);	ThrowIfNil_(mReportLayoutDatabasePanel);		mReportLayoutDefineOrderButton = dynamic_cast<CEyeDxButtonType*> (mReportLayoutDatabasePanel->FindPaneByID(kReportLayout_DefineFields));	ThrowIfNil_( mReportLayoutDefaultButton );		// Have the multipanel view listen to the tab control		mReportLayoutTabs->AddListener(mReportLayoutVariableMultiPanelView);		// And also add the Handler as a listener to the controls in the panels		UReanimator::LinkListenerToBroadcasters(&theHandler, mReportLayoutVariablePanel, PPob_VariablePanel);	UReanimator::LinkListenerToBroadcasters(&theHandler, mReportLayoutDefineTextPanel, PPob_DefineTextPanel);	UReanimator::LinkListenerToBroadcasters(&theHandler, mReportLayoutDatabasePanel, PPob_DatabasePanel);	// Now set up the controls		mReportLayoutVariableTable->SetCellSizer(new LCellSizeToFit(false));	// Add the dialog to the list of listeners of the list box	LTableSingleRowSelector *mTableSelector = new LTableSingleRowSelector(mReportLayoutVariableTable);		mReportLayoutVariableTable->SetTableSelector(mTableSelector);		LTableMultiGeometry *mTableGeometry = new LTableMultiGeometry( mReportLayoutVariableTable, 10, 14 );	mReportLayoutVariableTable->SetTableGeometry(mTableGeometry);	LTableArrayStorage *mTableStorage = new LTableArrayStorage( mReportLayoutVariableTable, (UInt32)0 );	mReportLayoutVariableTable->SetTableStorage(mTableStorage);	mReportLayoutVariableTable->AddListener(&theHandler);		// We make our own variable list based on whether the Advanced Features mode is on. If it is,	// we show all variables (hidden and not).		CEyeDxVariableList *localVariableList = new CEyeDxVariableList(CEyeDxVariableList::kSortByName);			// Copy over variables that are not hidden. Note that we save the value of the AdvancedFeatures flag	// once, here, before we create the list. That ensures that the local variable list is always correct.	// Otherwise, the user could toogle the flag in the middle of the dialog, and what's displayed in the	// table and menus would be out of whack.		CEyeDxBooleanType mShowHidden = AdvancedFeatures;		long theCount = mVariableList.GetCount();		for (long varNum = 1; varNum <= theCount; varNum++)	{		CEyeDxVariable *theListVariable = mVariableList.GetVariableByIndex(varNum);				// If the advanced feature mode is on, we show everything				if (mShowHidden)			localVariableList->AddVariable(theListVariable);		else		if (!theListVariable->GetVariableIsHidden())			localVariableList->AddVariable(theListVariable);		}	UpdateVariableList(mReportLayoutVariableTable, localVariableList, mReportLayoutVariableMenu);		mReportLayoutEditVariableButton->SetDescriptor("\pViewÉ");	mReportLayoutEditVariableButton->Disable();	mReportLayoutDeleteVariableButton->Disable();	// Temporarily stop listening so we don't get messages when we set the values		StopListening();#if FALSE		// If the user has requested that we allow space for letterhead, enable the space size menu		if (mReportPrefs.allowLetterHead == kNoLetterHead)		mReportLayoutSpaceSizeMenu->Disable();	else		mReportLayoutSpaceSizeMenu->Enable();			// TODO - need to figure out the best way to save and enter header size in a portable manner		//if (mReportPrefs.letterheadSize != 0)#endif		if (mPromptingPrefs.promptingStyle == kPromptOneAtATime)		mReportLayoutPromptStyleCheckBox->SetValue(1);	else		mReportLayoutPromptStyleCheckBox->SetValue(0);			// The menu items are 1..n, whereas the indexes are 0..n-1		ResID theCurrentDefineTextMenuItem = kReportLayoutHeaderText;		// Set the menu item, making sure that we add one to offset to the proper menu item.		mReportLayoutDefineTextMenu->SetValue(theCurrentDefineTextMenuItem + 1);		// Make copies of all of the handles for the current text, so we can revert if necessary			for (long i = 0; i < kReportLayoutNumText; i++)	{			theTemporaryTextHandles[i] = mReportCustomText[i];		if (mReportCustomText[i])			::HandToHand(&theTemporaryTextHandles[i]);	}		// Put the text in the window if some exists - note that the TextEdit code copies this	// so our copy is not modified.		if (theTemporaryTextHandles[theCurrentDefineTextMenuItem])	{		mReportLayoutTextEdit->SetTextHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);		SetDefineTextCaption(mReportLayoutTextEdit, mReportLayoutDefineTextCaption, theCurrentDefineTextMenuItem);	}		// Make the first tab the current pane		//mReportLayoutCurrentTab = kNoTab;	//ReportLayoutUpdateControls(kVariablesTab);				StartListening();	// Activate the list box so it immediately accepts keystrokes	theDialog->SetLatentSub(mReportLayoutTextEdit);		// Make the dialog visible.	theDialog->Show();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		if ( theMessage == msg_Cancel ) 		{			// Free the temporary memory						for (ResID i = 0; i < kReportLayoutNumText; i++)				::DisposeHandle(theTemporaryTextHandles[i]);							delete mTableSelector;			delete mTableGeometry;			delete mTableStorage;						delete localVariableList;			break;		}		else if (theMessage == msg_ReportLayoutTabClicked)		{			//ReportLayoutUpdateControls(mReportLayoutTabs->GetValue());		}#if FALSE		else if (theMessage == msg_ReportLayoutAllowSpace)		{			if (mReportLayoutAllowSpaceCheckbox->GetValue())				mReportLayoutSpaceSizeMenu->Enable();			else				mReportLayoutSpaceSizeMenu->Disable();		}		#endif		else if (theMessage == msg_ReportLayoutVarListSglClick)		{			// Look up the variable that they clicked on						long theItem = mTableSelector->GetFirstSelectedRow();						if (theItem > kNumFrozenRows)			{										CEyeDxVariable *theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);							if (theVariable->GetVariableClass() == CEyeDxVariable::kUser)				{					mReportLayoutEditVariableButton->Enable();					mReportLayoutEditVariableButton->SetDescriptor("\pEditÉ");					mReportLayoutDeleteVariableButton->Enable();				}				else				{					mReportLayoutEditVariableButton->Enable();					mReportLayoutEditVariableButton->SetDescriptor("\pViewÉ");					mReportLayoutDeleteVariableButton->Disable();				}					}		}				else if ((theMessage == msg_ReportLayoutVarListDblClick) ||				 (theMessage == msg_ReportLayoutEditVariable))		{			// Look up the variable that they double-clicked on, or the currently-selected			// item if the Edit button was pressed, and fetch it for editing						long theItem = mTableSelector->GetFirstSelectedRow();						if (theItem > kNumFrozenRows)			{										CEyeDxVariable *theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);							if (theVariable->GetVariableClass() == CEyeDxVariable::kUser)				{					mReportLayoutEditVariableButton->Enable();					mReportLayoutEditVariableButton->SetDescriptor("\pEditÉ");					mReportLayoutDeleteVariableButton->Enable();				}				else				{					mReportLayoutEditVariableButton->Enable();					mReportLayoutEditVariableButton->SetDescriptor("\pViewÉ");					mReportLayoutDeleteVariableButton->Disable();				}						HandleEditVariable(theVariable, false, mShowHidden);				UpdateVariableList(mReportLayoutVariableTable, localVariableList, mReportLayoutVariableMenu);				}		}				else if (theMessage == msg_ReportLayoutNewVariable)		{			// Create a new variable for editing						CEyeDxVariable *theVariable = new CEyeDxVariable(CEyeDxVariable::kUser);						if (HandleEditVariable(theVariable, true, mShowHidden) == true)			{				// Add the new variable to both the local list (the one shown in the menus and scrolling list)				// and the full global list								mVariableList.AddVariable(theVariable);				localVariableList->AddVariable(theVariable);								UpdateVariableList(mReportLayoutVariableTable, localVariableList, mReportLayoutVariableMenu);					mReportLayoutEditVariableButton->Enable();				mReportLayoutEditVariableButton->SetDescriptor("\pEditÉ");				mReportLayoutDeleteVariableButton->Enable();			}			else				delete theVariable;		}				else if (theMessage == msg_ReportLayoutDeleteVariable)		{			// Look up the variable that is currently selected and confirm that they want to delete it						long theItem = mTableSelector->GetFirstSelectedRow();						if (theItem > kNumFrozenRows)			{										CEyeDxVariable *theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);								CEyeDxLongStringType *theName = theVariable->GetName();								::ParamText("\pAre you sure you want to delete the variable ", *theName, "\p (no undo!)?", Str_Empty);				DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_YesNoALRT);				if (item_hit == PPob_YesNoALRT_Yes)				{					// Delete it from both the local list copy and the global copy					mVariableList.DeleteVariableByName(*theName);					localVariableList->DeleteVariableByName(*theName);					UpdateVariableList(mReportLayoutVariableTable, localVariableList, mReportLayoutVariableMenu);					}			}					}				else if (theMessage == msg_ReportLayoutDefineText)		{			// We throw away the previous text for the item that is currently displayed						if (theTemporaryTextHandles[theCurrentDefineTextMenuItem])				::DisposeHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);							// Now get a copy of the TextEdit handle, and make a copy of it.						theTemporaryTextHandles[theCurrentDefineTextMenuItem] = mReportLayoutTextEdit->GetTextHandle();						// Make a copy of it in our variable						::HandToHand(&theTemporaryTextHandles[theCurrentDefineTextMenuItem]);			if (::GetHandleSize(theTemporaryTextHandles[theCurrentDefineTextMenuItem]) > kWarnAboutLongOptionalFmt1Text)			{				::ParamText("\pThe number of characters you have entered may cause the report to print on more than one page.", 						"\pRun an analysis and test printing.", Str_Empty, Str_Empty);				UModalAlerts::CautionAlert(PPob_GeneralALRT);			}						// Now, get the newly-selected item, and load it - remember to subtract 1 from the menu item # to get the index						theCurrentDefineTextMenuItem = mReportLayoutDefineTextMenu->GetValue() - 1;						if (theTemporaryTextHandles[theCurrentDefineTextMenuItem])			{				mReportLayoutTextEdit->SetTextHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);				SetDefineTextCaption(mReportLayoutTextEdit, mReportLayoutDefineTextCaption, theCurrentDefineTextMenuItem);			}		}		else if (theMessage == msg_ReportLayoutRevert)		{			// Just set the text back to what they had previously entered						mReportLayoutTextEdit->SetTextHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);		}				else if (theMessage == msg_ReportLayoutDefault)		{			// Set the text to the default provided by EyeDx- don't copy it to the temporary handle,			// so the user can still revert to the previous version.						mReportLayoutTextEdit->SetTextHandle(mReportDefaultText[theCurrentDefineTextMenuItem]);		}				else if (theMessage == msg_ReportLayoutInsertVariable)		{			// We have to get the name of the variable from the menu. Then format it and insert it into			// the text						long theItem = mReportLayoutVariableMenu->GetValue();						if (theItem > kVariableMenuHeadingOffset)			{				// We look up the variable, remembing that the first one is index 2.								CEyeDxVariable *theVariable = localVariableList->GetVariableByIndex(theItem - kVariableMenuHeadingOffset);								CEyeDxLongStringType *theName = theVariable->GetName();				CEyeDxLongStringType theVariableStr = "\p{";				theVariableStr.Append(*theName);				theVariableStr.Append("\p}");								if ((mReportLayoutTextEdit->CalcTEHeight() + theVariableStr.Length()) < max_Int16)				{					// If the user has selected some text, inserting a variable should replace that					// text. We use the clear command to erase the current selection before inserting					// the variable reference.										mReportLayoutTextEdit->ObeyCommand(cmd_Clear, nil);					mReportLayoutTextEdit->Insert(&theVariableStr[1], theVariableStr[0], nil, true);				}				else				{					::ParamText("\pSorry, the existing text is too long to insert that variable!", "\pPlease shorten the text and try again.", Str_Empty, Str_Empty);					UModalAlerts::StopAlert(PPob_GeneralALRT);				}								// We also set the value to the first item, which is really just a heading. We get notification				// from the menu only if the user changes the selection. Thus, we use the fake first item as a 				// placeholder - each time the user makes a selection, we process the selection and then set the				// menu value back to the first item. That ensures that we will always get notification, even if				// the user selects the same variable for insertion twice in a row.						mReportLayoutVariableMenu->SetValue(kVariableMenuHeadingOffset);			}			}				else if (theMessage == msg_ReportLayoutDefineFields)		{				HandleExportVariable();		}				else if ( theMessage == msg_OK ) 		{			theResult = true;#if FALSE			if (mReportLayoutAllowSpaceCheckbox->GetValue())				mReportPrefs.allowLetterHead = kAllowLetterHead;			else				mReportPrefs.allowLetterHead = kNoLetterHead;#endif											// We throw away the previous text for the item that is currently displayed						if (theTemporaryTextHandles[theCurrentDefineTextMenuItem])				::DisposeHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);							// Now get a copy of the TextEdit handle, and make a copy of it.						theTemporaryTextHandles[theCurrentDefineTextMenuItem] = mReportLayoutTextEdit->GetTextHandle();						// Make a copy of it in our variable						::HandToHand(&theTemporaryTextHandles[theCurrentDefineTextMenuItem]);			if (::GetHandleSize(theTemporaryTextHandles[theCurrentDefineTextMenuItem]) > kWarnAboutLongOptionalFmt1Text)			{				::ParamText("\pThe number of characters you have entered may cause the report to print on more than one page.", 						"\pRun an analysis and test printing.", Str_Empty, Str_Empty);				UModalAlerts::CautionAlert(PPob_GeneralALRT);			}						// Now, save all of the text blocks.						// For each of the text block types, discard the previous text, and save the new text						ResID theResourceID = kSampleReportHeaderTextID;						for (ResID i = 0; i < kReportLayoutNumText; i++, theResourceID++)			{				// Discard the previous custom text handle if one exists								if (mReportCustomText[i])					::DisposeHandle(mReportCustomText[i]);							mReportCustomText[i] = theTemporaryTextHandles[i];							// No need to copy it, since it already is a copy! Just save it in the preferences 								mPreferences->SaveReportTextPrefs(mReportCustomText[i], theResourceID);			}						if (mReportLayoutPromptStyleCheckBox->GetValue() == 1)				mPromptingPrefs.promptingStyle = kPromptOneAtATime;			else				mPromptingPrefs.promptingStyle = kPromptAllInOne;				// Free the temporary memory						delete mTableSelector;			delete mTableGeometry;			delete mTableStorage;						delete localVariableList;			mPreferences->SavePromptingPrefs(&mPromptingPrefs);							mPreferences->SaveReportPrefs(&mReportPrefs);										mPreferences->SaveVariablePrefs(&mVariableList);						break;		}	}	return theResult;}Boolean CDocumentApp::HandleEditVariable(CEyeDxVariable *theVariable, CEyeDxBooleanType newVariable, CEyeDxBooleanType showHidden){	// Create the dialog handler.	StDialogHandler theHandler( PPob_EditVariableDialog, this );	// Get the dialog.	CEditVariableDialog *theDialog;	theDialog = dynamic_cast<CEditVariableDialog *>(theHandler.GetDialog());	ThrowIfNil_(theDialog);		theDialog->SetupDialog(&mVariableList, theVariable, newVariable, showHidden);		// Make the dialog visible.	theDialog->Show();		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_Cancel:			return false;			break;		case msg_OK:			if (theDialog->UserInputValid())			{				return true;			}			// Otherwise, we keep the dialog up and DON'T return			break;		}	}	return false;}Boolean CDocumentApp::HandleExportVariable(){	// Create the dialog handler.	StDialogHandler theHandler( PPob_ExportOrderDialog, this );	// Get the dialog.	CExportOrderDialog *theDialog;	theDialog = dynamic_cast<CExportOrderDialog *>(theHandler.GetDialog());	ThrowIfNil_(theDialog);		theDialog->SetupDialog(&mVariableList);		// Make the dialog visible.	theDialog->Show();		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_Cancel:			return false;			break;		case msg_OK:			return true;			break;		}	}	return false;}