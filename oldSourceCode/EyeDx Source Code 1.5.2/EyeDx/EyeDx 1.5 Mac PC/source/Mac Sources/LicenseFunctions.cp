// =================================================================================//	LicenseFunctions.cp					©1999 EyeDx, Inc. All rights reserved.// =================================================================================#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <PPobClasses.h>#include <UStandardDialogs.h>#include <LWindow.h>#include <LGroupBox.h>#include <LTextButton.h>#include "EyeDxMacConstants.h"#include "ABalloon.h"#include "FileCopy.h"const Str255	kLicenseFileName = "\pEyeDxMisc";void CDocumentApp::GetLicenseExpDateString(CEyeDxLongStringType &theString){	// We use the international utilities to format the date as expected for the locale		DateTimeRec theDateRec;		EyeDxLicenseInfo::DecodeDateCode(mLicenseExpDateCode, theDateRec.year, theDateRec.month, theDateRec.day);	theDateRec.hour = 23;	theDateRec.minute = 59;	theDateRec.second = 59;	theDateRec.dayOfWeek = 1;	// Dummy value		unsigned long theSeconds;		DateToSeconds(&theDateRec, &theSeconds);		::DateString(theSeconds, shortDate, theString, nil);}void CDocumentApp::GetLicenseCountString(CEyeDxLongStringType &theString){	theString = (long) mLicenseCount;}void CDocumentApp::SetLicenseStatusCaption(CEyeDxCaptionType *theCaption){	// Display the license status		CEyeDxLongStringType theStatusLine;	CEyeDxLongStringType theString;		GetLicenseCountString(theStatusLine);			theStatusLine.Append(" Runs Remaining, Valid Through ");		GetLicenseExpDateString(theString);		theStatusLine.Append(theString);		theStatusLine.Append("\p.");	theCaption->SetDescriptor(theStatusLine);			}void CDocumentApp::HandleLicenseDisplay(enum LicenseStatus theStatus){	if (theStatus == LicenseStatusNotInstalled)	{		::ParamText("\pThere is no license installed.", Str_Empty, Str_Empty, Str_Empty);		UModalAlerts::NoteAlert(PPob_GeneralALRT);		return;	}		// Create the dialog handler.		StDialogHandler theHandler( PPob_LicenseStatusDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	ThrowIfNil_(theDialog);		CEyeDxCaptionType *theExpDate = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kLicenseStatusExpDate));	ThrowIfNil_( theExpDate );		CEyeDxCaptionType *theAnalysisRuns = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kLicenseStatusAnalysisRuns));	ThrowIfNil_( theAnalysisRuns );	CEyeDxCaptionType *theCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kLicenseStatusCaption));	ThrowIfNil_( theCaption );	CEyeDxLongStringType theDateStatusString;	CEyeDxLongStringType theCountStatusString;	CEyeDxLongStringType theDateString;	CEyeDxLongStringType theCountString;		GetLicenseExpDateString(theDateString);	GetLicenseCountString(theCountString);		// By default, set the output strings to the returned values		theDateStatusString = theDateString;	theCountStatusString = theCountString;	switch (theStatus)	{	case LicenseStatusExpiredDate:		theDateStatusString = "\pExpired on " + theDateString + "\p.";		theCountStatusString = theCountString + "\p Analysis Runs Remaining.";		theCaption->SetDescriptor("\pRequest a new license with a new expiration date (and additional runs, if desired). The remaining run count will be added to the amount in the new license.");		break;	case LicenseStatusExpiredCount:		theDateStatusString = "\pPrevious license was valid through " + theDateString + "\p.";		theCountStatusString = "\pNo Analysis Runs Remaining.";		theCaption->SetDescriptor("\pRequest a new license with additional runs.");		break;	case LicenseStatusExpiredBoth:		theDateStatusString = "\pExpired on " + theDateString + "\p.";		theCountStatusString = "\pNo Analysis Runs Remaining.";		theCaption->SetDescriptor("\pRequest a new license with additional runs and a new expiration date.");		break;	case LicenseStatusDateOutOfRange:		theDateStatusString = "\pValid through midnight on " + theDateString + "\p.";		theCountStatusString = theCountString + "\p Analysis Runs Remaining.";		theCaption->SetDescriptor("\pThe system clock appears to have been reset - license not currently valid.");		break;	default:		theDateStatusString = "\pValid through midnight on " + theDateString + "\p.";		theCountStatusString = theCountString + "\p Analysis Runs Available.";		theCaption->SetDescriptor("\pYour license is currently valid.");		break;	}		theExpDate->SetDescriptor(theDateStatusString);		theAnalysisRuns->SetDescriptor(theCountStatusString);	// Make the dialog visible.	theDialog->Show();		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{					case msg_OK: 			done = true;			break;		}	}}void CDocumentApp::HandleLicenseExpired(enum LicenseStatus inLicenseStatus){	// Create the dialog handler.		StDialogHandler theHandler( PPob_LicenseExpiredDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	ThrowIfNil_(theDialog);		CEyeDxCaptionType *thePrompt = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kLicenseExpiredPrompt));	ThrowIfNil_( thePrompt );		switch (inLicenseStatus)	{	case LicenseStatusExpiredDate:		thePrompt->SetDescriptor("\pYour license has passed its expiration date.");		break;	case LicenseStatusExpiredCount:		thePrompt->SetDescriptor("\pYour license has no analysis runs available.");		break;	case LicenseStatusExpiredBoth:		thePrompt->SetDescriptor("\pYour license has passed its expiration date and has no analysis runs available.");		break;			case LicenseStatusDateOutOfRange:		thePrompt->SetDescriptor("\pIt appears that the system clock has been set back. License is disabled.");		break;	}		// Make the dialog visible.	theDialog->Show();		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{					case msg_OK: 			done = true;			break;		}	}}void CDocumentApp::HandleLicenseEntry(enum LicenseStatus inLicenseStatus, CEyeDxBooleanType exitPrompt){	// Before we do ANYTHING, prompt the user to confirm that the computer clock is set properly!	// Tell them to fix the date BEFORE installing the license!!!		Str255 theDateString;		unsigned long theDate;	::GetDateTime(&theDate);		::DateString(theDate, abbrevDate, theDateString, nil);			::ParamText("\pIs today ", theDateString, "\p? If this is NOT today's date, you MUST set the computer's clock properly before installing the license. If the year shown is 1904, then the battery may be dead.", Str_Empty);	DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_YesNoALRT);	if (item_hit == PPob_YesNoALRT_No)	{		// If we were told to display "Cancel and Exit" then do the exit!		// Otherwise, just return		if (exitPrompt)			exit (0);		else			return;	}	// Create the dialog handler.		StDialogHandler theHandler( PPob_LicenseEntryDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	ThrowIfNil_(theDialog);		CEyeDxCaptionType *thePrompt = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kLicenseEntryPrompt));	ThrowIfNil_( thePrompt );		switch (inLicenseStatus)	{	case LicenseStatusNotInstalled:		thePrompt->SetDescriptor("\pYou must install a license to use the EyeDx software.");		break;	case LicenseStatusExpiredDate:		thePrompt->SetDescriptor("\pYour license has passed its expiration date.");		break;	case LicenseStatusExpiredCount:		thePrompt->SetDescriptor("\pYour license has no analysis runs available.");		break;	case LicenseStatusExpiredBoth:		thePrompt->SetDescriptor("\pYour license has passed its expiration date and has no analysis runs available.");		break;	case LicenseStatusDateOutOfRange:		thePrompt->SetDescriptor("\pThe system clock appears to have been set back. Setting the clock to the correct date will re-enable your license if valid");		break;	case LicenseStatusValid:		thePrompt->SetDescriptor("\pYour license is valid. You may install a new license to extend the expiration date or increase the number of analysis runs.");		break;	}		CEyeDxButtonType *theCancelButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kLicenseEntry_Cancel));	ThrowIfNil_( theCancelButton );	CEyeDxEditFieldType *theCodeField1 = dynamic_cast<CEyeDxEditFieldType*> (theDialog->FindPaneByID(kLicenseEntryField1));	ThrowIfNil_( theCodeField1 );	CEyeDxEditFieldType *theCodeField2 = dynamic_cast<CEyeDxEditFieldType*> (theDialog->FindPaneByID(kLicenseEntryField2));	ThrowIfNil_( theCodeField2 );	CEyeDxEditFieldType *theCodeField3 = dynamic_cast<CEyeDxEditFieldType*> (theDialog->FindPaneByID(kLicenseEntryField3));	ThrowIfNil_( theCodeField3 );	CEyeDxEditFieldType *theCodeField4 = dynamic_cast<CEyeDxEditFieldType*> (theDialog->FindPaneByID(kLicenseEntryField4));	ThrowIfNil_( theCodeField4 );	CEyeDxEditFieldType *theCustomerID = dynamic_cast<CEyeDxEditFieldType*> (theDialog->FindPaneByID(kLicenseEntryCustomerID));	ThrowIfNil_( theCustomerID );		CEyeDxEditFieldType *theBogusField = dynamic_cast<CEyeDxEditFieldType*> (theDialog->FindPaneByID(kLicenseEntryBogusField));	ThrowIfNil_( theBogusField );		if (!exitPrompt)		theCancelButton->SetDescriptor("\pCancel");		// Make the dialog visible.	theDialog->Show();		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_Cancel:					// If we were told to display "Cancel and Exit" then do the exit!			// Otherwise, just break out of the loop.			if (exitPrompt)				exit (0);			done = true;			break;					case msg_OK: 					// Here we validate the entered license. This done by concatenating the			// entered license code segments, and passing that and the customer ID to the			// license object. It will tell us if the license is valid.						CEyeDxBooleanType validEntry = true;						CEyeDxLongStringType theBogusStr;			CEyeDxLongStringType theLicenseStr;			Str255 theFieldStr;						// We pretend that the bogus field has to be entered. We do this by just checking for			// a non-empty string. Of course, if they don't enter a valid value, it won't be caught.						theBogusField->GetDescriptor(theBogusStr);							// Now, validate the entered license string			theCodeField1->GetDescriptor(theFieldStr);			theLicenseStr.Append(theFieldStr);									theCodeField2->GetDescriptor(theFieldStr);			theLicenseStr.Append(theFieldStr);						theCodeField3->GetDescriptor(theFieldStr);			theLicenseStr.Append(theFieldStr);			theCodeField4->GetDescriptor(theFieldStr);			theLicenseStr.Append(theFieldStr);						// Get the customer ID and validate it						CEyeDxLongStringType theCustomerIDStr;						theCustomerID->GetDescriptor(theCustomerIDStr);									char custIDCStr[40];			strncpy(custIDCStr, (char *) &theCustomerIDStr[1], theCustomerIDStr[0]);			custIDCStr[theCustomerIDStr[0]] = '\0';						char licCStr[LicenseStringBufferLen];						strncpy(licCStr, (char *) &theLicenseStr[1], theLicenseStr[0]);			licCStr[theLicenseStr[0]] = '\0';						EyeDxLicenseInfo *theLicense = new EyeDxLicenseInfo();			if (!theLicense->IsValidLicenseString(licCStr))			{				::ParamText("\pInvalid license code. You must enter all four digits of each segment.", 					"\pUpper and lower case are important", Str_Empty, Str_Empty);				UModalAlerts::StopAlert(PPob_GeneralALRT);			}			else if (!theLicense->IsValidCustomerIDString(custIDCStr))			{				::ParamText("\pInvalid customer ID. You must enter at least 4 characters, and upper and lower case are important.", Str_Empty, Str_Empty, Str_Empty);				UModalAlerts::StopAlert(PPob_GeneralALRT);			}			else if (theBogusStr[0] == 0)			{				::ParamText("\pYou left the Zip/Postal Code field blank!", Str_Empty, Str_Empty, Str_Empty);				UModalAlerts::StopAlert(PPob_GeneralALRT);			}			else			{				// Decode the license TODO - this should give better feedback on exact reasons for debugging								if (!theLicense->DecodeLicense(licCStr, custIDCStr))				{					::ParamText("\pInvalid license ID.", Str_Empty, Str_Empty, Str_Empty);					UModalAlerts::StopAlert(PPob_GeneralALRT);				}				else				{					// Save the license information for future use. If a valid license is already					// installed, then try to update it. If the user is attempting to re-install					// the same license, we will get an error here, and the existing license will					// not be changed.														LicenseError theStatus = UpdateLicense(theLicense);					if (theStatus == kLicenseReuseError)					{						::ParamText("\pSorry. You cannot reuse an old license.", 									  "\pPlease obtain a new license from EyeDx, Inc.", Str_Empty, Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}					else if (theStatus == kLicenseNewOlderThanInstalledError)					{						::ParamText("\pSorry. You have entered a license that has an older expiration date than the currently-installed license.", "\pPlease contact EyeDx, Inc. customer service.", Str_Empty, Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}					else if (theStatus == kLicenseExpiredError)					{						::ParamText("\pSorry. You have entered an expired license.", "\pPlease obtain a new license from EyeDx, Inc.", Str_Empty, Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}					else if (theStatus != kLicenseNoError)					{						CEyeDxLongStringType theErrorCode = (long) theStatus;						::ParamText("\pSorry. Error ", theErrorCode,									  "\p occurred during license installation. Please contact EyeDx customer service.", Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}							else					{						// Display a notice showing the updated license information												HandleLicenseDisplay(GetLicenseStatus());						done = true;					}				}			}						delete theLicense;		}	}}// Values used to convert the long long values into two longsconst long long kLongLongLowerMask = 0x000000000ffffffff;const long		kLongLongUpperShift = 32;LicenseError CDocumentApp::EncodeLicenseFileData(LicenseData *inLicenseData){	// We take the 	mLicenseExpDateCode, mLicenseCount, mLicenseSN, and mLicenseLastUse	// member values and encode them into the passed data structure. We also calculate	// a checksum for the record to prevent tamering.		// Clear the structure first		memset(inLicenseData, 0, sizeof(LicenseData));	// The fields are negated before being set		inLicenseData->version = kMISCVers1;	inLicenseData->expDate = -mLicenseExpDateCode;				inLicenseData->lastUseDate = -mLicenseLastUse;	inLicenseData->availableRuns = -mLicenseCount;		inLicenseData->serialNumberLow = -(mLicenseSN & kLongLongLowerMask);	inLicenseData->serialNumberHigh = -((mLicenseSN >> kLongLongUpperShift) & kLongLongLowerMask);	inLicenseData->checksum = -(inLicenseData->version +								inLicenseData->expDate + 								inLicenseData->lastUseDate +								inLicenseData->availableRuns +								inLicenseData->serialNumberLow +								inLicenseData->serialNumberHigh);	// The other fields are zero		return kLicenseNoError;}LicenseError CDocumentApp::DecodeLicenseFileData(LicenseData *inLicenseData){	// We take the structure checksum for a valid value, and then check the individual fields	// for reasonable values. If all are reasonable, we transfer the values to the data members	// mLicenseExpDateCode, mLicenseCount, mLicenseSN, and mLicenseLastUse..		// Check the checksum. We chould be able to add up all of the fields and get zero.		long checksum = 0;		checksum = inLicenseData->checksum + inLicenseData->version +										 inLicenseData->expDate + 										 inLicenseData->lastUseDate +										 inLicenseData->availableRuns +										 inLicenseData->serialNumberLow +										 inLicenseData->serialNumberHigh;	// The other fields are zero											 	if (checksum != 0)		return kLicenseErrorNoLicense;			// The fields are negated before being set		if (inLicenseData->version != kMISCVers1)		return kLicenseErrorNoLicense;			// We check to see if the number of available runs is greater than -1 (0 is a valid number in this case) and	// less than a reasonably large number - currently 4000000.		if ((-inLicenseData->availableRuns < 0) || (-inLicenseData->availableRuns > (LicenseIncMaximum * LicenseIncMultiplier * 100)))		return kLicenseErrorNoLicense;		// Currently, we don't check the SN or date fields for validity.		mLicenseSN = ((-inLicenseData->serialNumberHigh) << kLongLongUpperShift) | (-inLicenseData->serialNumberLow);	mLicenseExpDateCode = -inLicenseData->expDate;				mLicenseLastUse = -inLicenseData->lastUseDate;		mLicenseCount = -inLicenseData->availableRuns;		return kLicenseNoError;}// This routine will check the mLicenseData member for status - either Valid,// Not Installed, or one of three Expired states (Date, Count, or Both),// and return the appropriate value. The first time through, it loads the// license information into the mLicenseData member functionLicenseStatus CDocumentApp::GetLicenseStatus(){	LicenseError theError = LoadLicense();	if (theError == kLicenseErrorNoLicense)		return LicenseStatusNotInstalled;							LicenseStatus theStatus = LicenseStatusValid;		if (mLicenseExpDateCode < EyeDxLicenseInfo::CreateTodayAsDateCode())		theStatus = LicenseStatusExpiredDate;			if (mLicenseCount == 0)	{		if (theStatus == LicenseStatusExpiredDate)			theStatus = LicenseStatusExpiredBoth;		else			theStatus = LicenseStatusExpiredCount;	}		if (mLicenseLastUse > EyeDxLicenseInfo::CreateTodayAsDateCode())		theStatus = LicenseStatusDateOutOfRange;		return theStatus;}// This routine takes a license info object pointer and extracts the count, serial number, and// expiration date from the license. It checks the serial number against the license currently// installed (if any). If the serial number in the new license is less than or equal to the// currently-installed serial number, an error is reported// and the license is not updated. Likewise, the date is also checked.// If the license passes the tests, the routine adds the count to the existing mLicenseCount field,// saves the expiration date and serial number, and then writes out the new license information.LicenseError CDocumentApp::UpdateLicense(EyeDxLicenseInfo *theLicense){	// The new license's serial number must be greater than the current one		if (mLicenseSN >= theLicense->GetSerialNumber())		return (kLicenseReuseError);		// The date codes can be directly compared, as older dates are smaller numbers.	// If for some reason they are installing a license that has an older expiration	// date than the license currently installed, that's an error.		if (mLicenseExpDateCode > theLicense->GetExpDateCode())		return (kLicenseNewOlderThanInstalledError);			// Also, the new license date code must be in the future - otherwise they are	// installing an expired license! We do allow the license to be today's date.		if (EyeDxLicenseInfo::CreateTodayAsDateCode() > theLicense->GetExpDateCode())		return (kLicenseExpiredError);	// Everything looks ok. Add the increment to the current number of available licenses.	// This number may be zero if no license is currently installed. We also save the	// new expiration date code and serial number.		mLicenseCount += theLicense->GetIncrement();	mLicenseExpDateCode = theLicense->GetExpDateCode();	mLicenseSN = theLicense->GetSerialNumber();		return (SaveLicense());}// This routine will load the mLicenseDate and mLicenseCount members from the license files// and do basic validation checking. Both license files must exist, and// the must be the same.LicenseError CDocumentApp::LoadLicense(){	LicenseData thePrimaryLicenseData;	LicenseData theBackupLicenseData;			if (mPrimaryLicense == nil)	{		// Create the primary license file object. This one takes just a filename and		// it will be created in the Preferences folder as an invisible file.				mPrimaryLicense = new CEyeDxLicenseFile(kLicenseFileName);	}		if (mBackupLicense == nil)	{		// Now, do the same for the backup file. This requires us to create a file spec		// based on the desired name and the desired folder. Currently, we use the EyeDx		// Folder.				FSSpec theBackupSpec;				::FSMakeFSSpec(mApplSpec.vRefNum, mApplSpec.parID, kLicenseFileName, &theBackupSpec);		mBackupLicense = new CEyeDxLicenseFile(theBackupSpec);	}		// Now that we have the objects, load the information. Note that we read the	// files _every_ time this routine is called to ensure that the user isn't playing	// around with the files.					mPrimaryLicense->LoadLicense(&thePrimaryLicenseData);		mBackupLicense->LoadLicense(&theBackupLicenseData);		// Ok. We now have the two license files. They have been created, and should be	// invisible. If they existed prior to these calls, the structures thePrimaryLicenseData	// and theBackupLicenseData should contain valid license information.		// There are four cases we have to deal with (failed == no license):	//	// 1. Load of primary failed but backup was ok - use the backup as the license.	// 2. Load of primary succeeded but backup failed - use the primary as the license.	// 3. Both loads failed - no license is installed.	// 4. Both loads succeeded - we just use the primary data.	//	// The SaveLicense routine will write both of the files, so they will be	// in sync at the end of this routine - we call SaveLicense.		mLicenseExpDateCode = 0;	mLicenseCount = 0;	mLicenseSN = 0;	mLicenseLastUse = 0L;		LicenseError returnVal = kLicenseNoError;	// First decode and validate the primary license. If it's ok, then we've taken care of cases	// 2 and 4 - just use the primary as the master. This routine will also fill-in the	// passed variables with the decoded values if the decoding succeeds, otherwise it will leave	// them alone.		returnVal = DecodeLicenseFileData(&thePrimaryLicenseData);		if (returnVal != kLicenseNoError)	{		// Primary is bad. This is case 1 or 3. Try decoding the backup data. If this fails, that's case 3 and there		// is no license installed. So note that, and will will write out empty data to both files.				returnVal = DecodeLicenseFileData(&theBackupLicenseData);				if (returnVal != kLicenseNoError)			returnVal = kLicenseErrorNoLicense;			else			// We have case case 1 - we'll use the backup data.			returnVal = kLicenseNoError;	}		// At this point the member data values for the license information have been loaded from the appropriate	// license file, or set to "no license" values. Both files will be updated the next time we call SaveLicense.	// We don't do that here so that we aren't always rewriting the files when we need to check the license	// status.			return returnVal;	}// This routine will write the mLicenseData member to the license filesLicenseError CDocumentApp::SaveLicense(){	LicenseData theLicenseData;		// Note the date of last use		mLicenseLastUse = EyeDxLicenseInfo::CreateTodayAsDateCode();	// Encode the data	EncodeLicenseFileData(&theLicenseData);		// Write it out to both files		mPrimaryLicense->SaveLicense(&theLicenseData);		mBackupLicense->SaveLicense(&theLicenseData);		return kLicenseNoError;}// This routine will update the mLicenseData member, and save the updated count to the// license filesLicenseError CDocumentApp::DecrementLicenseCounter(){	mLicenseCount--;	if (mLicenseCount < 0)		mLicenseCount = 0;	SaveLicense();	return kLicenseNoError;}