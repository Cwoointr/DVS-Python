// =================================================================================//	CDocumentApp.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for a document PowerPlant project////  The Application is derived from LDocApplication.  New Windows are managed//  by CTextDocument which is derived from LSingleDoc.  Each document contains//  a smart text view that remembers if it has changed since it was last saved.#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>extern "C"{#include <FSp_fopen.h>}#include <path2fss.h>#include "DC120.h"// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"//#include "CTextDocument.h"//#include "CTextView.h"#include "EyeDxMacConstants.h"// Apple Includes#include <StandardFile.h>#include <NumberFormatting.h>#include <OSUtils.h>// PowerPlant Includes#include <PP_Messages.h>#include <PP_Resources.h>#include <PPobClasses.h>#include <LGrowZone.h>#include <LIconPane.h>#include <LWindow.h>//#include <LPrintout.h>//#include <LPlaceHolder.h>#include <LBevelButton.h>#include <LCmdBevelButton.h>#include <LChasingArrows.h>#include <LCheckBox.h>#include <LCheckBoxGroupBox.h>#include <LClock.h>#include <LDisclosureTriangle.h>#include <LEditText.h>#include <LIconControl.h>#include <LImageWell.h>#include <LLittleArrows.h>#include <LPictureControl.h>#include <LPlacard.h>#include <LPopupButton.h>#include <LPopupGroupBox.h>#include <LProgressBar.h>#include <LPushButton.h>#include <LRadioButton.h>#include <LRadioGroupView.h>#include <LScrollBar.h>#include <LSeparatorLine.h>#include <LSlider.h>#include <LStaticText.h>#include <LTabsControl.h>#include <LTextGroupBox.h>#include <LWindowHeader.h>									// Standard Implementations#include <LStdPopupButtonImp.h>#include <LStdScrollBarImp.h>									// Appearance Manager Implementation#include <LAMBevelButtonImp.h>#include <LAMClockImp.h>#include <LAMControlImp.h>#include <LAMControlViewImp.h>#include <LAMEditTextImp.h>#include <LAMPlacardImp.h>#include <LAMPopupButtonImp.h>#include <LAMPopupGroupBoxImp.h>#include <LAMPushButtonImp.h>#include <LAMStaticTextImp.h>#include <LAMTabsControlImp.h>#include <LAMTrackActionImp.h>#include <LAMWindowHeaderImp.h>									// Grayscale Appearance Implementations#include <LGABevelButtonImp.h>#include <LGALittleArrowsImp.h>#include <LGAPushButtonImp.h>#include <LGARadioButtonImp.h>#include <LGACheckBoxImp.h>#include <LGADisclosureTriangleImp.h>#include <LGAPopupButtonImp.h>#include <LGASliderImp.h>#include <LGAIconControlImp.h>#include <LGASeparatorImp.h>#include <LGAPlacardImp.h>#include <LGAWindowHeaderImp.h>#include <LGAImageWellImp.h>#include <LGAStaticTextImp.h>#include <LGAGroupBoxImp.h>#include <LGATextGroupBoxImp.h>#include <LGACheckBoxGroupBoxImp.h>#include <LGAPopupGroupBoxImp.h>#include <LGAProgressBarImp.h>#include <LGAChasingArrowsImp.h>#include <LGAPictureControlImp.h>#include <LGATabsControlImp.h>#include <LGAEditTextImp.h>									// Other PP Classes#include <UEnvironment.h>#include <URegistrar.h>#include <LStdControl.h>#include <LDialogBox.h>#include <LEditField.h>#include <LMultiPanelView.h>#include <LScrollerView.h>									// Other GA Classes#include <LGADialog.h>#include <LGAColorSwatchControl.h>#include <LGAFocusBorder.h>#include <UResourceMgr.h>#include <UStandardDialogs.h>#include <UTextTraits.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <URegistrar.h>#include <UControlRegistry.h>// Other Classes - my own and 3rd party#include "CMyGWorldView.h"#include "USubFolderFinder.h"#include "CEyeDxPrefs.h"#include "ABalloon.h"#include "FileCopy.h"#include "CSingleClickListBox.h"#include "CAboutDialog.h"#include "CSpaceClickDialog.h"#include "CEditVariableDialog.h"#include "CPromptForVariableDialog.h"#include "CDefineChoicesDialog.h"#include "COutOfMemoryDialog.h"#include "UCustomDialogHandlers.h"#include "PowerPaintPictFile.h"#include "USoundPlayer.h"#undef PROFILEBLAH#ifdef PROFILEBLAH#include <profiler.h>#endiflong DebugFeatures;long AdvancedFeatures;const CEyeDxShortStringType	kEyeDxPrefsFileName		= "\pEyeDx Preferences";const CEyeDxShortStringType	kStartupMovieFileName	= "\pStartup Movie";const CEyeDxShortStringType	kStartupPictureFileName	= "\pStartup Picture";const CEyeDxShortStringType	kStartupSoundFileName	= "\pStartup Sound";//#define LOGGING#ifdef LOGGING#include "memlogger.h"FILE *logfile;long dummyGrow;#endifchar	DataPath[MAX_PATHNAME_CHARS];char	up_filename[MAX_FILENAME_CHARS];char	side_filename[MAX_FILENAME_CHARS];char	report_filename[MAX_FILENAME_CHARS];		// image data to analyze kept in global variablesunsigned char	*up_image,*side_image;int		UP_ROWS,UP_COLS,SIDE_ROWS,SIDE_COLS;		// flags and variables for user controlint		SideWhichWay,DisplayGraphics,RunInProgress,SaveFullImages;		// analyzation variablesint		MinIrisRad,MaxIrisRad,MinPupilRad,MaxPupilRad;int		MinCRArea,MaxCRArea,BrightThresh;		// animation variablesint		CircleThickness,FramePause,ZoomSteps,Flashes;extern pascal Boolean MyNavImagePreviewFilter(NavCBRecPtr callBackParms, void * );extern pascal Boolean MyNavImageObjectFilter(AEDesc* inItem, void *info, void* inUserData, NavFilterModes);extern pascal Boolean MyNavReportObjectFilter(AEDesc* inItem, void *info, void* inUserData, NavFilterModes);// =================================================================================//		¥ Main Program// ===========================================================================int main(){ 								#ifdef LOGGING	logfile = fopen("logfile", "w+");	logmemtofile(logfile, "main() - begin");#endif	SetDebugThrow_(PP_PowerPlant::debugAction_Alert);	// Set Debugging options	SetDebugSignal_(PP_PowerPlant::debugAction_Alert);	PP_PowerPlant::InitializeHeap(5);					// Initialize Memory Manager														// Parameter is number of Master Pointer														// blocks to allocate		PP_PowerPlant::UQDGlobals::InitializeToolbox(&qd);	// Initialize standard Toolbox managers		new PP_PowerPlant::LGrowZone(100000);				// Install a GrowZone function to catch														// low memory situations.	CDocumentApp	theApp;								// create instance of your application	theApp.Run();	#ifdef LOGGING	logmemtofile(logfile, "main() - postRun");	fclose(logfile);#endif		return 0;}// ---------------------------------------------------------------------------------//		¥ CDocumentApp// ---------------------------------------------------------------------------------//	ConstructorCDocumentApp::CDocumentApp(){	// Register the Appearance Manager/GA classes	// Since we want to minimize the application size, we don't want to just call the	// UControlRegistry::RegisterClasses call. This refers to all of the classes, and we	// want to link code only for those we actually use. I've commented-out the classes that	// are not currently used by the EyeDx software - if used they must be enabled in all of the	// cases below (Abstract, AM Implementation, and GA Implementation, plus Other).		// Just in case the user didn't set up the environment....		UEnvironment::InitEnvironment();				// Register the AM Abstraction Classes - these are used by both the AM and GA Implementation	// classes and are used regardless of whether or not the Appearance Manager is installed		RegisterClass_(LBevelButton);	//RegisterClass_(LChasingArrows);	RegisterClass_(LCheckBox);	//RegisterClass_(LCheckBoxGroupBox);	//RegisterClass_(LClock);	//RegisterClass_(LCmdBevelButton);	//RegisterClass_(LDisclosureTriangle);	RegisterClass_(LEditText);	//RegisterClass_(LIconControl);	//RegisterClass_(LImageWell);	//RegisterClass_(LLittleArrows);	//RegisterClass_(LPictureControl);	RegisterClass_(LPlacard);	RegisterClass_(LPopupButton);	//RegisterClass_(LPopupGroupBox);	RegisterClass_(LProgressBar);	RegisterClass_(LPushButton);	RegisterClass_(LRadioButton);	RegisterClass_(LScrollBar);	RegisterClass_(LSeparatorLine);	//RegisterClass_(LSlider);	RegisterClass_(LStaticText);	RegisterClass_(LTabsControl);	RegisterClass_(LTextGroupBox);	RegisterClass_(LWindowHeader);			if (UEnvironment::HasFeature (env_HasAppearance)) 	{		::RegisterAppearanceClient();		// Register the AM Implementation Classes				//RegisterClassID_(LAMControlImp, LChasingArrows::imp_class_ID);		RegisterClassID_(LAMControlImp, LCheckBox::imp_class_ID);		//RegisterClassID_(LAMControlImp, LDisclosureTriangle::imp_class_ID);		//RegisterClassID_(LAMControlImp, LIconControl::imp_class_ID);		//RegisterClassID_(LAMControlImp, LImageWell::imp_class_ID);		//RegisterClassID_(LAMControlImp, LPictureControl::imp_class_ID);		RegisterClassID_(LAMControlImp, LRadioButton::imp_class_ID);		RegisterClassID_(LAMControlImp, LSeparatorLine::imp_class_ID);				//RegisterClassID_(LAMControlViewImp, LCheckBoxGroupBox::imp_class_ID);		RegisterClassID_(LAMControlViewImp, LTextGroupBox::imp_class_ID);						//RegisterClassID_(LAMTrackActionImp, LLittleArrows::imp_class_ID);		RegisterClassID_(LAMTrackActionImp, LProgressBar::imp_class_ID);		RegisterClassID_(LAMTrackActionImp, LScrollBar::imp_class_ID);		RegisterClassID_(LAMTrackActionImp, LSlider::imp_class_ID);		RegisterClassID_(LAMBevelButtonImp,   LBevelButton::imp_class_ID);		//RegisterClassID_(LAMClockImp,		  LClock::imp_class_ID);		RegisterClassID_(LAMEditTextImp,	  LEditText::imp_class_ID);		RegisterClassID_(LAMPlacardImp,		  LPlacard::imp_class_ID);		RegisterClassID_(LAMPopupButtonImp,	  LPopupButton::imp_class_ID);		//RegisterClassID_(LAMPopupGroupBoxImp, LPopupGroupBox::imp_class_ID);		RegisterClassID_(LAMPushButtonImp,	  LPushButton::imp_class_ID);		RegisterClassID_(LAMStaticTextImp,	  LStaticText::imp_class_ID);		RegisterClassID_(LAMTabsControlImp,   LTabsControl::imp_class_ID);		RegisterClassID_(LAMWindowHeaderImp,  LWindowHeader::imp_class_ID);				if (!UEnvironment::HasFeature (env_HasAppearance101)) 		{						// The AM imps of LPopupButton and LPopupGroupBox				// require Appearance version 1.0.1 or later. So				// if we are running an earlier version (AM 1.0				// shipped with Mac OS 8.0), we have to use the				// GA imps for those two classes.					RegisterClassID_( LGAPopupButtonImp,	LPopupButton::imp_class_ID );			//RegisterClassID_( LGAPopupGroupBoxImp,	LPopupGroupBox::imp_class_ID );		}			} else 	{		// Register the GA Implementation Classes				RegisterClassID_( LGABevelButtonImp,		LBevelButton::imp_class_ID );		//RegisterClassID_( LGAChasingArrowsImp,		LChasingArrows::imp_class_ID );		RegisterClassID_( LGACheckBoxImp,			LCheckBox::imp_class_ID );		//RegisterClassID_( LGACheckBoxGroupBoxImp,	LCheckBoxGroupBox::imp_class_ID );		//RegisterClassID_( LGADisclosureTriangleImp,	LDisclosureTriangle::imp_class_ID );		RegisterClassID_( LGAEditTextImp,			LEditText::imp_class_ID );		//RegisterClassID_( LGAIconControlImp,		LIconControl::imp_class_ID );		//RegisterClassID_( LGAImageWellImp,			LImageWell::imp_class_ID );		//RegisterClassID_( LGALittleArrowsImp,		LLittleArrows::imp_class_ID );		//RegisterClassID_( LGAPictureControlImp,		LPictureControl::imp_class_ID );		RegisterClassID_( LGAPlacardImp,			LPlacard::imp_class_ID );		RegisterClassID_( LGAPopupButtonImp,		LPopupButton::imp_class_ID );		//RegisterClassID_( LGAPopupGroupBoxImp,		LPopupGroupBox::imp_class_ID );		RegisterClassID_( LGAProgressBarImp,		LProgressBar::imp_class_ID );		RegisterClassID_( LGAPushButtonImp,			LPushButton::imp_class_ID );		RegisterClassID_( LGARadioButtonImp,		LRadioButton::imp_class_ID );		RegisterClassID_( LGASeparatorImp,			LSeparatorLine::imp_class_ID );		//RegisterClassID_( LGASliderImp,				LSlider::imp_class_ID );		RegisterClassID_( LGAStaticTextImp,			LStaticText::imp_class_ID );		RegisterClassID_( LGATabsControlImp,		LTabsControl::imp_class_ID );		RegisterClassID_( LGATextGroupBoxImp,		LTextGroupBox::imp_class_ID );		RegisterClassID_( LGAWindowHeaderImp,		LWindowHeader::imp_class_ID );				// +++ No GA Imp for ScrollBar and Clock. Use native Imp.					//	RegisterClassID_( LGAScrollBarImp, LScrollBar::imp_classID );		//	RegisterClassID_( LGAClockImp, LClock::imp_class_ID );		if (UEnvironment::HasFeature (env_HasAppearance)) 		{			RegisterClassID_( LAMTrackActionImp,	LScrollBar::imp_class_ID);			//RegisterClassID_( LAMClockImp,			LClock::imp_class_ID);		} else 		{			RegisterClassID_( LStdScrollBarImp,		LScrollBar::imp_class_ID);			// There is no std Clock.		}					RegisterClass_( LGAGroupBoxImp );	}	// Now we register the classes common to the AM and GA class sets		RegisterClass_(LRadioGroupView);	RegisterClass_(LMultiPanelView);	RegisterClass_(LScrollerView);	RegisterClass_(LWindowThemeAttachment);	RegisterClass_(LKeyScrollAttachment);		//RegisterClass_(LGAColorSwatchControl);	RegisterClass_(LGADialog);	RegisterClass_(LGAFocusBorder);	// Register PowerPlant classes used in the PPob(s) other than the AM/GA classes	RegisterClass_(PP_PowerPlant::LWindow);			// You must register each kind of	RegisterClass_(PP_PowerPlant::LScrollerView);	// PowerPlant classes that you use	//RegisterClass_(PP_PowerPlant::LPrintout);		// in your PPob resource.	//RegisterClass_(PP_PowerPlant::LPlaceHolder);	RegisterClass_(PP_PowerPlant::LTextEditView);	RegisterClass_(PP_PowerPlant::LTextButton);	RegisterClass_(PP_PowerPlant::LView);	RegisterClass_(PP_PowerPlant::LPicture);	RegisterClass_(PP_PowerPlant::LRadioGroup);	RegisterClass_(PP_PowerPlant::CEyeDxIconType);	RegisterClass_(PP_PowerPlant::LPane);	RegisterClass_(PP_PowerPlant::LListBox);	RegisterClass_(PP_PowerPlant::LTabGroup);	RegisterClass_(PP_PowerPlant::LTextTableView);	RegisterClass_(PP_PowerPlant::LUndoer);	RegisterClass_(PP_PowerPlant::LColorEraseAttachment);		RegisterClass_(ABalloon);	RegisterClass_(CSingleClickListBox);	RegisterClass_(CEyeDxViewType);		// My dialog classes		RegisterClass_(CAboutDialog);	RegisterClass_(CEditVariableDialog);	RegisterClass_(CPromptForVariableDialog);	RegisterClass_(CDefineChoicesDialog);	RegisterClass_(COutOfMemoryDialog);	RegisterClass_(CSpaceClickDialog);		PP_PowerPlant::PP_StandardDialogs::Load();		// Preload facilities for std dialogs	}void CDocumentApp::SaveSessionStatus(){	mPreferences->SaveVariablePrefs(&mVariableList);	}// ---------------------------------------------------------------------------------//		¥ ~CDocumentApp// ---------------------------------------------------------------------------------//	DestructorCDocumentApp::~CDocumentApp(){	// Save our preferences		SaveSessionStatus();		delete mPreferences;		// Save our license information		delete mPrimaryLicense;	delete mBackupLicense;	PP_PowerPlant::PP_StandardDialogs::Unload();	// Clean up after std dialogs}// ---------------------------------------------------------------------------------//		¥ StartUp// ---------------------------------------------------------------------------------//	This function lets you do something when the application starts up//	without a document. For example, you could issue your own new command.voidCDocumentApp::StartUp(){	OSErr theErr = noErr;	mUpSelected = false;	mSideSelected = false;		mPrimaryLicense = nil;	mBackupLicense = nil;	// Create a FSSpec for the application folder, for use when copying files and setting	// up the backup license file.		theErr = ::FSMakeFSSpec(0, 0, LMGetCurApName(), &mApplSpec);	// Now that we've registered all of the classes, display the optional Splash Screen.	// We use the mApplSpec, so this has to happen after that is created.		HandleSplashScreen();	// The first thing we do is see if there is a valid license. If not, we prompt for one.	// We remain in the license prompt routine until we either get a valid license, or the	// user presses the Cancel and Exit button.		// Determine whether there is a license installed and if so, is it valid. If valid, we	// skip the following entry handling. If the license is not installed, then we prompt 	// for a license. If the license is expired, we just display a notice, telling the user that	// they can still use certain features, and to obtain a new license.		LicenseStatus theLicenseStatus = GetLicenseStatus();		switch (theLicenseStatus)	{	case LicenseStatusNotInstalled:		HandleLicenseEntry(theLicenseStatus, true);		break;			case LicenseStatusExpiredDate:	case LicenseStatusExpiredCount:	case LicenseStatusExpiredBoth:	case LicenseStatusDateOutOfRange:		HandleLicenseExpired(theLicenseStatus);		break;	case LicenseStatusValid:		// DO NOT write the license out here. Do it only when an actual analysis is run.		// This prevents (partially) the problem if the date has been set forward and then		// set back with the EyeDx software run between. It still will fail if the user		// tries to run analysis between, but just starting the software shouldn't cause		// a problem.		//SaveLicense();		break;	}		mMainWindow = PP_PowerPlant::LWindow::CreateWindow( PPob_ControlWindow, this );	UReanimator::LinkListenerToControls( this, mMainWindow, RidL_ControlWindow );	mMainWindow->Show();		mDiskWindow = PP_PowerPlant::LWindow::CreateWindow( PPob_DiskWindow, this );	UReanimator::LinkListenerToControls( this, mDiskWindow, RidL_DiskWindow );	mCameraWindow = PP_PowerPlant::LWindow::CreateWindow( PPob_CameraWindow, this );	UReanimator::LinkListenerToControls( this, mCameraWindow, RidL_CameraWindow );	mAutoCameraWindow = PP_PowerPlant::LWindow::CreateWindow( PPob_AutoCameraWindow, this );	UReanimator::LinkListenerToControls( this, mAutoCameraWindow, RidL_AutoCameraWindow );	mAnalysisWindow = PP_PowerPlant::LWindow::CreateWindow( PPob_AnalysisWindow, this );	UReanimator::LinkListenerToControls( this, mAnalysisWindow, RidL_AnalysisWindow );											// These objects are kept so we can enable or disable them in the HandleKeyPress member function		mMainRunFromDiskButton = dynamic_cast<CEyeDxButtonType *> (mMainWindow->FindPaneByID( kMainRunFromDiskButton ));	ThrowIfNil_( mMainRunFromDiskButton );		mMainSessionButton = dynamic_cast<CEyeDxButtonType *> (mMainWindow->FindPaneByID( kMainSessionButton ));	ThrowIfNil_( mMainSessionButton );			// Create an EraseAttachment and connect it to all of the captions so that they are	// automatically erased before they are redrawn.		mEraseAttachment = new LEraseAttachment(true);			// Create a BorderAttachment and connect it to all of the CEyeDxViewType objects				//mBorderAttachment = new LBorderAttachment(nil, nil, nil, true);			// Objects in the Run From Camera Window			mCameraUpView = dynamic_cast<CEyeDxViewType *> (mCameraWindow->FindPaneByID( kCameraUpMyGWorldView ));	ThrowIfNil_( mCameraUpView );	//mCameraUpView->AddAttachment(mBorderAttachment, nil, false);	mCameraSideView = dynamic_cast<CEyeDxViewType *> (mCameraWindow->FindPaneByID( kCameraSideMyGWorldView ));	ThrowIfNil_( mCameraSideView );	//mCameraSideView->AddAttachment(mBorderAttachment, nil, false);	// We also get the progress bars for the Run From Disk window so we can pass them to the ReadImage routine		mCameraUpThermometerPane = dynamic_cast<CEyeDxProgressType*> (mCameraWindow->FindPaneByID(kCameraUpThermometerPane));	ThrowIfNil_( mCameraUpThermometerPane );	mCameraSideThermometerPane = dynamic_cast<CEyeDxProgressType*> (mCameraWindow->FindPaneByID(kCameraSideThermometerPane));	ThrowIfNil_( mCameraSideThermometerPane );	mCameraUpProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraUpProgressCaption));	ThrowIfNil_( mCameraUpProgressCaption );	mCameraUpProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraSideProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraSideProgressCaption));	ThrowIfNil_( mCameraSideProgressCaption );	mCameraSideProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraAnimate = dynamic_cast<CEyeDxCheckBoxType*> (mCameraWindow->FindPaneByID(kCameraAnimate));	ThrowIfNil_( mCameraAnimate );		mCameraReportName = dynamic_cast<CEyeDxEditFieldType*> (mCameraWindow->FindPaneByID(kCameraReportName));	ThrowIfNil_( mCameraReportName );		mCameraUpCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraUpCaption));	ThrowIfNil_( mCameraUpCaption );	mCameraUpCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraSideCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraSideCaption));	ThrowIfNil_( mCameraSideCaption );	mCameraSideCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraUpPictureQualityIcon = dynamic_cast<CEyeDxIconType*> (mCameraWindow->FindPaneByID(kCameraUpQualityIcon));	ThrowIfNil_( mCameraUpPictureQualityIcon );	mCameraSidePictureQualityIcon = dynamic_cast<CEyeDxIconType*> (mCameraWindow->FindPaneByID(kCameraSideQualityIcon));	ThrowIfNil_( mCameraSidePictureQualityIcon );	mCameraLicenseStatusCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraLicenseStatusCaption));	ThrowIfNil_( mCameraLicenseStatusCaption );	mCameraLicenseStatusCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraSessionCaption = dynamic_cast<CEyeDxCaptionType*> (mCameraWindow->FindPaneByID(kCameraSessionCaption));	ThrowIfNil_( mCameraSessionCaption );	mCameraSessionCaption->AddAttachment(mEraseAttachment, nil, false);		mCameraUpZoomButton = dynamic_cast<CEyeDxIconButtonType*> (mCameraWindow->FindPaneByID(kCameraUpZoomButton));	ThrowIfNil_( mCameraUpZoomButton );		mCameraSideZoomButton = dynamic_cast<CEyeDxIconButtonType*> (mCameraWindow->FindPaneByID(kCameraSideZoomButton));	ThrowIfNil_( mCameraSideZoomButton );		// Now indicate the default button in the Run From Camera window		CEyeDxButtonType *theDefaultButton = dynamic_cast<CEyeDxButtonType*> (mCameraWindow->FindPaneByID(kCameraOKButton));	ThrowIfNil_( theDefaultButton );		theDefaultButton->SetDefaultButton(true);	// Objects in the Run From Camera (Auto) Window			mAutoCameraUpView = dynamic_cast<CEyeDxViewType *> (mAutoCameraWindow->FindPaneByID( kAutoCameraUpMyGWorldView ));	ThrowIfNil_( mAutoCameraUpView );	//mCameraUpView->AddAttachment(mBorderAttachment, nil, false);	mAutoCameraSideView = dynamic_cast<CEyeDxViewType *> (mAutoCameraWindow->FindPaneByID( kAutoCameraSideMyGWorldView ));	ThrowIfNil_( mAutoCameraSideView );	// We also get the progress bars for the Run From Disk window so we can pass them to the ReadImage routine		mAutoCameraUpThermometerPane = dynamic_cast<CEyeDxProgressType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraUpThermometerPane));	ThrowIfNil_( mAutoCameraUpThermometerPane );	mAutoCameraSideThermometerPane = dynamic_cast<CEyeDxProgressType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraSideThermometerPane));	ThrowIfNil_( mAutoCameraSideThermometerPane );	mAutoCameraUpProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraUpProgressCaption));	ThrowIfNil_( mAutoCameraUpProgressCaption );	mAutoCameraUpProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mAutoCameraSideProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraSideProgressCaption));	ThrowIfNil_( mAutoCameraSideProgressCaption );	mAutoCameraSideProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mAutoCameraReportName = dynamic_cast<CEyeDxCaptionType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraReportName));	ThrowIfNil_( mAutoCameraReportName );		mAutoCameraUpCaption = dynamic_cast<CEyeDxCaptionType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraUpCaption));	ThrowIfNil_( mAutoCameraUpCaption );	mAutoCameraUpCaption->AddAttachment(mEraseAttachment, nil, false);		mAutoCameraSideCaption = dynamic_cast<CEyeDxCaptionType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraSideCaption));	ThrowIfNil_( mAutoCameraSideCaption );	mAutoCameraSideCaption->AddAttachment(mEraseAttachment, nil, false);		mAutoCameraUpPictureQualityIcon = dynamic_cast<CEyeDxIconType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraUpQualityIcon));	ThrowIfNil_( mAutoCameraUpPictureQualityIcon );	mAutoCameraSidePictureQualityIcon = dynamic_cast<CEyeDxIconType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraSideQualityIcon));	ThrowIfNil_( mAutoCameraSidePictureQualityIcon );	mAutoCameraLicenseStatusCaption = dynamic_cast<CEyeDxCaptionType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraLicenseStatusCaption));	ThrowIfNil_( mAutoCameraLicenseStatusCaption );	mAutoCameraLicenseStatusCaption->AddAttachment(mEraseAttachment, nil, false);		mAutoCameraSessionCaption = dynamic_cast<CEyeDxCaptionType*> (mAutoCameraWindow->FindPaneByID(kAutoCameraSessionCaption));	ThrowIfNil_( mAutoCameraSessionCaption );	mAutoCameraSessionCaption->AddAttachment(mEraseAttachment, nil, false);		// Objects in the Run From Disk Window			mDiskUpView = dynamic_cast<CEyeDxViewType *> (mDiskWindow->FindPaneByID( kDiskUpMyGWorldView ));	ThrowIfNil_( mDiskUpView );	mDiskSideView = dynamic_cast<CEyeDxViewType *> (mDiskWindow->FindPaneByID( kDiskSideMyGWorldView ));	ThrowIfNil_( mDiskSideView );	// We also get the progress bars for the Run From Disk window so we can pass them to the ReadImage routine		mDiskUpThermometerPane = dynamic_cast<CEyeDxProgressType*> (mDiskWindow->FindPaneByID(kDiskUpThermometerPane));	ThrowIfNil_( mDiskUpThermometerPane );	mDiskSideThermometerPane = dynamic_cast<CEyeDxProgressType*> (mDiskWindow->FindPaneByID(kDiskSideThermometerPane));	ThrowIfNil_( mDiskSideThermometerPane );	mDiskUpProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mDiskWindow->FindPaneByID(kDiskUpProgressCaption));	ThrowIfNil_( mDiskUpProgressCaption );	mDiskUpProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskSideProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mDiskWindow->FindPaneByID(kDiskSideProgressCaption));	ThrowIfNil_( mDiskSideProgressCaption );	mDiskSideProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskAnimate = dynamic_cast<CEyeDxCheckBoxType*> (mDiskWindow->FindPaneByID(kDiskAnimate));	ThrowIfNil_( mDiskAnimate );		mDiskReportName = dynamic_cast<CEyeDxEditFieldType*> (mDiskWindow->FindPaneByID(kDiskReportName));	ThrowIfNil_( mDiskReportName );		mDiskUpCaption = dynamic_cast<CEyeDxCaptionType*> (mDiskWindow->FindPaneByID(kDiskUpCaption));	ThrowIfNil_( mDiskUpCaption );	mDiskUpCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskSideCaption = dynamic_cast<CEyeDxCaptionType*> (mDiskWindow->FindPaneByID(kDiskSideCaption));	ThrowIfNil_( mDiskSideCaption );	mDiskSideCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskUpPictureQualityIcon = dynamic_cast<CEyeDxIconType*> (mDiskWindow->FindPaneByID(kDiskUpQualityIcon));	ThrowIfNil_( mDiskUpPictureQualityIcon );	mDiskSidePictureQualityIcon = dynamic_cast<CEyeDxIconType*> (mDiskWindow->FindPaneByID(kDiskSideQualityIcon));	ThrowIfNil_( mDiskSidePictureQualityIcon );		mDiskLicenseStatusCaption = dynamic_cast<CEyeDxCaptionType*> (mDiskWindow->FindPaneByID(kDiskLicenseStatusCaption));	ThrowIfNil_( mDiskLicenseStatusCaption );	mDiskLicenseStatusCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskSessionCaption = dynamic_cast<CEyeDxCaptionType*> (mDiskWindow->FindPaneByID(kDiskSessionCaption));	ThrowIfNil_( mDiskSessionCaption );	mDiskSessionCaption->AddAttachment(mEraseAttachment, nil, false);		mDiskUpZoomButton = dynamic_cast<CEyeDxIconButtonType*> (mDiskWindow->FindPaneByID(kDiskUpZoomButton));	ThrowIfNil_( mDiskUpZoomButton );		mDiskSideZoomButton = dynamic_cast<CEyeDxIconButtonType*> (mDiskWindow->FindPaneByID(kDiskSideZoomButton));	ThrowIfNil_( mDiskSideZoomButton );		// Now indicate the default button in the Run From Disk window		theDefaultButton = dynamic_cast<CEyeDxButtonType*> (mDiskWindow->FindPaneByID(kDiskOKButton));	ThrowIfNil_( theDefaultButton );		theDefaultButton->SetDefaultButton(true);		// Objects in the Analysis Window		mAnalysisMainView = dynamic_cast<CEyeDxViewType *> (mAnalysisWindow->FindPaneByID( kAnalysisMainMyGWorldView ));	ThrowIfNil_( mAnalysisMainView );	//mAnalysisMainView->AddAttachment(mBorderAttachment, nil, false);	mAnalysisMainViewGroupBox = dynamic_cast<CEyeDxTextGroupBoxType *> (mAnalysisWindow->FindPaneByID( kAnalysisMainViewGroupBox ));	ThrowIfNil_( mAnalysisMainViewGroupBox );	mAnalysisUpView = dynamic_cast<CEyeDxViewType *> (mAnalysisWindow->FindPaneByID( kAnalysisUpMyGWorldView ));	ThrowIfNil_( mAnalysisUpView );	//mAnalysisUpView->AddAttachment(mBorderAttachment, nil, false);	mAnalysisUpViewGroupBox = dynamic_cast<CEyeDxTextGroupBoxType *> (mAnalysisWindow->FindPaneByID( kAnalysisUpViewGroupBox ));	ThrowIfNil_( mAnalysisUpViewGroupBox );	mAnalysisSideView = dynamic_cast<CEyeDxViewType *> (mAnalysisWindow->FindPaneByID( kAnalysisSideMyGWorldView ));	ThrowIfNil_( mAnalysisSideView );	//mAnalysisSideView->AddAttachment(mBorderAttachment, nil, false);	mAnalysisSideViewGroupBox = dynamic_cast<CEyeDxTextGroupBoxType *> (mAnalysisWindow->FindPaneByID( kAnalysisSideViewGroupBox ));	ThrowIfNil_( mAnalysisSideViewGroupBox );	mAnalysisThermometerPane = dynamic_cast<CEyeDxProgressType*> (mAnalysisWindow->FindPaneByID(kAnalysisThermometerPane));	ThrowIfNil_( mAnalysisThermometerPane );	mAnalysisProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mAnalysisWindow->FindPaneByID(kAnalysisProgressCaption));	ThrowIfNil_( mAnalysisProgressCaption );	mAnalysisProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mAnalysisUpCaption = dynamic_cast<CEyeDxCaptionType*> (mAnalysisWindow->FindPaneByID(kAnalysisUpCaption));	ThrowIfNil_( mAnalysisUpCaption );	mAnalysisUpCaption->AddAttachment(mEraseAttachment, nil, false);		mAnalysisSideCaption = dynamic_cast<CEyeDxCaptionType*> (mAnalysisWindow->FindPaneByID(kAnalysisSideCaption));	ThrowIfNil_( mAnalysisSideCaption );	mAnalysisSideCaption->AddAttachment(mEraseAttachment, nil, false);		// Add ourselves as a listener of ourself, so we can send messages to	// ourself in response to menu selections		AddListener(this);	// Now we initialize our globals		// We load resources from the application file BEFORE we create the preferences object, so that the	// preferences file is not in the list of resource files. IMPORTANT!!		// Get a handle to some sample text before we open our preferences file		StApplicationContext resourceContext; 		long theResourceID = kSampleReportHeaderTextID;		for (long i = 0; i < kReportLayoutNumText; i++, theResourceID++)			mReportDefaultText[i] = ::Get1Resource(kReportTextPrefs, theResourceID);		// We load all of the default EyeDx variable resources that we find into the variable list.		long numVariables = ::CountResources(kVariablePrefs);		for (long resourceNum = 1; resourceNum <= numVariables; resourceNum++)	{		// -----------------------------------------		// Get saved variable preference				CEyeDxVariablePrefs **theHandle = (CEyeDxVariablePrefs **) ::GetIndResource(kVariablePrefs, resourceNum);			if (theHandle != nil)		{			// We have to look up the name of the variable from the resource name						Str255 theName;			short theID;			OSType theType;						::GetResInfo(Handle(theHandle), &theID, &theType, theName);						// Lock the handle so we can dereference it						::HLock(Handle(theHandle));						CEyeDxLongStringType theNameLongStr(theName);						CEyeDxVariable *newVariable = new CEyeDxVariable(&theNameLongStr, *theHandle);						short theSTRId = (*theHandle)->optionStrListID;						if (theSTRId != 0)				LoadStringArrayFromSTR(newVariable, theSTRId);			::HUnlock(Handle(theHandle));		 	::ReleaseResource(Handle(theHandle));						mVariableList.AddVariable(newVariable);		}	}			// NOTE: All local setting of runtime variables MUST be done after the Preferences versions are loaded	// below! Otherwise, what you set here will be overwritten.		// Create the Preferences object		mPreferences = new CEyeDxPrefs(kEyeDxPrefsFileName);		// Read in the default browser type code. If no browser is specified, we will prompt the user to	// select one. This will be done later.		mPreferences->LoadBrowserPref(&mBrowserCreatorCode);		// Load the camera preferences, and set the global variables as needed.		mPreferences->LoadCameraPrefs(&mCameraPrefs);		SaveFullImages = mCameraPrefs.saveFiles;		// Load the report preferences, and set the global variables as needed.		mPreferences->LoadReportPrefs(&mReportPrefs);		// Load the EyeDx variables		mPreferences->LoadVariablePrefs(&mVariableList);		// Load the optional text for the report, providing a default if a user preference doesn't exist		theResourceID = kSampleReportHeaderTextID;		for (long i = 0; i < kReportLayoutNumText; i++, theResourceID++)			mReportCustomText[i] = mPreferences->LoadReportTextPrefs(mReportDefaultText[i], theResourceID);		mPreferences->LoadPromptingPrefs(&mPromptingPrefs);		// Now set some calculated variables		// We set the application version variable		CEyeDxVariable *theVersionVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableAPPLICATIONVERSION));	ThrowIfNil_( theVersionVariable );	// get the resource, 'vers' 1 in the current resource fork	StResource	versH( 'vers', 1, true, false );		// We have to calculate the location of the longVersion. It appears immediately	// after the shortVersion string.		CEyeDxLongStringType theVersionStr((*(VersRecHndl)((Handle)versH))->shortVersion);		theVersionVariable->SetValue(theVersionStr);				CEyeDxVariable *theSubjectsMeasuredVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTSMEASURED));	ThrowIfNil_( theSubjectsMeasuredVariable );	theSubjectsMeasuredVariable->SetValue(0);				// Set up the class that helps us find subfolders. Now that we have the session set up, the CreateFolders routine can	// use it to create the necessary folders. This has to be done here because subroutines called by the HandleEndOfSession	// use the FolderFinder object.			mFolderFinder.Initialize();		// Prompt for the startup variables first		if (HandlePromptForVariables(this, &mVariableList, mPromptingPrefs.promptingStyle, CEyeDxVariable::kPromptOnStart) == kEyeDxDialogCancelMessage)		CDocumentApp::ObeyCommand( PP_PowerPlant::cmd_Quit, nil );		// CDocumentApp::ObeyCommand	// Always set the TODAYS DATE variable so that it can be used in the end of session operation.		CEyeDxVariable *theTodaysDateVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableTODAYSDATE));	ThrowIfNil_( theTodaysDateVariable );	theTodaysDateVariable->ResetValue();	// We have to set up a default session name if one was not saved		CEyeDxLongStringType *theSessionName = nil;		CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	ThrowIfNil_( theSessionNameVariable );	// Note that when loaded the variable's value is set to the default		theSessionName = theSessionNameVariable->GetValue();	if (*theSessionName == "\p")		theSessionNameVariable->SetValue(CommonStringLiteral_(kDefaultSessionName));		if (*theSessionName != CommonStringLiteral_(kDefaultSessionName))	{		// If a session is active, we force the user preference for useSessions to on.				mReportPrefs.useSessions = kUseSessions;				// Prompt the user and ask if they wish to continue using this session				// If they say to end the session, perform the end session functions. It will ask the user if they want		// to start a new session, and do the appropriate things. If they don't it will automatically set up the		// default session. This call will update the main window button as needed.				::ParamText("\pThe current session is '", *theSessionName, "\p'. Do you want to continue using it, or end this session?", Str_Empty);		DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_SessionStartupALRT);		if (item_hit == PPob_SessionStartupALRT_No)		{			::HLock(mReportCustomText[kReportLayoutSessionSummaryText]);					HandleEndOfSession(this, &mVariableList, mMainSessionButton, nil, 								theSessionNameVariable, 								*mReportCustomText[kReportLayoutSessionSummaryText], 								::GetHandleSize(mReportCustomText[kReportLayoutSessionSummaryText]),								mPromptingPrefs.promptingStyle);						::HUnlock(mReportCustomText[kReportLayoutSessionSummaryText]);		}		else		{			// We have to re-prompt for the session variables, since we do not save them across runs! - well, now we do			//HandlePromptForVariables(this, &mVariableList, mPromptingPrefs.promptingStyle, CEyeDxVariable::kPromptForSession);						}	}	// Always set up the main button to the proper value based on the current state of the variable		UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theSessionNameVariable, mMainSessionButton, nil);			// And create the necessary folders		CreateFolders();		// Set the default image and report directories to the current session's	// Pimages and reports directories since that is the logical location.			mLastImageDirSpec = mPImagesDirSpec;	mLastReportDirSpec = mReportDirSpec;	strcpy(report_filename,"");		CEyeDxShortStringType theString(report_filename);		mCameraReportName->SetDescriptor(theString);	mDiskReportName->SetDescriptor(theString);	strcpy(up_filename,"");	strcpy(side_filename,"");	up_image = side_image = NULL;		mUpHandle = mSideHandle = NULL;	UP_ROWS = UP_COLS = SIDE_ROWS = SIDE_COLS = 0;	RunInProgress = 0;	// user interface used to be able to change all these values	// while we were researching this, but now they are fixed	DisplayGraphics = 0;		mCameraAnimate->SetValue(DisplayGraphics);	mDiskAnimate->SetValue(DisplayGraphics);	SideWhichWay = 0;	/* left */	MinIrisRad = MIN_IRIS_RAD;	MaxIrisRad = MAX_IRIS_RAD;	MinPupilRad = MIN_PUPIL_RAD;	MaxPupilRad = MAX_PUPIL_RAD;	MinCRArea = MIN_CR_AREA;	MaxCRArea = MAX_CR_AREA;	BrightThresh = BRIGHT_THRESH;#ifdef __POWERPC__	ZoomSteps = 40;	Flashes = 20;	FramePause = 1000 * 60 / 1000;	// Convert to Mac ticks (1/60 s)#else	ZoomSteps = 5;	Flashes = 5;	FramePause = 1;	// Convert to Mac ticks (1/60 s)#endif	CircleThickness = 1;	// Disable the Features flags - they can be turned on with the appropriate	// keystrokes - see the HandleKeyPress member function.		DebugFeatures = FALSE;	AdvancedFeatures = FALSE;		mDirectorySet = FALSE;		mDefaultDatabaseReportName = CommonStringLiteral_(kDefaultDatabaseReportName);		// Now check the depth of the monitor we are on. If it is 8 bits, tell the user that	// EyeDx recommends running on Thousands or Millions of colors		short theDepth = UDrawingUtils::GetPortPixelDepth(mMainWindow->GetMacPort()); 	if (theDepth < 16)	{		::ParamText("\pFor best image display quality, EyeDx recommends you set your monitor to Thousands or Millions of colors.", Str_Empty, Str_Empty, Str_Empty);		UModalAlerts::CautionAlert(PPob_GeneralALRT);	}	// Check to see if virtual memory is enabled. EyeDx requires that at least 1 MB be enabled	// on PowerPC systems to avoid memory shortages.#ifdef __POWERPC__	if (!UEnvironment::HasGestaltAttribute(gestaltVMAttr, gestaltVMPresent))	{		::ParamText("\pThe EyeDx program requires that at least 1 MB of virtual memory be available.", 					"\pUse the Memory Control Panel to set Virtual Memory to 1 MB more than installed RAM.",					"\pThen Restart the computer.", 					"\pEyeDx will now exit.");		UModalAlerts::StopAlert(PPob_GeneralALRT);		CDocumentApp::ObeyCommand( PP_PowerPlant::cmd_Quit, nil );		// CDocumentApp::ObeyCommand	}#endif	// If the auto start Auto Camera mode function is enabled, send ourselves a message to start that mode.		mFirstTimeAutoStart = false;	if (mCameraPrefs.autoStartAutoCameraMode)	{		mFirstTimeAutoStart = true;		BroadcastMessage(msg_MainRunFromCamera, 0);	}}static void SetDialogBounds(LWindow *theDialog, Rect &thePictureSize){	WindowPtr theWindowPtr = UWindows::FindNthWindow(1);		Rect theFrameRect = UWindows::GetWindowStructureRect(theWindowPtr);	Rect theViewRect = UWindows::GetWindowContentRect(theWindowPtr);		SInt16 theExtraWidth = (theFrameRect.right - theFrameRect.left) - (theViewRect.right - theViewRect.left);;	SInt16 theExtraHeight = (theFrameRect.bottom - theFrameRect.top) - (theViewRect.bottom - theViewRect.top);		// OK. Now we have to recenter the window on the main screen since we've changed its size		GDHandle	dominantDevice = UWindows::FindDominantDevice(theFrameRect);	// Window is offscreen, so use the main screen		if (dominantDevice == nil) 		dominantDevice = ::GetMainDevice();	Rect screenRect = (**dominantDevice).gdRect;		// Must compensate for MenuBar on the main screen		SInt16 offsetMenuBar = 0;		if (dominantDevice == ::GetMainDevice()) 		offsetMenuBar = GetMBarHeight();	screenRect.top += offsetMenuBar;			SInt16	screenWidth  = (SInt16) (screenRect.right - screenRect.left);	SInt16	screenHeight = (SInt16) (screenRect.bottom - screenRect.top);	SInt16	frameWidth  = (SInt16) (thePictureSize.right - thePictureSize.left) + theExtraWidth;	SInt16	frameHeight = (SInt16) (thePictureSize.bottom - thePictureSize.top) + theExtraHeight;	Rect theNewBounds;		// If the picture is larger than the screen, we will set the window to the	// size of the screen.		SInt16 theNewWidth = frameWidth;	SInt16 theNewHeight = frameHeight;		if ((screenHeight < frameHeight))	{		theNewHeight = screenHeight;		theNewWidth = (frameWidth * screenHeight) / frameHeight;	}		if (screenWidth < theNewWidth)	{		theNewWidth = screenWidth;		theNewHeight = (theNewHeight * screenWidth) / theNewWidth;				}	theNewBounds.left   = (screenWidth / 2) - (theNewWidth / 2);	theNewBounds.top    = (screenHeight / 2) - (theNewHeight / 2) + offsetMenuBar;	theNewBounds.right  = theNewBounds.left + theNewWidth;	theNewBounds.bottom = theNewBounds.top + theNewHeight;		theDialog->DoSetBounds(theNewBounds);	// This will also set the bounds of the picture, as we have											// tied it to its parent on all edges		}void CDocumentApp::HandleSplashScreen(){	// There are three possible files we deal with here. Startup Movie takes precidence over	// Startup Picture. Startup Sound is played only if Startup Picture is displayed. We	// display the movie only if Quicktime is present		// We display the splash screen if the SplashScreen file exists in the same folder as the	// application. If it exists, we also will play a sound file if one exists in the folder.	// The first thing we do is create a FSSpec for the picture file. It should be a PICT file in the	// current folder with the name defined by kStartupPictureFileName.		FInfo theFInfo;	#if FALSE		// Note that we cannot use the UQuicktime::Initialize and IsQuicktimePresent here because we do not	// want to initialize Quicktime if there is no movie file present. The Initialize function does that,	// and we want to avoid that overhead. So we check the Gestalt ourselves		SInt32	qtVersion;	Boolean	qtPresent = (::Gestalt(gestaltQuickTime, &qtVersion) == noErr)							&& CFM_AddressIsResolved_(::EnterMovies);	FSSpec theStartupMovieFile;		OSErr makeErr = ::FSMakeFSSpec(mApplSpec.vRefNum, 							 mApplSpec.parID, 							 kStartupMovieFileName, 							 &theStartupMovieFile);		makeErr = FSpGetFInfo(&theStartupMovieFile, &theFInfo);	if (qtPresent && (makeErr == noErr) && (theFInfo.fdType == MovieFileType)) // The file exists and we have quicktime	{		// Make sure QuickTime is set up properly. This duplicates the call to Gestalt above, but that's not a problem.		// We do have to call this to make sure UEnvironment is set properly, though.				UQuickTime::Initialize();				OSErr	err;		SInt16	movieRefNum;		err = ::OpenMovieFile(&theStartupMovieFile, &movieRefNum, fsRdPerm);		ThrowIfOSErr_(err);				SInt16	actualResID = DoTheRightThing;		Boolean	wasChanged;		Movie theMovie;				err = ::NewMovieFromFile(&theMovie, movieRefNum, &actualResID,									nil, newMovieActive, &wasChanged);		ThrowIfOSErr_(err);											err = ::CloseMovieFile(movieRefNum);		ThrowIfOSErr_(err);		// Get the size of the rectangle that contains the movie. That will be the size of the		// pane we will construct.				Rect theMovieSize;		::GetMovieBox(theMovie, &theMovieSize);					StSplashDialogHandler theSplashScreen ( PPob_SplashDialog, this );		LWindow *theDialog = theSplashScreen.GetDialog();					SPaneInfo thePaneInfo;		SBooleanRect theBindings;				theBindings.left = true;		theBindings.top = true;		theBindings.right = true;		theBindings.bottom = true;				thePaneInfo.paneID = 'spqt';		thePaneInfo.width = theMovieSize.right - theMovieSize.left;		thePaneInfo.height = theMovieSize.bottom - theMovieSize.top + 16;		thePaneInfo.visible = true;		thePaneInfo.enabled = true;		thePaneInfo.bindings = theBindings;		thePaneInfo.left = 2;		thePaneInfo.top = 2;		thePaneInfo.userCon = 0;		thePaneInfo.superView = theDialog;				// We don't want a controller, so tell the constructor to not create one.				SMoovControllerInfo theControllerInfo;				theControllerInfo.initFlags = mcNotVisible | mcTopLeftMovie;		theControllerInfo.actionFlags = 0;		theControllerInfo.moovAliasID = 0;		theControllerInfo.moovRsrcID = 0;		theControllerInfo.moovFlags = newMovieActive;				LMoovController* theMovieController = new LMoovController(thePaneInfo, theControllerInfo);		ThrowIfNil_(theMovieController);				theMovieController->SetMovie(theMovie, true);				// Get the size of the rectangle that contains the movie. That will be the size of the		// pane we will construct.				SDimension16 theFrameSize;				theMovieController->ResizeMovieTo(thePaneInfo.width, thePaneInfo.height, false);				theMovieController->GetFrameSize(theFrameSize);		theMovieSize.top = 0;		theMovieSize.left = 0;		theMovieSize.right = theFrameSize.width;		theMovieSize.bottom = theFrameSize.height;				SetDialogBounds(theDialog, theMovieSize);				// We have to refresh the display after we've resized the movie dialog						theMovieController->ResizeMovieTo(thePaneInfo.width, thePaneInfo.height, true);				// Now, show the pane and the dialog				theDialog->Show();				theMovieController->StartPlaying(true);				// Loop around until we get any message other than		// msg_Nothing. This allows the user to just click in the box or type a character		// to make it go away. 				MessageT theMessage = msg_Nothing;		do 		{			theMessage = theSplashScreen.DoDialog();						// We clear out of here if the movie stops playing.						if (!theMovieController->IsPlaying())				break;						} while ( theMessage == msg_Nothing );				// Cleanup				delete theMovieController;		UQuickTime::Finalize();	}	else#endif	{	FSSpec theStartupPictureFile;		OSErr makeErr = ::FSMakeFSSpec(mApplSpec.vRefNum, 							 mApplSpec.parID, 							 kStartupPictureFileName, 							 &theStartupPictureFile);		FInfo theFInfo;		makeErr = FSpGetFInfo(&theStartupPictureFile, &theFInfo);	if ((makeErr == noErr) && ((theFInfo.fdType == kPICTType) || (theFInfo.fdType == kJPEGType))) // The file exists	{		Rect thePictureSize;					StSplashDialogHandler theSplashScreen ( PPob_SplashDialog, this );		LWindow *theDialog = theSplashScreen.GetDialog();					CEyeDxViewType* thePicture = (CEyeDxViewType*) theDialog->FindPaneByID (kSplashDialogView);		ThrowIfNil_(thePicture);				// Now, open the image file, get the image size, and resize the dialog and the picture object		// within it to hold the picture. We have to account for the window's structure region. So we		// get the size of the Window's Content and Structure Regions.		// The difference is added to the picture size to adjust it correctly.				// Ok, now we've set things up for the dialog. See if the file is a PICT or JPEG				if (theFInfo.fdType == kPICTType)	// It's a PICT file		{						PicHandle theImage;			PowerPaintPictFile thePictFile(theStartupPictureFile);						try			{				theImage = thePictFile.ReadPicture();			}						catch (...)			{				return;	// Can't display the file - too much memory required			}						thePictFile.GetBounds(thePictureSize);			SetDialogBounds(theDialog, thePictureSize);						// This will reset the GWorld so that its size matches the new dialog size			thePicture->ResetImage();						thePicture->DrawPicture(theImage);						// The thePictFile will be deleted when we exit the block, and the associated PicHandle will			// also be freed		}		else if (theFInfo.fdType == kJPEGType)		{			int rows, cols;			CEyeDxHandleType theImage;								FILE *fileptr = FSp_fopen((ConstFSSpecPtr)&theStartupPictureFile, "rb");											if (ReadImage(fileptr, &theImage, &rows, &cols, nil, nil, nil, nil, true) == 0)				return;	// Can't display the picture!							::SetRect(&thePictureSize, 0, 0, (short)cols, (short)rows);						SetDialogBounds(theDialog, thePictureSize);						// This will reset the GWorld so that its size matches the new dialog size			thePicture->ResetImage();						::HLock((Handle)theImage);			thePicture->SetImageFromRaw24Bit((unsigned char *)*theImage, rows, cols);			::HUnlock((Handle)theImage);						::DisposeHandle(theImage);		}				// Now see if there is a sound file available. If so, open it and get the file reference number.				FSSpec theStartupSoundFile;				makeErr = ::FSMakeFSSpec(mApplSpec.vRefNum, 								 mApplSpec.parID, 								 kStartupSoundFileName, 								 &theStartupSoundFile);						makeErr = FSpGetFInfo(&theStartupSoundFile, &theFInfo);		LFile *theSndFile = nil;		if ((makeErr == noErr) && (theFInfo.fdType == kSoundFileType)) // The file exists			theSndFile = new LFile(theStartupSoundFile);					// Now, show the window and the dialog						thePicture->Show();				theDialog->Show();			if (theSndFile)		{			short curResFile = ::CurResFile();						short sndResForkRefNum = theSndFile->OpenResourceFork(fsRdPerm);						::UseResFile(sndResForkRefNum);			SndListHandle	theSoundH = (SndListHandle)::Get1NamedResource('snd ', theStartupSoundFile.name);			OSErr theStatus = ::ResError();			::UseResFile(curResFile);						if (theSoundH)			{				USoundPlayer::PlaySound(theSoundH);	// The source name must match the file name								// The USoundPlayer class makes a copy of the handle, so we can dispose it here				::DisposeHandle((Handle)theSoundH);			}			else			{				if (theStatus == memFullErr)					::ParamText("\pUnable to load sound file due to insuffient memory. Try increasing application memory allocation.", Str_Empty, Str_Empty, Str_Empty);				else				{					LStr255 theErrorCode = (long) theStatus;					::ParamText("\pSorry. Error ", theErrorCode,							  "\p occurred while trying to load the Startup Sound file. Please contact EyeDx customer service.", Str_Empty);				}								UModalAlerts::CautionAlert(PPob_GeneralALRT);				delete theSndFile;				theSndFile = nil;			}		}		// Loop around until we get any message other than		// msg_Nothing. This allows the user to just click in the box or type a character		// to make it go away. 				MessageT theMessage = msg_Nothing;		do 		{			theMessage = theSplashScreen.DoDialog ();						// We clear out of here if the sound stops playing - note that we check the sound only if			// the sound file was valid, otherwise the USoundPlayer object will be uninitialized.						if (theSndFile && !USoundPlayer::SoundStillPlaying())				break;						} while ( theMessage == msg_Nothing );				if (theSndFile)		{			USoundPlayer::StopCurrentSound();			delete theSndFile;		}	}}}#if FALSE// ---------------------------------------------------------------------------------//		¥ OpenDocument// ---------------------------------------------------------------------------------// This method is called when a file is chosen from the StandardFile Open Dialog// File_Menu->Open item.voidCDocumentApp::OpenDocument(	FSSpec	*inMacFSSpec ){	PP_PowerPlant::LDocument	*theDoc = PP_PowerPlant::LDocument::FindByFileSpec(*inMacFSSpec);		// If the document is already open, make it the current document	if (theDoc != nil) {						theDoc->MakeCurrent();			// otherwise, make a new Document	} else {									theDoc = new CTextDocument(this, inMacFSSpec);	}}// ---------------------------------------------------------------------------------//		¥ MakeNewDocument// ---------------------------------------------------------------------------------// This method creates a new document and installs it into the application's// Apple Event Object Model hierarchy.PP_PowerPlant::LModelObject *CDocumentApp::MakeNewDocument(){	// Make a new empty document.	return new CTextDocument( this, nil );	return NULL;}// ---------------------------------------------------------------------------------//		¥ ChooseDocument// ---------------------------------------------------------------------------------// This method uses the PowerPlant Standard Dialogs to let the user choose a// document to open.voidCDocumentApp::ChooseDocument(){	PP_PowerPlant::PP_StandardDialogs::LFileChooser	chooser;		if (chooser.AskOpenFile(PP_PowerPlant::LFileTypeList('TEXT'))) {		AEDescList		docList;		chooser.GetFileDescList(docList);		OpenOrPrintDocList(docList, PP_PowerPlant::ae_OpenDoc);	}}// ---------------------------------------------------------------------------------//		¥ PrintDocument// ---------------------------------------------------------------------------------// This method is called when the FileMenu->Print item is chosen.voidCDocumentApp::PrintDocument(	FSSpec	*inMacFSSpec ){	// Create a new document using the file spec.	CTextDocument	*theDocument = new CTextDocument( this, inMacFSSpec );	// Tell the document to print.	theDocument->DoPrint();}#endif// This function is used to create (and possibly recreate) subfolders. Recreating them// on the fly allows the user to rename the folders for organizational purposes. It also// allows for implementation of the session scheme. We just create the session folders// as needed.void CDocumentApp::CreateFolders(){	OSErr theErr;	FSSpec theSessionSpec;	CEyeDxLongStringType *theSessionName;	CEyeDxLongStringType theSessionNamePath;		CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	if (theSessionNameVariable)		theSessionName = theSessionNameVariable->GetValue();	else		return;	// A failure that should not occur			theSessionNamePath = "\p:";	theSessionNamePath.Append(*theSessionName);	//theSessionNameStr = theSessionName;		// First, create the session folder				LString::CopyPStr(theSessionNamePath, theSessionSpec.name);		if ((theErr = mFolderFinder.FindFolderNamed(theSessionSpec.name, theSessionSpec.parID, theSessionSpec.vRefNum)) != noErr)		ThrowOSErr_(theErr);		// Create an FSSpec for each of the subdirectories of the session folder. If the specified	// folder doesn't exist, the routine will create it.		LString::CopyPStr(theSessionNamePath, mReportsSpec.name);	LString::AppendPStr(mReportsSpec.name, "\p:reports");		if ((theErr = mFolderFinder.FindFolderNamed(mReportsSpec.name, mReportsSpec.parID, mReportsSpec.vRefNum)) != noErr)		ThrowOSErr_(theErr);	LString::CopyPStr(theSessionNamePath, mSImagesSpec.name);	LString::AppendPStr(mSImagesSpec.name, "\p:Simages");		if ((theErr = mFolderFinder.FindFolderNamed(mSImagesSpec.name, mSImagesSpec.parID, mSImagesSpec.vRefNum)) != noErr)		ThrowOSErr_(theErr);	LString::CopyPStr(theSessionNamePath, mPImagesSpec.name);	LString::AppendPStr(mPImagesSpec.name, "\p:Pimages");		if ((theErr = mFolderFinder.FindFolderNamed(mPImagesSpec.name, mPImagesSpec.parID, mPImagesSpec.vRefNum)) != noErr)		ThrowOSErr_(theErr);	LString::CopyPStr(theSessionNamePath, mEyesSpec.name);	LString::AppendPStr(mEyesSpec.name, "\p:eyes");		if ((theErr = mFolderFinder.FindFolderNamed(mEyesSpec.name, mEyesSpec.parID, mEyesSpec.vRefNum)) != noErr)		ThrowOSErr_(theErr);				OSErr makeErr;	makeErr = ::FSMakeFSSpec(mReportsSpec.vRefNum, mReportsSpec.parID, nil, &mReportDirSpec);	makeErr = ::FSMakeFSSpec(mPImagesSpec.vRefNum, mPImagesSpec.parID, nil, &mPImagesDirSpec);	// Finally, we copy the EyeDxLogo.jpg file into the new session folder		FSSpec theLogoSpec;	makeErr = ::FSMakeFSSpec(theSessionSpec.vRefNum, theSessionSpec.parID, "\pEyeDxLogo.jpg", &theLogoSpec);	// Try to delete the destination file. If it already exists, the FileCopy routine will complain and not	// overwrite it. So, we try to delete it whether or not exists, and ignore the result of the delete.		makeErr = ::FSpDelete(&theLogoSpec);		makeErr = FileCopy(mApplSpec.vRefNum, mApplSpec.parID, "\pEyeDxLogo.jpg",					   theLogoSpec.vRefNum, theLogoSpec.parID, nil, nil, nil, 0L, true);}void CDocumentApp::HideMoveShow(LWindow *toHide, LWindow *toShow){	Rect	theRect;	if (toHide)	{		toHide->Hide();		toHide->GetGlobalBounds(theRect);		toShow->MoveWindowTo(theRect.left, theRect.top);	}	toShow->Show();	toShow->Activate();}void CDocumentApp::HandleAbout(){	// Create the dialog handler.	StDialogHandler theHandler( PPob_AboutDialog, this );	// Get the dialog.	CAboutDialog *theDialog;	theDialog = dynamic_cast<CAboutDialog *>(theHandler.GetDialog());	ThrowIfNil_(theDialog);		theDialog->SetupDialog(mBrowserCreatorCode);		// Make the dialog visible.	theDialog->Show();		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_AbtD_EyeDxURL:		case msg_AbtD_EyeDxEmail: 		case msg_Cancel:		case msg_OK: 				done = true;		}	}}BooleanCDocumentApp::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) 	{					case cmd_Quit:		{			// Always close the camera if left open!						CloseCamera(nil);			// Now we check to see if the user is running a session other than the default, ask if they want to end the session			// or remember it for the next run.						CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));			if (theSessionNameVariable)			{				CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();								if (*theSessionName != CommonStringLiteral_(kDefaultSessionName))				{										// Prompt the user and ask if they wish to save this session for later use										// If they say to end the session, perform the end session functions, and then set the session name 					// to the default name					::ParamText("\pThe current session is '", *theSessionName, "\p'. Do you want to end this session, or remember it for use next time?", Str_Empty);					DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_SessionQuitALRT);					if (item_hit == PPob_SessionQuitALRT_No)					{						::HLock(mReportCustomText[kReportLayoutSessionSummaryText]);								HandleEndOfSession(this, &mVariableList, mMainSessionButton, nil, 											theSessionNameVariable, 											*mReportCustomText[kReportLayoutSessionSummaryText], 											::GetHandleSize(mReportCustomText[kReportLayoutSessionSummaryText]),											mPromptingPrefs.promptingStyle, true);									::HUnlock(mReportCustomText[kReportLayoutSessionSummaryText]);					}				}			}			cmdHandled = LDocApplication::ObeyCommand(inCommand, ioParam);		}		break;				case cmd_Preferences:		{			Boolean theResult = CDocumentApp::HandlePreferences();			CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));			UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, mMainSessionButton, nil);					}		break;		#if FALSE		case cmd_ReportLayout:		{			Boolean theResult = CDocumentApp::HandleReportLayout();		}		break;#endif				case cmd_About:		{			CDocumentApp::HandleAbout();			cmdHandled = true;		}		break;				case cmd_ExportReports:		{			CDocumentApp::HandleExportReports(false);			cmdHandled = true;		}		break;				case cmd_ExportReportsforEmailing:		{			CDocumentApp::HandleExportReports(true);			cmdHandled = true;		}		break;				case cmd_InstallLicense:		{			CDocumentApp::HandleLicenseEntry(GetLicenseStatus(), false);			cmdHandled = true;		}		break;				case cmd_DisplayLicense:		{			CDocumentApp::HandleLicenseDisplay(GetLicenseStatus());			cmdHandled = true;		}		break;				case cmd_DisplayReports:		{			BroadcastMessage(msg_MainViewReport, 0);			cmdHandled = true;		}		break;				case cmd_RunFromCamera:		{			BroadcastMessage(msg_MainRunFromCamera, 0);			cmdHandled = true;		}		break;#if FALSE		case cmd_RunFromCameraAuto:		{			CDocumentApp::HandleRunFromCameraAuto();			cmdHandled = true;		}		break;#endif			case cmd_RunFromDisk:		{			BroadcastMessage(msg_MainRunFromDisk, 0);			cmdHandled = true;		}		break;				case cmd_SelectUpImage:		{			if (RunInProgress == 1)				BroadcastMessage(msg_CameraUpSelectImage, 0);			else				BroadcastMessage(msg_DiskUpSelectImage, 0);			cmdHandled = true;		}		break;				case cmd_SelectSideImage:		{			if (RunInProgress == 1)				BroadcastMessage(msg_CameraSideSelectImage, 0);			else				BroadcastMessage(msg_DiskSideSelectImage, 0);			cmdHandled = true;		}		break;				case cmd_DisplayAnimation:		{			// Toggle the value of DisplayGraphics						SInt32 newDispGraphics = (DisplayGraphics ? 0 : 1);						if (RunInProgress == 1)				BroadcastMessage(msg_CameraAnimate, &newDispGraphics);			else				BroadcastMessage(msg_DiskAnimate, &newDispGraphics);			cmdHandled = true;		}		break;				default:			cmdHandled = LDocApplication::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}voidCDocumentApp::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	outUsesMark = false;	switch (inCommand) 	{			case cmd_DisplayLicense:			// The user can also display the			// current license status at anytime			outEnabled = true;			break;								case cmd_Preferences:		case cmd_RunFromCamera:		//case cmd_RunFromCameraAuto:		case cmd_RunFromDisk:		case cmd_ExportReports:		case cmd_ExportReportsforEmailing:		case cmd_DisplayReports:		case cmd_InstallLicense:			// These options are available only when we aren't running						if (RunInProgress == 0)				outEnabled = true;			else				outEnabled = false;							break;		case cmd_SelectUpImage:		case cmd_SelectSideImage:					// These options are available only when we are running						if (RunInProgress == 0)				outEnabled = false;			else				outEnabled = true;							break;		case cmd_DisplayAnimation:					// These options are available only when we are running						if (RunInProgress == 0)			{				outEnabled = false;				outUsesMark = true;				if (DisplayGraphics)					outMark = checkMark;				else					outMark = noMark;			}			else			{				outEnabled = true;				outUsesMark = true;				if (DisplayGraphics)					outMark = checkMark;				else					outMark = noMark;			}							break;		default:			LDocApplication::FindCommandStatus(inCommand, outEnabled,											outUsesMark, outMark, outName);			break;	}}void CDocumentApp::CleanupUpImage(CEyeDxViewType *theUpView){	if (mUpHandle != NULL)	{		DisposeHandle(mUpHandle);		mUpHandle = NULL;		up_image = NULL;		UP_ROWS = UP_COLS = 0;	}	// We always reset the specified view if it is passed		if (theUpView)		theUpView->ResetImage();	strcpy(up_filename,"");}void CDocumentApp::CleanupSideImage(CEyeDxViewType *theSideView){	if (mSideHandle != NULL)	{		DisposeHandle(mSideHandle);		mSideHandle = NULL;		side_image = NULL;		SIDE_ROWS = SIDE_COLS = 0;	}	// We always reset the specified view if it is passed		if (theSideView)		theSideView->ResetImage();	strcpy(side_filename,"");	}void CDocumentApp::CleanupImages(CEyeDxViewType *theUpView, CEyeDxViewType *theSideView){	CleanupUpImage(theUpView);	CleanupSideImage(theSideView);		RunInProgress = 0;}						    EyeDxNextStepCode CDocumentApp::AnalyzeImages( LWindow *theWindow, 						    CEyeDxViewType *theUpView,						    CEyeDxViewType *theSideView,						    CEyeDxBooleanType SaveFullInputImages,						    CEyeDxBooleanType showRetakeOptions,						    CEyeDxBooleanType cleanupImages,						    EyeDxNextStepCode imagesToAnalyze){	#ifdef LOGGING	logmemtofile(logfile, "AnalyzeImages() - start");#endif	// Reset the images		mAnalysisUpView->ResetImage();	mAnalysisSideView->ResetImage();	mAnalysisMainView->ResetImage();		// Once we are done, hide the Run window and display the Analysis Window	HideMoveShow(theWindow, mAnalysisWindow);	// Now, set up the analysis window. If the Display Graphics flag is set, we	// hide the two small thumbnail views, and enable the larger view. Otherwise,	// we set the thumbnail views to match the images in the Run window views	// We first hide all of the views so that they don't change state while the window	// is visible		mAnalysisUpView->Hide();	mAnalysisSideView->Hide();	mAnalysisMainView->Hide();	mAnalysisMainViewGroupBox->Hide();	mAnalysisUpViewGroupBox->Hide();	mAnalysisSideViewGroupBox->Hide();		mAnalysisProgressCaption->Show();	mAnalysisThermometerPane->Show();		// Lock the image handles so that we can dereference the handles to get pointer to	// pass to the lower-level routines.					::HLock(mUpHandle);	up_image = (unsigned char *)*mUpHandle;	::HLock(mSideHandle);	side_image = (unsigned char *)*mSideHandle;	if (DisplayGraphics)	{		mAnalysisMainView->Show();		mAnalysisMainViewGroupBox->Show();	}	else	{		Str255 theFilename;		mAnalysisUpView->Show();		mAnalysisUpViewGroupBox->Show();		mAnalysisSideView->Show();		mAnalysisSideViewGroupBox->Show();				c2pstrcpy(theFilename, up_filename);		mAnalysisUpCaption->SetDescriptor(theFilename);		mAnalysisUpCaption->Show();		mAnalysisUpCaption->Draw(nil);				c2pstrcpy(theFilename, side_filename);		mAnalysisSideCaption->SetDescriptor(theFilename);		mAnalysisSideCaption->Show();		mAnalysisSideCaption->Draw(nil);		mAnalysisUpView->SetImageFromRaw24Bit(up_image, UP_ROWS, UP_COLS);		mAnalysisSideView->SetImageFromRaw24Bit(side_image, SIDE_ROWS,SIDE_COLS);	}	// Force a refresh of the window to get the thermometer and caption to update properly		mAnalysisWindow->Draw(nil);		char *reportText[kReportLayoutNumText];	long reportTextSize[kReportLayoutNumText];		// Convert each of the text blocks into a pointer and a length		for (ResID i = 0; i < kReportLayoutNumText; i++)	{			if (mReportCustomText[i] != nil)		{			::HLock(mReportCustomText[i]);					reportText[i] = *mReportCustomText[i];			reportTextSize[i] = ::GetHandleSize(mReportCustomText[i]);		}		else		{			reportText[i] = NULL;			reportTextSize[i] = 0;		}	}		// Save the picture information in the appropriate variables		SavePictureInformation(&mVariableList, mUpPictInfoValid, mUpGenericPictInfo, mUpPictInfo, 									  mSidePictInfoValid, mSideGenericPictInfo, mSidePictInfo);		// Depending on whether we are doing reanalysis or not, we will tell the EyeDx routine to	// process both or just one of the two images by passing NULL pointers for the images to skip.	// We use the passed-in value of the previous results code to determine what to do here.	// The default is the Continue, which is used in non-Auto modes and also in non-retake	// processing in Auto mode.		char *up_selector;	char *side_selector;		switch (imagesToAnalyze)	{	case kNextStepContinue:	case kNextStepRetakeBoth:			up_selector = up_filename;		side_selector = side_filename;			break;			case kNextStepRetakeUp:			up_selector = up_filename;		side_selector = NULL;							break;			case kNextStepRetakeSide:			up_selector = NULL;		side_selector = side_filename;							break;	}					// Note that mAnalysisResults is a member of our class, which will preserve the values calculated	// by the EyeDx routine. Depending on the selectors, the values in the passed-in analysis results	// may be used in lieu of performing an analysis, in the retake cases.		EyeDx(up_selector, side_selector, SideWhichWay, SaveFullInputImages, mReportPrefs.adjustName, 			&mAnalysisResults, NULL, mAnalysisMainView, mAnalysisThermometerPane, mAnalysisProgressCaption,			(EyeDxReportFormat) mReportPrefs.formatOption,			&mVariableList,			reportText,			reportTextSize,			kReportLayoutNumText);	// Unlock the handles							//::HUnlock(mReportOptionalText);		::HUnlock(mUpHandle);	::HUnlock(mSideHandle);	for (ResID i = 0; i < kReportLayoutNumText; i++)	{			if (mReportCustomText[i] != nil)			::HUnlock(mReportCustomText[i]);	}			// Update the license if the analysis was successful		if ((mAnalysisResults.ReferralCode == kYesReferralCode) ||		(mAnalysisResults.ReferralCode == kNoReferralCode))	{		LicenseError theStatus = DecrementLicenseCounter();		if (theStatus != kLicenseNoError)		{			LStr255 theErrorCode = (long) theStatus;			::ParamText("\pSorry. Error ", theErrorCode,					  "\p occurred updating your license. Please contact EyeDx customer service.", Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);		}	}			// Now, reset the referral indicator if the user chose not to prepend then strings on the	// report name.			if (mBrowserCreatorCode == kUnknownType)	{		CDocumentApp::HandlePreferences();		CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));		UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, mMainSessionButton, nil);				}	// Set the creator of the report file to the specified browser	FSSpec theReportFSSpec;	FInfo theReportFInfo;	__path2fss(mAnalysisResults.Report_path, &theReportFSSpec);	FSpGetFInfo(&theReportFSSpec, &theReportFInfo);	theReportFInfo.fdCreator = mBrowserCreatorCode;	FSpSetFInfo(&theReportFSSpec, &theReportFInfo);		// To make the window look a bit nicer, we hide some of the elements		mAnalysisThermometerPane->Hide();	mAnalysisProgressCaption->Hide();			// Display the report if requested to do so. Note that the OpenReport routine handles	// the display of an alert if an error occurs. We return a next step indicator, which might be	// generated by the summary display. By default, we return the continue indication.		EyeDxNextStepCode theResult = kNextStepContinue;		// Image cleanup gets a bit tricky. If we are told to fork the browser to display the report,	// then we check to do cleanup before opening the report to minimize memory usage.		// If we are displaying the Summary Window, however, we need to keep the full images around	// so that we can display zoomed versions of them at user request. So we clean up afterwards.		// If neither the browser or summary option is selected, that means that we should always check for	// cleanup		if (mReportPrefs.displayOption == kDisplayReport)	{		// Now, clean up everything. In order to		// support retakes, we do this based on the passed-in flag. If the caller says not to do it,		// they are responsible for cleanup.		if (cleanupImages)			CleanupImages(theUpView, theSideView);		OSErr openErr = OpenReport(&theReportFSSpec);	}	else	if (mReportPrefs.displayOption == kDisplaySummary)	{		// Note that if not enough memory is available they may not be able to fork the browser		// to display the report!				theResult = HandleSummaryDisplay(&mAnalysisResults, &theReportFSSpec, showRetakeOptions);		// Now, clean up everything. In order to		// support retakes, we do this based on the passed-in flag. If the caller says not to do it,		// they are responsible for cleanup.		if (cleanupImages)			CleanupImages(theUpView, theSideView);	}	else	{		// Now, clean up everything. In order to		// support retakes, we do this based on the passed-in flag. If the caller says not to do it,		// they are responsible for cleanup.		if (cleanupImages)			CleanupImages(theUpView, theSideView);	}		RunInProgress = 0;	#ifdef LOGGING	logmemtofile(logfile, "AnalyzeImages() - end");#endif	return (theResult);}// ---------------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------------voidCDocumentApp::ListenToMessage(	MessageT	inMessage,	void		*ioParam ){		// The main application handles messages for itself and all pop-up windows. It keeps	// application state in several variables.		// Indicates whether the file open call was successful		CEyeDxBooleanType	openOK = false;	// We build a temporary object listing the file types we are interested in - namely, KDC, JPEG and TEXT		PP_PowerPlant::LFileTypeList	theImageFileTypes(PP_PowerPlant::fileTypes_All);	PP_PowerPlant::LFileTypeList	theTEXTFileTypes('TEXT');	// We also build temporary file chooser objects using the Standard File dialogs		PP_PowerPlant::PP_StandardDialogs::LFileChooser	theImageChooser;	PP_PowerPlant::PP_StandardDialogs::LFileChooser	theReportChooser;		// Set up the filter proc for theImageChooser to look for just kKDCType, 	// and files ending with extension ".kdc".		theImageChooser.SetPreviewProc((NavPreviewProcPtr) MyNavImagePreviewFilter);	theImageChooser.SetObjectFilterProc((NavObjectFilterProcPtr) MyNavImageObjectFilter);	theReportChooser.SetObjectFilterProc((NavObjectFilterProcPtr) MyNavReportObjectFilter);			// Change the last file spec into a directory spec for the image chooser to use		//OSErr makeErr = ::FSMakeFSSpec(mLastImageDirSpec.vRefNum, mLastImageDirSpec.parID, nil, &mLastImageDirSpec);	// Handle the specific message		switch ( inMessage ) 	{			///////////// Messages for the Control window /////////////				// Handle the Session Management Button				case msg_MainSessionButton:		{			// If we are currently using the default session, the the button says "Start Session". So, we			// call the HandleNewSession routine.						// Otherwise, we are in an active session, and want to close out this one. Note that in this specific			// case we don't care about the return values. The state of the current session will be self-consistent			// regardless of whether the user completed the operation or Cancelled.						// In all cases, the subroutines will update the main window button's label as required.						CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));			CEyeDxLongStringType *theSessionName = theVariable->GetValue();						if (*theSessionName == CommonStringLiteral_(kDefaultSessionName))				HandleNewSession(this, &mVariableList, mMainSessionButton, nil, mPromptingPrefs.promptingStyle);			else			{				::HLock(mReportCustomText[kReportLayoutSessionSummaryText]);						HandleEndOfSession(this, &mVariableList, mMainSessionButton, nil, theVariable, 									*mReportCustomText[kReportLayoutSessionSummaryText], 									::GetHandleSize(mReportCustomText[kReportLayoutSessionSummaryText]), 									mPromptingPrefs.promptingStyle);				::HUnlock(mReportCustomText[kReportLayoutSessionSummaryText]);			}						// Create the subfolders in case the user changed the session						CreateFolders();						// Set the default image and report directories to the current session's			// Pimages and reports directories since that is the logical location.							mLastImageDirSpec = mPImagesDirSpec;			mLastReportDirSpec = mReportDirSpec;		}		break;				// Handle the Run From Camera button				case msg_MainRunFromCamera:		{			// Check for available license status						if (GetLicenseStatus() != LicenseStatusValid)			{				HandleLicenseExpired(GetLicenseStatus());				break;			}							// Handle memory leaks gracefully!					if (FreeMem() < kRunThreshold)			{			 	::ParamText("\pThere is insufficent Application memory to run analysis.",			 				"\pPlease quit the application and restart it.", Str_Empty, Str_Empty);				UModalAlerts::StopAlert(PPob_GeneralALRT);							break;			}						StCursor wait;	// Set the pointer to the stop watch while we are setting up						// Create the subfolders in case the user renamed them						CreateFolders();						// Prompt for camera setup. If this returns cancel, then we're done. If this returns			// msg_OK, we run the automatic mode. If msg_CameraSetup_ManualButton is returned, we 			// run the manual mode.						MessageT theResponse = HandleCameraSetup(mFirstTimeAutoStart);						mFirstTimeAutoStart = false;						if (theResponse == msg_Cancel)				break;							else if (theResponse == msg_OK)			{				// We turn off the animation as it is not supported in the Auto mode				DisplayGraphics = false;				mCameraAnimate->SetValue(DisplayGraphics);				mDiskAnimate->SetValue(DisplayGraphics);				HandleRunFromCameraAuto();				// We also update the main window Session button in case the user changed sessions during this mode.				// This won't happen because the code for the mode will be updating only its own button and caption.								CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));				UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, mMainSessionButton, nil);						}			else			{				HandleStartOfSubject(&mVariableList);								// Update the license status caption								SetLicenseStatusCaption(mCameraLicenseStatusCaption);								// And indicate the current session								CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));				UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, nil, mCameraSessionCaption);							// Reset whether the user has selected the files.								mUpSelected = false;				mSideSelected = false;				mUpImageDownloaded = false;					mSideImageDownloaded = false;										mCameraUpPictureQualityIcon->Hide();				mCameraSidePictureQualityIcon->Hide();								// Hide the Control Window and show the Run From Disk window								HideMoveShow(mMainWindow, mCameraWindow);				mCameraUpCaption->SetDescriptor(Str_Empty);				mCameraSideCaption->SetDescriptor(Str_Empty);								mCameraUpView->ResetImage();				mCameraSideView->ResetImage();				mCameraReportName->SetDescriptor("\p");				// Here we attempt to connect to the camera. If that is successful,				// we load in the first two images if available as the Up and Side images.				// Then we wait for user input.								mCameraUpProgressCaption->SetDescriptor("\pConnecting to camera...");				mCameraUpProgressCaption->Draw(nil);				// Force a refresh of the window to get the window elements to update properly								mCameraWindow->Draw(nil);								DCPortNum thePortNum = (DCPortNum) mCameraPrefs.defaultPort;				if (!ConnectToCamera(this, mCameraUpProgressCaption, mCameraSideProgressCaption, 										mCameraUpView, mCameraUpCaption, 										mCameraSideView, mCameraSideCaption,										&mUpGenericPictInfo, &mSideGenericPictInfo, 										&mUpPictInfo, &mSidePictInfo, 										&thePortNum, (DCBitRate) mCameraPrefs.portSpeed))				{					CloseCamera(nil);					HideMoveShow(mCameraWindow, mMainWindow);				}				else				{					mCameraPrefs.defaultPort = (long) thePortNum;					// Save the preferences - this will record the last port used for the camera										mPreferences->SaveCameraPrefs(&mCameraPrefs);						mCameraUpPictureQualityIcon->Show();					mCameraSidePictureQualityIcon->Show();										mUpPictInfoValid = true;					mSidePictInfoValid = true;										// We handle three separate cases here, so that the user sees only one notice, rather than					// possibly two successive ones.										// If the quality isn't what we should be using, warn the user					if ((mUpPictInfo.PictQuality != DC120BestQuality) || (mSidePictInfo.PictQuality != DC120BestQuality))					{						Str255 thePrompt;						Str255 theEndPrompt;												// Default to the singular case												LString::CopyPStr("\pthe picture.", theEndPrompt);												// One, or the other or both images are not Best quality. Create an appropriate message												if ((mUpPictInfo.PictQuality != DC120BestQuality) && (mSidePictInfo.PictQuality != DC120BestQuality))						{							LString::CopyPStr("\pNeither image was", thePrompt);							LString::CopyPStr("\pboth pictures.", theEndPrompt);							mCameraUpPictureQualityIcon->SetIconID(kCautionQualityIconList);							mCameraSidePictureQualityIcon->SetIconID(kCautionQualityIconList);						}						else if (mUpPictInfo.PictQuality != DC120BestQuality)						{							LString::CopyPStr("\pThe Up image was not", thePrompt);							mCameraUpPictureQualityIcon->SetIconID(kCautionQualityIconList);							mCameraSidePictureQualityIcon->SetIconID(kGoodQualityIconList);						}						else if (mSidePictInfo.PictQuality != DC120BestQuality)						{							LString::CopyPStr("\pThe Side image was not", thePrompt);							mCameraUpPictureQualityIcon->SetIconID(kGoodQualityIconList);							mCameraSidePictureQualityIcon->SetIconID(kCautionQualityIconList);						}											 	::ParamText(thePrompt,					 				"\ptaken with the recommended 'Best' image quality setting,",					 				"\pand analysis may produce incorrect results. EyeDx recommends you retake",					 				theEndPrompt);						UModalAlerts::CautionAlert(PPob_GeneralALRT);					}					else					{						mCameraUpPictureQualityIcon->SetIconID(kGoodQualityIconList);						mCameraSidePictureQualityIcon->SetIconID(kGoodQualityIconList);					}										mCameraUpProgressCaption->SetDescriptor(Str_Empty);					mCameraUpProgressCaption->Draw(nil);					mCameraSideProgressCaption->SetDescriptor(Str_Empty);					mCameraSideProgressCaption->Draw(nil);										// Set the maximum number of characters in the Name field to the legal length										int theMaxReportNameLength = kMaxReportNameLength;										// If the adjustName option is turned on, we have to account for the prefix length					// when testing the maximum report name length.										if (mReportPrefs.adjustName)						theMaxReportNameLength -= kPrefixLength;						mCameraReportName->SetMaxChars(theMaxReportNameLength);										// Force a refresh of the window to get the thermometer and caption to hide properly									mCameraWindow->Draw(nil);					RunInProgress = 1;										mCameraUpZoomButton->Show();					mCameraSideZoomButton->Show();				}			}		}		break;		// Handle the Run From Disk button		case msg_MainRunFromDisk:		{			// Check for available license status						if (GetLicenseStatus() != LicenseStatusValid)			{				HandleLicenseExpired(GetLicenseStatus());				break;			}							// Handle memory leaks gracefully!					if (FreeMem() < kRunThreshold)			{			 	::ParamText("\pThere is insufficent Application memory to run analysis.",			 				"\pPlease quit the application and restart it.", Str_Empty, Str_Empty);				UModalAlerts::StopAlert(PPob_GeneralALRT);							break;			}			HandleStartOfSubject(&mVariableList);							// Create the subfolders in case the user renamed them						CreateFolders();						// Update the license status caption						SetLicenseStatusCaption(mDiskLicenseStatusCaption);						// And indicate the current session						CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));			UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, nil, mDiskSessionCaption);						// Reset whether the user has selected the files.						mUpSelected = false;			mSideSelected = false;						mDiskUpPictureQualityIcon->Hide();			mDiskSidePictureQualityIcon->Hide();						mDiskUpZoomButton->Hide();			mDiskSideZoomButton->Hide();						// Hide the Control Window and show the Run From Disk window						HideMoveShow(mMainWindow, mDiskWindow);			mDiskUpCaption->SetDescriptor(Str_Empty);			mDiskSideCaption->SetDescriptor(Str_Empty);			mDiskUpView->ResetImage();			mDiskSideView->ResetImage();			mDiskReportName->SetDescriptor("\p");			// Set the maximum number of characters in the Name field to the legal length						int theMaxReportNameLength = kMaxReportNameLength;						// If the adjustName option is turned on, we have to account for the prefix length			// when testing the maximum report name length.						if (mReportPrefs.adjustName)				theMaxReportNameLength -= kPrefixLength;			mDiskReportName->SetMaxChars(theMaxReportNameLength);								RunInProgress = 2;		}		break;				// Handle the View Report button		case msg_MainViewReport:		{			// Create the subfolders in case the user renamed them						CreateFolders();						FSSpec theReportSpec;						theReportChooser.SetDefaultLocation(mLastReportDirSpec, FALSE);						if (mBrowserCreatorCode == kUnknownType)			{				if (!CDocumentApp::HandlePreferences())					break;					// Cancel the operation if they canceled the selection of Browser				else				{					CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));					UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, mMainSessionButton, nil);							}			}			// Actually, we don't want to limit our selection to the current browser, since the user may			// have changed their choice along the way. So we just look for TEXT files in the reports			// folder.						//theTEXTFileTypes.SetSignature(mBrowserCreatorCode);	// We look for those created by the specified browser						// Turn off the option to display previews, since previewing HTML doesn't make sense						NavDialogOptions	*options = theReportChooser.GetDialogOptions();			if (options != nil) 			{				options->dialogOptionFlags =	kNavDontAddTranslateItems +		/* don't add translation choices on Open/Save */												kNavSelectAllReadableItem +			/* allow saving of stationery files */												kNavNoTypePopup;						LString::CopyPStr("\pEyeDx: Choose Report", options->windowTitle);				LString::CopyPStr("\pChoose", options->actionButtonLabel);			}						openOK = theReportChooser.AskChooseOneFile(theTEXTFileTypes, theReportSpec);							// Note that the OpenReport routine handles reporting errors using an alert if necessary									if (openOK)			{				StCursor wait;	// Set the pointer to the stop watch while we are setting up				// Save the last location for future loads				mLastReportDirSpec = theReportSpec;										 				OSErr openErr = OpenReport(&theReportSpec);			}		}		break;				// Handle the Program Version button - this is just the standard About action		case msg_MainAbout:		{			CDocumentApp::ObeyCommand( PP_PowerPlant::cmd_About, nil );		// CDocumentApp::ObeyCommand		}		break;				// Handle the Exit Program button - this is just the standard Quit action		case msg_MainQuit:		{			CDocumentApp::ObeyCommand( PP_PowerPlant::cmd_Quit, nil );		// CDocumentApp::ObeyCommand		}		break;		///////////// Messages for the Run From Camera window /////////////				// msg_CameraAnimate is handled below with the Run From Disk equivalent.				case msg_CameraUpSelectImage:		{			if (CDocumentApp::HandleCameraImageSelect(msg_CameraUpSelectImage, mCameraUpView, mCameraUpCaption, &mUpGenericPictInfo, &mUpPictInfo, mCameraUpPictureQualityIcon))			{				// If they made a new selection, and they had previously downloaded the image, the discard the previous one which is currently				// in memory								if (mUpImageDownloaded)				{					// Do not reset the view, because the chooser above just set it to the new image					CleanupUpImage(nil);					mUpImageDownloaded = false; // The current image hasn't been fully downloaded yet				}			}		}		break;				case msg_CameraSideSelectImage:		{			if (CDocumentApp::HandleCameraImageSelect(msg_CameraSideSelectImage, mCameraSideView, mCameraSideCaption, &mSideGenericPictInfo, &mSidePictInfo, mCameraSidePictureQualityIcon))			{				// If they made a new selection, and they had previously downloaded the image, the discard the previous one which is currently				// in memory								if (mSideImageDownloaded)				{					// Do not reset the view, because the chooser above just set it to the new image					CleanupSideImage(nil);					mSideImageDownloaded = false; // The current image hasn't been fully downloaded yet				}			}		}		break;		case msg_CameraUpZoomButton:		{			HandleVerifyZoom(kUpOrientation, mCameraUpView, mCameraUpCaption, &mUpImageDownloaded);		}		break;				case msg_CameraSideZoomButton:		{			HandleVerifyZoom(kSideOrientation, mCameraSideView, mCameraSideCaption, &mSideImageDownloaded);		}		break;				case msg_CameraCancel:		{					// ALWAYS close the camera!!						CloseCamera(nil);						// The user can cancel at any time. We just hide the Run From Disk Window and show			// the Control Window							CleanupImages(mCameraUpView, mCameraSideView);						// We also update the main window Session button in case the user changed sessions during this mode			// This won't happen because the code for the mode will be updating only its own button and caption.						CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));			UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, mMainSessionButton, nil);						HideMoveShow(mCameraWindow, mMainWindow);			RunInProgress = 0;		}		break;		// This handles the pressing of the Ok button		case msg_CameraOk:		{				// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 			// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.			// Since we've already allocated the memory for the images, we don't include them in the counts here.			// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.						short num3ByteDeepImages = 3;	// For the two input images and one pre-scaled annotated image that is written out for the report			short num1ByteDeepImages = 1;	// For the threshold image						CEyeDxLongStringType hintString = (DisplayGraphics ? "\pOr, press Cancel, turn off animation, and run again." : Str_Empty);							MessageT theMemoryMessage = DoCheckForMemory(this, 								DisplayGraphics,								IMAGE_HEIGHT,								IMAGE_WIDTH,								num3ByteDeepImages,								num1ByteDeepImages,								&hintString);			if (theMemoryMessage == msg_OK)			{							// Validate the report name _first_, so we don't waste time downloading 				// images in the case where the report name will cause us to fail. Saves				// the user's time.											CEyeDxLongStringType theReportNameString;								mCameraReportName->GetDescriptor(theReportNameString);								if (CheckReportValidity(this, 										&theReportNameString, 										mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME)),										mReportPrefs.adjustName))				{					if (HandlePromptForVariables(this, &mVariableList, mPromptingPrefs.promptingStyle, CEyeDxVariable::kPromptForSubject) == kEyeDxDialogCancelMessage)					{						// ALWAYS close the camera!!												CloseCamera(nil);												// The user can cancel at any time. We just hide the Run From Disk Window and show						// the Control Window													CleanupImages(mCameraUpView, mCameraSideView);												HideMoveShow(mCameraWindow, mMainWindow);						RunInProgress = 0;					}					else					{												StCursor wait;	// Set the pointer to the stop watch while we are setting up						// Force a refresh of the window to get the window elements to update properly.						// This is necessary here since we don't give the system any time to process events						// while we do the first download.												mCameraWindow->Draw(nil);						// If they pressed OK previously but a notice prevented them from continuing, delete the						// previous images												if ((mUpHandle != NULL) && !mUpImageDownloaded)						{							DisposeHandle(mUpHandle);							mUpHandle = NULL;							up_image = NULL;							UP_ROWS = UP_COLS = 0;						}												if ((mSideHandle != NULL) && !mSideImageDownloaded)						{							DisposeHandle(mSideHandle);							mSideHandle = NULL;							side_image = NULL;							SIDE_ROWS = SIDE_COLS = 0;						}												CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));								if (!mUpImageDownloaded)						{							mCameraUpThermometerPane->Show();							mCameraUpProgressCaption->Show();													CEyeDxVariable *theUpImageVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGE));							if (!DownloadImageFromCamera(1,&mUpHandle,&UP_ROWS,&UP_COLS,up_filename, theSessionNameVariable, theUpImageVariable,														nil, mCameraUpThermometerPane, mCameraUpProgressCaption, SaveFullImages))							{								CloseCamera(nil);								CleanupImages(mCameraUpView, mCameraSideView);								break;							}							mCameraUpThermometerPane->Hide();													// Force a refresh of the window to get the thermometer and caption to hide properly													mCameraWindow->Draw(nil);						}												if (!mSideImageDownloaded)						{									mCameraSideThermometerPane->Show();							mCameraSideProgressCaption->Show();														CEyeDxVariable *theSideImageVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGE));										if (!DownloadImageFromCamera(2,&mSideHandle,&SIDE_ROWS,&SIDE_COLS,side_filename, theSessionNameVariable, theSideImageVariable,						 									nil, mCameraSideThermometerPane, mCameraSideProgressCaption, SaveFullImages))															{								CloseCamera(nil);								CleanupImages(mCameraUpView, mCameraSideView);								break;							}							mCameraSideThermometerPane->Hide();														// Force a refresh of the window to get the thermometer and caption to hide properly														mCameraWindow->Draw(nil);						}												// ALWAYS close the camera!!!												CloseCamera(nil);												// First, we see if there's enough temporary memory to run. The peak usage is one 8 bit deep image and 						// one or two 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.						// We've already allocated the memory for the images, we don't include them in the counts here, since						// we are checking for enough _additional_ memory to run.						// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.												short num3ByteDeepImages = 1;	// For the one pre-scaled annotated image that is written out for the report												short num1ByteDeepImages = 1;	// For the threshold image												CEyeDxLongStringType hintString = (DisplayGraphics ? "\pOr, press Cancel, turn off animation, and run again." : Str_Empty);												MessageT theMessage = DoCheckForMemory(this, 											DisplayGraphics,											IMAGE_HEIGHT,											IMAGE_WIDTH,											num3ByteDeepImages,											num1ByteDeepImages,											&hintString);						if (theMessage == msg_OK)						{																	AnalyzeImages(mCameraWindow, mCameraUpView, mCameraSideView, SaveFullImages);														// Now update the variables for the end of a subject														HandleEndOfSubject(&mVariableList, NULL, &mDefaultDatabaseReportName);														// We also want to save the current session status in case of crash														SaveSessionStatus();							// Once we are done, hide the Analysis window and display the Control Window											HideMoveShow(mAnalysisWindow, mMainWindow);						}					}				}			}			// We also update the main window Session button in case the user changed sessions during this mode			// This won't happen because the code for the mode will be updating only its own button and caption.						CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));			UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, mMainSessionButton, nil);					}		break;					///////////// Messages for the Run From Disk window /////////////				// This handles the pressing of the Select Up Image button				case msg_DiskUpSelectImage:		{#ifdef LOGGING	logmemtofile(logfile, "HandleMessage() - up select start");#endif			NavDialogOptions	*options = theImageChooser.GetDialogOptions();			if (options != nil) 				LString::CopyPStr("\pEyeDx: Select Up Image", options->windowTitle);			theImageChooser.SetDefaultLocation(mLastImageDirSpec, FALSE);						openOK = theImageChooser.AskChooseOneFile(theImageFileTypes, mUpFileSpec);#ifdef LOGGING	logmemtofile(logfile, "HandleMessage() - after AskChooseOneFile");#endif			if (openOK)			{				// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 				// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.				// Actually, it's a bit more complicated. If we haven't selected either image, 3 or 4 is correct. If either image				// is selected (just one), it's 2 or 3, and if they've already selected both images and are just reselecting this				// one, it's 1 or 2.				// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.								short num3ByteDeepImages;								if (mUpSelected && mSideSelected)					num3ByteDeepImages = 1;		// For one pre-scaled annotated image that is written out for the report				else				if (mUpSelected || mSideSelected)					num3ByteDeepImages = 2;		// For the remaining input image and one pre-scaled annotated image that is written out for the report				else					num3ByteDeepImages = 3;		// For the two input images and one pre-scaled annotated image that is written out for the report				short num1ByteDeepImages = 1;	// For the threshold image								CEyeDxLongStringType hintString = (DisplayGraphics ? "\pOr, press Cancel, turn off animation, and run again." : Str_Empty);								MessageT theMemoryMessage = DoCheckForMemory(this, 									DisplayGraphics,									IMAGE_HEIGHT,									IMAGE_WIDTH,									num3ByteDeepImages,									num1ByteDeepImages,									&hintString);				if (theMemoryMessage == msg_OK)				{												StCursor wait;	// Set the pointer to the stop watch while we are setting up#ifdef LOGGING	logmemtofile(logfile, "HandleMessage() - after wait cursor");#endif					mUpSelected = true;										// If a file is already displayed, delete the old one					if (mUpHandle != NULL)					{					    DisposeHandle(mUpHandle);					    mUpHandle = NULL;					    up_image = NULL;					    UP_ROWS = UP_COLS = 0;					}					// Save the last location for future loads					mLastImageDirSpec = mUpFileSpec;										// Determine whether to copy files. First, default to the option the user					// has selected. Next, if the option is turned on, see if the source directory					// is the Pimages directory. If so, then there's no sense copying the file.										CEyeDxBooleanType copyFiles = mCameraPrefs.saveFiles;										if (copyFiles)					{						if ((mUpFileSpec.vRefNum == mPImagesSpec.vRefNum) &&					    	(mUpFileSpec.parID == mPImagesSpec.parID))					    	copyFiles = false;					}   										// Convert from Pascal to C string					strncpy(up_filename, (char *)&mUpFileSpec.name[1], (unsigned long)mUpFileSpec.name[0]);					up_filename[mUpFileSpec.name[0]] = '\0';				#ifdef LOGGING	logmemtofile(logfile, "HandleMessage() - before open");#endif					FInfo theFileFInfo;					FSpGetFInfo(&mUpFileSpec, &theFileFInfo);										FILE *fileptr = FSp_fopen((ConstFSSpecPtr)&mUpFileSpec, "rb");										if (!fileptr)					{						::ParamText("\pCannot open file.", Str_Empty, Str_Empty, Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}					else									{						// Assume that the pictinfo member isn't set - which will happen						// if the image is JPEG						mUpPictInfoValid = false;							mDiskUpThermometerPane->Show();						mDiskUpProgressCaption->Show();#ifdef LOGGING	logmemtofile(logfile, "HandleMessage() - before ReadImageFromFile");	#endif							// We save the Up Image filename here before it gets truncated by the read routine													CEyeDxVariable *theUpImageVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGE));						CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));								if (ReadImageFromFile(fileptr, &mUpHandle, &UP_ROWS,&UP_COLS, up_filename, theSessionNameVariable, theUpImageVariable,												copyFiles,												theFileFInfo.fdCreator,												theFileFInfo.fdType,												&mUpGenericPictInfo, &mUpPictInfo, &mUpPictInfoValid,												(void *)NULL, mDiskUpThermometerPane, mDiskUpProgressCaption, mDiskUpCaption) == 0)						{							mDiskUpThermometerPane->Hide();							mDiskUpProgressCaption->Hide();							mDiskUpCaption->Hide();							strcpy(up_filename,"");						}						else						{#ifdef LOGGING	logmemtofile(logfile, "HandleMessage() - after ReadImageFromFile");#endif							mDiskUpThermometerPane->Hide();							mDiskUpProgressCaption->Hide();							mDiskUpPictureQualityIcon->Show();							mDiskUpZoomButton->Show();														// If the quality isn't what we should be using, warn the user							if (mUpPictInfoValid && mUpPictInfo.PictQuality != DC120BestQuality)							{							 	::ParamText("\pThis image was not taken with the recommended 'Best' image quality setting,",							 				"\pand analysis of this image may produce incorrect results.",							 				"\pEyeDx recommends you retake this picture.", Str_Empty);								UModalAlerts::CautionAlert(PPob_GeneralALRT);								mDiskUpPictureQualityIcon->SetIconID(kCautionQualityIconList);							}							else								mDiskUpPictureQualityIcon->SetIconID(kGoodQualityIconList);#ifdef LOGGING	logmemtofile(logfile, "HandleMessage() - before SetImageFromRaw24Bit");#endif							HLock(mUpHandle);							mDiskUpView->SetImageFromRaw24Bit((unsigned char *)*mUpHandle, UP_ROWS, UP_COLS);							HUnlock(mUpHandle);#ifdef LOGGING	logmemtofile(logfile, "HandleMessage() - after SetImageFromRaw24Bit");#endif						}					}				}			}		}		break;		// This handles the pressing of the Select Side Image button		case msg_DiskSideSelectImage:		{			NavDialogOptions	*options = theImageChooser.GetDialogOptions();			if (options != nil) 				LString::CopyPStr("\pEyeDx: Select Side Image", options->windowTitle);			theImageChooser.SetDefaultLocation(mLastImageDirSpec, FALSE);			openOK = theImageChooser.AskChooseOneFile(theImageFileTypes, mSideFileSpec);			if (openOK)			{				// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 				// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.								// Actually, it's a bit more complicated. If we haven't selected either image, 3 or 4 is correct. If either image				// is selected (just one), it's 2 or 3, and if they've already selected both images and are just reselecting this				// one, it's 1 or 2.				// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.								short num3ByteDeepImages;								if (mUpSelected && mSideSelected)					num3ByteDeepImages = 1;		// For one pre-scaled annotated image that is written out for the report				else				if (mUpSelected || mSideSelected)					num3ByteDeepImages = 2;		// For the remaining input image and one pre-scaled annotated image that is written out for the report				else					num3ByteDeepImages = 3;		// For the two input images and one pre-scaled annotated image that is written out for the report				short num1ByteDeepImages = 1;	// For the threshold image												CEyeDxLongStringType hintString = (DisplayGraphics ? "\pOr, press Cancel, turn off animation, and run again." : Str_Empty);								MessageT theMemoryMessage = DoCheckForMemory(this, 									DisplayGraphics,									IMAGE_HEIGHT,									IMAGE_WIDTH,									num3ByteDeepImages,									num1ByteDeepImages,									&hintString);				if (theMemoryMessage == msg_OK)				{								StCursor wait;	// Set the pointer to the stop watch while we are setting up					mSideSelected = true;					// If a file is already displayed, delete the old one					if (mSideHandle != NULL)					{					    DisposeHandle(mSideHandle);					    mSideHandle = NULL;					    side_image = NULL;					    SIDE_ROWS = SIDE_COLS = 0;					}					// Save the last location for future loads					mLastImageDirSpec = mSideFileSpec;										// Determine whether to copy files. First, default to the option the user					// has selected. Next, if the option is turned on, see if the source directory					// is the Pimages directory. If so, then there's no sense copying the file.										CEyeDxBooleanType copyFiles = mCameraPrefs.saveFiles;										if (copyFiles)					{						if ((mSideFileSpec.vRefNum == mPImagesSpec.vRefNum) &&					    	(mSideFileSpec.parID == mPImagesSpec.parID))					    	copyFiles = false;					}   										// Convert from Pascal to C string					strncpy(side_filename, (char *)&mSideFileSpec.name[1], (unsigned long)mSideFileSpec.name[0]);					side_filename[mSideFileSpec.name[0]] = '\0';					FInfo theFileFInfo;					FSpGetFInfo(&mSideFileSpec, &theFileFInfo);										FILE *fileptr = FSp_fopen((ConstFSSpecPtr)&mSideFileSpec, "rb");										if (!fileptr)					{						::ParamText("\pCannot open file.", Str_Empty, Str_Empty, Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}					else									{						// Assume that the pictinfo member isn't set - which will happen						// if the image is JPEG						mSidePictInfoValid = false;							mDiskSideThermometerPane->Show();						mDiskSideProgressCaption->Show();						CEyeDxVariable *theSideImageVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGE));						CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));						if (ReadImageFromFile(fileptr, &mSideHandle,&SIDE_ROWS,&SIDE_COLS, side_filename, theSessionNameVariable, theSideImageVariable,												copyFiles,												theFileFInfo.fdCreator,												theFileFInfo.fdType,												&mSideGenericPictInfo, &mSidePictInfo, &mSidePictInfoValid, 												(void *)NULL, mDiskSideThermometerPane, mDiskSideProgressCaption, mDiskSideCaption)  == 0)						{							mDiskSideThermometerPane->Hide();							mDiskSideProgressCaption->Hide();							mDiskSideCaption->Hide();							strcpy(side_filename,"");						}						else						{							mDiskSideThermometerPane->Hide();							mDiskSideProgressCaption->Hide();							mDiskSidePictureQualityIcon->Show();							mDiskSideZoomButton->Show();														// If the quality isn't what we should be using, warn the user							if (mSidePictInfoValid && mSidePictInfo.PictQuality != DC120BestQuality)							{							 	::ParamText("\pThis image was not taken with the recommended 'Best' image quality setting,",							 				"\pand analysis of this image may produce incorrect results.",							 				"\pEyeDx recommends you retake this picture.", Str_Empty);								UModalAlerts::CautionAlert(PPob_GeneralALRT);								mDiskSidePictureQualityIcon->SetIconID(kCautionQualityIconList);							}							else								mDiskSidePictureQualityIcon->SetIconID(kGoodQualityIconList);															HLock(mSideHandle);							mDiskSideView->SetImageFromRaw24Bit((unsigned char *)*mSideHandle, SIDE_ROWS,SIDE_COLS);							HUnlock(mSideHandle);						}					}				}			}		}		break;		case msg_DiskUpZoomButton:		{			CEyeDxLongStringType theFileName = mUpFileSpec.name;						HandleSummaryZoom(&theFileName, mUpHandle, UP_ROWS, UP_COLS, nil, nil, 0, 0);		}		break;				case msg_DiskSideZoomButton:		{			CEyeDxLongStringType theFileName = mSideFileSpec.name;						HandleSummaryZoom(&theFileName, mSideHandle, SIDE_ROWS, SIDE_COLS, nil, nil, 0, 0);		}		break;				case msg_DiskOk:		{			// We only allow the user to continue if they have selected both the Up and Side Images						if (mUpSelected && mSideSelected)			{				// First, we see if there's enough temporary memory to run. The peak usage is one 8 bit deep image and 				// one or two 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.				// We've already allocated the memory for the images, we don't include them in the counts here, since				// we are checking for enough _additional_ memory to run.				// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.								short num3ByteDeepImages = 1;	// For one pre-scaled annotated image that is written out for the report									short num1ByteDeepImages = 1;	// For the threshold image								CEyeDxLongStringType hintString = (DisplayGraphics ? "\pOr, press Cancel, turn off animation, and run again." : Str_Empty);								MessageT theMessage = DoCheckForMemory(this, 									DisplayGraphics,									IMAGE_HEIGHT,									IMAGE_WIDTH,									num3ByteDeepImages,									num1ByteDeepImages,									&hintString);				if (theMessage == msg_OK)				{					CEyeDxLongStringType theReportNameString;										mDiskReportName->GetDescriptor(theReportNameString);										if (CheckReportValidity(this, 											&theReportNameString, 											mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME)),											mReportPrefs.adjustName))					{						if (HandlePromptForVariables(this, &mVariableList, mPromptingPrefs.promptingStyle, CEyeDxVariable::kPromptForSubject) == kEyeDxDialogCancelMessage)						{							// The user can cancel at any time. We just hide the Run From Disk Window and show							// the Control Window															CleanupImages(mCameraUpView, mCameraSideView);														HideMoveShow(mDiskWindow, mMainWindow);						}						else						{													StCursor wait;	// Set the pointer to the stop watch while we are setting up							// We keep track of the total number of retakes for this subject. However, for manual modes, this value is							// not used. So we set it to zero so it has a valid value for							// the report generation and database output functions called by the AnalyzeImages routine.														CEyeDxVariable *theTotalRetakesVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTTOTALRETAKES));							theTotalRetakesVariable->ResetValue();							AnalyzeImages(mDiskWindow, mDiskUpView, mDiskSideView, false);													// Now update the variables for the end of a subject														HandleEndOfSubject(&mVariableList, NULL, &mDefaultDatabaseReportName);														// We also want to save the current session status in case of crash														SaveSessionStatus();							// Once we are done, hide the Analysis window and display the Control Window											HideMoveShow(mAnalysisWindow, mMainWindow);						}					}				}				// We also update the main window Session button in case the user changed sessions during this mode				// This won't happen because the code for the mode will be updating only its own button and caption.								CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));				UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, mMainSessionButton, nil);						}			else			{				::ParamText("\pYou must choose both images.", Str_Empty, Str_Empty, Str_Empty);				UModalAlerts::NoteAlert(PPob_GeneralALRT);			}		}		break;							case msg_DiskCancel:		{			// The user can cancel at any time. We just hide the Run From Disk Window and show			// the Control Window							CleanupImages(mCameraUpView, mCameraSideView);						// We also update the main window Session button in case the user changed sessions during this mode			// This won't happen because the code for the mode will be updating only its own button and caption.						CEyeDxVariable *theVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));			UpdateSessionButtonAndCaption(mReportPrefs.useSessions, theVariable, mMainSessionButton, nil);						HideMoveShow(mDiskWindow, mMainWindow);		}		break;				// This saves changes to the Animate checkbox in either the Run From Camera or Run From Disk windows.		// The same variable is used in either case by the analysis routines.		case msg_CameraAnimate:		case msg_DiskAnimate:		{			DisplayGraphics = (CEyeDxBooleanType) *(long*)ioParam;						// Make sure the items reflect the current setting						StopListening();			mCameraAnimate->SetValue(DisplayGraphics);			mDiskAnimate->SetValue(DisplayGraphics);			StartListening();		}		break;				}}// This routine exists to handle keyboard shortcuts for the application that// do not correspond to menu commands.Boolean CDocumentApp::HandleKeyPress(const EventRecord &theKeyEvent){	UInt8		theChar		= (UInt8) (theKeyEvent.message & charCodeMask);	// We use Command-Shift keys for special functions		if (theKeyEvent.modifiers & (cmdKey | shiftKey)) 	{		switch (theChar)		{		case 'a':					// First, ask the user for the password if the Advanced Features flag is not on - no			// need to ask for a password to turn it off. Default the message to the OK state			// for the turn-off condition.						MessageT theMessage = msg_OK;								if (!AdvancedFeatures)			{				StDialogHandler thePasswordHandler( PPob_PasswordDialog, this );				// Get the dialog.				LWindow *thePasswordDialog;				thePasswordDialog = thePasswordHandler.GetDialog();				Assert_( thePasswordDialog != nil );								LEditText *thePassword = dynamic_cast<LEditText*> (thePasswordDialog->FindPaneByID(kPasswordPassword));				ThrowIfNil_( thePassword );				thePasswordDialog->Show();								CEyeDxLongStringType theEnteredPassword;				CEyeDxLongStringType theActualPassword = CommonStringLiteral_(kPasswordString);				DateTimeRec theTimeNow;				::GetTime(&theTimeNow);								CEyeDxLongStringType theDayNumber((long)theTimeNow.day);								theActualPassword = theActualPassword + theDayNumber;				while ( true ) 				{					// Handle dialog messages.					theMessage = thePasswordHandler.DoDialog();					if ( theMessage == msg_Cancel ) 						break;	// We just fall out of the loop in this case					else if (theMessage == msg_OK)					{						thePassword->GetDescriptor(theEnteredPassword);						if (theEnteredPassword != theActualPassword)							::SysBeep(5);						else							break;					}				}				}						if (theMessage == msg_OK)			{				// Toggle the Advanced Features - we keep a flag that can be checked when				// dialog boxes are created on the fly								AdvancedFeatures = (AdvancedFeatures ? FALSE : TRUE);								// Now handle any special operations that are performed immediately upon				// entering or exiting the Advance Features mode.								if (AdvancedFeatures)				{					// We have to test any object pointers before dereferencing them, 					// because we might be called before the window has been built!														NoteAlert(nil, CommonStringLiteral_("Advanced features enabled."));				}				else				{					// We have to test any object pointers before dereferencing them, 					// because we might be called before the window has been built!															NoteAlert(nil, CommonStringLiteral_("Advanced features disabled."));				}												// Now, tell the Super Commander to update any menus that may have				// been impacted by the change in state								LCommander::SetUpdateCommandStatus(true);				return true;			}			break;		case 'd':					// Toggle the Debug Features						DebugFeatures = (DebugFeatures ? FALSE : TRUE);			// Now, tell the Super Commander to update any menus that may have			// been impacted by the change in state						LCommander::SetUpdateCommandStatus(true);			return true;			break;		}	} 		// See if it is Return, ESC, or Cmd-Period. If so, and if we are running, simulate the	// Cancel or OK buttons		if (RunInProgress)	{		if ( UKeyFilters::IsEscapeKey(theKeyEvent) ||			 UKeyFilters::IsCmdPeriod(theKeyEvent) )				{			if (RunInProgress == 1)				BroadcastMessage(msg_CameraCancel, 0);			else				BroadcastMessage(msg_DiskCancel, 0);		}		else		if ( (theChar == char_Enter) || (theChar == char_Return) ) 		{			if (RunInProgress == 1)				BroadcastMessage(msg_CameraOk, 0);			else				BroadcastMessage(msg_DiskOk, 0);		}	}						// If we didn't handle it above, let the base class handle it		return LDocApplication::HandleKeyPress(theKeyEvent);}