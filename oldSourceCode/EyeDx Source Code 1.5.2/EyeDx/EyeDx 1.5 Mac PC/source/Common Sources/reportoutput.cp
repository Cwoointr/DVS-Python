		/*********************************************************		** This program finds eyes in images taken for photoscreening.		** It then makes measurements on the eye models and produces		** a (limited) diagnosis and screening decision.		**		** Coded by Adam Hoover in June-December '97.		** Ported to windows in January-February '98. (AH)		*********************************************************/#include <stdio.h>#include <math.h>#include <time.h>#ifndef macintosh#include <windows.h>#include <afxwin.h>#include <process.h>#include "globals.h"#include "FileVersion.h"#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"#include "CMFCCameraImageSelectDlg.h"#include "CMFCAnalysisWin.h"#include "CMFCRunWin.h"#include "CMFCRunFromCameraWin.h"#include "CMFCRunFromDiskWin.h"#include "CMFCAboutDialog.h"#include "CMFCPropertiesDlg.h"#include "EyeDxMFCMessages.h"#include "main.h"#include "CEyeDxVariables.h"// We reference this so we can get the version number informationextern CMainApp gMainApp;#else#include <string.h>#include <stdlib.h>#include <unistd.h>#include "EyeDxMacConstants.h"#include "CMyGWorldView.h"#include <LCaption.h>#include <path2fss.h>#include "globals.h"#include "CEyeDxVariables.h"#include <UResourceMgr.h>#include <UTextTraits.h>//#define LOGGING#ifdef LOGGING#include "memlogger.h"extern FILE *logfile;extern long dummyGrow;#endif#endif// ISO CHaracter to HTML Conversion Tablechar *HTMLConversion[256] = {	NULL,			// 00	NULL,			// 01	NULL,			// 02	NULL,			// 03	NULL,			// 04	NULL,			// 05	NULL,			// 06	NULL,			// 07	NULL,			// 08	NULL,			// 09#ifdef macintosh	"<BR>",			// 10#else	"",				// 10	// Don't output line feeds - just process returns#endif	NULL,			// 11	NULL,			// 12	"<BR>",			// 13	NULL,			// 14	NULL,			// 15	NULL,			// 16	NULL,			// 17	NULL,			// 18	NULL,			// 19	NULL,			// 20	NULL,			// 21	NULL,			// 22	NULL,			// 23	NULL,			// 24	NULL,			// 25	NULL,			// 26	NULL,			// 27	NULL,			// 28	NULL,			// 29	NULL,			// 30	NULL,			// 31	NULL,			// 32 space - DO NOT convert to non-breaking, as this will mess up word wrap, unfortunately!	NULL,			// 33	"&quot;",		// quotation mark	NULL,			// 35	NULL,			// 36	NULL,			// 37	"&amp;",		// ampersand	NULL,			// 39	NULL,			// 40	NULL,			// 41	NULL,			// 42	NULL,			// 43	NULL,			// 44	NULL,			// 45	NULL,			// 46	NULL,			// 47	NULL,			// 48	NULL,			// 49	NULL,			// 50	NULL,			// 51	NULL,			// 52	NULL,			// 53	NULL,			// 54	NULL,			// 55	NULL,			// 56	NULL,			// 57	NULL,			// 58	NULL,			// 59	"&lt;",			// less than, left angle bracket	NULL,			// 61	"&gt;",			// greater than, right angle bracket	NULL,			// 63	NULL,			// 64	NULL,			// 65	NULL,			// 66	NULL,			// 67	NULL,			// 68	NULL,			// 69	NULL,			// 70	NULL,			// 71	NULL,			// 72	NULL,			// 73	NULL,			// 74	NULL,			// 75	NULL,			// 76	NULL,			// 77	NULL,			// 78	NULL,			// 79	NULL,			// 80	NULL,			// 81	NULL,			// 82	NULL,			// 83	NULL,			// 84	NULL,			// 85	NULL,			// 86	NULL,			// 87	NULL,			// 88	NULL,			// 89	NULL,			// 90	NULL,			// 91	NULL,			// 92	NULL,			// 93	NULL,			// 94	NULL,			// 95	NULL,			// 96	NULL,			// 97	NULL,			// 98	NULL,			// 99	NULL,			// 100	NULL,			// 101	NULL,			// 102	NULL,			// 103	NULL,			// 104	NULL,			// 105	NULL,			// 106	NULL,			// 107	NULL,			// 108	NULL,			// 109	NULL,			// 110	NULL,			// 111	NULL,			// 112	NULL,			// 113	NULL,			// 114	NULL,			// 115	NULL,			// 116	NULL,			// 117	NULL,			// 118	NULL,			// 119	NULL,			// 120	NULL,			// 121	NULL,			// 122	NULL,			// 123	NULL,			// 124	NULL,			// 125	NULL,			// 126	NULL,			// 127#ifdef macintosh	"&Auml;",		// 128        	Ä             Ä      capital A, dieresis/umlaut	"&Aring;",		// 129       	Å             Å      capital A, ring	"&Ccedil;",		// 130      	Ç             Ç      capital C, cedilla	"&Eacute;",		// 131       	É             É      capital E, acute accent	"&Ntilde;",		// 132       	Ñ             Ñ      capital N, tilde	"&Ouml;",		// 133         	Ö             Ö      capital O,  dieresis/umlaut	"&Uuml;",		// 134         	Ü             Ü      capital U,  dieresis/umlaut	"&aacute;",		// 135       	á             á      lowercase a, acute accent	"&agrave;",		// 136       	à             à      lowercase a, grave accent	"&acirc;",		// 137        	â             â      lowercase a, circumflex	"&auml;",		// 138         	ä             ä      lowercase a, dieresis/umlaut	"&atilde;",		// 139       	ã             ã      lowercase a, tilde	"&aring;",		// 140        	å             å      lowercase a, ring	"&ccedil;",		// 141       	ç             ç      lowercase c, cedilla	"&eacute;",		// 142       	é             é      lowercase e, acute accent	"&egrave;",		// 143       	è             è      lowercase e, grave accent	"&ecirc;",		// 144        	ê             ê      lowercase e, circumflex	"&euml;",		// 145         	ë             ë      lowercase e, dieresis/umlaut	"&iacute;",		// 146       	í             í      lowercase i, acute accent	"&igrave;",		// 147       	ì             ì      lowercase i, grave accent	"&icirc;",		// 148        	î             î      lowercase i, circumflex	"&iuml;",		// 149         	ï             ï      lowercase i, dieresis/umlaut	"&ntilde;",		// 150       	ñ             ñ      lowercase n, tilde	"&oacute;",		// 151       	ó             ó      lowercase o, acute accent	"&ograve;",		// 152        	ò             ò      lowercase o, grave accent	"&ocirc;",		// 153        	ô             ô      lowercase o, circumflex	"&ouml;",		// 154         	ö             ö      lowercase o,  dieresis/umlaut	"&otilde;",		// 155      	õ             õ      lowercase o, tilde	"&uacute;",		// 156          ú             ú      lowercase u, acute accent	"&ugrave;",		// 157          ù             ù      lowercase u, grave accent	"&ucirc;",		// 158          û             û      lowercase u, circumflex	"&uuml;",		// 159          ü             ü      lowercase u, dieresis/umlaut	"&dagger;",		// 160			†			  †		 dagger	"&deg;",		// 161          °             °      degree sign	"&cent;",		// 162 								 cent sign	"&pound;",		// 163 								 pound sterling	"&sect;",		// 164								 section or numbered	"&bull;",		// 165								 bullet	"&para;",		// 166         ¶             ¶       paragraph sign, pilcrow	"&szlig;",		// 167         ß             ß       lowercase sharp s, German (sz ligature)		"&reg;",		// 168         ®             ®       registered trademark	"&copy;",		// 169         ©             ©       copyright	"&trade;",		// 170                               trademark	"&acute;",		// 171         ´             ´       acute accent	"&uml;",		// 172         ¨             ¨       umlaut or dieresis	"&ne;",			// 173								 not equal	"&AElig;",		// 174         Æ             Æ       capital AE ligature	"&Oslash;",		// 175         Ø             Ø       capital O, slash	"&infin;",		// 176								 infinity		"&plusmn;",		// 177         ±             ±       plus or minus	"&le;",			// 178								 less than or equal		"&ge;",			// 179								 greater than or equal		"&yen;",		// 180 								 yen sign	"&micro;",		// 181         µ             µ       micro sign	"&part;",		// 182								 partial differentiation	"&sum;",		// 183								 summation	"&prod;",		// 184								 product	"&pi;",			// 185								 pi	"&int;",		// 186								 integral	"&ordf;",		// 187         ª             ª       feminine ordinal	"&ordm;",		// 188         º             º       masculine ordinal	"&Omega;",		// 189								 capital omega	"&aelig;",		// 190         æ             æ       lowercase ae ligature	"&oslash;",		// 191         ø             ø       lowercase o, slash	"&iquest;",		// 192         ¿             ¿       inverted question mark	"&iexcl;",		// 193								 inverted exclamation	"&not;",		// 194         ¬             ¬       not sign	"&squ;",		// 195         						 radical	"&func;",		// 196								 florin	"&ap;",			// 197								 approx. equal	"&Delta;",		// 198								 Delta	"&laquo;",		// 199        «             «        left French quote, guillemotleft	"&raquo;",		// 200        »             »        Right French quote,	"&#133;",		// 201								 ellipsis	"&nbsp;",		// 202								 non-breaking space	"&Agrave;",		// 203        À             À        capital A, grave accent	"&Atilde;",		// 204        Ã             Ã        capital A, tilde	"&Otilde;",		// 205        Õ             Õ        capital O, tilde	"OE",			// 206								 captial oe ligature	"oe",			// 207								 lowercase oe ligature	"&mdash;",		// 208								 em dash	"&ndash;",		// 209								 en dash	"&quot;",		// 210								 leading double curly quote	"&quot;",		// 211								 trailing double curly quote	"'",			// 212								 leading single curly quote	"'",			// 213								 trailing single curly quote	"&divide;",		// 214        ÷             ÷        division sign	"&loz;",		// 215      						 lozenge	"&yuml;"		// 216         ÿ             ÿ       lowercase y, dieresis/umlaut	"&yuml;"		// 217         ÿ             ÿ       uppercase y, dieresis/umlaut	"/",			// 218								 fraction	"&curren;",		// 219								 general currency sign	"&lt;",			// 220								 guilsingleft	"&gt;",			// 221								 guilsingright	"fi",			// 222								 fi	"fl",			// 223								 fl	"&Dagger;",		// 224								 double dagger	"&middot;",		// 225         ·             ·       middle dot	",",			// 226								 ,	",,",			// 227								 ,,	" per thousand ",		// 228								 per thousand	"&Acirc;",		// 229        Â             Â        capital A, circumflex	"&Ecirc;",		// 230        Ê             Ê        capital E, circumflex	"&Aacute;",		// 231        Á             Á        capital A, acute accent	"&Euml;",		// 232        Ë             Ë        capital E, dieresis/umlaut	"&Egrave;",		// 233        È             È        capital E, grave accent	"&Iacute;",		// 234        Í             Í        capital I, acute accent	"&Icirc;",		// 235        Î             Î        capital I, circumflex	"&Iuml;",		// 236        Ï             Ï        capital I, dieresis/umlaut	"&Igrave;",		// 237        Ì             Ì        capital I, grave accent	"&Oacute;",		// 238        Ó             Ó        capital O, acute accent	"&Ocirc;",		// 239        Ô             Ô        capital O, circumflex	" APPLE ",		// 240								 Apple symbol 	"&Ograve;",		// 241        Ò             Ò        capital O, grave accent	"&Uacute;",		// 242        Ú             Ú        capital U, acute accent	"&Ucirc;",		// 243        Û             Û        capital U, circumflex	"&Ugrave;",		// 244        Ù             Ù        capital U, grave accent	"&sup1;",		// 245        1             1        superscript one	"^",			// 246								 circumflex	"~",			// 247								 tilde	"&macr;",		// 248        ¯             ¯        macron accent	"BREVE",		// 249								 breve	".",			// 250								 dotaccent	"RING",			// 251								 ring	"&cedil;",		// 252         ¸             ¸       cedilla	"&uml;",		// 253         ¨             ¨       hungarumlaut	"OGONEK",		// 254         ¨             ¨       ogonek	"CARON",		// 255         ¨             ¨       caron#else	" X ",			// 128	" X ",			// 129	",",			// 130	"&func;",		// 131								 florin	",,",			// 132	"&#133;",		// 133								  ellipsis	"&dagger;",		// 134			†			  †		 dagger	"&Dagger;",		// 135								 double dagger	"^",			// 136								 circumflex	" per thousand ",		// 137								 per thousand	"S",			// 138								 S with accent	"&lt;",			// 139								 less than, left angle bracket	"OE",			// 140								 captial oe ligature	" X ",			// 141	" X ",			// 142	" X ",			// 143	" X ",			// 144	"'",			// 145								 leading single curly quote	"'",			// 146								 trailing single curly quote	"&quot;",		// 147								 leading double curly quote	"&quot;",		// 148								 trailing double curly quote	"&middot;",		// 149         ·             ·       middle dot	"&mdash;",		// 150								 em dash	"&ndash;",		// 151								 en dash	"~",			// 152								 tilde	"&trade;",		// 153								 trademark	"s",			// 154								 s with accent	"&gt;",			// 155								 greater than, right angle bracket	"oe",			// 156								 lowercase oe ligature	" X ",			// 157	" X ",			// 158	"&yuml;",		// 159         ÿ             ÿ       uppercase y, dieresis/umlaut	"&nbsp;",		// non-breaking space	"&iexcl;",		// inverted exclamation	"&cent;",		// cent sign	"&pound;",		// pound sterling	"&curren;",		// general currency sign	"&yen;",		// yen sign	"&brvbar;",		// broken vertical bar	"&sect;",		// section or numbered	"&uml;",		//             ¨             ¨       umlaut or dieresis	"&copy;",		//            ©             ©       copyright	"&ordf;",		// 170           ª             ª       feminine ordinal	"&laquo;",		//           «             «       left French quote, guillemotleft	"&not;",		//             ¬             ¬       not sign	"&shy;",		//             |             |       soft hyphen	"&reg;",		//             ®             ®       registered trademark	"&macr;",		//            ¯             ¯       macron accent	"&deg;",		//             °             °       degree sign	"&plusmn;",		//          ±             ±       plus or minus	"&sup2;",		//            2             2       superscript two	"&sup3;",		//            3             3       superscript three	"&acute;",		// 180          ´             ´       acute accent	"&micro;",		//           µ             µ       micro sign	"&para;",		//            ¶             ¶       paragraph sign, pilcrow	"&middot;",		//          ·             ·       middle dot	"&cedil;",		//           ¸             ¸       cedilla	"&sup1;",		//            1             1       superscript one	"&ordm;",		//            º             º       masculine ordinal	"&raquo;",		//           »             »       Right French quote,	"&frac14;",		//          |             |       fraction one-fourth	"&frac12;",		//          |             |       fraction one-half	"&frac34;",		// 190         |             |       fraction three-fourths	"&iquest;",		//          ¿             ¿       inverted question mark	"&Agrave;",		//          À             À       capital A, grave accent	"&Aacute;",		//          Á             Á       capital A, acute accent	"&Acirc;",		//           Â             Â       capital A, circumflex	"&Atilde;",		//          Ã             Ã       capital A, tilde	"&Auml;",		//            Ä             Ä       capital A, dieresis/umlaut	"&Aring;",		//           Å             Å       capital A, ring	"&AElig;",		//           Æ             Æ       capital AE ligature	"&Ccedil;",		//          Ç             Ç       capital C, cedilla	"&Egrave;",		// 200       È             È      capital E, grave accent	"&Eacute;",		//           É             É      capital E, acute accent	"&Ecirc;",		//            Ê             Ê      capital E, circumflex	"&Euml;",		//             Ë             Ë      capital E, dieresis/umlaut	"&Igrave;",		//           Ì             Ì      capital I, grave accent	"&Iacute;",		//           Í             Í      capital I, acute accent	"&Icirc;",		//            Î             Î      capital I, circumflex	"&Iuml;",		//             Ï             Ï      capital I, dieresis/umlaut	"&ETH;",		//              |             |      capital Eth, Icelandic	"&Ntilde;",		//           Ñ             Ñ      capital N, tilde	"&Ograve;",		// 210       Ò             Ò      capital O, grave accent	"&Oacute;",		//           Ó             Ó      capital O, acute accent	"&Ocirc;",		//            Ô             Ô      capital O, circumflex	"&Otilde;",		//           Õ             Õ      capital O, tilde	"&Ouml;",		//             Ö             Ö      capital O,  dieresis/umlaut	"&times;",		//            |             |      multiplication sign	"&Oslash;",		//           Ø             Ø      capital O, slash	"&Ugrave;",		//           Ù             Ù      capital U, grave accent	"&Uacute;",		//           Ú             Ú      capital U, acute accent	"&Ucirc;",		//            Û             Û      capital U, circumflex	"&Uuml;",		// 220         Ü             Ü      capital U,  dieresis/umlaut	"&Yacute;",		//         n/a             |      capital Y, acute accent	"&THORN;",		//            |             |      capital THORN, Icelandic	"&szlig;",		//            ß             ß      lowercase sharp s, German (sz ligature)	"&agrave;",		//           à             à      lowercase a, grave accent	"&aacute;",		//           á             á      lowercase a, acute accent	"&acirc;",		//            â             â      lowercase a, circumflex	"&atilde;",		//           ã             ã      lowercase a, tilde	"&auml;",		//             ä             ä      lowercase a, dieresis/umlaut	"&aring;",		//            å             å      lowercase a, ring	"&aelig;",		// 230        æ             æ      lowercase ae ligature	"&ccedil;",		//           ç             ç      lowercase c, cedilla	"&egrave;",		//           è             è      lowercase e, grave accent	"&eacute;",		//           é             é      lowercase e, acute accent	"&ecirc;",		//            ê             ê      lowercase e, circumflex	"&euml;",		//             ë             ë      lowercase e, dieresis/umlaut	"&igrave;",		//           ì             ì      lowercase i, grave accent	"&iacute;",		//           í             í      lowercase i, acute accent	"&icirc;",		//            î             î      lowercase i, circumflex	"&iuml;",		//             ï             ï      lowercase i, dieresis/umlaut	"&eth;",		// 240          |             |      lowercase eth, Icelandic	"&ntilde;",		//           ñ             ñ      lowercase n, tilde	"&ograve;",		//            ò             ò      lowercase o, grave accent	"&oacute;",		//           ó             ó      lowercase o, acute accent	"&ocirc;",		//            ô             ô      lowercase o, circumflex	"&otilde;",		//           õ             õ      lowercase o, tilde	"&ouml;",		//             ö             ö      lowercase o,  dieresis/umlaut	"&divide;",		//           ÷             ÷      division sign	"&oslash;",		//           ø             ø      lowercase o, slash	"&ugrave;",		//           ù             ù      lowercase u, grave accent	"&uacute;",		// 250       ú             ú      lowercase u, acute accent	"&ucirc;",		//            û             û      lowercase u, circumflex	"&uuml;",		//             ü             ü      lowercase u, dieresis/umlaut	"&yacute;",		//           |             |      lowercase y, acute accent	"&thorn;",		//            |             |      lowercase thorn, Icelandic	"&yuml;"		//             ÿ             ÿ      lowercase y, dieresis/umlaut#endif};static void OutputConversion(FILE *fpt, CEyeDxBooleanType OutputHTML, unsigned char *ptr, long blockSize){	for (long i = 0; i < blockSize; i++)	{	    if (OutputHTML)	    {	    	if (HTMLConversion[*ptr] == NULL)				fputc(*ptr, fpt);			else				fprintf(fpt, HTMLConversion[*ptr]);		}		else		{#ifdef macintosh			if (*ptr == '\r')	// We convert carriage returns to newlines, which the stdio implementation converts back!				fputc('\n', fpt);			else#endif				fputc(*ptr, fpt);		}		ptr++;	}}#ifdef macintoshinline static void OutputString(FILE *fpt, CEyeDxBooleanType OutputHTML, const CEyeDxShortStringType *theString){#ifdef macintosh	OutputConversion(fpt, OutputHTML, (unsigned char *) theString->TextPtr(), (long) theString->Length());#else		OutputConversion(fpt, OutputHTML, (unsigned char *) LPCTSTR(*theString), (int)theString->GetLength());#endif}#endifinline static void OutputString(FILE *fpt, CEyeDxBooleanType OutputHTML, const CEyeDxLongStringType *theString){#ifdef macintosh	OutputConversion(fpt, OutputHTML, (unsigned char *) theString->TextPtr(), (long) theString->Length());#else		OutputConversion(fpt, OutputHTML, (unsigned char *) LPCTSTR(*theString), (int)theString->GetLength());#endif}inline static void OutputEndOfLine(FILE *fpt, CEyeDxBooleanType OutputHTML){	const CEyeDxShortStringType endOfLineString = CommonStringLiteral_(kEndOfLineString);#ifdef macintosh	OutputString(fpt, OutputHTML, &endOfLineString);#else		OutputString(fpt, OutputHTML, &endOfLineString);#endif}// This routine will take the input block of text, and perform two operations on it as it outputs it to the// specified file. First, it replaces variable references with the values of the variables it finds, and then// if the OutputHTML is set it translates special characters into HTML escape codes. If a variable is referenced that isn't defined, // then the literat text of the variable reference (e.g. "{XXX}") is output as-is.const char kOutputAltTextIfNoValue = '?';static void OutputFileText(FILE *fpt, CEyeDxBooleanType OutputHTML, CEyeDxVariableList *theVariableList, unsigned char *ptr, long blockSize){	unsigned char *p = ptr;			while (blockSize > 0)	{		// Output characters with conversion until we hit the end of the block or we hit a left brace.		// We test the value of blockSize first in case it is already 0, so we don't dereference an invalid		// pointer.				while ((blockSize > 0) && (*p != '{'))		{		    OutputConversion(fpt, OutputHTML, p, 1);			p++;			blockSize--;		}				// If blockSize is non-zero, means we found an opening brace				if (blockSize > 0)		{			// Save the current location, in case we need to just resume from here, and also save the remaining			// number of characters						unsigned char *searchp = p;			long remainingBlockSize = blockSize;						// We search for a closing brace. It must occur before the end of the line, and before the end of			// the text block. We test the value of remainingBlockSize first in case it is already 0, so we 			// don't dereference an invalid pointer.						while (remainingBlockSize && (*searchp != '}') && (*searchp != '\n') && (*searchp != '\r') )			{				searchp++;				remainingBlockSize--;			}						// If its a closing brace, then we may have found a variable reference. Check to see if the difference between			// the current searchp and the p value is less than or equal to the maximum length of a variable name. Note			// that the test for remainingBlockSize >= 0 allows us to find a brace at the very end of the text block.						CEyeDxBooleanType validVariable = false;							if ((remainingBlockSize >= 0) && (*searchp == '}'))			{				unsigned char *altTextp = p;								// For now, assume the character before the brace is the end of the name string				unsigned char *endOfNamep = searchp;								// Now we see if the user specified alternate text to be output if the variable isn't set. This involves				// searching from p to searchp -1 for a question mark or slash. If found, we point to the character following the special character.								while ((altTextp < searchp) && (*altTextp != kOutputAltTextIfNoValue))					altTextp++;									// If we found a colon, assume that the end of the name is the character before the colon, and point at the				// first character of the alternate text								if (*altTextp == kOutputAltTextIfNoValue)				{					endOfNamep = altTextp;					altTextp++;				}									// Now we see if the name we found was shorter than the legal variable name. If not, we bail and just output				// everything as-is. Otherwise, we capture the variable name and proceed								if ((endOfNamep - p - 1) <= kCEyeDxVariableNameLength)				{					// Copy the name of the variable out of the text buffer										CEyeDxLongStringType theName;#ifdef macintosh								   			theName[0] = (endOfNamep - p - 1);		   			::BlockMove((p + 1), &theName[1], (endOfNamep - p - 1));#else					char buffer[kCEyeDxVariableNameLength + 1];					strncpy(buffer, (char *)(p + 1), (endOfNamep - p - 1));					buffer[(endOfNamep - p - 1)] = '\0';					theName = buffer;#endif									// Now, lookup the variable by name. If we get back a null pointer, no such					// variable exists. Otherwise, output the variable's value to the output file using					// the HTML conversion function.										CEyeDxVariable *theVariable = theVariableList->GetVariableByName(theName);										if (theVariable != NULL)					{						// The first thing we do is look for any special variables. These are variables that are						// replaced by generated values. The  only one that exists presently is the SESSION REPORT LIST						// variable, which is available anytime, but really makes sense only during Session Summary Report.												if (theName == CommonStringLiteral_(kCEyeDxVariableSESSIONREREPORTLIST))						{							// We have to generate a list of report names from the current session folder. We call a platform-specific							// routine that will return to us a sorted list and a count. We are responsible for deleting the list after							// we are done with it.													CEyeDxVariable *theSessionNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));							CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();																					CTemplateShortStrArray *theSortedReportList = GetReportList(theSessionName);														// Get an array of counters that tell us which reports may represent duplicates. This array							// is indexed in the same order as the items in the sorted report list. Counts of 2 indicate							// that the report probably does not have any duplicates (it matched itself as both source and							// as destination in the GetReportList routine. Counts greater than 2 means that							// the report name was found as part of at least one other report name (i.e. it is a substring							// of the other report name). The routine also tells us whether any duplicates are found via							// the passed boolean variable, so we can quickly determine what to do.							// Note that on the Mac, this list has a dummy item 0 so we can access it with the same array							// indices as for the report name list.														CEyeDxBooleanType duplicatesFound = false;														// Note that we may get back a NULL pointer on Windows, if the input list is empty. So we							// have to be careful handling this below.							short *theCountList = GetReportDuplicateList(theSortedReportList, &duplicatesFound);														// If there are no duplicates in the list, we just output a single list of all of the							// reports, without any special headers. If there are duplicates, we first output the 							// list of items with count 1 with a header, and then follow that							// with the list of the non-1 items with a different header.														CEyeDxArrayIndexType theItem;							CEyeDxArrayIndexType theFirstItem;							CEyeDxArrayIndexType theLastItem;#ifdef macintosh							theFirstItem = 1;							theLastItem = theSortedReportList->GetCount();		// i.e. 1.. n#else							theFirstItem = 0;							theLastItem = theSortedReportList->GetSize() - 1;	// i.e. 0..n-1#endif							CEyeDxShortStringType *theString;							CEyeDxLongStringType theSubjectsMeasuredNote = CommonStringLiteral_(kSummaryReportSubjectsMeasuredNote);							CEyeDxLongStringType theNonDuplicateHeader = CommonStringLiteral_(kSummaryReportNonDuplicateHeader);							CEyeDxLongStringType theDuplicateHeader = CommonStringLiteral_(kSummaryReportDuplicateHeader);							if (duplicatesFound == false)							{															// We output the Subjects Measured Note as-is.																OutputString(fpt, OutputHTML, &theSubjectsMeasuredNote);	   							OutputEndOfLine(fpt, OutputHTML);	   							OutputEndOfLine(fpt, OutputHTML);																// Now that we have the list, we just output them one per line. Eventually, we'll probably have to output multi-column								// lists.								// Get the next string																theItem = theFirstItem;																	while (theItem <= theLastItem)								{#ifdef macintosh									theSortedReportList->FetchItemAt(theItem, theString);#else									theString = theSortedReportList->GetAt(theItem);#endif			   						OutputString(fpt, OutputHTML, theString);		   							OutputEndOfLine(fpt, OutputHTML);			   															// Delete it when we are done																		delete theString;									theItem++;								}							}							else							{								// We output the Subjects Measured Note with an appended sentence that refers to the lists below.																OutputString(fpt, OutputHTML, &theSubjectsMeasuredNote);	   							OutputEndOfLine(fpt, OutputHTML);								theSubjectsMeasuredNote = CommonStringLiteral_(kSummaryReportSubjectsMeasuredNoteAddendum);								OutputString(fpt, OutputHTML, &theSubjectsMeasuredNote);	   							OutputEndOfLine(fpt, OutputHTML);	   							OutputEndOfLine(fpt, OutputHTML);																// Two passes are necessary. First, output the header for the non-duplicate list											   					OutputString(fpt, OutputHTML, &theNonDuplicateHeader);		   						OutputEndOfLine(fpt, OutputHTML);		   						OutputEndOfLine(fpt, OutputHTML);																theItem = theFirstItem;																while (theItem <= theLastItem)								{									if (theCountList[theItem] == 2)									{#ifdef macintosh										theSortedReportList->FetchItemAt(theItem, theString);#else										theString = theSortedReportList->GetAt(theItem);#endif				   						OutputString(fpt, OutputHTML, theString);				   						OutputEndOfLine(fpt, OutputHTML);											// Delete it when we are done																			delete theString;									}									theItem++;								}		   						OutputEndOfLine(fpt, OutputHTML);																// Now, output the header for the duplicate list											   					OutputString(fpt, OutputHTML, &theDuplicateHeader);		   						OutputEndOfLine(fpt, OutputHTML);		   						OutputEndOfLine(fpt, OutputHTML);																// Reparse the list looking for the potential duplicates																theItem = theFirstItem;																while (theItem <= theLastItem)								{									if (theCountList[theItem] > 2)									{#ifdef macintosh										theSortedReportList->FetchItemAt(theItem, theString);#else										theString = theSortedReportList->GetAt(theItem);#endif					   						OutputString(fpt, OutputHTML, theString);		   								OutputEndOfLine(fpt, OutputHTML);											// Delete it when we are done																			delete theString;									}									theItem++;								}							}														// At this point we've deleted all of the strings in the list							// Discard the string list and the count list. Note that the countList may be NULL							// on Windows, if theSortedReportList is empty.														if (theCountList)								delete theCountList;														delete theSortedReportList;						}						else	// It's not a special case variable so handle it in the normal fashion						{							CEyeDxLongStringType *theValue = theVariable->GetValue();														if (*theValue == CommonStringLiteral_(""))							{								// The variable doesn't have a value, so we output the alternate text.								// All we do here is output from altTextp till it matches searchp. If they are								// the same pointer, we output nothing (that handles the "{Var:}" case.																while (altTextp != searchp)									OutputConversion(fpt, OutputHTML, altTextp++, 1);							}							else			   					OutputString(fpt, OutputHTML, theValue);	   					}	   						   					// Now that we've output the value string or the alternate string,		   				// skip over brace, adjust the remaining character count, and continue on.		   				p = searchp + 1;		   				blockSize = remainingBlockSize - 1;		   						   				validVariable = true;					}				}							}			// If we get to here and the variable isn't valid for some reason, we just output everything			if (!validVariable)			{				// Output the opening brace and just continue from the next character in the main loop							    OutputConversion(fpt, OutputHTML, p, 1);				p++;				blockSize--;			}			}	}}void DatabaseOutput(CEyeDxWindowType	*theWindow,					char				*theDatabaseFileName,					CEyeDxVariableList	*theVariableList){	FILE	*fpt;	// We will append to the file		if ((fpt=fopen(theDatabaseFileName,"a")) == NULL)	{		StopAlert(theWindow, CommonStringLiteral_("Unable to open database file for writing."));		return;	}		// All we do here is loop through the variable list by Export Order. If no variables are	// slated for export, then we don't append a record.		CEyeDxVariable *theVariable;	short theExportOrder = kNoExportOrder;	while ((theVariable = theVariableList->GetNextExportedVariable(theExportOrder)) != NULL)	{		// The first time through, we do not output a leading tab character. That allows us to		// output tabs for all other variables without needing a way to "look ahead" if we output		// tabs after each variable!				if (theExportOrder != kNoExportOrder)			fputc('\t', fpt);					// Get the variable's value				CEyeDxLongStringType *theValue = theVariable->GetValue();				// if we have a CheckBox or Menu variable, output the text string associated with the value,		// rather than the value itself				// We output the text of the variable's value, but we convert tabs into spaces, and newlines into spaces.#ifdef macintosh		long theLength = theValue->Length();		unsigned char *ptr = (unsigned char *) theValue->TextPtr();#else		long theLength = theValue->GetLength();		LPCTSTR ptr = (LPCTSTR) *theValue;#endif		for (long i = 0; i < theLength; i++)		{	    	if (*ptr == '\t' || *ptr == '\n' || *ptr == '\r')				fputc(' ', fpt);			else				fputc(*ptr, fpt);			ptr++;		}				// Next time, get the item with the export order that is higher than the current one		// or NULL if no such variable exists.				theExportOrder = theVariable->GetExportOrder();	}		// If we outputted a record, the output a newline to terminate the record. On Windows, we	// also first output a carriage return		if (theExportOrder != kNoExportOrder)		OutputEndOfLine(fpt, false);			fclose(fpt);}// This routine will dump the values of all of the variables as text. If the OutputHTML flag is set,// the names and values of each variable will be converted into HTML codes.static void OutputAllVariables(FILE *fpt, 								CEyeDxBooleanType			OutputHTML,								CEyeDxVariableList			*theVariableList){	unsigned char outputBuffer[520];		CEyeDxArrayIndexType theFirstItem;	CEyeDxArrayIndexType theLastItem;#ifdef macintosh	theFirstItem = 1;	theLastItem = theVariableList->GetCount();		// i.e. 1.. n#else	theFirstItem = 0;	theLastItem = theVariableList->GetCount() - 1;	// i.e. 0..n-1#endif	CEyeDxArrayIndexType theItem = theFirstItem;		while (theItem <= theLastItem)	{		CEyeDxVariable *theVariable = theVariableList->GetVariableByIndex(theItem);		unsigned char nameBuffer[256];		unsigned char valueBuffer[256];				CopyEyeDxStringToCString(theVariable->GetName(), nameBuffer);		CopyEyeDxStringToCString(theVariable->GetValue(), valueBuffer);		sprintf((char *)outputBuffer, "%-40s %s", (char *)nameBuffer, (char *)valueBuffer);		OutputConversion(fpt, OutputHTML, outputBuffer, strlen((char *)outputBuffer));		OutputEndOfLine(fpt, false);				theItem++;	}}void ReportOutput(CEyeDxWindowType		*theWindow,					AnalysisResults		*theAnalysisResults,					EyeDxReportFormat	theReportFormat,					CEyeDxVariableList	*theVariableList,					char				**theOptionalReportText,					long				*theOptionalReportTextSize,					long				theNumOptionalReportText){	FILE	*fpt;	if ((fpt=fopen(theAnalysisResults->Report_path,"w")) == NULL)	{		StopAlert(theWindow, CommonStringLiteral_("Unable to open report for writing."));		std::exit(0);	}		CEyeDxVariable *theTodaysDateVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableTODAYSDATE));	CEyeDxVariable *theStartTimeVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTSTARTTIME));	CEyeDxVariable *theApplVersionVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableAPPLICATIONVERSION));	CEyeDxLongStringType footer = CommonStringLiteral_("<ADDRESS> info@eyedx.com / Version ");		if (theApplVersionVariable)		footer += *(theApplVersionVariable->GetValue());	else		footer += CommonStringLiteral_("pNo version available");			footer += CommonStringLiteral_(" / ");		if (theTodaysDateVariable)		footer += *(theTodaysDateVariable->GetValue());	else		footer += CommonStringLiteral_("No date available");			footer += CommonStringLiteral_(", ");		if (theStartTimeVariable)		footer += *(theStartTimeVariable->GetValue());	else		footer += CommonStringLiteral_("No time available");			footer += CommonStringLiteral_(" </A></ADDRESS>\n");	  	fprintf(fpt, "<HTML>\n");  	fprintf(fpt, "<HEAD>\n");	fprintf(fpt, "<META NAME=\"GENERATOR\" CONTENT=\"EyeDx\">\n");	// The following is a kludge that hopefully forces the browser to refresh the report file every time.	fprintf(fpt, "<META HTTP-EQUIV=\"expires\" CONTENT=\"Tue, 31 Dec 1996 01:23:45 GMT\">\n<META HTTP-EQUIV=\"Pragma\" CONTENT=\"no-cache\">\n");	fprintf(fpt, "<TITLE>EyeDx Digital Analysis</TITLE>\n");	fprintf(fpt, "</HEAD>\n");	fprintf(fpt, "<BODY BGCOLOR=\"#ffffff\">\n");		if (AdvancedFeatures)	{		// Now output the encoded results as an HTML comment				fprintf(fpt, "<!--\n");		fprintf(fpt, "A:\n");		fprintf(fpt, "TP:     %d\n", theAnalysisResults->upResults.total_points);		fprintf(fpt, "TC:     %d\n", theAnalysisResults->upResults.total_circles);		fprintf(fpt, "PT:     %g\n", theAnalysisResults->upResults.pupil_threshold);		fprintf(fpt, "PPD:    %g\n", theAnalysisResults->upResults.pupil_to_pupil_dist);		fprintf(fpt, "PHA:    %g\n", theAnalysisResults->upResults.pupils_horizon_angle);		fprintf(fpt, "S:      %d\n", theAnalysisResults->upResults.strabismus);		fprintf(fpt, "RRL:    %d\n", theAnalysisResults->upResults.red_reflex_lumin);		fprintf(fpt, "\n");		fprintf(fpt, "REC:    (%g, %g, %g, %g)\n", theAnalysisResults->upResults.righteye_circles[0],															  theAnalysisResults->upResults.righteye_circles[1],														  	  theAnalysisResults->upResults.righteye_circles[2],															  theAnalysisResults->upResults.righteye_circles[3]);		fprintf(fpt, "RA:     (%d, %d)\n", 	theAnalysisResults->upResults.right_arr_col, theAnalysisResults->upResults.right_arr_row);		fprintf(fpt, "RACl:   %d\n", 		theAnalysisResults->upResults.right_arr_class);		fprintf(fpt, "RECRP:  (%d, %d)\n",  (int)(theAnalysisResults->upResults.righteye_cr_point % theAnalysisResults->upResults.cols),											(int)(theAnalysisResults->upResults.righteye_cr_point / theAnalysisResults->upResults.cols));		fprintf(fpt, "\n");		fprintf(fpt, "LEC:    (%g, %g, %g, %g)\n", theAnalysisResults->upResults.lefteye_circles[0],															  theAnalysisResults->upResults.lefteye_circles[1],															  theAnalysisResults->upResults.lefteye_circles[2],															  theAnalysisResults->upResults.lefteye_circles[3]);		fprintf(fpt, "LA:     (%d, %d)\n", 	theAnalysisResults->upResults.left_arr_col, theAnalysisResults->upResults.left_arr_row);		fprintf(fpt, "LACl:   %d\n", 		theAnalysisResults->upResults.left_arr_class);		fprintf(fpt, "LECRP:  (%d, %d)\n",  (int)(theAnalysisResults->upResults.lefteye_cr_point % theAnalysisResults->upResults.cols),											(int)(theAnalysisResults->upResults.lefteye_cr_point / theAnalysisResults->upResults.cols));		fprintf(fpt, "\n");		fprintf(fpt, "B:\n");		fprintf(fpt, "TP:     %d\n", theAnalysisResults->sideResults.total_points);		fprintf(fpt, "TC:     %d\n", theAnalysisResults->sideResults.total_circles);		fprintf(fpt, "PT:     %g\n", theAnalysisResults->sideResults.pupil_threshold);		fprintf(fpt, "PPD: 	  %g\n", theAnalysisResults->sideResults.pupil_to_pupil_dist);		fprintf(fpt, "PHA:    %g\n", theAnalysisResults->sideResults.pupils_horizon_angle);		fprintf(fpt, "S:      %d\n", theAnalysisResults->sideResults.strabismus);		fprintf(fpt, "RRL:    %d\n", theAnalysisResults->sideResults.red_reflex_lumin);		fprintf(fpt, "\n");		fprintf(fpt, "REC:    (%g, %g, %g, %g)\n", theAnalysisResults->sideResults.righteye_circles[0],															  theAnalysisResults->sideResults.righteye_circles[1],														  	  theAnalysisResults->sideResults.righteye_circles[2],															  theAnalysisResults->sideResults.righteye_circles[3]);		fprintf(fpt, "RA:     (%d, %d)\n", 	theAnalysisResults->sideResults.right_arr_col, theAnalysisResults->sideResults.right_arr_row);		fprintf(fpt, "RACl:   %d\n", 		theAnalysisResults->sideResults.right_arr_class);		fprintf(fpt, "RECRP:  (%d, %d)\n",  (int)(theAnalysisResults->sideResults.righteye_cr_point % theAnalysisResults->sideResults.cols),											(int)(theAnalysisResults->sideResults.righteye_cr_point / theAnalysisResults->sideResults.cols));		fprintf(fpt, "\n");		fprintf(fpt, "LEC:    (%g, %g, %g, %g)\n", theAnalysisResults->sideResults.lefteye_circles[0],															  theAnalysisResults->sideResults.lefteye_circles[1],															  theAnalysisResults->sideResults.lefteye_circles[2],															  theAnalysisResults->sideResults.lefteye_circles[3]);		fprintf(fpt, "LA:     (%d, %d)\n", 	theAnalysisResults->sideResults.left_arr_col, theAnalysisResults->sideResults.left_arr_row);		fprintf(fpt, "LACl:   %d\n", 		theAnalysisResults->sideResults.left_arr_class);		fprintf(fpt, "LECRP:  (%d, %d)\n",  (int)(theAnalysisResults->sideResults.lefteye_cr_point % theAnalysisResults->sideResults.cols),											(int)(theAnalysisResults->sideResults.lefteye_cr_point / theAnalysisResults->sideResults.cols));		fprintf(fpt, "\n");		fprintf(fpt, "Variables:\n");		fprintf(fpt, "\n");				OutputAllVariables(fpt, true, theVariableList);		fprintf(fpt, "-->\n");	}		switch (theReportFormat)	{	case kStandardReportFormat:			fprintf(fpt, "<CENTER>\n");		fprintf(fpt, "<TABLE BORDER=2 CELLSPACING=2 CELLPADDING=2>\n");		fprintf(fpt, "<TR ALIGN=CENTER> ");		fprintf(fpt, "<TD ALIGN=CENTER VALIGN=MIDDLE WIDTH=120> ");		fprintf(fpt, "<IMG HEIGHT=75 WIDTH=91 SRC=\"../EyeDxLogo.jpg\">\n");		fprintf(fpt, "<TD><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=2 WIDTH=520>\n");		fprintf(fpt, "<TR ALIGN=CENTER><TD><B><FONT SIZE=5>");		fprintf(fpt, "Digital Vision Screening Report</FONT></B>\n");		fprintf(fpt, "</TABLE>\n<HR>\n");		fprintf(fpt, "<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 ALIGN=LEFT>\n");		fprintf(fpt, "<TR><TD ALIGN=RIGHT WIDTH=260>\n");		fprintf(fpt, "<H3><B><I>Name or ID number:</I></B> </H3></TD>\n");		fprintf(fpt, "<TD ALIGN=LEFT><H3>&nbsp;&nbsp; %s</H3></TD></TR>\n", theAnalysisResults->ReportName);		fprintf(fpt, "<TR><TD WIDTH=260><DIV ALIGN=right>\n");		fprintf(fpt, "<H3><I>Screening Result:</I></H3>\n");		fprintf(fpt, "</DIV></TD><TD><H3>&nbsp;&nbsp; ");	  		  	switch (theAnalysisResults->ReferralCode)	  	{	  	case kYesReferralCode:			fprintf(fpt, "Refer");			break;				  	case kNoReferralCode:			fprintf(fpt, "Pass");			break;				  	case kSecondImageReferralCode:			fprintf(fpt, "Second image required.");			break;				  	case kUnclearReferralCode:			fprintf(fpt, "Image(s) unclear.  Please repeat.");			break;					}	  		  	fprintf(fpt, " </H3></TD></TR>\n");	  	fprintf(fpt, "</TABLE></TABLE><P>\n\n");	  	fprintf(fpt, "<TABLE BORDER=3 CELLSPACING=2 CELLPADDING=2>\n");	  	fprintf(fpt, "<TR ALIGN=CENTER> ");	 	    fprintf(fpt, "<TD> Photo ID:  %s (up) ", theAnalysisResults->UpName);	  		    fprintf(fpt, "<TD> Photo ID:  %s (%s) ", theAnalysisResults->SideName,				(theAnalysisResults->SideOrientation == 0 ? "left" : "right"));	  		  	fprintf(fpt, "\n");	    fprintf(fpt, "<TR ALIGN=CENTER> ");	  		    fprintf(fpt, "<TD> <IMG HEIGHT=240 WIDTH=320 SRC=\"../Simages/%s%sUsc.jpg\">\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);	    fprintf(fpt, "<TD> <IMG HEIGHT=240 WIDTH=320 SRC=\"../Simages/%s%sSsc.jpg\">\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);	  		  	fprintf(fpt, "\n");	  		  	// We do two different things based on whether the AdvancedFeatures flag is set. If it is not set (the normal condition), we create	  	// a single table row that will contain two columns (for Up and Side). In each cell there may appear one of two subtables: a side-by-side	  	// display of the annotated eye images, or an over/under table consisting of the two annotation strings.	  		  	// If the advancedFeatures flag is set, we create two rows (creating the old style report with raw eye images).	  		  	if (!AdvancedFeatures)	  	{	  		// We are creating the normal report format without the raw eye images. This will be either a text two row subtable with the	  		// result text, or a two column sub table with the annotated eyes.	  			  		fprintf(fpt, "<TR ALIGN=CENTER> ");	  			  		// First handle the Up image - this definition applies to either image or annotation display subtable in this row	  				fprintf(fpt, "<TD WIDTH=290> <TABLE BORDER=1 CELLSPACING=2 CELLPADDING=2>\n");						// This TR is either the first (and only row) of the image table, or the top row of the annotation table			    		fprintf(fpt, "  <TR ALIGN=CENTER> <TD> ");	    	if (theAnalysisResults->UpAnnotate)	    	{	    		// Top annotation cell	      		fprintf(fpt, "%s\n",theAnalysisResults->eye_image_annot[kUpTopResult]);	      			      		// Bottom annotation cell	      		fprintf(fpt, "  <TR ALIGN=CENTER> <TD> ");	      			        	fprintf(fpt, "%s\n", theAnalysisResults->eye_image_annot[kUpBottomResult]);			}	    	else	// Display the two annotated images side-by-side	      	{	    		fprintf(fpt, "<IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sUre.jpg\">\n",        theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);	    		fprintf(fpt, "  <TD> <IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sUle.jpg\">\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);	    	}	    		    	// And we're done with the Up subtable	    		    	fprintf(fpt, "  </TABLE>\n");	    	// Now we do the same for the Side image - this definition applies to either image or annotation display subtable in this row	    				fprintf(fpt, "<TD WIDTH=290> <TABLE BORDER=1 CELLSPACING=2 CELLPADDING=2>\n");			// This TR is either the first (and only row) of the image table, or the top row of the annotation table			    		fprintf(fpt, "  <TR ALIGN=CENTER> <TD> ");	    	if (theAnalysisResults->SideAnnotate)	    	{	    		// Top annotation cell	      		fprintf(fpt, "%s\n",theAnalysisResults->eye_image_annot[kSideTopResult]);	      			      		// Bottom annotation cell	      		fprintf(fpt, "  <TR ALIGN=CENTER> <TD> ");	      			        	fprintf(fpt, "%s\n", theAnalysisResults->eye_image_annot[kSideBottomResult]);			}	    	else	// Display the two annotated images side-by-side	      	{	    		fprintf(fpt, "<IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sSre.jpg\">\n",        theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);	    		fprintf(fpt, "  <TD> <IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sSle.jpg\">\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);	    	}	    		    	// And we're done with the Side subtable	    		    	fprintf(fpt, "  </TABLE>\n");    	}    	else	// We include both the raw and annotated eyes, and display the text annotation (if it exists) in two different    			// tables instead of two rows of one subtable    	{	  		fprintf(fpt, "<TR ALIGN=CENTER> ");	  			    	fprintf(fpt, "<TD WIDTH=290> <TABLE BORDER=1 CELLSPACING=2 CELLPADDING=2>\n");    		fprintf(fpt, "  <TR ALIGN=CENTER> <TD> ");    		    	if (theAnalysisResults->UpAnnotate)	      		fprintf(fpt, "%s\n", theAnalysisResults->eye_image_annot[kUpTopResult]);	   		else	      	{      			fprintf(fpt, "<IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sUrr.jpg\">\n",        theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);      			fprintf(fpt, "  <TD> <IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sUlr.jpg\">\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);	      	}	    		    	fprintf(fpt, "  </TABLE>\n");		  			  		    	fprintf(fpt, "<TD WIDTH=290> <TABLE BORDER=1 CELLSPACING=2 CELLPADDING=2>\n");    		fprintf(fpt, "  <TR ALIGN=CENTER> <TD> ");    		    	if (theAnalysisResults->SideAnnotate)	      		fprintf(fpt, "%s\n", theAnalysisResults->eye_image_annot[kSideTopResult]);	   		else	      	{	      		fprintf(fpt, "<IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sSrr.jpg\">\n",         theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);  	    		fprintf(fpt, "  <TD> <IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sSlr.jpg\">\n",  theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);	      	}	    		    	fprintf(fpt, "  </TABLE>\n");				  		    	fprintf(fpt, "<TR ALIGN=CENTER> ");	    		  		fprintf(fpt, "<TD WIDTH=290> <TABLE BORDER=1 CELLSPACING=2 CELLPADDING=2>\n");	  		fprintf(fpt, "  <TR ALIGN=CENTER> <TD> ");	      			    	if (theAnalysisResults->UpAnnotate)	        	fprintf(fpt, "%s\n", theAnalysisResults->eye_image_annot[kUpBottomResult]);	 		else	    	{	    		fprintf(fpt, "<IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sUre.jpg\">\n",        theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);	    		fprintf(fpt, "  <TD> <IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sUle.jpg\">\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);	    	}	  		fprintf(fpt, "  </TABLE>\n");	    		  		fprintf(fpt, "<TD WIDTH=290> <TABLE BORDER=1 CELLSPACING=2 CELLPADDING=2>\n");	  		fprintf(fpt, "  <TR ALIGN=CENTER> <TD> ");	      			    	if (theAnalysisResults->SideAnnotate)	      		fprintf(fpt, "%s\n", theAnalysisResults->eye_image_annot[kSideBottomResult]);	  		else	    	{	    		fprintf(fpt, "<IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sSre.jpg\">\n",        theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);	    		fprintf(fpt, "  <TD> <IMG HEIGHT=128 WIDTH=128 SRC=\"../eyes/%s%sSle.jpg\">\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);	   		}	  		fprintf(fpt, "  </TABLE>\n");    	}  		  	fprintf(fpt, "</TABLE><P>\n");	  	fprintf(fpt, "<TABLE BORDER=0 CELLPADDING=2 CELLSPACING=2 WIDTH=665>\n");	  	fprintf(fpt, "<TR><TD ALIGN=LEFT>\n");	  	fprintf(fpt, "EyeDx screening estimates refractive errors, strabismus and pupil opacities.\n");	  	fprintf(fpt, "Please be aware of the tolerances of the system noted in the\n");	  	fprintf(fpt, "EyeDx Digital Vision Screening System User's Guide.\n");	  		  	if (AdvancedFeatures)	  	{		  	fprintf(fpt, "<TR><TD ALIGN=LEFT>\n");		  	fprintf(fpt, "Display of annotated eyes is for viewing purposes only and is not required\n");		  	fprintf(fpt, "by the EyeDx software to provide the referral recommendation.\n");	  	}	  	fprintf(fpt, "<TR><TD ALIGN=CENTER>Patent pending.\n");	  	fprintf(fpt, "</TABLE><P>\n");	  		unsigned char buffer[256];		CopyEyeDxStringToCString(&footer, buffer);		fputs((char *)buffer, fpt);  		fprintf(fpt, "</CENTER>\n\n");  	  		break;  		  	case kCustomReportFormat1:  			// Report text section - explanations and other information		fprintf(fpt, "<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=2 WIDTH=100%%>\n");      	if (theOptionalReportTextSize[kReportLayoutHeaderText])    	{	  		fprintf(fpt, "<TR>\n");	// Report heading	    	fprintf(fpt, "<TD VALIGN=TOP ALIGN=CENTER>\n");	      	fprintf(fpt, "<H2>");    		// Loop through the text, outputting HTML codes when necessary, text otherwise    					OutputFileText(fpt, true, theVariableList, (unsigned char *) theOptionalReportText[kReportLayoutHeaderText],								  theOptionalReportTextSize[kReportLayoutHeaderText]);			fprintf(fpt, "</H2></TD>\n");	  		fprintf(fpt, "</TR>\n");    	}	    	  		      	if (theOptionalReportTextSize[kReportLayoutIntroductionText])    	{	  		fprintf(fpt, "<TR>\n");	// Introduction	    	fprintf(fpt, "<TD VALIGN=TOP>");	         		// Loop through the text, outputting HTML codes when necessary, text otherwise    					OutputFileText(fpt, true, theVariableList, (unsigned char *) theOptionalReportText[kReportLayoutIntroductionText],								  theOptionalReportTextSize[kReportLayoutIntroductionText]);	  		fprintf(fpt, "</TR>\n");    	}	    	  		fprintf(fpt, "<TR>\n");	// Results block  		    	fprintf(fpt, "<TD VALIGN=TOP>");    		  	switch (theAnalysisResults->ReferralCode)	  	{	  	case kYesReferralCode:	  		      	if (theOptionalReportTextSize[kReportLayoutReferResultText])	    	{	    		// Loop through the text, outputting HTML codes when necessary, text otherwise	    						OutputFileText(fpt, true, theVariableList, (unsigned char *) theOptionalReportText[kReportLayoutReferResultText],								  theOptionalReportTextSize[kReportLayoutReferResultText]);	    	}	    				break;				  	case kNoReferralCode:	  		      	if (theOptionalReportTextSize[kReportLayoutPassResultText])	    	{	    		// Loop through the text, outputting HTML codes when necessary, text otherwise	    						OutputFileText(fpt, true, theVariableList, (unsigned char *) theOptionalReportText[kReportLayoutPassResultText],								  theOptionalReportTextSize[kReportLayoutPassResultText]);	    	}	    				break;				  	case kSecondImageReferralCode:	  	case kUnclearReferralCode:	  		      	if (theOptionalReportTextSize[kReportLayoutRetakeResultText])	    	{	    		// Loop through the text, outputting HTML codes when necessary, text otherwise	    						OutputFileText(fpt, true, theVariableList, (unsigned char *) theOptionalReportText[kReportLayoutRetakeResultText],								  theOptionalReportTextSize[kReportLayoutRetakeResultText]);	    	}	    				break;		}		  		fprintf(fpt, "</TR>\n");  			  			  				fprintf(fpt, "</TABLE>\n");		// Image table				fprintf(fpt, "<TABLE WIDTH=100%% BORDER=1 CELLSPACING=2 CELLPADDING=2>\n");  		fprintf(fpt, "<TR>\n");	// Heading, giving the EyeDx name, the report name, and the result    	fprintf(fpt, "<TD COLSPAN=2 VALIGN=TOP>\n");      	fprintf(fpt, "<DIV ALIGN=CENTER><P>EyeDx Digital Vision Screening Report: %s - ", theAnalysisResults->ReportName);      		  	switch (theAnalysisResults->ReferralCode)	  	{	  	case kYesReferralCode:			fprintf(fpt, "Refer");			break;				  	case kNoReferralCode:			fprintf(fpt, "Pass");			break;				  	case kSecondImageReferralCode:			fprintf(fpt, "Second image required.");			break;				  	case kUnclearReferralCode:			fprintf(fpt, "Image(s) unclear.  Please repeat.");			break;					}	  			fprintf(fpt, "</DIV></TD>\n");  		fprintf(fpt, "</TR>\n");  		  		fprintf(fpt, "<TR>\n");	// Names of the images    	fprintf(fpt, "<TD WIDTH=50%% VALIGN=TOP>\n");      	fprintf(fpt, "<DIV ALIGN=CENTER><P>Photo ID: %s (Up)</DIV></TD>\n",  theAnalysisResults->UpName);    	fprintf(fpt, "<TD WIDTH=50%% VALIGN=TOP>\n");      	fprintf(fpt, "<DIV ALIGN=CENTER><P>&nbsp;Photo ID: %s (%s)</DIV></TD>\n", theAnalysisResults->SideName,       					(theAnalysisResults->SideOrientation == 0 ? "Left" : "Right"));  		fprintf(fpt, "</TR>\n");  				fprintf(fpt, "<TR>\n");  	// The scaled input images				  	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../Simages/%s%sUsc.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);	  	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../Simages/%s%sSsc.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);		  			fprintf(fpt, "</TR>\n");		fprintf(fpt, "<TR>\n");	// The results - either text or graphics, depending on the analysis results     	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER>\n");     	  		if (theAnalysisResults->UpAnnotate)	// No images to display - display appropriate error strings instead  		{			fprintf(fpt, "<TABLE WIDTH=100%% BORDER=0 CELLSPACING=2 CELLPADDING=0>\n");        	fprintf(fpt, "<TR>\n");          	fprintf(fpt, "<TD WIDTH=100%%>\n");            fprintf(fpt, "<DIV ALIGN=CENTER><P>%s</DIV></TD>\n", theAnalysisResults->eye_image_annot[kUpTopResult]);        	fprintf(fpt, "</TR>\n");        	fprintf(fpt, "<TR>\n");          	fprintf(fpt, "<TD WIDTH=100%%>\n");            fprintf(fpt, "<DIV ALIGN=CENTER><P>%s</DIV></TD>", theAnalysisResults->eye_image_annot[kUpBottomResult]);        	fprintf(fpt, "</TR>\n");        	fprintf(fpt, "</TABLE>\n");    	} 		else	// We have images to display    	{        	// Eye image table        	    		fprintf(fpt, "<TABLE WIDTH=57%% BORDER=1 CELLSPACING=0 CELLPADDING=0>\n");    		    		if (AdvancedFeatures)    		{	        	fprintf(fpt, "<TR>\n");	// Regular eye images	          	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../eyes/%s%sUrr.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName); 	          	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../eyes/%s%sUlr.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName); 	        	fprintf(fpt, "</TR>\n");        	}        	        	fprintf(fpt, "<TR>\n");	// Annotated eye images          	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../eyes/%s%sUre.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);           	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../eyes/%s%sUle.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);         	fprintf(fpt, "</TR>\n");      		fprintf(fpt, "</TABLE>\n");      		fprintf(fpt, "</TD>\n");	  			    	}     	fprintf(fpt, "</TD>\n");     	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER>\n");  		if (theAnalysisResults->SideAnnotate)	// No images to display - display appropriate error strings instead  		{			fprintf(fpt, "<TABLE WIDTH=100%% BORDER=0 CELLSPACING=2 CELLPADDING=0>\n");        	fprintf(fpt, "<TR>\n");          	fprintf(fpt, "<TD WIDTH=100%%>\n");            fprintf(fpt, "<DIV ALIGN=CENTER><P>%s</DIV></TD>\n", theAnalysisResults->eye_image_annot[kSideTopResult]);        	fprintf(fpt, "</TR>\n");        	fprintf(fpt, "<TR>\n");          	fprintf(fpt, "<TD WIDTH=100%%>\n");            fprintf(fpt, "<DIV ALIGN=CENTER><P>%s</DIV></TD>\n", theAnalysisResults->eye_image_annot[kSideBottomResult]);        	fprintf(fpt, "</TR>\n");        	fprintf(fpt, "</TABLE>\n");    	} 		else	// We have images to display    	{        	// Eye image table        	    		fprintf(fpt, "<TABLE WIDTH=57%% BORDER=1 CELLSPACING=0 CELLPADDING=0>\n");    		    		if (AdvancedFeatures)    		{	        	fprintf(fpt, "<TR>\n");	// Regular eye images	          	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../eyes/%s%sSrr.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName); 	          	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../eyes/%s%sSlr.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName); 	        	fprintf(fpt, "</TR>\n");        	}        	        	fprintf(fpt, "<TR>\n");	// Annotated eye images          	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../eyes/%s%sSre.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);           	fprintf(fpt, "<TD WIDTH=50%% ALIGN=CENTER><IMG SRC=\"../eyes/%s%sSle.jpg\" ALIGN=BOTTOM BORDER=0 NATURALSIZEFLAG=2></TD>\n", theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);         	fprintf(fpt, "</TR>\n");      		fprintf(fpt, "</TABLE>\n");      		fprintf(fpt, "</TD>\n");      	}     	fprintf(fpt, "</TD>\n");		fprintf(fpt, "</TR>\n");				fprintf(fpt, "<TR>\n");	// EyeDx credit and warning row		fprintf(fpt, "<TD COLSPAN=2 VALIGN=TOP ALIGN=CENTER><FONT SIZE=-1>\n");		fprintf(fpt, "EyeDx screening system estimates refractive errors, pupil opacities and strabismus "  			"based on established screening tolerances. Patent pending.</FONT></TD>\n"); 		fprintf(fpt, "</TR>\n"); 				fprintf(fpt, "</TABLE>\n");      	if (theOptionalReportTextSize[kReportLayoutFooterText])    	{			fprintf(fpt, "<TABLE WIDTH=100%% BORDER=0 CELLSPACING=2 CELLPADDING=2>\n");	  		fprintf(fpt, "<TR>\n");	// Report heading	    	fprintf(fpt, "<TD VALIGN=TOP>");    		// Loop through the text, outputting HTML codes when necessary, text otherwise    					OutputFileText(fpt, true, theVariableList, (unsigned char *) theOptionalReportText[kReportLayoutFooterText],								  theOptionalReportTextSize[kReportLayoutFooterText]);			fprintf(fpt, "</TD>\n");	  		fprintf(fpt, "</TR>\n");			fprintf(fpt, "</TABLE>\n");    	}	    	  		break;  	}  		fprintf(fpt, "</BODY>\n");	fprintf(fpt, "</HTML>\n");	fclose(fpt);}void SessionSummaryOutput(CEyeDxWindowType		*theWindow,							CEyeDxVariableList	*theVariableList,							const char			*theSummaryReportText,							long				theSummaryReportTextSize){	FILE	*fpt;	char sessionSummaryRptPath[1000];		CEyeDxVariable *theSessionNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();	#ifdef macintosh	char sessionName[63];	strncpy(sessionName, theSessionName->TextPtr(), theSessionName->Length());	sessionName[theSessionName->Length()] = '\0';					sprintf(sessionSummaryRptPath, ":%s:%s", sessionName, kDefaultSessionSummaryName);#else	sprintf(sessionSummaryRptPath, "%s%s\\%s", DataPath, *theSessionName, kDefaultSessionSummaryName);#endif	if ((fpt=fopen(sessionSummaryRptPath,"w")) == NULL)	{		StopAlert(theWindow, CommonStringLiteral_("Unable to open session summary report for writing."));		std::exit(0);	}		// Now, we take the text block for the session summary report, and output it to the file. We specify that we do	// not want HTML conversion. The routine will perform variable insertion as appropriate. It handles the special case	// of report name list by generating the list on the fly from the session name variable.		OutputFileText(fpt, false, theVariableList, (unsigned char *) theSummaryReportText, theSummaryReportTextSize);		fclose(fpt);#ifdef macintosh	// Set the creator of the summary file to TeachText	FSSpec theReportFSSpec;	FInfo theReportFInfo;	__path2fss(sessionSummaryRptPath, &theReportFSSpec);	::FSpGetFInfo(&theReportFSSpec, &theReportFInfo);	theReportFInfo.fdCreator = kTeachTextCreator;	theReportFInfo.fdType = kTeachTextType;	::FSpSetFInfo(&theReportFSSpec, &theReportFInfo);			// We also add a 'styl' resource to the file so that it is displayed in monospaced font.		StScrpHandle theScrpHandle = (StScrpHandle) ::NewHandle(sizeof(short) + sizeof(ScrpSTElement));	::HLock((Handle)theScrpHandle);	(*theScrpHandle)->scrpNStyles = 1;	ScrpSTElement *theStyleStruct = &(*theScrpHandle)->scrpStyleTab[0];		// Save the current Text State and load the font. The StTextState will restore the previous port's	// text state when we exit the routine.		StTextState theTextState;		TextTraitsRecord theTextTraits;		UTextTraits::LoadTextTraits(kNormalMonospacedTextTraits, theTextTraits);	UTextTraits::SetPortTextTraits(&theTextTraits);		// Now we can get the font ascent information		FontInfo theFontInfo;		::GetFontInfo(&theFontInfo);		SInt16 lineHeight = (SInt16) (theFontInfo.ascent + theFontInfo.descent + theFontInfo.leading);	theStyleStruct->scrpStartChar = 0L; 						/* starting character position */    theStyleStruct->scrpHeight = lineHeight;   				/* line height */    theStyleStruct->scrpAscent = theFontInfo.ascent;    theStyleStruct->scrpFont = theTextTraits.fontNumber;    theStyleStruct->scrpFace = theTextTraits.style;   		/* unpacked byte */    theStyleStruct->scrpSize = theTextTraits.size;    theStyleStruct->scrpColor = theTextTraits.color;        // Save the current resource file, which will be restored on exit.    	StCurResFile theCurResFile;    	::FSpCreateResFile(&theReportFSSpec, kTeachTextCreator, kTeachTextType, nil);	ThrowIfResError_();												// And open it	SInt16 rsrcRefNum  = ::FSpOpenResFile(&theReportFSSpec, fsWrPerm);	ThrowIfResError_();    // Write the attributes to the file        ::AddResource(Handle(theScrpHandle), ResType_TextStyle, 128, "\p");    ::WriteResource(Handle(theScrpHandle));    ::ReleaseResource(Handle(theScrpHandle));    ::CloseResFile(rsrcRefNum);   #endif}