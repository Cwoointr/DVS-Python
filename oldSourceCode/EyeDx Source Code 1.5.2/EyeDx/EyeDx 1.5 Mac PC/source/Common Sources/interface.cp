#include <stdio.h>#ifndef macintosh#include <windows.h>#include <process.h>#include "resource.h"#define	FLASH_DELAY	166L#else#include <string.h>#include <stdlib.h>#include <unistd.h>#include "EyeDxMacConstants.h"#include "CMyGWorldView.h"#include <LCaption.h>#include <path2fss.h>//#define LOGGING#ifdef LOGGING#include "memlogger.h"extern FILE *logfile;extern long dummyGrow;#endif#define FLASH_DELAY	10L		// 10 ticks = 166 ms#endif#include <ctype.h>#include "globals.h"#include "DC120.h"long startTicks;long endTicks;static int			CameraOpen=0; // 0 => no, 1=> driver, 2=> camerastatic DCDriver		Driver;	// Kodak camera hooksstatic DCCamera		Camera;int	NumOfPicts = 0, LastNumOfPicts=0, UpPictNum=1, SidePictNum=2;static DCCamMemType	CamOrCard;// Global that holds the list of pictures for use in the selection dialogschar *PictNamePtr;			/*			** During animation, used to flash located eyes.			*/void FlashCircles(unsigned char *Background,				  int ROWS,int COLS,				  double *circle1,				  double *circle2,				  CEyeDxViewType *theView){	int		i;	for (i=0; i<Flashes; i++)  	{		long colors[] = { 255, 128, 0 };					long red = colors[(i+0)%3];		long green = colors[(i+2)%3];		long blue = colors[(i+1)%3];					theView->DrawCircle(ROWS, COLS, circle1[0], circle1[1], circle1[2], CircleThickness, red, green, blue);		theView->DrawCircle(ROWS, COLS, circle2[0], circle2[1], circle2[2], CircleThickness, red, green, blue);		OSSleep(FLASH_DELAY);	}}			/*			** During animation, used to zoom in on subimage area.			*/void ZoomDisplay(unsigned char *Image,				int ROWS,int COLS,				int zy, int zx,				int ZoomRows,int ZoomCols,				int ZoomSteps,				CEyeDxViewType *theView){	int	EYE_ROWS,EYE_COLS,EyeX,EyeY,i,dROWS,dCOLS,dx,dy;		EYE_ROWS=ZoomRows;	EYE_COLS=ZoomCols;	EyeX=zx-EYE_COLS/2;	EyeY=zy-EYE_ROWS/2;	if (EyeX < 0) EyeX=0;	if (EyeY < 0) EyeY=0;	for (i=ZoomSteps; i>=0; i--)	{		if (ZoomSteps == 0)		{			dROWS=EYE_ROWS; dCOLS=EYE_COLS; dx=EyeX; dy=EyeY;		}		else		{	  		dROWS=EYE_ROWS+(int)((double)(ROWS-EYE_ROWS)*(double)i/(double)ZoomSteps);	  		dCOLS=EYE_COLS+(int)((double)(COLS-EYE_COLS)*(double)i/(double)ZoomSteps);	  		dx=EyeX-(int)((double)(EyeX-0)*(double)i/(double)ZoomSteps);	  		dy=EyeY-(int)((double)(EyeY-0)*(double)i/(double)ZoomSteps);  		}		theView->ZoomImageFromRaw24Bit(Image, ROWS, COLS, dCOLS, dROWS, dx, dy);  	}}// These variables hold pointers to the progress and captions that show download// and image decompressing statusstatic CEyeDxProgressType *sThermometer;static CEyeDxCaptionType *sCaption;int DownloadSide;	/* 0 or 1 meaning up or side image currently being downloaded */static CEyeDxBooleanType pascal  DownloadProgress(DCProgressStatus		Status,								short				PercentComplete,								DCProgressType		Type,								long				){	// These may be null pointers in some cases where we don't want feedback		if (sThermometer)		SetThermometerValue(sThermometer, PercentComplete);		if (sCaption)	{		// We set the caption once at the beginning, to avoid flashing on each update		if (Status == DCProgressInit)		{			if (Type == DCTransferImage)				SetCaptionText(sCaption, CommonStringLiteral_("Downloading"));			else /* Type == DCImageProcess */				SetCaptionText(sCaption, CommonStringLiteral_("Decompressing"));		}	}		return(TRUE);}// This routine will download the current camera configuration, and then use that as a // baseline to set the configuration to a standard set for taking picturesint SetCameraConfiguration(CEyeDxWindowType *theWindow,					 	  CEyeDxCaptionType *theStatusCaption){	DC120Config		theDC120Config;			SetCaptionText(theStatusCaption, CommonStringLiteral_("Checking camera settings..."));	// We don't care about the generic status, as it only gives the Time and Camera ID.		if (DCGetConfig(&Camera, (DCConfigPtr) NULL, &theDC120Config) != DC_NoErr)  	{		StopAlert(theWindow, CommonStringLiteral_("Unable to retrieve camera configuration."));		return(0);	}		// Now that we have the camera's current configuration, we set certain fields to values	// required for the EyeDx software		// We do a bit of optimization here. We see if any of the values are not correct. If all are	// correct, we do not send anything to the camera. This eliminates one serial operation.		if ((theDC120Config.CaptureSleepTO != 128) ||	    (theDC120Config.TimerDelay != DC120TimerNoDelay) ||		(theDC120Config.FlashMode != DC120FlashOn) ||		(theDC120Config.PictQuality != DC120BestQuality) ||		(theDC120Config.ZoomPosition != DC120Zoom111mm) ||		(theDC120Config.FocusMode != DC120MultiZoneFocus) ||		(theDC120Config.ManualExpFlag != FALSE))	{		// Since we have to send them all, we set them all regardless of whether one or more		// was incorrect.				theDC120Config.CaptureSleepTO = 128;		theDC120Config.TimerDelay = DC120TimerNoDelay;		theDC120Config.DefFlashMode = DC120FlashOn;		// We can't test this - it is set only		theDC120Config.FlashMode = DC120FlashOn;		theDC120Config.PictQuality = DC120BestQuality;		theDC120Config.ZoomPosition = DC120Zoom111mm;		theDC120Config.FocusMode = DC120MultiZoneFocus;		theDC120Config.ManualExpFlag = FALSE;				// We do not set the CaptureSleepTO, ReviewSleepTO, ManualExpTime, TimeFormat,		// DateFormat, DistanceDspFormat, ManualFNumber, or AutoExpCompValue fields									SetCaptionText(theStatusCaption, CommonStringLiteral_("Getting camera ready..."));		if (DCSetConfig(&Camera, (DCConfigPtr) NULL, &theDC120Config) != DC_NoErr)	  	{			StopAlert(theWindow, CommonStringLiteral_("Unable to set camera configuration."));			return(0);		}	}			SetCaptionText(theStatusCaption, EMPTYSTR);	return (1);	}int DeletePicture(CEyeDxWindowType *theWindow,				  CEyeDxCaptionType *theStatusCaption,				  DCPictInfo *theGenericPictInfo){	SetCaptionText(theStatusCaption, CommonStringLiteral_("Erasing image in camera..."));		if (DCDeletePicture(&Camera, CamOrCard, DCNoAlbum, theGenericPictInfo->PictNumber) != DC_NoErr)	{		StopAlert(theWindow, CommonStringLiteral_("Unable to delete last picture."));		return(0);	}	SetCaptionText(theStatusCaption, EMPTYSTR);	return(1);}int CheckCameraStatus(CEyeDxWindowType 			*theWindow,					  short						picturesNeeded,					  short						*picturesRemaining,					  CEyeDxCaptionType 		*theStatusCaption,					  DC120BatteryStatus		*theBatteryLevel,					  CEyeDxBooleanType			*theFlashStatus){	DCStatus 		GenericStatus;	DC120Status 	DC120StatusInfo;		// We determine if a card is available. If so, that's where we will command the	// camera to store the picture. To do so, we have to get the camera status.		SetCaptionText(theStatusCaption, CommonStringLiteral_("Checking out the camera..."));	if (DCGetStatus(&Camera, &GenericStatus, &DC120StatusInfo) != DC_NoErr)	{		StopAlert(theWindow, CommonStringLiteral_("Unable to retrieve camera status."));		return(0);	}		// If the camera battery level is Empty, the DCTakePicture call may fail with an invalid	// parameter error! So, if it's empty, alert the user, and tell them to use an AC Adaptor	// or replace the batteries. Note that we test this only if the camera isn't already plugged	// into the adaptor.		*theBatteryLevel = DC120StatusInfo.BatteryLevel;		// We also return whether the flash is charged		*theFlashStatus = DC120StatusInfo.FlashStatus;		// We increment picturesNeeded by one. This is to cover the situation where the picture count may	// be inaccurate during to variability in compression. For example, if there are two pictures left,	// the next picture may not compress enough to allow the remaining picture to be taken. So we check	// for one more picture than is requested to account for this.		picturesNeeded++;		// We always save the number of remaining pictures for the caller's use		if (CamOrCard == DCPCCard)		*picturesRemaining = DC120StatusInfo.CardBestRemaining;	else		*picturesRemaining = DC120StatusInfo.MemBestRemaining;	// DO NOT change from card to memory or vice versa! If this is done between the Up and Side	// images, the wrong image will be downloaded! This is because there is a single CamOrCard	// variable for both Up and Side, and changing midstream will cause the wrong picture to be	// accessed and deleted!		if (*picturesRemaining < picturesNeeded)	{		StopAlert(theWindow, CommonStringLiteral_("The camera does not have enough memory to take the required pictures."));		return(0);	}		return (1);}	static void SetupProcessingParams(){	DCImgProcData	WindowsCompatibleSetup;		// Set up the processing parameters to match the PC for the color balance and gamma.		#ifdef macintosh	WindowsCompatibleSetup.ImageType = DCRGBImage32;#else	WindowsCompatibleSetup.ImageType = DCRGBImage24;#endif	WindowsCompatibleSetup.RotateFlag = TRUE;	WindowsCompatibleSetup.RotateAngle = DCRotate0;	WindowsCompatibleSetup.UseDefaultCRT = FALSE;	// Important - we will supply the Windows values!	WindowsCompatibleSetup.WhiteBalance = DCWBAuto;	WindowsCompatibleSetup.CRTData.RedChroma.XChroma = 0.64;	WindowsCompatibleSetup.CRTData.RedChroma.YChroma = 0.33;	WindowsCompatibleSetup.CRTData.GrnChroma.XChroma = 0.30;	WindowsCompatibleSetup.CRTData.GrnChroma.YChroma = 0.60;	WindowsCompatibleSetup.CRTData.BluChroma.XChroma = 0.15;	WindowsCompatibleSetup.CRTData.BluChroma.YChroma = 0.06;	WindowsCompatibleSetup.CRTData.Gamma = 2.3;	WindowsCompatibleSetup.CRTData.WhiteTemp = 6500.0;		DCSetImageProcessing(&Camera, &WindowsCompatibleSetup);}int TakePicture(int						Location,				CEyeDxWindowType 		*theWindow,				CEyeDxCaptionType 		*theStatusCaption,				CEyeDxCaptionType 		*theFilenameCaption,				CEyeDxViewType 			*theView, 				DCPictInfo				*theGenericPictInfo,				DC120PictInfo 			*thePictInfo){	OSErr 			ret; // Error code	DCStatus 		GenericStatus;	DC120Status 	DC120StatusInfo;	DCPictInfo		NewPictInfo;	DC120PictInfo	NewPictFullInfo;	// We allocate space for the thumbnail image		long thumb_elements;	long thumb_size;		// Downloaded images on the PC are 24 bits, in BGR format.	// Downloaded images on the Mac are 32 bits, in NRGB format.	thumb_elements = kBytesPerPixel;	thumb_size = THUMB_WIDTH*THUMB_HEIGHT*thumb_elements;	NewPictInfo.ThumbPtr=(char *)malloc(thumb_size);	SetCaptionText(theStatusCaption, CommonStringLiteral_("Taking picture... Wait for camera flash, and then for image to appear on computer screen."));		ret = DCTakePicture(&Camera, CamOrCard, TRUE, &NewPictInfo, (VOIDPTR)&NewPictFullInfo);		if (ret != DC_NoErr)	{		StopAlert(theWindow, CommonStringLiteral_("Could not take picture."));		free(NewPictInfo.ThumbPtr);		return(0);	}								// Now that we've taken the picture, we need to save the picture number for later downloading		SetCaptionText(theStatusCaption, CommonStringLiteral_("Checking out the camera..."));  	if (DCGetStatus(&Camera, &GenericStatus, (VOIDPTR) &DC120StatusInfo) != DC_NoErr)  	{		StopAlert(theWindow, CommonStringLiteral_("Unable to determine picture taken."));		UpPictNum=SidePictNum=0;		CloseCamera(theWindow);		free(NewPictInfo.ThumbPtr);		return(0);	}		// We set the globals for the memory type and the number of pictures based on the memory	// type we used to take the picture.		if (CamOrCard == DCPCCard)	{  		NumOfPicts=GenericStatus.CardPictTaken;	}	else	{		NumOfPicts=GenericStatus.MemPictTaken;	}  	  	// The picture we just took is the last one in the camera. Set the global for Up or Side  	// picture number based on the image we are currently grabbing.  	  	if (Location == 1)  	{  		UpPictNum = NumOfPicts;		sprintf(up_filename,"%s", NewPictFullInfo.ImageName);	} 	else  	{  		SidePictNum = NumOfPicts;		sprintf(side_filename,"%s", NewPictFullInfo.ImageName);	}			// If the caller has requested information about the picture, copy it		if (thePictInfo)		*thePictInfo = NewPictFullInfo;			if (theGenericPictInfo)		*theGenericPictInfo = NewPictInfo;	SetCaptionText(theStatusCaption, CommonStringLiteral_("Setting thumbnail..."));  	  	#ifndef macintosh		unsigned char	*ReorderImage = (unsigned char *)malloc(THUMB_WIDTH*THUMB_HEIGHT*3);	for (int r=0; r<THUMB_HEIGHT; r++)  		for (int c=0; c<THUMB_WIDTH; c++)    	{			// Must reorder the bytes on the PC, as well as flip theimage vertically   			ReorderImage[(r*THUMB_WIDTH+c)*3+2]=NewPictInfo.ThumbPtr[((THUMB_HEIGHT-1-r)*THUMB_WIDTH+c)*thumb_elements+0];    		ReorderImage[(r*THUMB_WIDTH+c)*3+1]=NewPictInfo.ThumbPtr[((THUMB_HEIGHT-1-r)*THUMB_WIDTH+c)*thumb_elements+1];    		ReorderImage[(r*THUMB_WIDTH+c)*3+0]=NewPictInfo.ThumbPtr[((THUMB_HEIGHT-1-r)*THUMB_WIDTH+c)*thumb_elements+2];    	}	theView->SetImageFromRaw24Bit(ReorderImage,THUMB_HEIGHT,THUMB_WIDTH);		free(ReorderImage);	char theFilename[255];	if (Location == 1)		strcpy(theFilename, up_filename);	else		strcpy(theFilename, side_filename);#else	// No need to reorder the image on the Mac, and the native image view format is 32 bit		theView->SetImageFromRaw32Bit((unsigned char *)NewPictInfo.ThumbPtr, THUMB_HEIGHT, THUMB_WIDTH);		Str255 theFilename;	if (Location == 1)		c2pstrcpy(theFilename, up_filename);	else		c2pstrcpy(theFilename, side_filename);#endif	SetCaptionText(theFilenameCaption, theFilename);		SetCaptionText(theStatusCaption, EMPTYSTR);	free(NewPictInfo.ThumbPtr);	return (1);}int OpenCameraDriver(DCStatus *GenericStatus,					 DC120Status *FullDC120Status,					 CEyeDxWindowType *theWindow,					 CEyeDxCaptionType *theStatusCaption,					 DCPortNum *defaultPortNum,					 DCBitRate theConnectionRate,					 CEyeDxBooleanType chooseMemoryForTakingPictures){	int 				theIOStatus;	SHORT				Version=DCSDKVersion;	int					PortNum;				// Have to use an int so we can iterate below	if (CameraOpen == 0)  	{		memset(&Driver,0,sizeof(DCDriver));  		theIOStatus = DCOpenDriver(&Version,&Driver);  		if (theIOStatus != DC_NoErr)    	{			StopAlert(theWindow, CommonStringLiteral_("DownloadFromCamera(): Unable to open camera driver."));    		return(0);    	}  		CameraOpen=1;  		Camera.Driver=&Driver;  		Camera.CamType=DC120;  		Camera.SpecificCamType=DC120;  		Camera.CamId = (char *)malloc(DCCamIDLength);		Camera.BitRate=theConnectionRate;  		// First, we try the default port number passed-in. If this  		// works, then we just use that. Otherwise, loop through the  		// ports. When the correct one is found, pass-back the found port  		// which will be saved as a preference. This will shorten the  		// startup time if the user always plugs the camera into the  		// same port  		  		Camera.PortNum= *defaultPortNum;  		    	if (DCOpenCamera(&Camera) != DC_NoErr)		{	  		for (PortNum = DCPortNum1; PortNum <= kMaxPortNum; PortNum++)	    	{	    		// Don't bother with the one that just failed - skip it	    		// to reduce the detection and connection time	    			    		if (PortNum != *defaultPortNum)	    		{	    			Camera.PortNum = (DCPortNum)PortNum;	    			if (DCOpenCamera(&Camera) == DC_NoErr)	    			{	    				*defaultPortNum = (DCPortNum)PortNum;		  				break;		  			}		  		}	    	}	    		  		if (PortNum > kMaxPortNum)	    	{#ifndef macintosh				StopAlert(theWindow, CommonStringLiteral_("Unable to open camera. Power on? Weak batteries? Cable connected?"));#else				StopAlert(theWindow, CommonStringLiteral_("Unable to open camera. Power on? Weak batteries? Cable connected? Remember to turn off AppleTalk if using the Printer Port."));#endif			    CloseCamera(theWindow);			    return(0);	    	}	    }  		CameraOpen=2;  	}  		SetCaptionText(theStatusCaption, CommonStringLiteral_("Checking out the camera..."));	// Note we get DC120 specific status to enable us to download the image name list later	    theIOStatus = DCGetStatus(&Camera,GenericStatus,(VOIDPTR)FullDC120Status);  	if (theIOStatus != DC_NoErr)  	{		StopAlert(theWindow, CommonStringLiteral_("Unable to determine picture taken."));		UpPictNum=SidePictNum=0;		CloseCamera(theWindow);		return(0);	}		// Determine which type of camera memory (interal or card) should used. This depends on	// the intentions of the caller (opening for reading, opening for taking new pictures),	// determined by the passed flag.		if (chooseMemoryForTakingPictures)	{		// In this case, we need to pick the memory type that is available AND has		// space to hold the two required pictures at the "Best" setting. Note that we		// use a count of 3 pictures because the remaining count may not accurately reflect		// the amount of memory required to store each picture (varies by amount of compression).				if (FullDC120Status->CardAvailable && (FullDC120Status->CardBestRemaining >= 3))		{			// Save the current number of pictures stored in the card.						CamOrCard = DCPCCard;				  			NumOfPicts = FullDC120Status->CardNumImages;		}		else		{			// No choice - must use camera memory. The caller must check to see if the 			// camera has enough room for the number of pictures required.			  			NumOfPicts = FullDC120Status->MemNumImages;  			if (NumOfPicts < 0)  				NumOfPicts = 0;			CamOrCard = DCCameraMemory;		}	}	else	{			// If we are using the camera to access existing pictures, we check to see if the		// card has any pictures. If it does, we use it. Otherwise, we use the camera memory.				// We use the card if it has any pictures in it.				NumOfPicts = FullDC120Status->CardNumImages;	  	CamOrCard = DCPCCard;	  		  	// If the card has no pictures, use the internal camera memory instead.	  			if (NumOfPicts <= 0)	  	{	  		NumOfPicts = FullDC120Status->MemNumImages;			CamOrCard = DCCameraMemory;	  	}		if (NumOfPicts < 0)			NumOfPicts = 0;  	}  	// Finally, check the camera clock, and sync it with the computer's clock  		DCConfig		genericConfig;		genericConfig.CamId = Camera.CamId;	if (DCGetConfig(&Camera, &genericConfig, (DC120Config *) NULL) != DC_NoErr)	{		StopAlert(theWindow, CommonStringLiteral_("Unable to determine camera configuration."));		UpPictNum=SidePictNum=0;		CloseCamera(theWindow);		return(0);	}		// Now, check the time in the genericConfig structure vs. the system's time.	// We cannot use localtime because the CodeWarrior version doesn't set the DST field!		struct tm *tptr;	#ifdef macintosh	struct tm theTm;		LongDateRec theDateRec;	LongDateCvt theCurrentDateTime;	theCurrentDateTime.hl.lHigh = 0L;	::GetDateTime(&theCurrentDateTime.hl.lLow);		::LongSecondsToDate(&theCurrentDateTime.c, &theDateRec);		theTm.tm_sec 		= theDateRec.ld.second;	theTm.tm_min 		= theDateRec.ld.minute;	theTm.tm_hour 		= theDateRec.ld.hour;	theTm.tm_mday 		= theDateRec.ld.day;	theTm.tm_mon 		= theDateRec.ld.month - 1;		// Month is 0..11	theTm.tm_year 		= theDateRec.ld.year - 1900;	// Years from 1900   	theTm.tm_isdst 		= 0;	tptr = &theTm;#else	CTime theCurrentTime = CTime::GetCurrentTime();	tptr = theCurrentTime.GetLocalTm();	// Make sure that we leave the is_dst field as-is! Setting it to 0 or 1 appears	// to cause the SDK to offset the hours field THE WRONG WAY.#endif		// If any of the fields differ, we set the time. Note that we do NOT check seconds or the	// wday and yday fields..		if ((genericConfig.Time.tm_min 		!= tptr->tm_min) ||		(genericConfig.Time.tm_hour 	!= tptr->tm_hour) ||		(genericConfig.Time.tm_mday 	!= tptr->tm_mday) ||		(genericConfig.Time.tm_mon 		!= tptr->tm_mon) ||		(genericConfig.Time.tm_year 	!= tptr->tm_year))	{		// Note that we set the camera clock only if the computer's date is a valid date with respect to		// what the camera accepts. Setting the camera clock will fail if the computer's date is before		// 00:00:00 1 Jan 1994. Note that this can happen if the computer's battery has gone dead, and the		// date is invalid.				if (tptr->tm_year > 93)		{			SetCaptionText(theStatusCaption, CommonStringLiteral_("Setting camera clock..."));						// However, we setting the clock we do set the seconds. However, wday and yday are not			// settable.						genericConfig.Time.tm_sec 		= tptr->tm_sec;			genericConfig.Time.tm_min 		= tptr->tm_min;			genericConfig.Time.tm_hour 		= tptr->tm_hour;			genericConfig.Time.tm_mday 		= tptr->tm_mday;			genericConfig.Time.tm_mon 		= tptr->tm_mon;			genericConfig.Time.tm_year 		= tptr->tm_year;			genericConfig.Time.tm_isdst 	= tptr->tm_isdst;						int theIOStatus;			if ((theIOStatus = DCSetConfig(&Camera, &genericConfig, (DC120Config *) NULL)) != DC_NoErr)			{#ifdef macintosh				CautionAlert(theWindow, CommonStringLiteral_("Unable to set camera date and time. Will continue."));#else				CString errorString;				errorString.Format("Unable to set camera date and time. Will continue.\nCode = %d, params = %d %d %d %d %d %d %d %d %d", 										theIOStatus,										genericConfig.Time.tm_sec,										genericConfig.Time.tm_min,										genericConfig.Time.tm_hour,										genericConfig.Time.tm_mday,										genericConfig.Time.tm_mon ,										genericConfig.Time.tm_year ,										genericConfig.Time.tm_isdst,										genericConfig.Time.tm_wday,										genericConfig.Time.tm_yday);								CautionAlert(theWindow, errorString);#endif			}		}				else			CautionAlert(theWindow, CommonStringLiteral_("Skipping setting date and time - your computer's clock appears to be wrong!"));			}			  	return (1);}			/*			** Opens the driver and camera (static variables kept here)			** and downloads the first two icons.			** Returns 1 (success) or 0 (failure).			*/int ConnectToCamera(CEyeDxWindowType *theWindow,					CEyeDxCaptionType *theUpStatusCaption, CEyeDxCaptionType *theSideStatusCaption, 					CEyeDxViewType *theUpView, CEyeDxCaptionType *theUpCaption, 					CEyeDxViewType *theSideView, CEyeDxCaptionType *theSideCaption,					DCPictInfo	*theUpGenericPictInfo, DCPictInfo	*theSideGenericPictInfo,					DC120PictInfo *theUpPictInfo, DC120PictInfo *theSidePictInfo,					DCPortNum *defaultPortNum, DCBitRate theConnectionRate){	int 				theIOStatus;	DCStatus			GenericStatus;	DC120Status 		FullDC120Status; // Structure of DC120Status#ifdef LOGGING	logmemtofile(logfile, "ConnectToCamera() - start");#endif	// Save the last picture count		LastNumOfPicts = NumOfPicts;	NumOfPicts=0;	PictNamePtr = NULL;	if (OpenCameraDriver(&GenericStatus, &FullDC120Status, theWindow, theUpStatusCaption, defaultPortNum, theConnectionRate, false) == 0)  	{    	UpPictNum=SidePictNum=0;    	return(0);	}		// Now that the camera is open and we've retrieved the number of available pictures,	// do some basic checks.		if (NumOfPicts < 1)  	{		StopAlert(theWindow, CommonStringLiteral_("No pictures stored in camera."));  		UpPictNum=SidePictNum=0;		CloseCamera(theWindow);  		return(0);  	}  	  	// First, try to reselect the last two pictures used. We saved the LastNumOfPicts previously.  	// If this number is less than or equal to the current NumOfPicts, we just use the previous  	// values of UpPictNum and SidePictNum. If the NumOfPicts is < LastNumOfPicts, this means that  	// all bets are off whether the images referred to by the UpPictNum and SidePictNum correspond to  	// any of the images in the camera. So, we pick the last two images. If LastNumOfPicts < 1, then  	// either the camera was empty the last time, or this is the first time we are running.  	  	if (LastNumOfPicts > NumOfPicts || LastNumOfPicts < 1)  	{	  	// Choose the last two pictures in the camera	  	UpPictNum = NumOfPicts - 1;	  	SidePictNum = NumOfPicts;	  	// Wrap around - if only one picture, then both Up and Side will be the same picture.	  	if (UpPictNum < 1)	  		UpPictNum = 1;  	}  			if (UpPictNum > NumOfPicts)  		UpPictNum=0;	if (SidePictNum > NumOfPicts)  		SidePictNum=0;  			SetCaptionText(theUpStatusCaption, CommonStringLiteral_("Downloading image..."));	GetIconFromCamera(UpPictNum, 1, theUpGenericPictInfo, theUpPictInfo, theWindow, theUpView, theUpCaption);	SetCaptionText(theUpStatusCaption, EMPTYSTR);	SetCaptionText(theSideStatusCaption, CommonStringLiteral_("Downloading image..."));	GetIconFromCamera(SidePictNum, 2, theSideGenericPictInfo, theSidePictInfo, theWindow, theSideView, theSideCaption);	SetCaptionText(theSideStatusCaption, CommonStringLiteral_("Downloading image list..."));		// In addition, the Mac version obtains a list of available images in the	// camera for use in the selection dialog.		DC120AllAlbumPtr AllAlbumPtr;		// We add 1 for the root album		int AlbumCount;		if (CamOrCard == DCCameraMemory)		AlbumCount = FullDC120Status.MemNumAlbums;	else		AlbumCount = FullDC120Status.CardNumAlbums;		// We add one to account for the root album		AllAlbumPtr = (DC120AllAlbumPtr) malloc((AlbumCount + 1) * sizeof(DC120AllAlbum));		if (AllAlbumPtr != NULL)	{		theIOStatus = DCAlbumGetAllName(&Camera, CamOrCard,	(VOIDPTR)AllAlbumPtr);		if (theIOStatus == DC_NoErr)		{					// Now, add up the number of pictures in all albums. This is required because the			// routines that download images ignore the album structure, and they see all images			// in the specific type of memory (camera or card). Therefore, this list must also 			// include all images.									int numPictEntries = 0;			for (int album = 0; album < (AlbumCount + 1); album++)				numPictEntries += AllAlbumPtr[album].PictNum;							// Now that we have the count, allocate the necessary space, and append the contents			// of each picture list onto the allocated memory. Note that if an album has no			// pictures, we don't bother downloading, and we keep the pointer at the same			// location. That's ok because the picture numbers in the camera are sequential,			// and do not have gaps due to empty albums or different numbers of pictures per			// album.						PictNamePtr = (char *) malloc(numPictEntries * DC120AlbumPictureSize);			char *p = PictNamePtr;			for (int album = 0; album < (AlbumCount + 1); album++)			{				if (AllAlbumPtr[album].PictNum != 0)				{					theIOStatus = DCAlbumGetPictureName(&Camera, CamOrCard, album, p);					// Now, move the pointer by the number of picture names we just downloaded					p += (AllAlbumPtr[album].PictNum * DC120AlbumPictureSize);				}			}		}	}		// We don't need to keep this around.		free(AllAlbumPtr);	SetCaptionText(theSideStatusCaption, EMPTYSTR);	return(1);}		/*		** Grabs an icon image from the camera and puts		** it in the left or right subwindow		*/void GetIconFromCamera(int					NewPictNum,	// 1...NumOfPicts from camera														// 0 make empty (white) image														// -1 increment and get														// -2 decrement and get														// -3 just redraw - not used on Mac since the view handles refreshing itself					   	int					Location,	// 1 => left, 2 => right						DCPictInfo			*theGenericPictInfo, 					   						   	DC120PictInfo 		*thePictInfo,	// Returns the detailed information about the picture						CEyeDxWindowType	*theWindow,						CEyeDxViewType 	*theView,					   	CEyeDxCaptionType	*theFilenameCaption){	DCPictInfo		NewPictInfo;	DC120PictInfo	NewPictFullInfo;	if (NewPictNum < 0)  	{  		if (Location == 1)		{			if (NewPictNum == -1)	  			UpPictNum++;	  		else if (NewPictNum == -2)	  			UpPictNum--;	  						if (UpPictNum > NumOfPicts)	  			UpPictNum=1;	  		else if (UpPictNum < 1)	  			UpPictNum = NumOfPicts;	  						NewPictNum=UpPictNum;    	}  		else		{			if (NewPictNum == -1)	  			SidePictNum++;	  		else if (NewPictNum == -2)	  			SidePictNum--;			if (SidePictNum > NumOfPicts)	  			SidePictNum=1;	  		else if (SidePictNum < 1)	  			SidePictNum = NumOfPicts;			NewPictNum=SidePictNum;		}  	}	long thumb_elements;	long thumb_size;		// Downloaded images on the PC are 24 bits, in BGR format.	// Downloaded images on the Mac are 32 bits, in NRGB format.	thumb_elements = kBytesPerPixel;	thumb_size = THUMB_WIDTH*THUMB_HEIGHT*thumb_elements;	NewPictInfo.ThumbPtr=(char *)malloc(thumb_size);	if (NewPictNum > 0)  	{  		DCGetCameraPictInfo(&Camera,CamOrCard,DCNoAlbum,(short)NewPictNum,							TRUE,&NewPictInfo,&NewPictFullInfo);  		if (Location == 1)			sprintf(up_filename,"%s",NewPictFullInfo.ImageName); 		 else			sprintf(side_filename,"%s",NewPictFullInfo.ImageName);		// If the caller has requested information about the picture, copy it		if (theGenericPictInfo)			*theGenericPictInfo = NewPictInfo;		if (thePictInfo)			*thePictInfo = NewPictFullInfo;  	}	else  	{		memset(NewPictInfo.ThumbPtr, 255, thumb_size);  		if (Location == 1)			strcpy(up_filename,"");  		else			strcpy(side_filename,"");  	}  	  	#ifndef macintosh		unsigned char	*ReorderImage = (unsigned char *)malloc(THUMB_WIDTH*THUMB_HEIGHT*3);	for (int r=0; r<THUMB_HEIGHT; r++)  		for (int c=0; c<THUMB_WIDTH; c++)    	{			// Must reorder the bytes on the PC, as well as flip theimage vertically   			ReorderImage[(r*THUMB_WIDTH+c)*3+2]=NewPictInfo.ThumbPtr[((THUMB_HEIGHT-1-r)*THUMB_WIDTH+c)*thumb_elements+0];    		ReorderImage[(r*THUMB_WIDTH+c)*3+1]=NewPictInfo.ThumbPtr[((THUMB_HEIGHT-1-r)*THUMB_WIDTH+c)*thumb_elements+1];    		ReorderImage[(r*THUMB_WIDTH+c)*3+0]=NewPictInfo.ThumbPtr[((THUMB_HEIGHT-1-r)*THUMB_WIDTH+c)*thumb_elements+2];    	}	theView->SetImageFromRaw24Bit(ReorderImage,THUMB_HEIGHT,THUMB_WIDTH);		free(ReorderImage);	char theFilename[255];	if (Location == 1)		strcpy(theFilename, up_filename);	else		strcpy(theFilename, side_filename);#else	// No need to reorder the image on the Mac, and the native image view format is 32 bit		theView->SetImageFromRaw32Bit((unsigned char *)NewPictInfo.ThumbPtr, THUMB_HEIGHT, THUMB_WIDTH);		Str255 theFilename;	if (Location == 1)		c2pstrcpy(theFilename, up_filename);	else		c2pstrcpy(theFilename, side_filename);#endif	SetCaptionText(theFilenameCaption, theFilename);		free(NewPictInfo.ThumbPtr);}int DownloadImageFromCamera(int						Location,							CEyeDxHandleType		*rawdata,							int						*NEW_ROWS,							int						*NEW_COLS,							char					*new_filename,							CEyeDxVariable			*theSessionNameVariable,							CEyeDxVariable			*theFilenameVariable,							CEyeDxWindowType		*theWindow,							CEyeDxProgressType 		*theThermometer, 							CEyeDxCaptionType 		*theProgressCaption,							CEyeDxBooleanType		theSaveFullImagesFlag,							DC120OutputWidth		optionalWidth){	int				r,c,NewPictNum;	DCPictInfo		NewPictInfo;	DC120PictInfo	NewPictFullInfo;	DCImageIOCB		Input,Output;	DCOutputWindow	theOutputWindow;	DCProgressCB	Progress;	unsigned char	*raw;	// Set up the processing parameters to match the PC for the color balance and gamma.		SetupProcessingParams();	// Now we specify scaling of the image. The default is the full image, but we don't care - we	// just set the width to the value passed to us and make the call.		theOutputWindow.HOffset = 0;	theOutputWindow.VOffset = 0;	theOutputWindow.Width = optionalWidth;	theOutputWindow.Height = 0;	theOutputWindow.RowBytes = 0;	theOutputWindow.ThumbRowBytes = 0;	DCSetOutputWindow(&Camera, &theOutputWindow);		if (Location == 1)  	{  		NewPictNum=UpPictNum;  		DownloadSide=0;  	}	else  	{  		NewPictNum=SidePictNum;  		DownloadSide=1;  	}	if (NewPictNum == 0)  		return(0);  			OSErr err = DCGetCameraPictInfo(&Camera,CamOrCard,DCNoAlbum,(short)NewPictNum,						FALSE,&NewPictInfo,&NewPictFullInfo);	if (err != DC_NoErr)	{		*rawdata=NULL;		StopAlert(theWindow, CommonStringLiteral_("Unable to get information about picture."));		CloseCamera(theWindow);		return(0);	}							*NEW_ROWS=NewPictInfo.PictHeight;	*NEW_COLS=NewPictInfo.PictWidth;		CEyeDxBooleanType error = FALSE;#ifndef macintosh	if ((*rawdata=(unsigned char *)calloc((*NEW_ROWS)*(*NEW_COLS)*3,1)) == NULL)		error = TRUE;	else  	  		raw = (unsigned char *) *rawdata;#else	OSErr theErr;	*rawdata = ::TempNewHandle((*NEW_ROWS)*(*NEW_COLS)*3, &theErr);	if (theErr != noErr || *rawdata == NULL)		error = TRUE;	else	{			// Lock the handle so we can dereference it and simulate the raw pointer that's used in 		// the PC version		HLock(*rawdata);       	 	raw = (unsigned char *) **rawdata;   	}#endif	if (error)	{		*rawdata=NULL;		StopAlert(theWindow, CommonStringLiteral_("DownloadFromCamera(): Unable to allocate memory."));		CloseCamera(theWindow);		return(0);	}		// Also, set the static variables to point at the thermometer progress bar and the progress caption.	// Note that we may be called with the caption and thermometer pointers as null.		sCaption = theProgressCaption;	sThermometer = theThermometer;		if (theThermometer)		SetThermometerValues(theThermometer, 0L, 100L, 0L);	// Now, allocate the memory for the native image which we will download from the	// camera.		Input.BufferSize=NewPictInfo.PictMinBufIn;	#ifndef macintosh	if ((Input.Buffer= new char [Input.BufferSize]) == NULL)		error = TRUE;#else	Handle theInputHandle = ::TempNewHandle(Input.BufferSize, &theErr);	if (theErr != noErr || theInputHandle == NULL)	{		error = TRUE;		// Free all of the temporary memory we allocated				HUnlock(*rawdata);		DisposeHandle(*rawdata);			}	else	{		// Lock the handle so we can dereference it and simulate the raw pointer that's used in 		// the PC version		HLock(theInputHandle);		Input.Buffer = (char *) *theInputHandle;	}#endif	if (error)	{		*rawdata=NULL;		StopAlert(theWindow, CommonStringLiteral_("DownloadFromCamera(): Unable to allocate input image download memory."));		CloseCamera(theWindow);		return(0);	}		Input.IOFunc=NULL;	Input.RefCon=0L;	Progress.ProgFunc=(DCProgressProc)DownloadProgress;		// Now, get the picture in native format. This will allow us to save it in a file	// if the user so desires		if (DCGetNativePicture(&Camera,CamOrCard,DCNoAlbum,						&NewPictInfo,&Input,&Progress) != DC_NoErr)	{#ifndef macintosh		free(Input.Buffer);		free(*rawdata);#else		// Free all of the temporary memory we allocated				HUnlock(theInputHandle);		DisposeHandle(theInputHandle);				HUnlock(*rawdata);		DisposeHandle(*rawdata);		#endif		StopAlert(theWindow, CommonStringLiteral_("DownloadFromCamera(): Error downloading native image."));		*rawdata =NULL;		(*NEW_ROWS)=(*NEW_COLS)=0;		CloseCamera(theWindow);		return(0);  	}  	  	// Now we have the native image data in the buffer pointed to by  	// Input.Buffer.	if (theSaveFullImagesFlag)	{		// Write the native data out to a 		// file.		char savefile[255];		CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();		#ifndef macintosh			sprintf(savefile,"%s%s%cPimages%c%s.kdc", DataPath, *theSessionName, PATHSEPARATOR, PATHSEPARATOR, NewPictFullInfo.ImageName);#else		char sessionName[255];		strncpy(sessionName, theSessionName->TextPtr(), theSessionName->Length());		sessionName[theSessionName->Length()] = '\0';		sprintf(savefile,"%c%s%cPimages%c%s.kdc", PATHSEPARATOR, sessionName, PATHSEPARATOR, PATHSEPARATOR, NewPictFullInfo.ImageName);#endif  		FILE *rawfpt;  		CEyeDxBooleanType overwrite = true;  		  		// First, try opening the file in read mode to see if it exists. If it does,  		// prompt the user to confirm overwriting it  		  		rawfpt = fopen(savefile, "rb");  		if (rawfpt != NULL)  		{  			fclose(rawfpt);  			#ifndef macintosh			CString prompt;						prompt.Format("A file named %s already exists in the Pimages folder.\nLoading will continue. Skip copying to Pimages?", NewPictFullInfo.ImageName);	  		if (theWindow->MessageBox(prompt, AfxGetAppName(), MB_YESNO) == IDYES)#else			LStr255 prompt(NewPictFullInfo.ImageName);						::ParamText("\pA file named ", prompt, "\p already exists in the Pimages folder.", "\pLoading will continue. Skip copying to Pimages?");			DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_OverwriteSkipALRT);			if (item_hit == PPob_OverwriteSkipALRT_Yes)#endif				overwrite = false;		}				if (overwrite)		{			rawfpt=fopen(savefile,"wb");			if (rawfpt == NULL)			{#ifndef macintosh				free(Input.Buffer);				free(*rawdata);#else				// Free all of the temporary memory we allocated								HUnlock(theInputHandle);				DisposeHandle(theInputHandle);								HUnlock(*rawdata);				DisposeHandle(*rawdata);		#endif				StopAlert(theWindow, CommonStringLiteral_("DownloadFromCamera(): Cannot open output KDC file."));				*rawdata =NULL;				(*NEW_ROWS)=(*NEW_COLS)=0;				CloseCamera(theWindow);				return(0);		  	}					fwrite(Input.Buffer, Input.BufferSize, 1, rawfpt);			fclose(rawfpt);						SetOSType(savefile, kKodakPictureTransferCreator, kKDCType);		}	}		// Now we allocate the space needed to hold the raw image data, which will	// be converted from the natove image in the Input.Buffer.		long image_elements;	// Downloaded images on the PC are 24 bits, in BGR format.	// On the Mac they are 32 bits in RGB format.	image_elements = kBytesPerPixel;	Output.BufferSize=(*NEW_ROWS)*(*NEW_COLS)*image_elements;	#ifndef macintosh	if ((Output.Buffer=(char *)calloc(Output.BufferSize,1)) == NULL)	{		error = TRUE;		free(Input.Buffer);		free(*rawdata);	}#else	Handle theOutputHandle = ::TempNewHandle(Output.BufferSize, &theErr);	if (theErr != noErr || theOutputHandle == NULL)	{		error = TRUE;		// Free all of the temporary memory we allocated				HUnlock(theInputHandle);		DisposeHandle(theInputHandle);				HUnlock(*rawdata);		DisposeHandle(*rawdata);			}	else	{		// Lock the handle so we can dereference it and simulate the raw pointer that's used in 		// the PC version		HLock(theOutputHandle);		Output.Buffer = (char *) *theOutputHandle;	}#endif	if (error)	{		StopAlert(theWindow, CommonStringLiteral_("DownloadFromCamera(): Unable to allocate download memory."));		*rawdata = NULL;		CloseCamera(theWindow);		return(0);	}	Output.IOFunc=NULL;	Output.RefCon=0L;	Progress.ProgFunc=(DCProgressProc)DownloadProgress;	// Reset the thermometer to show progress while processing the native image		if (theThermometer)		SetThermometerValues(theThermometer, 0L, 100L, 0L);	// Now, process the image into the raw format that we need for analysis		if (DCProcNativePicture(&Camera,&NewPictInfo,&Input,&Output,&Progress) != DC_NoErr)	{#ifndef macintosh		free(Output.Buffer);		free(Input.Buffer);		free(*rawdata);#else		// Free all of the temporary memory we allocated				HUnlock(theInputHandle);		DisposeHandle(theInputHandle);				HUnlock(theOutputHandle);		DisposeHandle(theOutputHandle);				HUnlock(*rawdata);		DisposeHandle(*rawdata);		#endif		StopAlert(theWindow, CommonStringLiteral_("DownloadFromCamera(): Error processing image."));		*rawdata=NULL;		(*NEW_ROWS)=(*NEW_COLS)=0;		CloseCamera(theWindow);		return(0);  	}	else  	{  		sprintf(new_filename,"%s",NewPictFullInfo.ImageName);  		  		if (theFilenameVariable)  		{			// We save the entire filename, including extension, since this variable will most likely be used to record the file			// names for later access.					CEyeDxLongStringType theFilename = new_filename;			theFilename += "\p.kdc";					theFilenameVariable->SetValue(theFilename);  		}  		  		for (r=0; r<*NEW_ROWS; r++)    		for (c=0; c<*NEW_COLS; c++)	  		{#ifndef macintosh				// Must reorder the bytes on the PC, as well as flip theimage vertically	  			raw[(r*(*NEW_COLS)+c)*3+0]=(unsigned char)Output.Buffer[(((*NEW_ROWS)-1-r)*(*NEW_COLS)+c)*3+2];	  			raw[(r*(*NEW_COLS)+c)*3+1]=(unsigned char)Output.Buffer[(((*NEW_ROWS)-1-r)*(*NEW_COLS)+c)*3+1];	  			raw[(r*(*NEW_COLS)+c)*3+2]=(unsigned char)Output.Buffer[(((*NEW_ROWS)-1-r)*(*NEW_COLS)+c)*3+0];#else				// Must eliminate the unused Alpha Channel byte on the Mac	  			raw[(r*(*NEW_COLS)+c)*3+0]=Output.Buffer[(r*(*NEW_COLS)+c)*image_elements+1];	  			raw[(r*(*NEW_COLS)+c)*3+1]=Output.Buffer[(r*(*NEW_COLS)+c)*image_elements+2];	  			raw[(r*(*NEW_COLS)+c)*3+2]=Output.Buffer[(r*(*NEW_COLS)+c)*image_elements+3];#endif	  				  		}  	}	#ifndef macintosh		free(Input.Buffer);	free(Output.Buffer);	#else	HUnlock(theInputHandle);	DisposeHandle(theInputHandle);	HUnlock(theOutputHandle);	DisposeHandle(theOutputHandle);	// Unlock the handle		HUnlock(*rawdata);#endif		// Hide the progress bar and set the caption to an empty string - DON'T HIDE IT!	if (theProgressCaption)		SetCaptionText(theProgressCaption, EMPTYSTR);	return(1);}// This routine will read the native image data into an allocated buffer from the// specified file, and then process it into a raw image. It also takes in the file// name from the caller (which may or may not have the ".kdc" extension), and strips// off any extension.int ReadImageFromFile(		FILE					*fp,							CEyeDxHandleType		*rawdata,							int						*NEW_ROWS,							int						*NEW_COLS,							char					*new_filename,							CEyeDxVariable			*theSessionNameVariable,							CEyeDxVariable			*theFilenameVariable,							CEyeDxBooleanType		copyToPimages,							OSType					outputCreator,							OSType					outputType,							DCPictInfo				*theGenericPictInfo,							DC120PictInfo			*thePictInfo,							CEyeDxBooleanType		*thePictInfoIsValid,							CEyeDxWindowType		*theWindow,							CEyeDxProgressType		*theThermometer,							CEyeDxCaptionType		*theProgressCaption,							CEyeDxCaptionType		*theFilenameCaption){	int				r,c;	DCPictInfo		NewPictInfo;	DC120PictInfo	NewPictFullInfo;	DCImageIOCB		Input,Output;	DCProgressCB	Progress;	int 				theIOStatus;	SHORT				Version=DCSDKVersion;	unsigned char		*raw;	CEyeDxBooleanType				error = FALSE;	// Assume that pictinfo structure will not be set in JPEG case   	*thePictInfoIsValid = FALSE;   		// We determine the size of the file by seeking to the end, and then getting	// the file position		unsigned long theSize;		fseek(fp, 0L, SEEK_END);	fgetpos(fp, &theSize);		// Now we know how big the file is. Allocate memory to hold it in memory	// temporarily		Input.BufferSize = theSize;	#ifndef macintosh	if ((Input.Buffer= new char[theSize]) == NULL)		error = TRUE;#else	OSErr theErr;	Handle theInputHandle = ::TempNewHandle(theSize, &theErr);	if (theErr != noErr || theInputHandle == NULL)		error = TRUE;	else	{			// Lock the handle so we can dereference it and simulate the raw pointer that's used in 		// the PC version		HLock(theInputHandle);		Input.Buffer = (char *) *theInputHandle;	}#endif	if (error)	{		StopAlert(theWindow, CommonStringLiteral_("ReadImageFromFile(): Unable to allocate input image memory."));		return(0);	}	// Now read the file into memory		fseek(fp, 0L, SEEK_SET);	fread(Input.Buffer, theSize, 1, fp);		  	// We have the native image data in the buffer pointed to by  	// Input.Buffer. If we are told to save the image in the Pimages folder,  	// do so here	if (copyToPimages)	{		// Write the native data out to a 		// file.		char savefile[255];		CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();		#ifndef macintosh			sprintf(savefile,"%s%s%cPimages%c%s", DataPath, *theSessionName, PATHSEPARATOR, PATHSEPARATOR, new_filename);#else		char sessionName[255];		strncpy(sessionName, theSessionName->TextPtr(), theSessionName->Length());		sessionName[theSessionName->Length()] = '\0';		sprintf(savefile,"%c%s%cPimages%c%s", PATHSEPARATOR, sessionName, PATHSEPARATOR, PATHSEPARATOR, new_filename);#endif  		FILE *rawfpt;  		  		CEyeDxBooleanType overwrite = true;  		  		// First, try opening the file in read mode to see if it exists. If it does,  		// prompt the user to confirm overwriting it  		  		rawfpt = fopen(savefile, "rb");  		if (rawfpt != NULL)  		{  			fclose(rawfpt);  			#ifndef macintosh			CString prompt;						prompt.Format("A file named %s already exists in the Pimages folder.\nLoading will continue. Skip copying to Pimages?", new_filename);	  		if (theWindow->MessageBox(prompt, AfxGetAppName(), MB_YESNO) == IDYES)#else			LStr255 prompt(new_filename);						::ParamText("\pA file named ", prompt, "\p already exists in the Pimages folder.", "\pLoading will continue. Skip copying to Pimages?");			DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_OverwriteSkipALRT);			if (item_hit == PPob_OverwriteSkipALRT_Yes)#endif			overwrite = false;		}				if (overwrite)		{			rawfpt=fopen(savefile,"wb");			if (rawfpt == NULL)			{				*rawdata = NULL;#ifndef macintosh				free(Input.Buffer);#else				HUnlock(theInputHandle);				DisposeHandle(theInputHandle);#endif				DCCloseCamera(&Camera);				DCCloseDriver(&Driver);				StopAlert(theWindow, CommonStringLiteral_("Cannot save image in Pimage folder."));				return(0);		  	}  							fwrite(Input.Buffer, Input.BufferSize, 1, rawfpt);			fclose(rawfpt);							SetOSType(savefile, outputCreator, outputType);		}	}		if (theFilenameVariable)	{		// We save the entire filename, including extension, since this variable will most likely be used to record the file		// names for later access.			theFilenameVariable->SetValue(new_filename);	}  			// Convert the input filename into a filename w/o extension. Note that at least	// on the Mac, since extensions are not a required part of a filename,	// we handle the cases where there is an extension and where there isn't.	// We just strip off any extension if it exists, and then tack on ".kdc"		char theExtension[255];		// Since filenames can contain multiple "." characters, we find the location of	// the _last_ one. Then we see if the following string is 'kdc', 'jpg', or 'jpeg'	// (upper or lower case. If not, we just copy the entire string.	// If the extension is 'kdc', 'jpg', or 'jpeg', then we truncate the string at the ".".		char *lastperiod = strrchr(new_filename, '.');	if (lastperiod != NULL)	{		// Copy the extension, and convert to lower case to make comparison		// easy				char *p = lastperiod + 1;		char *e = &theExtension[0];				while (*p)			*e++ = tolower(*p++);				*e = '\0';				// If the extension is 'kdc', 'jpg', or 'jpeg', then truncate the string at the period.		// We will restore it when we tack-on the extension.				if (strcmp(theExtension, "kdc") == 0)			*lastperiod = '\0';		if (strcmp(theExtension, "jpg") == 0)			*lastperiod = '\0';		if (strcmp(theExtension, "jpeg") == 0)			*lastperiod = '\0';	}#ifndef macintosh	char local_new_filename[255];	strcpy(local_new_filename, new_filename);#else	Str255 local_new_filename;	c2pstrcpy(local_new_filename, new_filename);	#endif	SetCaptionText(theFilenameCaption, local_new_filename);	// Check if the image is a JPEG image. We do this by looking at the first two bytes in	// memory. If they match the magic number for JPEG, we call the ReadImage routine which handles	// JPEG. Otherwise, we continue processing the memory-based image and see if it is KDC format		fseek(fp, 0L, SEEK_SET);	char text[4];		text[0]=getc(fp); text[1]=getc(fp);	if (text[0] == -1  &&  text[1] == -40)  	{  		// It is in jpeg format - move file pointer back to start		fseek(fp, 0L, SEEK_SET);				// Deallocate the memory we don't need   		#ifndef macintosh		free(Input.Buffer);#else		HUnlock(theInputHandle);		DisposeHandle(theInputHandle);#endif  		return(ReadImage(fp, rawdata, NEW_ROWS, NEW_COLS, new_filename, theWindow,	theThermometer, theProgressCaption));	}	text[2]=getc(fp); text[2]='\0';	if (strcmp(text,"P6") == 0)	{  		// It is in ppm format - move file pointer back to start		fseek(fp, 0L, SEEK_SET);				// Deallocate the memory we don't need   		#ifndef macintosh		free(Input.Buffer);#else		HUnlock(theInputHandle);		DisposeHandle(theInputHandle);#endif  		return(ReadImage(fp, rawdata, NEW_ROWS, NEW_COLS, new_filename, theWindow,	theThermometer, theProgressCaption));	}	SetThermometerValues(theThermometer, 0L, 100L, 0L);	SetCaptionText(theProgressCaption, CommonStringLiteral_("Loading image"));		fclose(fp);	// Now we have the KDC image in memory. We need to get information about it,	// namely, the camera type and size. But to do that, we need to open the SDK	// "driver" first, even though we aren't talking to the camera.				memset(&Driver,0,sizeof(DCDriver));	theIOStatus = DCOpenDriver(&Version,&Driver);	if (theIOStatus != DC_NoErr)  	{		StopAlert(theWindow, CommonStringLiteral_("ReadImageFromFile(): Unable to open camera driver."));    	return(0);    }  	Camera.Driver=&Driver;	// Now we retrieve the camera type from the image data		// The I/O port parameters are meaningless for file-based I/O				Camera.CamType = DCNoCamera;	Camera.CamId = (char *)malloc(DCCamIDLength);	theIOStatus = DCOpenCamera(&Camera);	if (theIOStatus != DC_NoErr)	{		DCCloseDriver(&Driver);		StopAlert(theWindow, CommonStringLiteral_("ReadImageFromFile(): Unable to set up Kodak driver."));	    UpPictNum=SidePictNum=0;	    return(0);	}					// Now, we should be able to get the actual camera type from the	// image.		// The Buffer and BufferSize elements were set above when we read the image in		Input.IOFunc = NULL;	Input.RefCon = 0L;	DCCameraType CamType;	theIOStatus = DCGetNativeCameraType(&Camera, &Input, &CamType);	if(theIOStatus != DC_NoErr)	{#ifndef macintosh		free(Input.Buffer);#else		HUnlock(theInputHandle);		DisposeHandle(theInputHandle);#endif		DCCloseCamera(&Camera);		DCCloseDriver(&Driver);		StopAlert(theWindow, CommonStringLiteral_("ReadImageFromFile(): Unable to get image file information."));    	return(0);    }        if (CamType != DC120)    {#ifndef macintosh		free(Input.Buffer);#else		HUnlock(theInputHandle);		DisposeHandle(theInputHandle);		#endif		DCCloseCamera(&Camera);		DCCloseDriver(&Driver);		StopAlert(theWindow, CommonStringLiteral_("Image was not taken with a DC120 Camera."));    	return(0);    }    	// Set up the processing parameters to match the PC for the color balance and gamma.		SetupProcessingParams();	if (DCGetNativePictInfo(&Camera,&Input,FALSE,&NewPictInfo,&NewPictFullInfo) != DC_NoErr)	{		*rawdata = NULL;		DCCloseCamera(&Camera);		DCCloseDriver(&Driver);		StopAlert(theWindow, CommonStringLiteral_("Unable to get picture information."));		return(0);	}							*NEW_ROWS=NewPictInfo.PictHeight;	*NEW_COLS=NewPictInfo.PictWidth;	// Set the static variables to point at the thermometer progress bar and the progress caption		sCaption = theProgressCaption;	sThermometer = theThermometer;	#ifndef macintosh	if ((*rawdata=(unsigned char *)calloc((*NEW_ROWS)*(*NEW_COLS)*3,1)) == NULL)		error = TRUE;	else	{				// Point at the block we allocated			raw = *rawdata;	}#else	*rawdata = ::TempNewHandle((*NEW_ROWS)*(*NEW_COLS)*3, &theErr);	if (theErr != noErr || *rawdata == NULL)		error = TRUE;	else	{		// Lock the handle so we can dereference it and simulate the raw pointer that's used in 		// the PC version		HLock(*rawdata);		raw = (unsigned char *) **rawdata;	}#endif	if (error)	{		*rawdata = NULL;		DCCloseCamera(&Camera);		DCCloseDriver(&Driver);		StopAlert(theWindow, CommonStringLiteral_("ReadImageFromFile(): Unable to allocate memory."));		return(0);	}		Input.IOFunc=NULL;	Input.RefCon=0L;		// Now we allocate the space needed to hold the raw image data, which will	// be converted from the natove image in the Input.Buffer.		long image_elements;	// Downloaded images on the PC are 24 bits, in BGR format.	// Downloaded images on the Mac are 32 bits, in NRGB format.	image_elements = kBytesPerPixel;	Output.BufferSize=(*NEW_ROWS)*(*NEW_COLS)*image_elements;	#ifndef macintosh	if ((Output.Buffer=(char *)calloc(Output.BufferSize,1)) == NULL)		error = TRUE;		#else	Handle theOutputHandle = ::TempNewHandle(Output.BufferSize, &theErr);	if (theErr != noErr || theOutputHandle == NULL)		error = TRUE;	else	{			// Lock the handle so we can dereference it and simulate the raw pointer that's used in 		// the PC version		HLock(theOutputHandle);		Output.Buffer = (char *) *theOutputHandle;	}#endif	if (error)	{		DCCloseCamera(&Camera);		DCCloseDriver(&Driver);		StopAlert(theWindow, CommonStringLiteral_("ReadImageFromFile(): Unable to allocate download memory."));#ifndef macintosh		free(*rawdata);		free(Input.Buffer);#else		// Free all of the temporary memory we allocated				HUnlock(theInputHandle);		DisposeHandle(theInputHandle);				HUnlock(*rawdata);		DisposeHandle(*rawdata);#endif		*rawdata = NULL;		return(0);	}	Output.IOFunc=NULL;	Output.RefCon=0L;	Progress.ProgFunc=(DCProgressProc)DownloadProgress;#ifdef LOGGING	fprintf(logfile, "ReadImageFromFile() - Output.BufferSize = %d\n", Output.BufferSize);	fprintf(logfile, "ReadImageFromFile() - Input.BufferSize = %d\n", Input.BufferSize);		logmemtofile(logfile, "ReadImageFromFile() - before processing");#endif	// Now, process the image into the raw format that we need for analysis		if (DCProcNativePicture(&Camera,&NewPictInfo,&Input,&Output,&Progress) != DC_NoErr)	{#ifndef macintosh		free(*rawdata);		free(Input.Buffer);		free(Output.Buffer);#else		// Free all of the temporary memory we allocated				HUnlock(theInputHandle);		DisposeHandle(theInputHandle);				HUnlock(theOutputHandle);		DisposeHandle(theOutputHandle);				HUnlock(*rawdata);		DisposeHandle(*rawdata);		#endif		DCCloseCamera(&Camera);		DCCloseDriver(&Driver);		StopAlert(theWindow, CommonStringLiteral_("ReadImageFromFile(): Error processing downloaded image."));		*rawdata=NULL;		(*NEW_ROWS)=(*NEW_COLS)=0;		return(0);  	}	else  	{  		// If the caller asks for a copy of the Picture Information, copy it.  		  		if (theGenericPictInfo)  			*theGenericPictInfo = NewPictInfo;  			  			  		if (thePictInfo)  			*thePictInfo = NewPictFullInfo;  			  			  		for (r=0; r<*NEW_ROWS; r++)    		for (c=0; c<*NEW_COLS; c++)	  		{#ifndef macintosh				// Must reorder the bytes on the PC, as well as flip theimage vertically	  			raw[(r*(*NEW_COLS)+c)*3+0]=Output.Buffer[(((*NEW_ROWS)-1-r)*(*NEW_COLS)+c)*3+2];	  			raw[(r*(*NEW_COLS)+c)*3+1]=Output.Buffer[(((*NEW_ROWS)-1-r)*(*NEW_COLS)+c)*3+1];	  			raw[(r*(*NEW_COLS)+c)*3+2]=Output.Buffer[(((*NEW_ROWS)-1-r)*(*NEW_COLS)+c)*3+0];#else				// Must eliminate the unused Alpha Channel byte on the Mac	  			raw[(r*(*NEW_COLS)+c)*3+0]=Output.Buffer[(r*(*NEW_COLS)+c)*image_elements+1];	  			raw[(r*(*NEW_COLS)+c)*3+1]=Output.Buffer[(r*(*NEW_COLS)+c)*image_elements+2];	  			raw[(r*(*NEW_COLS)+c)*3+2]=Output.Buffer[(r*(*NEW_COLS)+c)*image_elements+3];#endif	  				  		}  	}	#ifdef LOGGING	logmemtofile(logfile, "ReadImageFromFile() - before deallocating");#endif//#define SAVERAWBUFFER#ifdef SAVERAWBUFFERchar bufx[1000];strcpy(bufx, (const char *)local_new_filename);strcat(bufx, ".raw");  FILE *fpt=fopen(bufx,"wb");  fprintf(fpt,"P6 %d %d 255\n",*NEW_COLS,*NEW_ROWS);  fwrite(raw,3,(*NEW_ROWS)*(*NEW_COLS),fpt);  fclose(fpt);#endif#ifndef macintosh		free(Input.Buffer);	free(Output.Buffer);#else	HUnlock(theInputHandle);	DisposeHandle(theInputHandle);	HUnlock(theOutputHandle);	DisposeHandle(theOutputHandle);	// Unlock the handle		HUnlock(*rawdata);#endif		// Hide the progress bar and set the caption to an empty string - DON'T HIDE IT!	SetCaptionText(theProgressCaption, EMPTYSTR);	free(Camera.CamId);	DCCloseCamera(&Camera);	DCCloseDriver(&Driver);		*thePictInfoIsValid = TRUE;		return(1);}// This routine will read the native image data into an allocated buffer from the// specified file, and then get the thumbnail image. The disp_notice flag tells the// routine whether to display a notice or not. This is important when this routine// is used for previews in the open file dialog - the display of the notice may// cover the preview area in the dialog box, and thus, when closed, the dialog box// will have to be repainted, and so the routine is called again - an endless cycle!int ReadIconFromFile(		FILE				*fp,							unsigned char		**thumb_image,							int					*ROWS,							int					*COLS,							DCPictInfo			*theGenericPictInfo,							DC120PictInfo		*thePictInfo,							CEyeDxWindowType	*theWindow,							CEyeDxBooleanType	disp_notice){	DCPictInfo		NewPictInfo;	DC120PictInfo	NewPictFullInfo;	DCImageIOCB		Input;	int 			theIOStatus;	SHORT			Version=DCSDKVersion;	// We determine the size of the file by seeking to the end, and then getting	// the file position		unsigned long theSize;		fseek(fp, 0L, SEEK_END);	fgetpos(fp, &theSize);		// Now we know how big the file is. Allocate memory to hold it in memory	// temporarily		Input.BufferSize = theSize;	CEyeDxBooleanType error = FALSE;#ifndef macintosh	if ((Input.Buffer= new char [theSize]) == NULL)		error = TRUE;#else	OSErr theErr;	Handle theInputHandle = ::TempNewHandle(theSize, &theErr);	if (theErr != noErr || theInputHandle == NULL)		error = TRUE;	else	{			// Lock the handle so we can dereference it and simulate the raw pointer that's used in 		// the PC version		HLock(theInputHandle);		Input.Buffer = (char *) *theInputHandle;	}#endif	if (error)	{		*thumb_image = NULL;		if (disp_notice)			StopAlert(theWindow, CommonStringLiteral_("ReadIconFromFile(): Unable to allocate input image memory."));		return(0);	}		// Now read the file into memory		fseek(fp, 0L, SEEK_SET);	fread(Input.Buffer, theSize, 1, fp);	fclose(fp);		// Now we have the KDC image in memory. We need to get information about it,	// namely, the camera type and size. But to do that, we need to open the SDK	// "driver" first, even though we aren't talking to the camera.		memset(&Driver,0,sizeof(DCDriver));	theIOStatus = DCOpenDriver(&Version,&Driver);	if (theIOStatus != DC_NoErr)  	{#ifndef macintosh		free(Input.Buffer);#else		HUnlock(theInputHandle);		DisposeHandle(theInputHandle);#endif		if (disp_notice)			StopAlert(theWindow, CommonStringLiteral_("ReadIconFromFile(): Unable to open camera driver."));    	return(0);    }  	Camera.Driver=&Driver;	// Now we retrieve the camera type from the image data		// The I/O port parameters are meaningless for file-based I/O				Camera.CamType = DCNoCamera;	Camera.CamId = (char *)malloc(DCCamIDLength);	theIOStatus = DCOpenCamera(&Camera);	if (theIOStatus != DC_NoErr)	{#ifndef macintosh		free(Input.Buffer);#else		HUnlock(theInputHandle);		DisposeHandle(theInputHandle);#endif		DCCloseDriver(&Driver);		if (disp_notice)			StopAlert(theWindow, CommonStringLiteral_("ReadIconFromFile(): Unable to open camera driver."));	    return(0);	}					// Now, we should be able to get the actual camera type from the	// image.		// The Buffer and BufferSize elements were set above when we read the image in		Input.IOFunc = NULL;	Input.RefCon = 0L;	DCCameraType CamType;	theIOStatus = DCGetNativeCameraType(&Camera, &Input, &CamType);	if(theIOStatus != DC_NoErr)	{#ifndef macintosh		free(Input.Buffer);#else		HUnlock(theInputHandle);		DisposeHandle(theInputHandle);#endif		DCCloseCamera(&Camera);		DCCloseDriver(&Driver);		if (disp_notice)			StopAlert(theWindow, CommonStringLiteral_("Unable to get camera information from file. Is this a KDC file?"));    	return(0);    }        if (CamType != DC120)    {#ifndef macintosh		free(Input.Buffer);#else		HUnlock(theInputHandle);		DisposeHandle(theInputHandle);		#endif		DCCloseCamera(&Camera);		DCCloseDriver(&Driver);		if (disp_notice)			StopAlert(theWindow, CommonStringLiteral_("Image was not taken with a DC120 Camera."));    	return(0);    }    	// Set up the processing parameters to match the PC for the color balance and gamma.		SetupProcessingParams();		// Now, we allocate memory for the file's thumbnail image		long thumb_elements;	long thumb_size;		// Downloaded images on the PC are 24 bits, in BGR format.	// Downloaded images on the Mac are 32 bits, in NRGB format.		thumb_elements = kBytesPerPixel;	thumb_size = THUMB_WIDTH*THUMB_HEIGHT*thumb_elements;	NewPictInfo.ThumbPtr=(char *)malloc(thumb_size);	*ROWS = THUMB_HEIGHT;	*COLS = THUMB_WIDTH;		DCGetNativePictInfo(&Camera,&Input,TRUE,&NewPictInfo,&NewPictFullInfo);	// If the caller has requested information about the picture, copy it	if (thePictInfo)		*thePictInfo = NewPictFullInfo;	if (theGenericPictInfo)		*theGenericPictInfo = NewPictInfo;		#ifndef macintosh		*thumb_image=(unsigned char *)malloc(THUMB_WIDTH*THUMB_HEIGHT*3);	unsigned char *p = *thumb_image;	for (int r=0; r<THUMB_HEIGHT; r++)  		for (int c=0; c<THUMB_WIDTH; c++)    	{			// Must reorder the bytes on the PC, as well as flip theimage vertically   			p[(r*THUMB_WIDTH+c)*3+2]=(unsigned char)NewPictInfo.ThumbPtr[((THUMB_HEIGHT-1-r)*THUMB_WIDTH+c)*thumb_elements+0];    		p[(r*THUMB_WIDTH+c)*3+1]=(unsigned char)NewPictInfo.ThumbPtr[((THUMB_HEIGHT-1-r)*THUMB_WIDTH+c)*thumb_elements+1];    		p[(r*THUMB_WIDTH+c)*3+0]=(unsigned char)NewPictInfo.ThumbPtr[((THUMB_HEIGHT-1-r)*THUMB_WIDTH+c)*thumb_elements+2];    	}	free(NewPictInfo.ThumbPtr);	free(Input.Buffer);#else	// No need to reorder the data on the Mac - it's just returned.	::HUnlock(theInputHandle);	::DisposeHandle(theInputHandle);	*thumb_image = (unsigned char *)NewPictInfo.ThumbPtr;#endif			DCCloseCamera(&Camera);	DCCloseDriver(&Driver);		return(1);}void CloseCamera(CEyeDxWindowType *theWindow){	if (CameraOpen >= 2) 		if (DCCloseCamera(&Camera) != DC_NoErr)  			StopAlert(theWindow, CommonStringLiteral_("Unable to close camera."));		if (CameraOpen >= 1)	{		// Free the allocated camera ID string - these are protected with if statements		// so that if this routine is called when the camera has not been used, it won't		// try to deallocate memory that was never allocated (i.e. uninitialized pointers)			if (Camera.CamId)		{			free (Camera.CamId);			Camera.CamId = NULL;		}		if (PictNamePtr)			free(PictNamePtr);			  		if (DCCloseDriver(&Driver) != DC_NoErr)  			StopAlert(theWindow, CommonStringLiteral_("Unable to close camera driver."));	}	CameraOpen=0;}// This routine checks the passed picture information structure for various standard// parameters. It returns a bitmap that indicates different error conditions.unsigned long CheckPictInfo(DC120PictInfo *thePictInfo){	unsigned long retVal = 0;		if (thePictInfo->PictQuality != DC120BestQuality)		retVal |= kNotBestQuality;		if (!thePictInfo->FlashUsed)		retVal |= kNoFlash;			if (thePictInfo->ZoomPosition != DC120Zoom111mm)		retVal |= kNotZoomed;			if (thePictInfo->FocusMode != DC120MultiZoneFocus)		retVal |= kBadFocusMode;			if (thePictInfo->FocusPosition <= kMinFocusRange)		retVal |= kSubjectTooClose;			if (thePictInfo->FocusPosition >= kMaxFocusRange)		retVal |= kSubjectTooFar;	if (thePictInfo->PictOrientation != DCRotate0)		retVal |= kBadOrientation;			return (retVal);}