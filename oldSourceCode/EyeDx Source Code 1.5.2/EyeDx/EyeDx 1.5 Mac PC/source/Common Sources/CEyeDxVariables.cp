// =================================================================================//	CEyeDxVariables.cp// =================================================================================//	CEyeDxVariables.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>#include <limits.h>#include "globals.h"#include "CEyeDxVariables.h"#ifdef macintosh#include "CEyeDxPrefs.h"// ===========================================================================//	¥ CCEyeDxLongStringTypeComparator// ===========================================================================//	Compares CEyeDxLongStringType's namesCCEyeDxLongStringTypeComparator*	CCEyeDxLongStringTypeComparator::sCCEyeDxLongStringTypeComparator = nil;CCEyeDxLongStringTypeComparator::CCEyeDxLongStringTypeComparator(){}CCEyeDxLongStringTypeComparator::~CCEyeDxLongStringTypeComparator(){}SInt32CCEyeDxLongStringTypeComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxLongStringType **OneString = (CEyeDxLongStringType **) inItemOne;	CEyeDxLongStringType **TwoString = (CEyeDxLongStringType **) inItemTwo;	return (LString::CompareBytes((*OneString)->TextPtr(), 							 	  (*TwoString)->TextPtr(), 							  	  (*OneString)->Length(),							  	  (*TwoString)->Length()));}BooleanCCEyeDxLongStringTypeComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxLongStringType **OneString = (CEyeDxLongStringType **) inItemOne;	CEyeDxLongStringType **TwoString = (CEyeDxLongStringType **) inItemTwo;#ifdef macintosh	return (LString::CompareBytes((*OneString)->TextPtr(), 							   	  (*TwoString)->TextPtr(), 							  	  (*OneString)->Length(),							   	  (*TwoString)->Length()) == 0);								  #else#endif}CCEyeDxLongStringTypeComparator*CCEyeDxLongStringTypeComparator::GetComparator(){	if (sCCEyeDxLongStringTypeComparator == nil) 	{		sCCEyeDxLongStringTypeComparator = new CCEyeDxLongStringTypeComparator();#ifdef macintosh		ThrowIfNil_(sCCEyeDxLongStringTypeComparator);#endif	}	return sCCEyeDxLongStringTypeComparator;}LComparator*CCEyeDxLongStringTypeComparator::Clone(){	return new CCEyeDxLongStringTypeComparator();}#endif// ---------------------------------------------------------------------------------//		¥ CEyeDxVariable()// ---------------------------------------------------------------------------------CEyeDxVariable::CEyeDxVariable(CEyeDxVariable::VariableClass theClass){	Init(theClass, 		 CEyeDxVariable::kFixed,		 CommonStringLiteral_("New Variable"),		 EMPTYSTR,		 CEyeDxVariable::kPromptNone,		 CEyeDxVariable::kGeneralString,		 false,		 EMPTYSTR,		 EMPTYSTR,		 kNoPromptOrder,		 kNoExportOrder,		 0,		 false);}CEyeDxVariable::CEyeDxVariable(){	Init(CEyeDxVariable::kEyeDx, 		 CEyeDxVariable::kFixed,		 CommonStringLiteral_("New Variable"),		 EMPTYSTR,		 CEyeDxVariable::kPromptNone,		 CEyeDxVariable::kGeneralString,		 false,		 EMPTYSTR,		 EMPTYSTR,		 kNoPromptOrder,		 kNoExportOrder,		 0,		 false);}CEyeDxVariable::CEyeDxVariable(const CEyeDxVariable &srcVariable){	Init(srcVariable.mVariableClass, 		 srcVariable.mVariableType,		 srcVariable.mName,		 srcVariable.mPromptString,		 srcVariable.mPromptType,		 srcVariable.mDataType,		 srcVariable.mValueMustBeEntered,		 srcVariable.mDefaultValue,		 srcVariable.mCommentString,		 srcVariable.mPromptOrder,		 srcVariable.mExportOrder,		 srcVariable.mExtraEntryLines,		 srcVariable.mIsHidden,		 srcVariable.mOptionStrings);}CEyeDxVariable& CEyeDxVariable::operator=(const CEyeDxVariable &srcVariable){	// This handles the case where the statement "var = var;" is written		if (this != &srcVariable)	{		 // We must copy the input's list of option strings, and the strings themselves.		 // First, we delete our own strings if they exist.		 		CEyeDxShortStringType *theString;#ifdef macintosh		long numChoices = mOptionStrings->GetCount();		TArrayIterator<CEyeDxShortStringType *> iterator(*mOptionStrings);				while (iterator.Next(theString))			delete theString;			#else		CEyeDxArrayIndexType theItem = 0;				while (theItem < mOptionStrings->GetSize())		{			theString = mOptionStrings->GetAt(theItem);			if (theString)				delete theString;			theItem++;		}#endif		// Now we delete our option strings object - the Init function will create a new one				delete mOptionStrings;				Init(srcVariable.mVariableClass, 			 srcVariable.mVariableType,			 srcVariable.mName,			 srcVariable.mPromptString,			 srcVariable.mPromptType,			 srcVariable.mDataType,			 srcVariable.mValueMustBeEntered,			 srcVariable.mDefaultValue,			 srcVariable.mCommentString,			 srcVariable.mPromptOrder,			 srcVariable.mExportOrder,			 srcVariable.mExtraEntryLines,			 srcVariable.mIsHidden,			 srcVariable.mOptionStrings);	}		 	return *this;	}// Resource-specific constructor that is used when reading resourcesCEyeDxVariable::CEyeDxVariable(CEyeDxLongStringType *theName, CEyeDxVariablePrefs *srcVariable){#ifdef macintosh	Init((CEyeDxVariable::VariableClass) srcVariable->varClass, 		(CEyeDxVariable::VariableType) srcVariable->varType,		 *theName,		 srcVariable->promptString,		 (CEyeDxVariable::PromptType) srcVariable->promptType,		 (CEyeDxVariable::DataType) srcVariable->dataType,		 srcVariable->valueMustBeEntered,		 srcVariable->defaultValue,		 srcVariable->commentString,		 srcVariable->promptOrder,		 srcVariable->exportOrder,		 srcVariable->extraEntryLines,		 srcVariable->hidden,		 nil);		// If its a version 2 variable, it includes the value string. That means that we should	// restore its value	if (srcVariable->version == kEvarVers2)		SetValue(srcVariable->value);	#else	Init((CEyeDxVariable::VariableClass) srcVariable->varClass, 		(CEyeDxVariable::VariableType) srcVariable->varType,		 "",		 "",		 (CEyeDxVariable::PromptType) srcVariable->promptType,		 (CEyeDxVariable::DataType) srcVariable->dataType,		 srcVariable->valueMustBeEntered,		 "",		 "",		 srcVariable->promptOrder,		 srcVariable->exportOrder,		 srcVariable->extraEntryLines,		 srcVariable->hidden,		 NULL);#endif}CEyeDxVariable::CEyeDxVariable(CEyeDxVariable::VariableClass theClass,							 CEyeDxLongStringType theName,							 CEyeDxShortStringType thePromptString,							 CEyeDxVariable::PromptType thePromptType,							 CEyeDxVariable::DataType theDataType,							 CEyeDxBooleanType theValueMustBeEntered,							 CEyeDxShortStringType theDefaultValue,							 CEyeDxShortStringType theCommentString,							 short thePromptOrder,							 short theExportOrder,							 short theExtraEntryLines){	Init(theClass, 		 CEyeDxVariable::kPrompted,		 theName,		 thePromptString,		 thePromptType,		 theDataType,		 theValueMustBeEntered,		 theDefaultValue,		 theCommentString,		 thePromptOrder,		 theExportOrder,		 theExtraEntryLines,		 false);}CEyeDxVariable::CEyeDxVariable(CEyeDxVariable::VariableClass theClass,							 CEyeDxLongStringType theName,							 CEyeDxLongStringType theValue,							 CEyeDxShortStringType theCommentString,							 short theExportOrder){	Init(theClass, 		 CEyeDxVariable::kFixed,		 theName,		 EMPTYSTR,		 CEyeDxVariable::kPromptNone,		 CEyeDxVariable::kGeneralString,		 false,		 theValue,		 theCommentString,		 kNoPromptOrder,		 theExportOrder,		 0,		 false);}void CEyeDxVariable::Init(CEyeDxVariable::VariableClass theClass,						 CEyeDxVariable::VariableType theType,							 CEyeDxLongStringType theName,							 CEyeDxShortStringType thePromptString,							 CEyeDxVariable::PromptType thePromptType,							 CEyeDxVariable::DataType theDataType,							 CEyeDxBooleanType theValueMustBeEntered,							 CEyeDxShortStringType theDefaultValue,							 CEyeDxShortStringType theCommentString,							 short thePromptOrder,							 short theExportOrder,							 short theExtraEntryLines,							 CEyeDxBooleanType theIsHidden,							 CTemplateShortStrArray *theOptionsList){	mVariableClass = theClass;		// We no longer allow kTypeNone variables. They should really be general strings.		if (theDataType == kTypeNone)		theDataType = kGeneralString;			mVariableType = theType;	mPromptType = thePromptType;	mDataType = theDataType;	mName = theName;	mDefaultValue = theDefaultValue;	mValue = mDefaultValue;	mPromptString = thePromptString;	mCommentString = theCommentString;	mPromptOrder = thePromptOrder;	mExportOrder = theExportOrder;	mValueMustBeEntered = theValueMustBeEntered;	mIsHidden = theIsHidden;	mExtraEntryLines = theExtraEntryLines;		// We always create the list - it simplifies things elsewhere (especially when editing variables)	// Note that we tell it to remain unsorted - we want to preserve the order the user specified.#ifdef macintosh	mOptionStrings = new CTemplateShortStrArray(CCEyeDxLongStringTypeComparator::GetComparator(), false);	ThrowIfNil_(mOptionStrings);#else	mOptionStrings = new CTemplateShortStrArray();#endif	if (theOptionsList && (GetDataType() == CEyeDxVariable::kMenu))	{		// Now we have an empty list - add the strings from the input variable, making copies of		// them as we go				CEyeDxShortStringType *theString;#ifdef macintosh				TArrayIterator<CEyeDxShortStringType *> iterator(*theOptionsList);		 			 		while (iterator.Next(theString))		{			CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(*theString);							mOptionStrings->AddItem(theStringCopy);		}#else		CEyeDxArrayIndexType theItem = 0;			 		while (theItem < theOptionsList->GetSize())		{			theString = theOptionsList->ElementAt(theItem);			CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(*theString);							mOptionStrings->Add(theStringCopy);			theItem++;		}#endif				// We also want to force the default value to be one of the values in the array. If not found,		// the default becomes the first value.				ValidateDefault();	}}// This routine will make sure that the default value in a menu type item is a member of the// Options List. If not, the first item in the list is made the default, overriding the previous// value. This can be called after the options list is manipulated by application code to make// sure everything is in sync.void CEyeDxVariable::ValidateDefault(){	if (mOptionStrings && (GetDataType() == CEyeDxVariable::kMenu))	{		CEyeDxShortStringType *theString;#ifdef macintosh				TArrayIterator<CEyeDxShortStringType *> iterator(*mOptionStrings);		 			 		CEyeDxArrayIndexType theDefaultItem = 1;		CEyeDxArrayIndexType theItem = 1;		while (iterator.Next(theString))		{			if (*theString== *(GetDefaultValue()))				theDefaultItem = theItem;			theItem++;		}		#else		CEyeDxArrayIndexType theDefaultItem = 0;		CEyeDxArrayIndexType theItem = 0;			 		while (theItem < mOptionStrings->GetSize())		{			theString = mOptionStrings->ElementAt(theItem);						if (*theString== *(GetDefaultValue()))				theDefaultItem = theItem;			theItem++;		}#endif				// We also want to force the default value to be one of the values in the array. If not found,		// the default becomes the first value.				CEyeDxShortStringType *theDefaultItemStr;#ifdef macintosh				mOptionStrings->FetchItemAt(theDefaultItem, theDefaultItemStr);#else		theDefaultItemStr = mOptionStrings->GetAt(theDefaultItem);#endif		SetDefaultValue(*theDefaultItemStr);	}}void CEyeDxVariable::SetValue(DCTime timeValue){	short year;		// Dates in the DCTime structure are based from 1900.		year = 1900 + timeValue.tm_year;		#ifdef macintosh	Str255 theString;	DateCacheRecord theDateCache;	LongDateRec dateTime;	LongDateCvt theLongDate;				::InitDateCache(&theDateCache);		dateTime.ld.era = 0;		dateTime.ld.year = year;	dateTime.ld.month = timeValue.tm_mon + 1;	// Month field is 0..11. Huh?	dateTime.ld.day = timeValue.tm_mday;	dateTime.ld.hour = timeValue.tm_hour;	dateTime.ld.minute = timeValue.tm_min;	dateTime.ld.second = timeValue.tm_sec;	dateTime.ld.pm = 0;				::LongDateToSeconds(&dateTime, &theLongDate.c);					switch (mDataType)	{	case kPastDate:	case kDate:		::LongDateString(&theLongDate.c, abbrevDate, theString, nil);				SetValue(theString);			break;			case kTime:	// For time variables, we set the value to the current time		::LongTimeString(&theLongDate.c, true, theString, nil);				SetValue(theString);		break;			default:		// Do nothing		break;	}					#else	// Month field is 0..11. Huh?		CTime theTime(year, (timeValue.tm_mon + 1), timeValue.tm_mday, 				  timeValue.tm_hour, timeValue.tm_min, timeValue.tm_sec, timeValue.tm_isdst);	switch (mDataType)	{	case kPastDate:	case kDate:		SetValue(theTime.Format("%x"));				break;			case kTime:	// For time variables, we set the value to the current time		SetValue(theTime.Format("%X"));		break;			default:		// Do nothing		break;	}					#endif}void CEyeDxVariable::ResetValue(){#ifdef macintosh	Str255 theString;	unsigned long theDate;#else	CTime theCurrentTime;#endif			switch (mDataType)	{	case kTypeNone:			// For these we just use the default value	case kGeneralString:	case kPastDate:			// Not really any good value for this - just use default	case kCheckBox:	case kMenu:		SetValueToDefault();		break;			case kDate:#ifdef macintosh		::GetDateTime(&theDate);				::DateString(theDate, abbrevDate, theString, nil);				SetValue(theString);	#else		theCurrentTime = CTime::GetCurrentTime();				SetValue(theCurrentTime.Format("%x"));#endif								break;				case kTime:	// For time variables, we set the value to the current time#ifdef macintosh		::GetDateTime(&theDate);				::TimeString(theDate, true, theString, nil);			SetValue(theString);#else		theCurrentTime = CTime::GetCurrentTime();						SetValue(theCurrentTime.Format("%X"));#endif			break;	case kIntegerNumber:	// For integers and floats, we set the value to zero	case kFloatNumber:			SetValue(CommonStringLiteral_("0"));		break;			}					}// ---------------------------------------------------------------------------------//		¥ ~CEyeDxVariable// ---------------------------------------------------------------------------------CEyeDxVariable::~CEyeDxVariable(){	// Clean up the allocated option strings		if (mOptionStrings)	{		CEyeDxShortStringType *theString;		#ifdef macintosh		TArrayIterator<CEyeDxShortStringType *> iterator(*mOptionStrings);				// Deallocate the strings				while (iterator.Next(theString))			delete theString;#else		CEyeDxArrayIndexType theItem = 0;				while (theItem < mOptionStrings->GetSize())		{			theString = mOptionStrings->GetAt(theItem);			if (theString)				delete theString;			theItem++;		}#endif	}		delete mOptionStrings;}#ifndef macintoshIMPLEMENT_SERIAL(CEyeDxVariable, CObject, kCEyeDxVariableCurrentSchema | VERSIONABLE_SCHEMA)// This member function supports serialization of the class under Windowsvoid CEyeDxVariable::Serialize(CArchive &ar){	CObject::Serialize(ar);		long theItemCount;	if (ar.IsStoring())	{		// To save the class, we save the various data members. Then, we save a count of the 		// number of items in the options list.		// Finally, for each option string in the list we tell it to serialize itself				ar << mName;		ar << (short)mVariableClass;		ar << (short)mVariableType;		ar << (short)mPromptType;		ar << (short)mDataType;		ar << mDefaultValue;		ar << mValue;			ar << mPromptString;		ar << mCommentString;		ar << mPromptOrder;		ar << mExportOrder;		ar << mValueMustBeEntered;		ar << mIsHidden;		ar << mExtraEntryLines;		long theItemCount = mOptionStrings->GetSize();		ar << theItemCount;				CEyeDxShortStringType *theString;		// Now, for each item, tell it to serialize				for (CEyeDxArrayIndexType theItem = 0; theItem < theItemCount; theItem++)		{			// The Windows implementation uses 0-based indexes						theString = mOptionStrings->GetAt(theItem);			ar << *theString;		}			}	else	{		switch (ar.GetObjectSchema())		{		case kCEyeDxVariableCurrentSchema:					ar >> mName;						// We have to do it this way because the archive doesn't apparently deal with enums			// properly! 			short theVariableClass;			ar >> theVariableClass;			mVariableClass = (VariableClass) theVariableClass;						short theVariableType;			ar >> theVariableType;			mVariableType = (VariableType) theVariableType;						short thePromptType;			ar >> thePromptType;			mPromptType = (PromptType) thePromptType;						short theDataType;			ar >> theDataType;			mDataType = (DataType) theDataType;						ar >> mDefaultValue;			ar >> mValue;			ar >> mPromptString;			ar >> mCommentString;			ar >> mPromptOrder;			ar >> mExportOrder;			ar >> mValueMustBeEntered;			ar >> mIsHidden;			ar >> mExtraEntryLines;			ar >> theItemCount;						CEyeDxShortStringType *theString;			// Now, for each item, tell it to serialize						for (CEyeDxArrayIndexType theItem = 0; theItem < theItemCount; theItem++)			{				theString = new CEyeDxShortStringType();				ar >> *theString;											mOptionStrings->Add(theString);			}						break;		}	}}#endif#ifdef macintosh// ===========================================================================//	¥ CEyeDxVariableComparators// ===========================================================================//	Compares CEyeDxVariable namesCEyeDxVariableNameComparator*	CEyeDxVariableNameComparator::sCEyeDxVariableNameComparator = nil;CEyeDxVariableNameComparator::CEyeDxVariableNameComparator(){}CEyeDxVariableNameComparator::~CEyeDxVariableNameComparator(){}SInt32CEyeDxVariableNameComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;	OneString = (*One)->GetName();	TwoString = (*Two)->GetName();	return (LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length()));}BooleanCEyeDxVariableNameComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;		OneString = (*One)->GetName();	TwoString = (*Two)->GetName();	return (LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length()) == 0);								  }CEyeDxVariableNameComparator*CEyeDxVariableNameComparator::GetComparator(){	if (sCEyeDxVariableNameComparator == nil) 	{		sCEyeDxVariableNameComparator = new CEyeDxVariableNameComparator();		ThrowIfNil_(sCEyeDxVariableNameComparator);	}	return sCEyeDxVariableNameComparator;}LComparator*CEyeDxVariableNameComparator::Clone(){	return new CEyeDxVariableNameComparator();}// ===========================================================================//	¥ CEyeDxVariablePromptComparator// ===========================================================================//	Compares CEyeDxVariable dialog prompt orderCEyeDxVariablePromptComparator*	CEyeDxVariablePromptComparator::sCEyeDxVariablePromptComparator = nil;CEyeDxVariablePromptComparator::CEyeDxVariablePromptComparator(){}CEyeDxVariablePromptComparator::~CEyeDxVariablePromptComparator(){}longCEyeDxVariablePromptComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OnePromptOrder;	short TwoPromptOrder;		OnePromptOrder = (*One)->GetPromptOrder();	TwoPromptOrder = (*Two)->GetPromptOrder();		return (OnePromptOrder - TwoPromptOrder);}BooleanCEyeDxVariablePromptComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OnePromptOrder;	short TwoPromptOrder;		OnePromptOrder = (*One)->GetPromptOrder();	TwoPromptOrder = (*Two)->GetPromptOrder();		return (OnePromptOrder == TwoPromptOrder);}CEyeDxVariablePromptComparator*CEyeDxVariablePromptComparator::GetComparator(){	if (sCEyeDxVariablePromptComparator == nil) 	{		sCEyeDxVariablePromptComparator = new CEyeDxVariablePromptComparator();#ifdef macintosh		ThrowIfNil_(sCEyeDxVariablePromptComparator);#endif	}	return sCEyeDxVariablePromptComparator;}LComparator*CEyeDxVariablePromptComparator::Clone(){	return new CEyeDxVariablePromptComparator();}// ===========================================================================//	¥ CEyeDxVariableExportComparator// ===========================================================================//	Compares CEyeDxVariable dialog prompt orderCEyeDxVariableExportComparator*	CEyeDxVariableExportComparator::sCEyeDxVariableExportComparator = nil;CEyeDxVariableExportComparator::CEyeDxVariableExportComparator(){}CEyeDxVariableExportComparator::~CEyeDxVariableExportComparator(){}SInt32CEyeDxVariableExportComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneExportOrder;	short TwoExportOrder;		OneExportOrder = (*One)->GetExportOrder();	TwoExportOrder = (*Two)->GetExportOrder();		return (OneExportOrder - TwoExportOrder);}BooleanCEyeDxVariableExportComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneExportOrder;	short TwoExportOrder;		OneExportOrder = (*One)->GetExportOrder();	TwoExportOrder = (*Two)->GetExportOrder();		return (OneExportOrder == TwoExportOrder);}CEyeDxVariableExportComparator*CEyeDxVariableExportComparator::GetComparator(){	if (sCEyeDxVariableExportComparator == nil) 	{		sCEyeDxVariableExportComparator = new CEyeDxVariableExportComparator();		ThrowIfNil_(sCEyeDxVariableExportComparator);	}	return sCEyeDxVariableExportComparator;}LComparator*CEyeDxVariableExportComparator::Clone(){	return new CEyeDxVariableExportComparator();}// ===========================================================================//	¥ CEyeDxVariableClassComparator// ===========================================================================//	Compares CEyeDxVariable class types and name as a secondary sortCEyeDxVariableClassComparator*	CEyeDxVariableClassComparator::sCEyeDxVariableClassComparator = nil;CEyeDxVariableClassComparator::CEyeDxVariableClassComparator(){}CEyeDxVariableClassComparator::~CEyeDxVariableClassComparator(){}SInt32CEyeDxVariableClassComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneClass;	short TwoClass;		OneClass = (*One)->GetVariableClass();	TwoClass = (*Two)->GetVariableClass();		CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;	OneString = (*One)->GetName();	TwoString = (*Two)->GetName();		// Class takes precedence over name. Name comparision	// is used only if the class is the same.		SInt32 classResult = OneClass - TwoClass;		if (classResult == 0)		return (LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length()));	else		return (classResult);}BooleanCEyeDxVariableClassComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneClass;	short TwoClass;		OneClass = (*One)->GetVariableClass();	TwoClass = (*Two)->GetVariableClass();		CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;	OneString = (*One)->GetName();	TwoString = (*Two)->GetName();		SInt32 classResult = OneClass - TwoClass;	SInt32 nameResult;		nameResult = LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length());	if ((classResult == 0) && (nameResult == 0))		return true;	else		return false;}CEyeDxVariableClassComparator*CEyeDxVariableClassComparator::GetComparator(){	if (sCEyeDxVariableClassComparator == nil) 	{		sCEyeDxVariableClassComparator = new CEyeDxVariableClassComparator();		ThrowIfNil_(sCEyeDxVariableClassComparator);	}	return sCEyeDxVariableClassComparator;}LComparator*CEyeDxVariableClassComparator::Clone(){	return new CEyeDxVariableClassComparator();}// ===========================================================================//	¥ CEyeDxVariableTypeComparator// ===========================================================================//	Compares CEyeDxVariable types and when to prompt and name as secondary sortsCEyeDxVariableTypeComparator*	CEyeDxVariableTypeComparator::sCEyeDxVariableTypeComparator = nil;CEyeDxVariableTypeComparator::CEyeDxVariableTypeComparator(){}CEyeDxVariableTypeComparator::~CEyeDxVariableTypeComparator(){}SInt32CEyeDxVariableTypeComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneType;	short TwoType;		OneType = (*One)->GetVariableType();	TwoType = (*Two)->GetVariableType();		CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;	OneString = (*One)->GetName();	TwoString = (*Two)->GetName();		short OneWhen;	short TwoWhen;		OneWhen = (*One)->GetWhenToPrompt();	TwoWhen = (*Two)->GetWhenToPrompt();		SInt32 whenResult = OneWhen - TwoWhen;		// Type takes precedence over name. When to Prompt is used next.	// Name comparision is used only if the type ane when to prompt is the same.		SInt32 typeResult = OneType - TwoType;		if (typeResult == 0)	{		if (whenResult == 0)			return (LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length()));		else			return (whenResult);	}	else		return (typeResult);}BooleanCEyeDxVariableTypeComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneType;	short TwoType;		OneType = (*One)->GetVariableType();	TwoType = (*Two)->GetVariableType();		CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;	OneString = (*One)->GetName();	TwoString = (*Two)->GetName();		SInt32 typeResult = OneType - TwoType;	short OneWhen;	short TwoWhen;		OneWhen = (*One)->GetWhenToPrompt();	TwoWhen = (*Two)->GetWhenToPrompt();		SInt32 whenResult = OneWhen - TwoWhen;		SInt32 nameResult;		nameResult = LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length());	if ((typeResult == 0) && (whenResult == 0) && (nameResult == 0))		return true;	else		return false;}CEyeDxVariableTypeComparator*CEyeDxVariableTypeComparator::GetComparator(){	if (sCEyeDxVariableTypeComparator == nil) 	{		sCEyeDxVariableTypeComparator = new CEyeDxVariableTypeComparator();		ThrowIfNil_(sCEyeDxVariableTypeComparator);	}	return sCEyeDxVariableTypeComparator;}LComparator*CEyeDxVariableTypeComparator::Clone(){	return new CEyeDxVariableTypeComparator();}// ===========================================================================//	¥ CEyeDxVariableDataTypeComparator// ===========================================================================//	Compares CEyeDxVariable data types and name as a secondary sort. This is// more tricky. We want to sort in an order that makes sense to the user, rather than// the order that the DataType enums are defined. So, we convert the enum values to// compare values, which are sorted in the same order as the items in the Edit Variable// dialog's type menu:////	Any String//  Integer Number//  Time//  Date//  Past Date//  Check Box//  Menu//  Float Number (not current used)CEyeDxVariableDataTypeComparator*	CEyeDxVariableDataTypeComparator::sCEyeDxVariableDataTypeComparator = nil;CEyeDxVariableDataTypeComparator::CEyeDxVariableDataTypeComparator(){}CEyeDxVariableDataTypeComparator::~CEyeDxVariableDataTypeComparator(){}SInt32CEyeDxVariableDataTypeComparator::Compare(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneDataType;	short TwoDataType;		// We handle kTypeNone (-1) below as a special case.		CEyeDxVariable::DataType sortOrder[] = 	{ 		CEyeDxVariable::kGeneralString, 		CEyeDxVariable::kIntegerNumber, 		CEyeDxVariable::kTime, 		CEyeDxVariable::kDate, 		CEyeDxVariable::kPastDate, 		CEyeDxVariable::kCheckBox, 		CEyeDxVariable::kMenu, 		CEyeDxVariable::kFloatNumber 	};	OneDataType = (*One)->GetDataType();	if (OneDataType == CEyeDxVariable::kTypeNone)		OneDataType = CEyeDxVariable::kGeneralString;	OneDataType = sortOrder[OneDataType];	TwoDataType = (*Two)->GetDataType();	if (TwoDataType == CEyeDxVariable::kTypeNone)		TwoDataType = CEyeDxVariable::kGeneralString;	TwoDataType = sortOrder[TwoDataType];		CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;	OneString = (*One)->GetName();	TwoString = (*Two)->GetName();		// Type takes precedence over name. Name comparision	// is used only if the class is the same.		SInt32 dataTypeResult = OneDataType - TwoDataType;		if (dataTypeResult == 0)		return (LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length()));	else		return (dataTypeResult);}BooleanCEyeDxVariableDataTypeComparator::IsEqualTo(	const void*		inItemOne,	const void*		inItemTwo,	UInt32			/* inSizeOne */,	UInt32			/* inSizeTwo */) const{	CEyeDxVariable **One = (CEyeDxVariable **) inItemOne;	CEyeDxVariable **Two = (CEyeDxVariable **) inItemTwo;	short OneDataType;	short TwoDataType;		OneDataType = (*One)->GetDataType();	TwoDataType = (*Two)->GetDataType();		CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;	OneString = (*One)->GetName();	TwoString = (*Two)->GetName();		SInt32 dataTypeResult = OneDataType - TwoDataType;	SInt32 nameResult;		nameResult = LString::CompareBytes(OneString->TextPtr(), 							  TwoString->TextPtr(), 							  OneString->Length(),							  TwoString->Length());	if ((dataTypeResult == 0) && (nameResult == 0))		return true;	else		return false;}CEyeDxVariableDataTypeComparator*CEyeDxVariableDataTypeComparator::GetComparator(){	if (sCEyeDxVariableDataTypeComparator == nil) 	{		sCEyeDxVariableDataTypeComparator = new CEyeDxVariableDataTypeComparator();		ThrowIfNil_(sCEyeDxVariableDataTypeComparator);	}	return sCEyeDxVariableDataTypeComparator;}LComparator*CEyeDxVariableDataTypeComparator::Clone(){	return new CEyeDxVariableDataTypeComparator();}#else// Windows sorting functions for the CListCtrl objectint CALLBACK CEyeDxVariable::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort){	CEyeDxVariable *One = (CEyeDxVariable *) lParam1;	CEyeDxVariable *Two = (CEyeDxVariable *) lParam2;	CEyeDxLongStringType *OneString;	CEyeDxLongStringType *TwoString;	OneString = One->GetName();	TwoString = Two->GetName();				int nameResult = OneString->Compare(*TwoString);		switch (lParamSort)	{	case kSortColumnByName:		return (nameResult);		break;			case kSortColumnByClass:		short OneClass;		short TwoClass;				OneClass = One->GetVariableClass();		TwoClass = Two->GetVariableClass();				// Class takes precedence over name. Name comparision		// is used only if the class is the same.				int classResult = OneClass - TwoClass;				if (classResult == 0)			return (nameResult);		else			return (classResult);				break;			case kSortColumnByType:		short OneType;		short TwoType;				OneType = One->GetVariableType();		TwoType = Two->GetVariableType();				short OneWhen;		short TwoWhen;				OneWhen = One->GetWhenToPrompt();		TwoWhen = Two->GetWhenToPrompt();				int whenResult = OneWhen - TwoWhen;				// Type takes precedence over name. When to Prompt is used next.		// Name comparision is used only if the type ane when to prompt is the same.				int typeResult = OneType - TwoType;				if (typeResult == 0)		{			if (whenResult == 0)				return (nameResult);			else				return (whenResult);		}		else			return (typeResult);		break;			case kSortColumnByDataType:		short OneDataType;		short TwoDataType;				// We handle kTypeNone (-1) below as a special case.				CEyeDxVariable::DataType sortOrder[] = 		{ 			CEyeDxVariable::kGeneralString, 			CEyeDxVariable::kIntegerNumber, 			CEyeDxVariable::kTime, 			CEyeDxVariable::kDate, 			CEyeDxVariable::kPastDate, 			CEyeDxVariable::kCheckBox, 			CEyeDxVariable::kMenu, 			CEyeDxVariable::kFloatNumber 		};		OneDataType = One->GetDataType();		if (OneDataType == CEyeDxVariable::kTypeNone)			OneDataType = CEyeDxVariable::kGeneralString;		OneDataType = sortOrder[OneDataType];		TwoDataType = Two->GetDataType();		if (TwoDataType == CEyeDxVariable::kTypeNone)			TwoDataType = CEyeDxVariable::kGeneralString;		TwoDataType = sortOrder[TwoDataType];				// Type takes precedence over name. Name comparision		// is used only if the class is the same.				int dataTypeResult = OneDataType - TwoDataType;				if (dataTypeResult == 0)			return (nameResult);		else			return (dataTypeResult);		break;			case kSortColumnByOtherAttributes:		return (0);		break;	}}#endif// ---------------------------------------------------------------------------------//		¥ CEyeDxVariableList members// ---------------------------------------------------------------------------------CEyeDxVariableList::CEyeDxVariableList(){#ifdef macintosh		mComparator = GetComparator(kSortByName);	ThrowIfNil_(mComparator);		mVariableList = new CEyeDxTemplateVariableArray(mComparator, true);	ThrowIfNil_(mVariableList);	mSortOrder = kSortByName;#else	mVariableList = new CEyeDxTemplateVariableArray();	mKeepSorted = true;#endif}#ifdef macintoshLComparator *CEyeDxVariableList::GetComparator(SortOrder theSortOrder){	LComparator *theComparator = nil;		switch (theSortOrder)	{	case kSortByName:		theComparator = new CEyeDxVariableNameComparator();		break;		case kSortByPromptOrder:		theComparator = new CEyeDxVariablePromptComparator();		break;	case kSortByExportOrder:		theComparator = new CEyeDxVariableExportComparator();		break;	case kSortByClass:		theComparator = new CEyeDxVariableClassComparator();		break;	case kSortByType:		theComparator = new CEyeDxVariableTypeComparator();		break;	case kSortByDataType:		theComparator = new CEyeDxVariableDataTypeComparator();		break;	}	return (theComparator);}void CEyeDxVariableList::SetSortOrder(SortOrder theSortOrder){	// Note that when we set the comparator, the list takes over ownership of	// it. That means it will delete it if we set a new one. Therefore, we	// must always allocate a new one when the sort order changes.		mComparator = GetComparator(theSortOrder);	ThrowIfNil_(mComparator);	mVariableList->SetComparator(mComparator); 	mSortOrder = theSortOrder;}	#endifCEyeDxVariableList::CEyeDxVariableList(CEyeDxVariableList::SortOrder sortOrder){#ifdef macintosh	mComparator = GetComparator(sortOrder);		mVariableList = new CEyeDxTemplateVariableArray(mComparator, true);	ThrowIfNil_(mVariableList);	mSortOrder = sortOrder;#else	mVariableList = new CEyeDxTemplateVariableArray();	mKeepSorted = true;#endif}CEyeDxVariableList::~CEyeDxVariableList(){#ifdef macintosh	delete mComparator;#endif	delete mVariableList;}CEyeDxBooleanType CEyeDxVariableList::VariableExists(CEyeDxLongStringType Name){	CEyeDxVariable *theVariable;#ifdef macintosh	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);		while (iterator.Next(theVariable))	{		if (*(theVariable->GetName()) == Name)			return true;	}#else	CEyeDxArrayIndexType theItem = 0;		while (theItem < mVariableList->GetSize())	{				theVariable = mVariableList->GetAt(theItem++);		if (*(theVariable->GetName()) == Name)			return true;	}#endif	return false;}	void CEyeDxVariableList::AddVariable(CEyeDxVariable *theVariable){#ifdef macintosh	mVariableList->AddItem(theVariable);#else	mVariableList->Add(theVariable);	// TODO - Need to sort the list!#endif}	void CEyeDxVariableList::InsertVariableAt(CEyeDxArrayIndexType theIndex, CEyeDxVariable *theVariable){#ifdef macintosh	mVariableList->InsertItemsAt(1, theIndex, theVariable);#else	mVariableList->InsertAt(theIndex, theVariable, 1);#endif}	void CEyeDxVariableList::DeleteVariable(CEyeDxVariable *theVariable){#ifdef macintosh	mVariableList->Remove(theVariable);#else	// There's no equivalent under Windows - have to search the list ourselves and delete manually		DeleteVariableByName(*(theVariable->GetName()));#endif}void CEyeDxVariableList::DeleteVariableByName(CEyeDxLongStringType Name){	CEyeDxVariable *theVariable;#ifdef macintosh	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);		while (iterator.Next(theVariable))	{		if (*(theVariable->GetName()) == Name)			mVariableList->Remove(theVariable);	}#else	CEyeDxArrayIndexType theItem = 0;		while (theItem < mVariableList->GetSize())	{		// The Windows implementation uses 0-based indexes				theVariable = mVariableList->GetAt(theItem);		if (*(theVariable->GetName()) == Name)			mVariableList->RemoveAt(theItem);		theItem++;	}#endif}void CEyeDxVariableList::DeleteVariableByIndex(CEyeDxArrayIndexType theIndex){#ifdef macintosh	mVariableList->RemoveItemsAt(1, theIndex);#else	mVariableList->RemoveAt(theIndex);#endif}CEyeDxVariable * CEyeDxVariableList::GetVariableByName(CEyeDxLongStringType Name){	CEyeDxVariable *theVariable;#ifdef macintosh	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);		while (iterator.Next(theVariable))	{		if (*(theVariable->GetName()) == Name)			return theVariable;	}	return nil;#else	CEyeDxArrayIndexType theItem = 0;		while (theItem < mVariableList->GetSize())	{		// The Windows implementation uses 0-based indexes				theVariable = mVariableList->GetAt(theItem);		if (*(theVariable->GetName()) == Name)			return theVariable;		theItem++;	}	return NULL;#endif}	CEyeDxVariable * CEyeDxVariableList::GetVariableByIndex(CEyeDxArrayIndexType Index){	CEyeDxVariable *theVariable;#ifdef macintosh	mVariableList->FetchItemAt(Index, theVariable);#else	theVariable = mVariableList->GetAt(Index);#endif	return (theVariable);}	unsigned long CEyeDxVariableList::GetCount(){#ifdef macintosh	return mVariableList->GetCount(); #else	return mVariableList->GetSize(); #endif}void CEyeDxVariableList::SetAllVariablesToDefault(CEyeDxVariable::VariableType theType,												 CEyeDxVariable::PromptType thePromptType){	CEyeDxVariable *theVariable;#ifdef macintosh	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);		while (iterator.Next(theVariable))	{		if ((theVariable->GetVariableType() == theType) &&			(theVariable->GetWhenToPrompt() == thePromptType))			theVariable->SetValueToDefault();	}#else	CEyeDxArrayIndexType theItem = 0;		while (theItem < mVariableList->GetSize())	{				theVariable = mVariableList->GetAt(theItem);		if ((theVariable->GetVariableType() == theType) &&			(theVariable->GetWhenToPrompt() == thePromptType))			theVariable->SetValueToDefault();		theItem++;	}#endif}// This routine is used to look up variables based on their dialog and prompt order. The first call requires that the// promptType be set, and the specific dialog (0...n) be set as well. The theAfterPromptOrder variable, if set to -1, indicates// that we want the very first variable in the specified dialog. In subsequent calls, we pass in the theAfterPromptOrder parameter// the promptOrder of the variable we have last processed, and the routine will find the next variable. If no variable is found// that meets the criteria, NULL is returned.CEyeDxVariable *CEyeDxVariableList::GetNextPromptedVariable(CEyeDxVariable::PromptType promptType, short theAfterPromptOrder){	CEyeDxVariable *theVariable;	CEyeDxVariable *theReturnVariable = NULL;	// Look for the variable with the lowest promptOrder in the specified dialog and with the specified promptType that	// is also greater than the passed theAfterPromptOrder value. Note that for the case of theAfterPromptOrder == -1, this	// will find the first (lowest) number prompt in the dialog.		short lowestPromptOrder = SHRT_MAX;	#ifdef macintosh	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	while (iterator.Next(theVariable))	{		if (theVariable->GetWhenToPrompt() == promptType)		{			if ((theVariable->GetPromptOrder() < lowestPromptOrder) && (theVariable->GetPromptOrder() > theAfterPromptOrder))			{				lowestPromptOrder = theVariable->GetPromptOrder();				theReturnVariable = theVariable;			}		}	}#else	CEyeDxArrayIndexType theItem = 0;		while (theItem < mVariableList->GetSize())	{		theVariable = mVariableList->GetAt(theItem);		if (theVariable->GetWhenToPrompt() == promptType)		{			if ((theVariable->GetPromptOrder() < lowestPromptOrder) && (theVariable->GetPromptOrder() > theAfterPromptOrder))			{				lowestPromptOrder = theVariable->GetPromptOrder();				theReturnVariable = theVariable;			}		}		theItem++;	}#endif	return theReturnVariable;}// This routine, given the promptType and dialog, will get the next unused promptOrder value after the highest// value found. Used to assign new values to variables, and to detect if there are any prompts for the specified dialog.// If not, kNoPromptOrder is returned.short CEyeDxVariableList::GetNextAvailablePromptNumber(CEyeDxVariable::PromptType promptType){	CEyeDxVariable *theVariable;	// Look for the variable with the highest promptOrder in the specified dialog and with the specified promptType.	// Note that we find the highest - not necessarily the next available! There may be gaps if variables are deleted.		short highestPromptOrder = kNoPromptOrder;	#ifdef macintosh	TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	while (iterator.Next(theVariable))	{		if (theVariable->GetWhenToPrompt() == promptType)		{			if ((theVariable->GetPromptOrder() > highestPromptOrder))			{				highestPromptOrder = theVariable->GetPromptOrder();			}		}	}#else	CEyeDxArrayIndexType theItem = 0;		while (theItem < mVariableList->GetSize())	{		// The Windows implementation uses 0-based indexes				theVariable = mVariableList->GetAt(theItem);		if (theVariable->GetWhenToPrompt() == promptType)		{			if ((theVariable->GetPromptOrder() > highestPromptOrder))			{				highestPromptOrder = theVariable->GetPromptOrder();			}		}		theItem++;	}#endif	return highestPromptOrder;}// This routine will parse the current list of prompted variables. For each prompt type, it will// compress the list of prompt order numbers so that there are no gaps.void CEyeDxVariableList::CompressPromptOrder(){	CEyeDxVariable *theVariable;	CEyeDxVariableList *theSortedList = new CEyeDxVariableList(CEyeDxVariableList::kSortByPromptOrder);#ifdef macintosh	ThrowIfNil_(theSortedList);	long theFirstIndex = 1;	long theVarCount = GetCount();		#else	long theFirstIndex = 0;	long theVarCount = GetCount() - 1;			// Have to adjust the end index for Windows#endif	// For each prompt type, look up all of that type of prompted variable and add them to the list.	// When we have the complete list, set the prompt order in sequential order, and then clear the	// entry from the list. Repeat for each prompt type.		for (short thePromptType = CEyeDxVariable::kPromptOnStart; thePromptType <= CEyeDxVariable::kPromptTypeLast; thePromptType++)	{		// We want to insert elements in sorted order				theSortedList->SetKeepSorted(true);				long promptedCount = 0;		for (long theVarNum = theFirstIndex; theVarNum <= theVarCount; theVarNum++)		{			theVariable = GetVariableByIndex(theVarNum);						// If this variable is this prompt type, add it to our sorted list						if (theVariable->GetWhenToPrompt() == thePromptType)			{				theSortedList->AddVariable(theVariable);				promptedCount++;							}		}		#ifndef macintosh		// On Windows, the array index values are zero-based. So we have to adjust so that the loop		// counter below works properly				promptedCount--;#endif				// Ok, now we have a list of the prompted variables for this prompt type and this dialog.		// Now, renumber them starting at 0. Tell the list to not re-sort as we do this, though				theSortedList->SetKeepSorted(false);				short theNewPromptOrder = 0;		for (long theVarNum = theFirstIndex; theVarNum <= promptedCount; theVarNum++)		{			theVariable = theSortedList->GetVariableByIndex(theVarNum);						theVariable->SetPromptOrder(theNewPromptOrder++);						}		for (long theVarNum = theFirstIndex; theVarNum <= promptedCount; theVarNum++)		{			// Just delete the first one over and over till the list is empty						theSortedList->DeleteVariableByIndex(theFirstIndex);		}	}		// We're done with the sorted list - delete it		delete theSortedList;}// This routine is used to look up variables based on their export order. The theAfterExportOrder variable, if set to -1, indicates// that we want the very first variable in the specified dialog. In subsequent calls, we pass in the theAfterExportOrder parameter// the exportOrder of the variable we have last processed, and the routine will find the next variable. If no variable is found// that meets the criteria, NULL is returned.CEyeDxVariable *CEyeDxVariableList::GetNextExportedVariable(short theAfterExportOrder){	CEyeDxVariable *theVariable;	CEyeDxVariable *theReturnVariable = NULL;	// Look for the variable with the lowest exportOrder that is also greater than the passed theAfterExportOrder 	// value. Note that for the case of theAfterExportOrder == -1, this	// will find the first (lowest) number exported variable.		short lowestExportOrder = SHRT_MAX;#ifdef macintosh		TArrayIterator<CEyeDxVariable *> iterator(*mVariableList);	while (iterator.Next(theVariable))	{		if (theVariable->GetExportOrder() != kNoExportOrder)		{			if ((theVariable->GetExportOrder() < lowestExportOrder) && (theVariable->GetExportOrder() > theAfterExportOrder))			{				lowestExportOrder = theVariable->GetExportOrder();				theReturnVariable = theVariable;			}		}	}#else	CEyeDxArrayIndexType theItem = 0;		while (theItem < mVariableList->GetSize())	{		// The Windows implementation uses 0-based indexes				theVariable = mVariableList->GetAt(theItem);		if (theVariable->GetExportOrder() != kNoExportOrder)		{			if ((theVariable->GetExportOrder() < lowestExportOrder) && (theVariable->GetExportOrder() > theAfterExportOrder))			{				lowestExportOrder = theVariable->GetExportOrder();				theReturnVariable = theVariable;			}		}		theItem++;	}#endif	return theReturnVariable;}// This routine will parse the current list of exported variables. It will// compress the list of export order numbers so that there are no gaps.void CEyeDxVariableList::CompressExportOrder(){	CEyeDxVariable *theVariable;	CEyeDxVariableList *theSortedList = new CEyeDxVariableList(CEyeDxVariableList::kSortByExportOrder);#ifdef macintosh	ThrowIfNil_(theSortedList);	long theFirstIndex = 1;	long theVarCount = GetCount();		#else	long theFirstIndex = 0;	long theVarCount = GetCount() - 1;			// Have to adjust the end index for Windows#endif	long exportedCount = 0;	for (long theVarNum = theFirstIndex; theVarNum <= theVarCount; theVarNum++)	{		theVariable = GetVariableByIndex(theVarNum);				// If this variable is in this dialog, add it to our sorted list				if (theVariable->GetExportOrder() != kNoExportOrder)		{			theSortedList->AddVariable(theVariable);			exportedCount++;						}	}			#ifndef macintosh		// On Windows, the array index values are zero-based. So we have to adjust so that the loop		// counter below works properly				exportedCount--;#endif	// Ok, now we have a list of the exported variables.	// Now, renumber them starting at 0.		short theNewExportOrder = 0;	for (long theVarNum = theFirstIndex; theVarNum <= exportedCount; theVarNum++)	{		theVariable = theSortedList->GetVariableByIndex(theVarNum);				theVariable->SetExportOrder(theNewExportOrder++);		}				// We're done with the sorted list - delete it		delete theSortedList;}#ifndef macintoshIMPLEMENT_SERIAL(CEyeDxVariableList, CObject, kCEyeDxVariableListCurrentSchema | VERSIONABLE_SCHEMA)// This member function supports serialization of the class under Windowsvoid CEyeDxVariableList::Serialize(CArchive &ar){	CObject::Serialize(ar);		long theItemCount;	if (ar.IsStoring())	{		// To save the class, we save the flag that indicates whether the list is to be kept		// sorted first. Then, we save a count of the number of items in the variable list.		// Finally, for each variable in the list we tell it to serialize itself				ar << mKeepSorted;		theItemCount = mVariableList->GetSize();		ar << theItemCount;				// Now, for each item, tell it to serialize				for (long theItem = 0; theItem < theItemCount; theItem++)		{			CEyeDxVariable *theVariable = GetVariableByIndex(theItem);					ar.WriteObject(theVariable);		}			}	else	{		switch (ar.GetObjectSchema())		{		case kCEyeDxVariableListCurrentSchema:					// First, we load the sort flag. Then the item count, and then read the items in							ar >> mKeepSorted;			ar >> theItemCount;						for (long theItem = 0; theItem < theItemCount; theItem++)			{				// We use the ReadObject routine so that the proper object information is deserialized'				// for a VERSIONABLE_SCHEMA type object								CEyeDxVariable *theVariable = (CEyeDxVariable *)ar.ReadObject(RUNTIME_CLASS(CEyeDxVariable));								// if the variable exists in the passed-in table already, that means that				// EyeDx provided it as a template for the user to use. We delete the EyeDx				// template, since the user has already defined a variable of the same name.								CEyeDxLongStringType *theName = theVariable->GetName();								if (GetVariableByName(*theName) != NULL)					DeleteVariableByName(*theName);								AddVariable(theVariable);			}						break;		}	}}#endif