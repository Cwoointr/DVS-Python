// =================================================================================//	CEyeDxVariables.cp// =================================================================================//	CEyeDxVariables.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>#include <limits.h>#ifdef macintosh#include "EyeDxMacConstants.h"#else#include "resource.h"#endif#include "globals.h"#include "CEyeDxVariables.h"#ifdef macintosh#include "CPromptForVariableDialog.h"#include "COutOfMemoryDialog.h"#else#include "main.h"#endifvoid SavePictureInformation(CEyeDxVariableList *theVariableList, 					   CEyeDxBooleanType theUpPictInfoValid, DCPictInfo &UpGenericPictInfo, DC120PictInfo &UpPictInfo, 					   CEyeDxBooleanType theSidePictInfoValid, DCPictInfo &SideGenericPictInfo, DC120PictInfo &SidePictInfo){	CEyeDxVariable *theUpImageDate = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGEDATE));	CEyeDxVariable *theSideImageDate = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGEDATE));	CEyeDxVariable *theUpImageTime = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGETIME));	CEyeDxVariable *theSideImageTime = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGETIME));			if (theUpImageDate && theUpImageTime)	{		if (theUpPictInfoValid)		{			theUpImageDate->SetValue(UpGenericPictInfo.TimeStamp);			theUpImageTime->SetValue(UpGenericPictInfo.TimeStamp);		}		else		{			theUpImageDate->SetValue(CommonStringLiteral_(kCEyeDxVariableDATENotAvailable));			theUpImageTime->SetValue(CommonStringLiteral_(kCEyeDxVariableTIMENotAvailable));		}	}		if (theSideImageDate && theSideImageTime)	{		if (theSidePictInfoValid)		{			theSideImageDate->SetValue(SideGenericPictInfo.TimeStamp);			theSideImageTime->SetValue(SideGenericPictInfo.TimeStamp);		}		else		{			theSideImageDate->SetValue(CommonStringLiteral_(kCEyeDxVariableDATENotAvailable));			theSideImageTime->SetValue(CommonStringLiteral_(kCEyeDxVariableTIMENotAvailable));		}	}	// Save the focus distance in the appropriate variables		CEyeDxVariable *theUpImageFocusPosition = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGEFOCUS));	CEyeDxVariable *theSideImageFocusPosition = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGEFOCUS));		if (theUpImageFocusPosition)	{		if (theUpPictInfoValid)			theUpImageFocusPosition->SetValue(UpPictInfo.FocusPosition);		else			theUpImageFocusPosition->SetValue(CommonStringLiteral_(kCEyeDxVariableIMAGEFOCUSNotAvailable));	}		if (theSideImageFocusPosition)	{		if (theSidePictInfoValid)			theSideImageFocusPosition->SetValue(SidePictInfo.FocusPosition);		else			theSideImageFocusPosition->SetValue(CommonStringLiteral_(kCEyeDxVariableIMAGEFOCUSNotAvailable));	}	}void HandleStartOfSubject(CEyeDxVariableList *theVariableList){	// We keep track of the total number of retakes for this subject. However, for manual modes, this value is	// not used. So we set it to zero so it has a valid value for	// the report generation and database output functions called by the AnalyzeImages routine.		CEyeDxVariable *theTotalRetakesVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTTOTALRETAKES));	if (theTotalRetakesVariable)		theTotalRetakesVariable->ResetValue();	// Now we save the start time for the subject for statistical purposes. We also set the Subject End Time to a "Not Available"	// string in case it is used in the report. It doesn't have a valid value until after the report is generated, but before the	// database record is written.		CEyeDxVariable *theStartTimeVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTSTARTTIME));	CEyeDxVariable *theEndTimeVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTENDTIME));	CEyeDxVariable *theTodaysDateVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableTODAYSDATE));		if (theStartTimeVariable && theEndTimeVariable && theTodaysDateVariable)	{		theStartTimeVariable->ResetValue();		theEndTimeVariable->SetValue(CommonStringLiteral_(kCEyeDxVariableTIMENotAvailable));		theTodaysDateVariable->ResetValue();	}}void HandleEndOfSubject(CEyeDxVariableList *theVariableList, CEyeDxWindowType *theWindow, CEyeDxLongStringType *theDatabaseFileName){	CEyeDxVariable *theSubjectsMeasuredVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTSMEASURED));	if (theSubjectsMeasuredVariable)	{		long theSubjectCount;		theSubjectsMeasuredVariable->GetValue(theSubjectCount);		theSubjectCount++;		theSubjectsMeasuredVariable->SetValue(long(theSubjectCount));	}			// We do the same for the SESSION SUBJECT COUNT variable		CEyeDxVariable *theSessionSubjectCountVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONSUBJECTCOUNT));	if (theSessionSubjectCountVariable)	{		long theCount;		theSessionSubjectCountVariable->GetValue(theCount);		theCount++;		theSessionSubjectCountVariable->SetValue(long(theCount));	}		// Now, we bump the counters that keep track of Pass, Refer, or Retakes for the session. We are given the variable list, and can look	// up the RESULTS variable for this information		CEyeDxVariable *theResultVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableRESULT));	if (theResultVariable)	{		// Make sure we set this to NULL - that handles the case where the user has cancelled during a run, and the		// result is not a valid value				CEyeDxVariable *theSessionCountVariable = NULL;				if (*(theResultVariable->GetValue()) == CommonStringLiteral_(kResultPass))			theSessionCountVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONPASSCOUNT));		else if (*(theResultVariable->GetValue()) == CommonStringLiteral_(kResultRefer))			theSessionCountVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONREFERCOUNT));		else if (*(theResultVariable->GetValue()) == CommonStringLiteral_(kResultRetake))			theSessionCountVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONRETAKECOUNT));		if (theSessionCountVariable)		{			long theCount;			theSessionCountVariable->GetValue(theCount);			theCount++;			theSessionCountVariable->SetValue(long(theCount));		}	}				// Now we save the end time for the analysis for statistical purposes		CEyeDxVariable *theEndTimeVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTENDTIME));	if (theEndTimeVariable)		theEndTimeVariable->ResetValue();			CEyeDxVariable *theSessionNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();		CEyeDxLongStringType theDatabasePath;#ifdef macintosh	theDatabasePath += LEADINGPATHSEPARATOR;#else	theDatabasePath = DataPath;	#endif	theDatabasePath += *theSessionName;				theDatabasePath += PATHSEPARATOR;	theDatabasePath += *theDatabaseFileName;				char databaseFileName[256];#ifdef macintosh	strncpy(databaseFileName, theDatabasePath.TextPtr(), theDatabasePath.Length());	databaseFileName[theDatabasePath.Length()] = '\0';#else	strcpy(databaseFileName, theDatabasePath);#endif								// Output the database record here, since we are truly done with this subject		DatabaseOutput(theWindow,			databaseFileName,			theVariableList);					}// This routine will calculate the subject's age based on the value of the BIRTH DATE variable.// It will set the AGE variable, and return the age as an integer. If BIRTH DATE is not set, then// the AGE variable is set to an appropriate string, and the kAgeNotCalculated value is returned.int HandleAgeCalculation(CEyeDxVariableList *theVariableList){	// We calculate the age if the user has entered a birth date	CEyeDxVariable *theBirthDateVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableBIRTHDATE));	CEyeDxVariable *theAgeVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableAGE));		int ageInYears = kAgeNotCalculated;		if (theAgeVariable && theBirthDateVariable)	{		if (theAgeVariable)			theAgeVariable->SetValue(kAgeNotCalculatedString);	// Indicate not calculated		CEyeDxLongStringType *theBirthDateStr = theBirthDateVariable->GetValue();#ifdef macintosh		if (theBirthDateStr->Length() > 0)		{			// Calculate age by converting entered string into a LongDateRec and subtracting from the current date						DateCacheRecord theDateCache;			::InitDateCache(&theDateCache);								long lengthUsed;			LongDateRec dateTime;			StringToDateStatus stdStatus;							// Use the international utilities to check the inputs			stdStatus = ::StringToDate(theBirthDateStr->TextPtr(), theBirthDateStr->Length(), &theDateCache, &lengthUsed, &dateTime);						// We don't care if it was entered as a long date						stdStatus &= ~longDateFound;						if (stdStatus == 0)			{				// Looks like a valid date. Calculate the difference between today's date and the entered date. Convert back				// to date and time, and then convert the difference between the year values to an integer. "0" indicates less				// than a year old, of course!								// First, convert the entered birth date into long format				LongDateCvt theEnteredDate;									// Make sure we clear the time values so they don't influence the calculation									dateTime.ld.hour = 0;				dateTime.ld.minute = 0;				dateTime.ld.second = 0;				dateTime.ld.pm = 0;								::LongDateToSeconds(&dateTime, &theEnteredDate.c);								// Now, get today's date in the same format								LongDateCvt theCurrentDateTime;				theCurrentDateTime.hl.lHigh = 0L;				::GetDateTime(&theCurrentDateTime.hl.lLow);											// Now we have two dates that can be compared. We subtract the birth date from today's date. This				// gives us a long difference in time.								LongDateCvt theDifference;				theDifference.c = theCurrentDateTime.c - theEnteredDate.c;									const long long kSecsPerYear = (60 * 60 * 24 * 365);								// Divide by the number of seconds in a year. Since we just need an approximate difference, we				// do not take into account leap years.								ageInYears = (long) (theDifference.c / kSecsPerYear);								theAgeVariable->SetValue(long(ageInYears));			}#else		if (theBirthDateStr->GetLength() > 0)		{			// Use the 3rd-party ComDate Class to parse the entered date string to see if it is valid.												// We have to convert the input string into a wide-character (UNICODE) string for this to work. The			// built-in A2OLE macro used in the library fails to do the conversion!						int nLenOfWideCharStr = ::MultiByteToWideChar(CP_ACP, 0, *theBirthDateStr, -1, NULL, 0);						// Allocate ememory to hold the converted string						LPWSTR lpWideCharStr = (WCHAR *) ::HeapAlloc(::GetProcessHeap(), 0, nLenOfWideCharStr * sizeof(WCHAR));						::MultiByteToWideChar(CP_ACP, 0, *theBirthDateStr, -1, lpWideCharStr, nLenOfWideCharStr);						CComDATE enteredDateTime;						if (!enteredDateTime.ParseDateTime(lpWideCharStr, VAR_DATEVALUEONLY))				return ageInYears;										::HeapFree(::GetProcessHeap(), 0, lpWideCharStr); 						CComDATE theCurrentDateTime = CComDATE::Now();						CComSpan theDifference = theCurrentDateTime - enteredDateTime;			const long kDaysPerYear = (365);						// Divide by the number of days in a year. Since we just need an approximate difference, we			// do not take into account leap years.						long theDifferenceInDays = theDifference.Days();						ageInYears = theDifferenceInDays / kDaysPerYear;						theAgeVariable->SetValue(long(ageInYears));#endif		}	}		// Note that if for some reason the BIRTH DATE string is in the future this may be negative, and	// since -1 is the not calculated flag... However, prompts for the BIRTH DATE use the "Date In Past"	// option, so this shouldn't be a problem.		return ageInYears;}CEyeDxMessageType HandlePromptForVariables(CEyeDxWindowType *theWindow, 											CEyeDxVariableList *theVariableList, 											short thePromptingStyle, 											CEyeDxVariable::PromptType thePromptType){	// Used to tell the prompt to reload a value the user previously entered, rather than	// the default. This is used when the user requests to back up in a sequence of dialogs		CEyeDxBooleanType reloadValue = false;		// First, check to see if there are any variables that should be prompted at this point.	// If not, just return true, to tell the caller to continue.		short nextPromptNumber = theVariableList->GetNextAvailablePromptNumber(thePromptType);	if (nextPromptNumber == kNoPromptOrder)		return true;			// Ok, we have something to prompt for. We have two different ways to prompt: all prompts	// in one dialog, or a separate dialog for each. This is based on a user preference. 		if (thePromptingStyle == kPromptAllInOne)			return (DoPromptForVariable(theWindow, theVariableList, thePromptType, kNoPromptOrder, false, false));	else	{		// We loop through all of the prompts in this dialog, one at a time, calling the dialog		// handler. If any dialog returns false (Cancel), we stop and return false to the caller.		// Once done, we return true to indicate that all variables were successfully entered.				short currentPromptNumber = kNoPromptOrder;		short previousPromptNumber = kNoPromptOrder;				CEyeDxVariable *theVariable;				while ((theVariable = theVariableList->GetNextPromptedVariable(thePromptType, currentPromptNumber)) != NULL)		{			// Now, we update to the current variable's prompt order, and loop back, asking for the next			// one. If this one is the last, we'll get a NULL						previousPromptNumber = currentPromptNumber;						currentPromptNumber = theVariable->GetPromptOrder();						CEyeDxMessageType theResult;			// We allow the Go Back button to be enabled (the last parameter) if we are not at the first prompt			if ((theResult = DoPromptForVariable(theWindow, theVariableList, thePromptType, currentPromptNumber, (previousPromptNumber != kNoPromptOrder), reloadValue)) == kEyeDxDialogGoBackMessage)			{				// User has requested that we back up one step. Since the call to get the variable looks for the variable				// _after_ the "currentPromptNumber", we actually have to go back _two_ steps in the count to go back one				// in terms of variables.								currentPromptNumber -= 2;								reloadValue = true;			}			else if (theResult == kEyeDxDialogCancelMessage)				return theResult;			else				reloadValue = false;		}				// All prompts answered correctly, so tell the caller to go ahead.				return kEyeDxDialogOKMessage;	}}CEyeDxMessageType DoPromptForVariable(CEyeDxWindowType *theWindow, 										CEyeDxVariableList *theVariableList,										CEyeDxVariable::PromptType thePromptType, 										short thePromptOrder, 										CEyeDxBooleanType allowGoBack, 										CEyeDxBooleanType reloadValue){#ifdef macintosh	// Create the dialog handler.	StDialogHandler theHandler( PPob_PromptForVariableDialog, (LCommander *)theWindow );	// Get the dialog.	CPromptForVariableDialog *theDialog;	theDialog = dynamic_cast<CPromptForVariableDialog *>(theHandler.GetDialog());	ThrowIfNil_(theDialog);		theDialog->SetupDialog(theVariableList, thePromptType, thePromptOrder, allowGoBack, reloadValue);		// Make the dialog visible.	theDialog->Show();		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_Cancel:		case msg_PromptForVariableDialog_GoBack:			return theMessage;			break;		case msg_OK: 			// If the validation failed, don't fall out of here!			if (theDialog->UserInputValid())				return kEyeDxDialogOKMessage;			break;		}	}	return kEyeDxDialogCancelMessage;#else	CMFCPromptForVariableDlg dlg(theWindow,									theVariableList, 									thePromptType, 									thePromptOrder, 									allowGoBack, 									reloadValue);		return (dlg.DoModal());#endif}CEyeDxMessageType DoCheckForMemory(CEyeDxWindowType *theWindow, 										CEyeDxBooleanType animationEnabled,										short upRows,										short upCols,										short num3ByteDeepImages,										short num1ByteDeepImages,										CEyeDxLongStringType *hintString){	// First, we see if there's enough temporary memory to run. The peak usage is one 8 bit deep image and 	// one or two 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.		if (animationEnabled)		num3ByteDeepImages++;			long theBytesRequiredForAnalysis = ((((upRows * upCols) * 3) * num3ByteDeepImages) + (((upRows * upCols) * 1) * num1ByteDeepImages)) * 1.1;	long theGrow;	CEyeDxMessageType theMessage = kEyeDxDialogOKMessage;		// Now we check the amount of available temporary memory, and if the message returned from	// the dialog told us to try again. If the memory available has increased to the amount we	// need, we'll drop through. If the user hits the Cancel button, we give up now.		while ((CheckAvailTempMem(&theGrow) < theBytesRequiredForAnalysis) && (theMessage == kEyeDxDialogOKMessage))	{		theMessage = DoPromptForOutOfMemory(theWindow, theBytesRequiredForAnalysis, hintString);	}		return (theMessage);}CEyeDxMessageType DoPromptForOutOfMemory(CEyeDxWindowType *theWindow, 											long theAmountNeeded,											CEyeDxLongStringType *hintString){#ifdef macintosh	// Create the dialog handler.	StDialogHandler theHandler( PPob_OutOfMemoryDialog, (LCommander *)theWindow );	// Get the dialog.	COutOfMemoryDialog *theDialog;	theDialog = dynamic_cast<COutOfMemoryDialog *>(theHandler.GetDialog());	ThrowIfNil_(theDialog);		theDialog->SetupDialog(theAmountNeeded, hintString);		// Make the dialog visible.	theDialog->Show();		while (1) 	{		// Handle dialog messages.		CEyeDxMessageType theMessage = theHandler.DoDialog();		switch (theMessage)		{		case kEyeDxDialogCancelMessage:			return theMessage;			break;		case kEyeDxDialogOKMessage: 			return theMessage;			break;		}	}	return kEyeDxDialogCancelMessage;#else	CEyeDxLongStringType thePromptStr;		thePromptStr.Format("The EyeDx Application needs %d Kbytes of memory, and only %d Kbytes are available. Please exit other applications if possible and press Retry. ",						(theAmountNeeded / 1024), (CheckAvailTempMem(NULL) / 1024));	thePromptStr += *hintString;	CEyeDxMessageType theMessage = theWindow->MessageBox(thePromptStr, AfxGetAppName(), MB_RETRYCANCEL | MB_ICONEXCLAMATION);	if (theMessage == IDRETRY)		return kEyeDxDialogCancelMessage;	else		return kEyeDxDialogOKMessage;#endif}CEyeDxMessageType HandleStartOfSession(CEyeDxWindowType *theWindow, 						 CEyeDxVariableList *theVariableList,						 CEyeDxButtonType *theMainWindowButton,						 CEyeDxCaptionType *theMainWindowCaption,						 CEyeDxLongStringType *theSessionName,						 short thePromptingStyle,						 CEyeDxBooleanType useSessions){	// We set the new Session Name as the value for the SESSION NAME	// variable.		CEyeDxVariable *theSessionNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));		if (theSessionNameVariable)		theSessionNameVariable->SetValue(*theSessionName);		// We reset the SESSION SUBJECT COUNT, SESSION PASS COUNT, SESSION REFER COUNT, and SESSION RETAKE COUNT	// variables.		CEyeDxVariable *theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONSUBJECTCOUNT));		if (theVariable)		theVariable->ResetValue();		theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONPASSCOUNT));		if (theVariable)		theVariable->ResetValue();		theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONREFERCOUNT));		if (theVariable)		theVariable->ResetValue();		theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONRETAKECOUNT));		if (theVariable)		theVariable->ResetValue();		theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONSTARTDATE));		if (theVariable)		theVariable->ResetValue();		theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONSTARTTIME));		if (theVariable)		theVariable->ResetValue();		// We set the main window button only if we aren't running the default session		UpdateSessionButtonAndCaption(useSessions, theSessionNameVariable, theMainWindowButton, theMainWindowCaption);	if (*theSessionName != CommonStringLiteral_(kDefaultSessionName))	{		// Now, we prompt for the variables that are to be set at the start of a session. We return the value returned		// by this routine so that the caller knows whether the user hit the Cancel button in the prompt dialogs.			return (HandlePromptForVariables(theWindow, theVariableList, thePromptingStyle, CEyeDxVariable::kPromptForSession));		}	else	{		// We are just setting up the default session so we do not prompt for variables. So we pretend that everything		// is fine.				return kEyeDxDialogOKMessage;	}}static CEyeDxMessageType DoPromptForSessionName(CEyeDxWindowType *theWindow, 											CEyeDxLongStringType *theNewSessionName){	// This routine displays a dialog to prompt for the session name.	// If OK is pressed, the name is validated, and the user prompted if it is	// invalid. #ifdef macintosh		// Create the dialog handler.	StDialogHandler theHandler( PPob_SessionNameDialog, (LCommander *)theWindow );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );		CEyeDxEditFieldType *theSessionName = dynamic_cast<CEyeDxEditFieldType*> (theDialog->FindPaneByID(kSessionNameField));	ThrowIfNil_( theSessionName );		CEyeDxCaptionType *theSessionCaption = dynamic_cast<CEyeDxCaptionType*> (theDialog->FindPaneByID(kSessionNamePrompt));	ThrowIfNil_( theSessionCaption );			theSessionName->SetMaxChars(kMaxSessionNameLength);		LStr255 theSessionPrompt = "\pPlease enter up to ";	theSessionPrompt.Append(kMaxSessionNameLength);	theSessionPrompt.Append("\p characters for the session name:");	theSessionCaption->SetDescriptor(theSessionPrompt);		theDialog->Show();		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		if ( theMessage == msg_Cancel ) 			return theMessage;					else if ( theMessage == msg_OK ) 		{			// Get the entered session name and see if it is valid.			// If it is, we return true. If not, the user is prompted and we			// continue looping.			CEyeDxLongStringType theSessionNameString;						theSessionName->GetDescriptor(theSessionNameString);						if (CheckSessionValidity(theWindow, &theSessionNameString))			{				*theNewSessionName = theSessionNameString;				return theMessage;			}		}	}	return msg_Cancel;#else	CMFCGetSessionNameDlg dlg((CMainWindow *)theWindow, theNewSessionName);		return (dlg.DoModal());#endif}CEyeDxMessageType HandleNewSession(CEyeDxWindowType *theWindow, 						 CEyeDxVariableList *theVariableList,						 CEyeDxButtonType *theMainWindowButton,						 CEyeDxCaptionType *theMainWindowCaption,						 short thePromptingStyle){	CEyeDxMessageType theReturn = kEyeDxDialogOKMessage;	// Ask the user for the name of the new session. We loop here until we get an entry that is not blank,	// and is also not the name of an existing session, or the Cancel button is pressed.		CEyeDxBooleanType validName = false;	CEyeDxLongStringType theNewSessionName;		// Prompt for a string. It must not be too long, must not be empty, must not contain invalid filename	// characters, and must not be the same as an existing session name. If it meets all of these requirements,	// we set the validName flag. If the usr hits Cancel in the dialog, we will fall out of here and cancel the	// new session function.		theReturn = DoPromptForSessionName(theWindow, &theNewSessionName);		if (theReturn == kEyeDxDialogOKMessage)	{		// We will start the default session. The HandleStartOfSession will set up everything properly		theReturn = HandleStartOfSession(theWindow, theVariableList, theMainWindowButton, theMainWindowCaption, &theNewSessionName, thePromptingStyle, true);	}	else	// They cancelled entering a new session name. Therefore, we will restart the default session	{				CEyeDxLongStringType theDefaultSessionName = kDefaultSessionName;		theReturn = HandleStartOfSession(theWindow, theVariableList, theMainWindowButton, theMainWindowCaption, &theDefaultSessionName, thePromptingStyle, true);	}		return theReturn;}CEyeDxMessageType HandleEndOfSession(CEyeDxWindowType *theWindow, 						 CEyeDxVariableList *theVariableList,						 CEyeDxButtonType *theMainWindowButton,						 CEyeDxCaptionType *theMainWindowCaption,						 CEyeDxVariable *theSessionVariable,						 const char *theSummaryReportText,						 long theSummaryReportTextSize,						 short thePromptingStyle,						 CEyeDxBooleanType autoSelectDefault){	CEyeDxMessageType theReturn = kEyeDxDialogOKMessage;	CEyeDxLongStringType *theSessionName = theSessionVariable->GetValue();		// First, we ask the user to confirm ending the session. If they decide not to, we return an OK status	// to the caller, indicating that a session is active. When we are told to auto select the default session,	// that is typically on exit, and the user has already decided what to do.		if (!autoSelectDefault)	{		CEyeDxLongStringType thePrompt = CommonStringLiteral_("Are you sure you want to end the current session (");		thePrompt += *theSessionName;		thePrompt += CommonStringLiteral_(")?");	#ifndef macintosh		if (theWindow->MessageBox(thePrompt, AfxGetAppName(), MB_YESNO) == IDNO)#else		::ParamText(thePrompt, Str_Empty, Str_Empty, Str_Empty);		DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_YesNoALRT);		if (item_hit == PPob_YesNoALRT_No)#endif			return theReturn;	}		// Looks like they really want to do it. So log some information about the end of the session			CEyeDxVariable *theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONENDDATE));	if (theVariable)		theVariable->ResetValue();		theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONENDTIME));	if (theVariable)			theVariable->ResetValue();			// We have to close out the current session by writing out the Session Summary Report at this point			SessionSummaryOutput(theWindow, theVariableList, theSummaryReportText, theSummaryReportTextSize);				if (!autoSelectDefault)	{		char sessionSummaryRptPath[1000];#ifndef macintosh		if (theWindow->MessageBox("Would you like to display the session summary report?", AfxGetAppName(), MB_YESNO) == IDYES)		{				sprintf(sessionSummaryRptPath, "%s%s\\%s", DataPath, *theSessionName, kDefaultSessionSummaryName);			OpenTextFile(sessionSummaryRptPath);			// We delay a bit so that the document is open before continuing			OSSleep(CalculateDelay(5));		}#else		::ParamText("\pWould you like to display the session summary report?", Str_Empty, Str_Empty, Str_Empty);		DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_YesNoALRT);		if (item_hit == PPob_YesNoALRT_Yes)		{			FSSpec sessionSummarySpec;			char sessionName[63];			strncpy(sessionName, theSessionName->TextPtr(), theSessionName->Length());			sessionName[theSessionName->Length()] = '\0';							sprintf(sessionSummaryRptPath, ":%s:%s", sessionName, kDefaultSessionSummaryName);			__path2fss(sessionSummaryRptPath, &sessionSummarySpec);			OpenSpecifiedDocument(&sessionSummarySpec, kUnknownType);			// We delay a bit so that the document is open before continuing			//OSSleep(CalculateDelay(5));		}	#endif		// This is normally used on Quit, when the user says they don't want to keep using the session. In this		// case we want to avoid asking them for a new session.			// Now we ask the user if they want to start a new session	#ifndef macintosh		if (theWindow->MessageBox("Do you want to start a new session?", AfxGetAppName(), MB_YESNO) == IDYES)#else		::ParamText("\pDo you want to start a new session?", Str_Empty, Str_Empty, Str_Empty);		item_hit = UModalAlerts::NoteAlert(PPob_YesNoALRT);		if (item_hit == PPob_YesNoALRT_Yes)#endif			theReturn = HandleNewSession(theWindow, theVariableList, theMainWindowButton, theMainWindowCaption, thePromptingStyle);		else		{			// We will start the default session. The HandleStartOfSession will set up everything properly						CEyeDxLongStringType theDefaultSessionName = kDefaultSessionName;			theReturn = HandleStartOfSession(theWindow, theVariableList, theMainWindowButton, theMainWindowCaption, &theDefaultSessionName, thePromptingStyle, true);		}	}	else	{		// We will start the default session. The HandleStartOfSession will set up everything properly.				CEyeDxLongStringType theDefaultSessionName = kDefaultSessionName;		theReturn = HandleStartOfSession(theWindow, theVariableList, theMainWindowButton, theMainWindowCaption, &theDefaultSessionName, thePromptingStyle, true);	}	return theReturn;}// Either the button or the caption variables may be nil/NULL for this call.void UpdateSessionButtonAndCaption(CEyeDxBooleanType useSessions, CEyeDxVariable *theSessionNameVariable, CEyeDxButtonType *theSessionButton, CEyeDxCaptionType *theSessionCaption){	// Note that when loaded the variable's value is set to the default		CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();				if (*theSessionName != CommonStringLiteral_(kDefaultSessionName))	{		// Set the main window button to indicate that a session is active				if (theSessionButton)		{#ifdef macintosh			theSessionButton->SetDescriptor(CommonStringLiteral_(kEndSessionButtonLabel));			if (useSessions)				theSessionButton->Enable();			else				theSessionButton->Disable();#else			theSessionButton->SetWindowText(CommonStringLiteral_(kEndSessionButtonLabel));				if (useSessions)				theSessionButton->EnableWindow(TRUE);			else				theSessionButton->EnableWindow(FALSE);#endif		}				if (theSessionCaption)		{			CEyeDxLongStringType theCaptionStr = CommonStringLiteral_("Current Session: ");			theCaptionStr += *theSessionName;		#ifdef macintosh			theSessionCaption->SetDescriptor(theCaptionStr);	#else			theSessionCaption->SetWindowText(theCaptionStr);	#endif		}			}	else	{		// Set the main window button to indicate that a session is not active				if (theSessionButton)		{#ifdef macintosh			theSessionButton->SetDescriptor(CommonStringLiteral_(kStartSessionButtonLabel));			if (useSessions)				theSessionButton->Enable();			else				theSessionButton->Disable();#else			theSessionButton->SetWindowText(CommonStringLiteral_(kStartSessionButtonLabel));				if (useSessions)				theSessionButton->EnableWindow(TRUE);			else				theSessionButton->EnableWindow(FALSE);#endif		}				if (theSessionCaption)#ifdef macintosh			theSessionCaption->SetDescriptor(EMPTYSTR);#else			theSessionCaption->SetWindowText(EMPTYSTR);	#endif	}}