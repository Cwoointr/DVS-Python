#pragma once#include <stdio.h>#include <stdlib.h>#ifndef macintosh		#define WINDOWS		/* for Kodak SDK */#ifndef WIN32#define WIN32		/* for Kodak SDK, 32-bit windows */#endif // WIN32#endif // macintosh#include "DC120.h"// These macros map the appropriate object types for Windows or MacOS Powerplant to// common names. This allows for a single source-code reference of most routines.#ifdef __cplusplus#ifdef macintosh#include <path2fss.h>#include "EyeDxMacConstants.h"#include <PP_Messages.h>/////////////////////////////////// MACINTOSH PLATFORM COMMON DEFINTIONS //////////////////////////////////#include "CMyGworldView.h"#include <LGADialog.h>#include <LProgressBar.h>#include <LStaticText.h>#include <LPopupButton.h>#include <LPushButton.h>#include <LTextGroupBox.h>#include <LEditText.h>#include <LIconPane.h>#include <LCheckBox.h>#include <LRadioButton.h>#include <LIconControl.h>#include <LBevelButton.h>#include <LTabsControl.h>typedef	LGADialog	 			CEyeDxDialogType;typedef	LProgressBar 			CEyeDxProgressType;typedef	LStaticText				CEyeDxCaptionType;typedef	CMyGWorldView			CEyeDxViewType;typedef	LIconPane				CEyeDxIconType;typedef	LPopupButton			CEyeDxPopupMenuType;typedef void					CEyeDxWindowType;typedef LPushButton				CEyeDxButtonType;typedef LTextGroupBox			CEyeDxTextGroupBoxType;typedef LEditText				CEyeDxEditFieldType;typedef	LCheckBox				CEyeDxCheckBoxType;typedef	LRadioButton			CEyeDxRadioButtonType;typedef Handle					CEyeDxHandleType;typedef LStr255					CEyeDxLongStringType;		typedef TString<Str63>			CEyeDxShortStringType;typedef	bool					CEyeDxBooleanType;typedef ArrayIndexT				CEyeDxArrayIndexType;typedef	MessageT				CEyeDxMessageType;typedef LBevelButton			CEyeDxIconButtonType;typedef LTabsControl			CEyeDxTabsControlType;// These constants define return values from dialogsconst CEyeDxMessageType	kEyeDxDialogOKMessage		= msg_OK;const CEyeDxMessageType	kEyeDxDialogCancelMessage	= msg_Cancel;const CEyeDxMessageType kEyeDxDialogGoBackMessage	= msg_PromptForVariableDialog_GoBack;// This macro is used to pass strings to the SetCaptionText routine#define	CommonStringLiteral_(str)	StringLiteral_(str)#define	PATHSEPARATOR				':'#define	PATHSEPARATORSTR			":"#define	LEADINGPATHSEPARATOR		PATHSEPARATORSTR#define	EMPTYSTR				"\p"#define	kEndOfLineString		"\p\n"// This constant defines the number of bytes per pixel elementconst int kBytesPerPixel		= 4;// These inline routines allow for common cross-platform source code. They take// a platform-independent object pointer and appropriate parameters, and perform// the necessary platform-specific operations.inline	void SetCaptionText(CEyeDxCaptionType *theCaption, const char *text){	theCaption->Show();	theCaption->SetDescriptor((ConstStringPtr)text);	theCaption->Draw(nil);}inline	void SetCaptionText(CEyeDxCaptionType *theCaption, const unsigned char *text){	theCaption->Show();	theCaption->SetDescriptor((ConstStringPtr)text);	theCaption->Draw(nil);}inline void SetThermometerValues(CEyeDxProgressType *theThermometer, long start, long end, long position){	theThermometer->SetMinValue(start);	theThermometer->SetMaxValue(end);	theThermometer->SetValue(position);	theThermometer->Draw(nil);}inline void SetThermometerValue(CEyeDxProgressType *theThermometer, long position){	theThermometer->SetValue(position);}inline void IncrementThermometerValue(CEyeDxProgressType *theThermometer, long increment){	long theCurrentValue = theThermometer->GetValue();		theThermometer->SetValue(theCurrentValue + increment);}inline void SetThermometerMode(CEyeDxProgressType *theThermometer, CEyeDxBooleanType isIndeterminate){	theThermometer->SetIndeterminateFlag(isIndeterminate);}inline void GiveOSTime(){	// Let the OS have some time	EventRecord theEvent;	::WaitNextEvent(0, &theEvent, 1L, nil);}inline void SetOSType(char *filename, OSType creator, OSType type){	FSSpec theFSSpec;	FInfo theFInfo;		__path2fss(filename, &theFSSpec);	FSpGetFInfo(&theFSSpec, &theFInfo);	theFInfo.fdCreator = creator;	// Generic creator type	theFInfo.fdType = type;	// JPEG Type	FSpSetFInfo(&theFSSpec, &theFInfo);}inline void StopAlert(CEyeDxWindowType *, 						unsigned char *str1, unsigned char *str2 = CommonStringLiteral_(EMPTYSTR),						unsigned char *str3 = CommonStringLiteral_(EMPTYSTR), unsigned char *str4 = CommonStringLiteral_(EMPTYSTR)){	::ParamText(str1, str2, str3, str4);	UModalAlerts::StopAlert(PPob_GeneralALRT);}inline void CautionAlert(CEyeDxWindowType *, 						unsigned char *str1, unsigned char *str2 = CommonStringLiteral_(EMPTYSTR),						unsigned char *str3 = CommonStringLiteral_(EMPTYSTR), unsigned char *str4 = CommonStringLiteral_(EMPTYSTR)){	::ParamText(str1, str2, str3, str4);	UModalAlerts::CautionAlert(PPob_GeneralALRT);}inline void NoteAlert(CEyeDxWindowType *, 						unsigned char *str1, unsigned char *str2 = CommonStringLiteral_(EMPTYSTR),						unsigned char *str3 = CommonStringLiteral_(EMPTYSTR), unsigned char *str4 = CommonStringLiteral_(EMPTYSTR)){	::ParamText(str1, str2, str3, str4);	UModalAlerts::NoteAlert(PPob_GeneralALRT);}inline void OSSleep(long timeout){	// Timeouts on the Mac are in system ticks (16.666 ms)	unsigned long theDelay;	::Delay(timeout, &theDelay);}inline long CheckAvailTempMem(long *theGrow){	return ::TempMaxMem(theGrow);}inline void CopyEyeDxStringToCString(const CEyeDxLongStringType *const theSrc, unsigned char *const theDst){	strncpy((char *)theDst, theSrc->TextPtr(), theSrc->Length());	theDst[theSrc->Length()] = '\0';				}inline void CopyEyeDxStringToCString(const CEyeDxShortStringType *const theSrc, unsigned char *const theDst){	strncpy((char *)theDst, theSrc->TextPtr(), theSrc->Length());	theDst[theSrc->Length()] = '\0';				}#else // must be Windows/////////////////////////////////// WINDOWS 95 PLATFORM COMMON DEFINTIONS //////////////////////////////////#include "resource.h"#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"typedef	CProgressCtrl			CEyeDxProgressType;		typedef	CStatic					CEyeDxCaptionType;		typedef	CEyeDxDibStatic			CEyeDxViewType;			#define CEyeDxWindowType		CWnd					// Under Windows this has to be a #define instead of a typedef		typedef CButton					CEyeDxButtonType;typedef unsigned char *			CEyeDxHandleType;		typedef CString					CEyeDxLongStringType;	typedef CString					CEyeDxShortStringType;	#define	CEyeDxBooleanType		BOOL					// Under Windows this has to be a #define instead of a typedef	typedef int						CEyeDxArrayIndexType;typedef int						CEyeDxMessageType;// These constants define return values from dialogsconst CEyeDxMessageType	kEyeDxDialogOKMessage		= IDOK;const CEyeDxMessageType	kEyeDxDialogCancelMessage	= IDCANCEL;const CEyeDxMessageType kEyeDxDialogGoBackMessage	= IDD_PROMPT_FOR_VARIABLE_GOBACK;// This macro is used to pass strings to the SetCaptionText routine#define	CommonStringLiteral_(str)	(str)#define	PATHSEPARATOR				'\\'#define	PATHSEPARATORSTR			"\\"#define	LEADINGPATHSEPARATOR		""#define	EMPTYSTR				""#define	kEndOfLineString		"\r\n"// This constant defines the number of bytes per pixel elementconst int kBytesPerPixel		= 3;// These inline routines allow for common cross-platform source code. They take// a platform-independent object pointer and appropriate parameters, and perform// the necessary platform-specific operations.inline void SetCaptionText(CEyeDxCaptionType *theCaption, const char *text){	theCaption->ShowWindow(SW_SHOW);	theCaption->SetWindowText(text);}inline void SetThermometerValues(CEyeDxProgressType *theThermometer, long start, long end, long position){	theThermometer->SetRange(start, end);	theThermometer->SetPos(position);}inline void SetThermometerValue(CEyeDxProgressType *theThermometer, long position){	theThermometer->SetPos(position);}inline void IncrementThermometerValue(CEyeDxProgressType *theThermometer, long increment){	theThermometer->OffsetPos(increment);}inline void SetThermometerMode(CEyeDxProgressType *, BOOL){	// TODO Doesn't do anything - not supported in Windows theThermometer->SetTaskType(mode);}// Not needed for Windowsinline void GiveOSTime(){}inline long CheckAvailTempMem(long *)	// Parameter is not used{	MEMORYSTATUS ms;		ms.dwLength = sizeof(ms);	GlobalMemoryStatus(&ms);		return ms.dwAvailVirtual;}// Not applicable to Windowstypedef	long OSType;inline void SetOSType(char *, OSType, OSType ){}inline void StopAlert(CEyeDxWindowType *theWindow, 						char *str1, char *str2 = EMPTYSTR,						char *str3 = EMPTYSTR, char *str4 = EMPTYSTR){	// These are to eliminate unused parameter warnings. They are optimized out	// by the compiler. Can't use the normal method of not listing a name for the	// formal parameter because of the need to have an initializer.		char *x = str2;	x = str3;	x = str4;		theWindow->MessageBox(str1, "Error", MB_OK | MB_ICONSTOP);}inline void CautionAlert(CEyeDxWindowType *theWindow, 						char *str1, char *str2 = EMPTYSTR,						char *str3 = EMPTYSTR, char *str4 = EMPTYSTR){	// These are to eliminate unused parameter warnings. They are optimized out	// by the compiler. Can't use the normal method of not listing a name for the	// formal parameter because of the need to have an initializer.		char *x = str2;	x = str3;	x = str4;		theWindow->MessageBox(str1, "Caution", MB_OK | MB_ICONEXCLAMATION);}inline void NoteAlert(CEyeDxWindowType *theWindow, 						char *str1, char *str2 = EMPTYSTR,						char *str3 = EMPTYSTR, char *str4 = EMPTYSTR){	// These are to eliminate unused parameter warnings. They are optimized out	// by the compiler. Can't use the normal method of not listing a name for the	// formal parameter because of the need to have an initializer.		char *x = str2;	x = str3;	x = str4;		theWindow->MessageBox(str1, "Note", MB_OK | MB_ICONINFORMATION);}inline void OSSleep(long timeout){	// Sleep times on the PC are in ms	Sleep(timeout);}// This function isn't needed on Windowsinline void HUnlock(void *){}inline void CopyEyeDxStringToCString(const CEyeDxLongStringType *const theSrc, unsigned char *const theDst){	strcpy((char *)theDst, *theSrc);}#endif	// macintosh#endif	// __cplusplus#ifdef __cplusplus// This section defines the class used to describe variables. Note that the class varies// between Mac and Windows by using native data types, but the implementation of the// code is platform-specific. This allows common modules to access variables in a // portable manner.#include "CEyeDxVariables.h"#endif/////////////////////////////////// CROSS PLATFORM COMMON DEFINTIONS //////////////////////////////////// Constants used in display and analysisenum SideSelect { UpImage = 1, SideImage = 2 };#define IMAGE_WIDTH		1280	// Expected image size#define	IMAGE_HEIGHT	960#define JPEG_THUMB_SCALE	8	// The maximum supported by the JPEG library#define THUMB_WIDTH		80	/* size of thumbnail images from camera */#define THUMB_HEIGHT	60#define MAX_BRIGHTS	1000	/* max number of places to try to fit eyes */#define	BRIGHT			255	/* image labels used in threshimage */#define BRIGHT_CHECKING	1	/*  during processing */#define POSS_REFLEX		254#define CORN_REFLEX		253#define ABNORMAL		252#define	BRIGHT_OTHER	2#define	DARK			200#define	OTHER			0#define MIN_IRIS_RAD	17		/* units are pixel lengths */#define MAX_IRIS_RAD	83		/* units are pixel lengths */#define MIN_CR_AREA		4		/* units are pixel squares */#define MAX_CR_AREA		80		/* units are pixel squares */#define MIN_PUPIL_RAD	6		/* units are pixel lengths */#define MAX_PUPIL_RAD	39		/* units are pixel lengths */#define MIN_2R_AREA		0.05	/* units are percentage of pupil area */#define MAX_2R_AREA		0.50	/* units are percentage of pupil area */#define BRIGHT_THRESH	200		/* units are intensity-levels */#define MAX_HEAD_TILT	30.0	/* units are degrees */#define MAX_EYE_RESID	1.5		/* units are pixel-distances */#define MAX_EYE_SPACE	4.0		/* units are pixel-distances */#define MAX_EYE_GRAD	500		/* units are intensity-levels */#define MIN_EYE_ARC		0.3		/* units are percentage of circle-arc */#define MAX_LUMIN_DIFF	20		/* units are intensity-levels */#define MIN_CRESC		0.25	/* units are percentage of pupil perimeter */#define MAX_CR_PUP_DIST	0.20	/* units are percentage of pupil radius */#define SQR(x) ((x)*(x))	/* macro for square */#ifndef M_PI			/* in case M_PI not found in math.h */#define M_PI 3.1415927#endifstruct resultsStruct{	int		resultflag;	char	fail_text[250];	double	lefteye_circles[4];	double	righteye_circles[4];	int		right_arr_row;	int		right_arr_col;	int		left_arr_row;	int		left_arr_col;	int		strabismus;	int		red_reflex_lumin;	int		left_arr_class;	int		right_arr_class;	double	pupil_threshold;	double	pupil_to_pupil_dist;	double	pupils_horizon_angle;	int		lefteye_cr_point;	int		righteye_cr_point;	int		total_points;	int		total_circles;	int		cols;				// for decoding cr_point, which is encoded y * cols + x};#define NOT_AVAILABLE	0	/* labels for test reports (internal) */#define NORMAL			1#define CRESCENT		2#define OTHER_BLOB		3#define NOT_LOOKING		2#define	STRABISMUS		3// These are for the older version of ClassifyPupilAlignment#if FALSE#define EXOTROPIA		3#define ESOTROPIA		4#define HYPERTROPIA		5#endif#define NOT_DETECTED	2#define UNEQUAL_LUMIN	3// This string contains characters that are considered illegal for filenames// on both patforms.#define ILLEGAL_FILENAME_CHARS	"\\/*?<>|:\""// Various global variables#define MAX_FILENAME_CHARS	250#define MAX_PATHNAME_CHARS	500extern char	DataPath[MAX_PATHNAME_CHARS];extern char	up_filename[MAX_FILENAME_CHARS];extern char	side_filename[MAX_FILENAME_CHARS];extern char	report_filename[MAX_FILENAME_CHARS];		// image data to analyze kept in global variablesextern unsigned char	*up_image,*side_image;extern int				UP_ROWS,UP_COLS,SIDE_ROWS,SIDE_COLS;		// flags and variables for user controlextern int				SideWhichWay,DisplayGraphics,RunInProgress, SaveFullImages;		// analyzation variablesextern int				MinIrisRad,MaxIrisRad,MinPupilRad,MaxPupilRad;extern int				MinCRArea,MaxCRArea,BrightThresh;		// animation variablesextern int				CircleThickness,FramePause,ZoomSteps,Flashes;// This is the length of the prefix that we tack-on to the beginning of the// report filenameconst int	kNumValidPrefixes				= 4;			// Doesn't include the Null indicator#define		kNullReferralIndicator			""#define		kYesReferralIndicator			"R_"	// Refer#define		kNoReferralIndicator			"P_"	// Pass#define		kSecondImageReferralIndicator	"S_"	// Second Image#define		kUnclearReferralIndicator		"U_"	// Unclearconst int	kLengthOfReferralPrefix			= 2;enum EyeDxReferralCode { kYesReferralCode, kNoReferralCode, kSecondImageReferralCode, kUnclearReferralCode };enum EyeDxResultsCode { kNoErrors, kRetakeUp, kRetakeSide, kRetakeBoth };enum EyeDxNextStepCode { kNextStepContinue, kNextStepRetakeUp, kNextStepRetakeSide, kNextStepRetakeBoth, kNextStepDisplayReport };// These are the strings used for the names of various built-in variable names#define		kCEyeDxVariableBIRTHDATE				"BIRTH DATE"#define		kCEyeDxVariableAGE						"AGE"#define		kCEyeDxVariableUPIMAGE					"UP IMAGE NAME"#define		kCEyeDxVariableUPIMAGEFOCUS				"UP IMAGE FOCUS POSITION"#define		kCEyeDxVariableUPIMAGEDATE				"UP IMAGE DATE"#define		kCEyeDxVariableUPIMAGETIME				"UP IMAGE TIME"#define		kCEyeDxVariableSIDEIMAGE				"SIDE IMAGE NAME"#define		kCEyeDxVariableSIDEIMAGEFOCUS			"SIDE IMAGE FOCUS POSITION"#define		kCEyeDxVariableSIDEIMAGEDATE			"SIDE IMAGE DATE"#define		kCEyeDxVariableSIDEIMAGETIME			"SIDE IMAGE TIME"#define		kCEyeDxVariableRESULT					"RESULT"#define		kCEyeDxVariablePIMAGESPATH				"PIMAGES PATH"#define		kCEyeDxVariableREPORTNAME				"REPORT NAME"#define		kCEyeDxVariableONEYRPROMPT				"ONE YEAR PROMPT"#define		kCEyeDxVariableTODAYSDATE				"TODAYS DATE"#define		kCEyeDxVariableSUBJECTSTARTTIME			"SUBJECT START TIME"#define		kCEyeDxVariableSUBJECTENDTIME			"SUBJECT END TIME"#define		kCEyeDxVariableSUBJECTANALYSISSTARTTIME	"SUBJECT ANALYSIS START TIME"#define		kCEyeDxVariableSUBJECTANALYSISENDTIME	"SUBJECT ANALYSIS END TIME"#define		kCEyeDxVariableSUBJECTTOTALRETAKES		"SUBJECT TOTAL RETAKES"#define		kCEyeDxVariableSUBJECTSMEASURED			"SUBJECTS MEASURED"#define		kCEyeDxVariableAPPLICATIONVERSION		"APPLICATION VERSION"#define		kCEyeDxVariableSESSIONNAME				"SESSION NAME"#define		kCEyeDxVariableSESSIONSUBJECTCOUNT		"SESSION SUBJECT COUNT"#define		kCEyeDxVariableSESSIONPASSCOUNT			"SESSION PASS COUNT"#define		kCEyeDxVariableSESSIONREFERCOUNT		"SESSION REFER COUNT"#define		kCEyeDxVariableSESSIONRETAKECOUNT		"SESSION RETAKE COUNT"#define		kCEyeDxVariableSESSIONREREPORTLIST		"SESSION REPORT LIST"#define		kCEyeDxVariableSESSIONSTARTDATE			"SESSION START DATE"#define		kCEyeDxVariableSESSIONENDDATE			"SESSION END DATE"#define		kCEyeDxVariableSESSIONSTARTTIME			"SESSION START TIME"#define		kCEyeDxVariableSESSIONENDTIME			"SESSION END TIME"// This is the name of the default session#define		kDefaultSessionName						"NonSession"#ifdef macintosh#define		kStartSessionButtonLabel				"Start Session"#define		kEndSessionButtonLabel					"End Session"#else#define		kStartSessionButtonLabel				"&Start Session"#define		kEndSessionButtonLabel					"&End Session"#endif// These are the standard result strings used in the RESULT variable#define		kResultPass								"Pass"#define		kResultRefer							"Refer"#define		kResultRetake							"Retake"// The response strings for the ONEYRPROMPT prompt variable#define		kOneYrPromptNotAsked					"Not asked"#define		kOneYrPromptYes							"Yes"#define		kOneYrPromptNo							"No"#define		kOneYrPromptCalculatedOlder				"Calculated as 1 Year or Older"#define		kOneYrPromptCalculatedYounger			"Calculated as Younger than 1 Year"// This indicates whether the AGE variable was set#define		kAgeNotCalculated						-1#define		kAgeNotCalculatedString					"Not calculated"// Indicates that the Up or Side Focus Distance is not available (for JPEG, for example)#define		kCEyeDxVariableIMAGEFOCUSNotAvailable	"Not available"// Indicates that the associated date or time variable is not available. This usually occurs when a report references// an "end" type variable that is set only after the report is generated, or when JPEG images are used that don't// have date and timestamps.#define		kCEyeDxVariableDATENotAvailable			"Not available"#define		kCEyeDxVariableTIMENotAvailable			"Not available"// These values are output in the Session Summary Report#define		kSummaryReportSubjectsMeasuredNote			"Note: the Subjects Measured count may reflect more than one examination per subject."#define		kSummaryReportSubjectsMeasuredNoteAddendum	"Refer to the report list below for possible duplicate reports."#define		kSummaryReportNonDuplicateHeader			"Summary of subjects with one report:"#define		kSummaryReportDuplicateHeader				"Subjects with potentially more than one report:"							// These are constants for the preferences. Unfortunately they are a bit different for Mac and Windows#ifdef macintoshenum { kDisplayReport = 0, kDontDisplayReport = 1, kDisplaySummary = 2 };enum EyeDxReportFormat { kStandardReportFormat = 0, kCustomReportFormat1 = 1 };enum { kDontAdjustName = 0, kAdjustName = 1 };enum { kDontSaveImages = 0, kSaveImages = 1 };enum { kNoLetterHead = 0, kAllowLetterHead = 1 };enum { kNoSessions = 0, kUseSessions = 1 };enum { kNoAutoStart = 0, kAutoStart = 1 };#elseenum { kDontDisplayReport = FALSE, kDisplayReport = TRUE,  kDisplaySummary = 2 };enum EyeDxReportFormat { kStandardReportFormat = 0, kCustomReportFormat1 = 1 };enum { kDontAdjustName = FALSE, kAdjustName = TRUE };enum { kDontSaveImages = FALSE, kSaveImages = TRUE };enum { kNoLetterHead = FALSE, kAllowLetterHead = TRUE };enum { kNoSessions = FALSE, kUseSessions = TRUE };enum { kNoAutoStart = FALSE, kAutoStart = TRUE };#endif// This constant is somewhat arbitrary - it warns the user that the text they have entered// for the Format 1 const int kWarnAboutLongOptionalFmt1Text = 600;// Menu items for the Report Layout Dialog and to index the array of handles to these text blocksconst long		kReportLayoutNumText			= 7;const long		kReportLayoutHeaderText			= 0;	// Must add 1 to get a menu item index!const long		kReportLayoutIntroductionText	= 1;const long		kReportLayoutPassResultText		= 2;const long		kReportLayoutReferResultText	= 3;const long		kReportLayoutRetakeResultText	= 4;const long		kReportLayoutFooterText			= 5;const long		kReportLayoutSessionSummaryText	= 6;// This structure is used to pass back the various results values from the lower-level analysis routinesconst short kNumEyeImages = 8;const short kNumSImages = 2;// These are indicies for the specific items in the arrayconst short	kUpRightRawEye 		= 0;const short	kUpLeftRawEye 		= 1;const short	kSideRightRawEye 	= 2;const short	kSideLeftRawEye 	= 3;const short	kUpRightAnnotEye	= 4;const short	kUpLeftAnnotEye 	= 5;const short	kSideRightAnnotEye 	= 6;const short	kSideLeftAnnotEye 	= 7;const short	kUpSimage		 	= 0;const short	kSideSimage		 	= 1;const short kNumResultStrings 	= 4;const short kUpTopResult		= 0;const short kSideTopResult		= 1;const short kUpBottomResult		= 2;const short kSideBottomResult	= 3;// These are organized as follows: left to right in the report (up-right-raw, up-left-raw, side-right-raw,// side-left-raw), followed by the equivalent annotated images. The eye path strings will be empty if the eye// image was not created, and the annot strings will have an explanation.typedef struct AnalysisResultsStruct{	char					ReportName[MAX_FILENAME_CHARS];	char					Report_path[MAX_FILENAME_CHARS];	char					UpName[MAX_FILENAME_CHARS];	char					SideName[MAX_FILENAME_CHARS];		char					LastTwoCharsUpName[3];	char					LastTwoCharsSideName[3];		short					SideOrientation;	enum EyeDxReferralCode	ReferralCode;	char					*ReferralIndicator;	enum EyeDxResultsCode	ResultsCode;	char					Simage_path[kNumSImages][MAX_FILENAME_CHARS];	char					eye_image_path[kNumEyeImages][MAX_FILENAME_CHARS];	short					UpAnnotate;	short					SideAnnotate;	char					eye_image_annot[kNumResultStrings][MAX_FILENAME_CHARS];	struct 	resultsStruct 	upResults;	struct 	resultsStruct 	sideResults;} AnalysisResults;			// Functions for displaying imagesvoid FlashCircles(unsigned char *,int,int,double *,double *, CEyeDxViewType *);void ZoomDisplay(unsigned char *, int ,int , int , int , int ,int , int , CEyeDxViewType *);		// kodak camera-related stuff		#ifndef macintoshextern DCBitRate CameraConnectionRate;#endifint OpenCameraDriver(DCStatus 			*GenericStatus,					 DC120Status 		*FullDC120Status,					 CEyeDxWindowType 	*theWindow,					 CEyeDxCaptionType 	*theStatusCaption,					 DCPortNum 			*defaultPortNum,					 DCBitRate 			theConnectionRate,					 CEyeDxBooleanType	chooseMemoryForTakingPictures = false);					 int SetCameraConfiguration(CEyeDxWindowType *theWindow,					 	  CEyeDxCaptionType *theStatusCaption);int DeletePicture(CEyeDxWindowType 		*theWindow,				  CEyeDxCaptionType 	*theStatusCaption,				  DCPictInfo 			*theGenericPictInfo);int CheckCameraStatus(CEyeDxWindowType 		*theWindow,					  short					picturesNeeded,					  short					*picturesRemaining,					  CEyeDxCaptionType 	*theStatusCaption,					  DC120BatteryStatus	*theBatteryLevel,					  CEyeDxBooleanType		*theFlashStatus);int TakePicture(int						Location,				CEyeDxWindowType 		*theWindow,				CEyeDxCaptionType 		*theStatusCaption,				CEyeDxCaptionType 		*theFilenameCaption,				CEyeDxViewType 			*theView, 				DCPictInfo				*theGenericPictInfo,				DC120PictInfo 			*thePictInfo);				int ConnectToCamera(CEyeDxWindowType 	*,					CEyeDxCaptionType 	*, 					CEyeDxCaptionType 	*, 					CEyeDxViewType 		*, 					CEyeDxCaptionType 	*, 					CEyeDxViewType 		*, 					CEyeDxCaptionType 	*,					DCPictInfo 			*theUpGenericPictInfo, 					DCPictInfo 			*theSideGenericPictInfo,					DC120PictInfo 		*theUpPictInfo, 					DC120PictInfo 		*theSidePictInfo,					DCPortNum 			*defaultPortNum, 					DCBitRate 			theConnectionRate);void GetIconFromCamera(int, 					   int, 					   DCPictInfo 					*theGenericPictInfo, 					   DC120PictInfo				*thePictInfo,					   CEyeDxWindowType				*theWindow,					   CEyeDxViewType 				*theView, 					   CEyeDxCaptionType 			*theFilenameCaption);int DownloadImageFromCamera(int, CEyeDxHandleType *,int *,int *,char *, 							CEyeDxVariable			*theSessionNameVariable,							CEyeDxVariable			*theFilenameVariable,							CEyeDxWindowType		*theWindow,							CEyeDxProgressType 		*theThermometer, 							CEyeDxCaptionType 		*theProgressCaption,							CEyeDxBooleanType		theSaveFullImagesFlag,							DC120OutputWidth		optionalWidth = DC120OutputW1280);int ReadIconFromFile(		FILE					*fp,							unsigned char			**thumb_image,							int						*ROWS,							int						*COLS,							DCPictInfo 				*theGenericPictInfo, 							DC120PictInfo			*thePictInfo,	// Returns the detailed information about the picture							CEyeDxWindowType		*theWindow,							CEyeDxBooleanType		disp_notice = TRUE);int ReadImageFromFile(		FILE					*fp,							CEyeDxHandleType		*new_image,							int						*NEW_ROWS,							int						*NEW_COLS,							char					*new_filename,							CEyeDxVariable			*theSessionNameVariable,							CEyeDxVariable			*theFilenameVariable,							CEyeDxBooleanType		copyToPimages,							OSType					outputCreator,							OSType					outputType,							DCPictInfo 				*theGenericPictInfo, 							DC120PictInfo			*thePictInfo,							CEyeDxBooleanType		*thePictInfoIsValid,							CEyeDxWindowType		*theWindow,							CEyeDxProgressType		*theThermometer,							CEyeDxCaptionType		*theProgressCaption,							CEyeDxCaptionType		*theFilenameCaption);void CloseCamera(CEyeDxWindowType *theWindow);// These define bit values for the results of the CheckPictInfo call. Note that the// camera tends to misjudge the distance as beeing shorter than it is, so we skew the range// downward.const long			kMaxFocusRange		= 1300;const long			kMinFocusRange		= 900;const unsigned long kNotBestQuality 	= 0x00000001;const unsigned long kNoFlash 			= 0x00000002;const unsigned long kSubjectTooClose 	= 0x00000004;const unsigned long kSubjectTooFar	 	= 0x00000008;const unsigned long kNotZoomed		 	= 0x00000010;const unsigned long kBadFocusMode	 	= 0x00000020;const unsigned long kBadOrientation	 	= 0x00000040;unsigned long CheckPictInfo(DC120PictInfo *thePictInfo);		// loading and saving imagesvoid StripFilename(char *,char *, CEyeDxBooleanType StripExtension = TRUE);int GetJPEGImageInfo(FILE *, int *DEPTH, int *ROWS, int *COLS);int ReadImage(FILE *, CEyeDxHandleType *,int *,int *, char *, 			CEyeDxWindowType *, CEyeDxProgressType *, CEyeDxCaptionType *,			CEyeDxBooleanType allowAnySize = TRUE);int CreateJPEGThumbnail(FILE 			*fpt,					/* complete name of image to read */			 	unsigned char		 	**rawdata,				/* image data allocated in temporary memory, returned */			 	int						*ROWS,			 	int 					*COLS);int SaveImage(char *,unsigned char	*,int,int,float, CEyeDxWindowType *, CEyeDxProgressType *, CEyeDxCaptionType *);int WriteImage(char *, char *, char *, unsigned char *,int,int, double *,int *,int,int *,int,int,					double *,int *,int,int *,int,int,int,int,int,int, float, CEyeDxWindowType *, CEyeDxProgressType *, CEyeDxCaptionType *);void ReportOutput(CEyeDxWindowType		*theWindow,					AnalysisResults		*theAnalysisResults,					EyeDxReportFormat	theReportFormat,					CEyeDxVariableList	*theVariableList,					char				**theOptionalReportText,					long				*theOptionalReportTextSize,					long				theNumOptionalReportText);void DatabaseOutput(CEyeDxWindowType	*theWindow,					char				*theDatabaseFileName,					CEyeDxVariableList	*theVariableList);		// Functions for analyzing given image(s)void EyeDx(char *,char *,int,int, CEyeDxBooleanType, AnalysisResults *, CEyeDxWindowType *, CEyeDxViewType *, 				CEyeDxProgressType *, CEyeDxCaptionType *,				EyeDxReportFormat	theReportFormat,				CEyeDxVariableList	*theVariableList,				char				**theOptionalReportText,				long				*theOptionalReportTextSize,				long				theNumOptionalReportText);int ProcessImage(char					*filename,			/* input filename */				int						OrientationFlag,	/* input:	0 => up, 1 => left, 2 => right */				char					*report_name,				char					*session_name,				resultsStruct			*resultsData,				int						,					/* input:	write out full-size images? */				int						,					/* input:	write out raw zoomed eyes? */				long					FocusPosition,		// Used to detect pupil size				EyeDxReportFormat		theReportFormat,	// Used to determine how to scale the images				CEyeDxWindowType		*theWindow,			// Object to display error messages				CEyeDxViewType			*theViewObject,		// The view object to draw into			 	CEyeDxProgressType		*theThermometer,	/* Control object that displays progress */				CEyeDxCaptionType		*theCaption);void ClassifyPupilInterior(unsigned char *,unsigned char *,unsigned char *,int,int,						   double *,int,int *,int *,int *,int *,int *,int *,int *,int *, CEyeDxViewType *);void FindCircles(unsigned char *,int,int,unsigned char *,int *,int,double **,double *,				 double *,double *,double **,double *,double *,double *,double *, CEyeDxProgressType *, CEyeDxViewType *);int FindBrightSpots(unsigned char *,int,int,unsigned char *,int *,int *, CEyeDxProgressType *);#ifdef __cplusplusextern "C" {#endifvoid DontUseIsolatedPoints(int *,int,int *,int *,int);void ComputeCircleFitStatistics(double *,int *,int,int *,int,int *,int,int,								double *,double *,double *);void FitSubArcCircle(int *,int,int *,int *,int *,double *,int,int);int RegionFill(unsigned char *,int,int,int,int,int,int);void ClassifyPupilAlignment(double *,int *,int,double *,int *,int,int,int,int *);void ImageToWorldCoords(double u,double v,double *camera_calib,						double *x,double *y);void Fit_Circle_To_Points(int,int *,int *,double *);int BestTwoCircles(int *,int,int,double **,double *,double *,double *,double **,double *,				   double *,double *,double *,int *,int *);void MakeCircleIndices(double,double,double,int,int,int *,int *);void MakeLineIndices(int,int,int,int,int,int,int *,int *);#ifdef __cplusplus}#endifextern long DebugFeatures;extern long AdvancedFeatures;extern char *PictNamePtr;extern int	NumOfPicts,LastNumOfPicts, UpPictNum, SidePictNum;const long		kPrefixLength		= 2;#ifdef macintosh// Definitions of come global constantsconst OSType	kKodakPictureTransferCreator= 'Kpta';const OSType	kKDCType					= 'KDC ';// File type codes we are interested inconst OSType	kJPEGType					= 'JPEG';const OSType	kPICTType					= 'PICT';const OSType	kSoundFileType				= 'sfil';const OSType	kEyeDxPrefsType				= 'pref';const OSType	kTeachTextType				= 'TEXT';// Application creator codes we are interested inconst OSType	kEyeDxCreator				= 'EyDx';const OSType	kNetscapeCreator			= 'MOSS';const OSType	kExplorerCreator			= 'MSIE';const OSType	kTeachTextCreator			= 'ttxt';// Utility routine to copy C strings to Pascal strings and to open files#ifdef __cplusplusvoid c2pstrcpy(Str255 dst, const char *src);// The maximum file name length for the report file (31 characters - the length of "nnScc.jpg")// We also enforce a minimum length, chosen to be 3 since subject initials are often used for// report names. This minimum helps us detect reruns of the same subject in the session summary// report, which is based upon report names.const long		kMinReportNameLength		= 3;const long		kMaxReportNameLength		= 22;// The maximum session folder name length is the Mac file name length, and we also enforce a minimum// for no specific reason :^)const long		kMinSessionNameLength		= 2;const long		kMaxSessionNameLength		= 31;extern "C" {OSErr OpenSpecifiedDocument(const FSSpec * documentFSSpecPtr, OSType openWith = kUnknownType);OSErr LaunchApplicationWithDocument(const FSSpec * applicationFSSpecPtr,	const FSSpec * documentFSSpecPtr);OSErr SendOpenDocumentEventToProcess(ProcessSerialNumber *targetPSN,	const FSSpec * documentFSSpecPtr);OSErr FindApplicationFromDocument(const FSSpec * documentFSSpecPtr,	FSSpecPtr applicationFSSpecPtr, OSType openWith = kUnknownType);}const short kMaxPortNum = DCPortNum2;const long kPlatformSecondsToDelayValue			= 60; // System Ticks on Mac (1/60th of second)#endif // __cplusplus#else	// windows// The maximum file name length for the report file (make it the same as on the Mac to allow// interchange between platforms)// We also enforce a minimum length, chosen to be 3 since subject initials are often used for// report names. This minimum helps us detect reruns of the same subject in the session summary// report, which is based upon report names.const long		kMinReportNameLength			= 3;const long		kMaxReportNameLength			= 22;// The maximum session folder name length is the Mac file name lengthconst long		kMinSessionNameLength			= 2;const long		kMaxSessionNameLength			= 31;// Definitions of some global constants - dummies in Windowsconst OSType	kKodakPictureTransferCreator	= 0;const OSType	kKDCType						= 0;// File type codes we are interested inconst OSType	kJPEGType						= 0;const OSType	kEyeDxPrefsType					= 0;const OSType	kUnknownType					= 0;const short kMaxPortNum = DCPortNum4;const long kPlatformSecondsToDelayValue			= 1000; // ms under Windows#endif	// windowsinline long CalculateDelay(long seconds){	return (seconds * kPlatformSecondsToDelayValue);}const long kTriesToCheckFlash = 5;const long kFlashRechargeTimeoutInSecs = 2;	// 2 secondsconst long kFlashRechargeTimeout = CalculateDelay(kFlashRechargeTimeoutInSecs);	// 2 seconds in ms// Some constants used in the license schemeenum LicenseStatus { LicenseStatusNotInstalled, 					 LicenseStatusExpiredDate, 					 LicenseStatusExpiredCount, 					 LicenseStatusExpiredBoth, 					 LicenseStatusDateOutOfRange,					 LicenseStatusValid };					 enum LicenseError { kLicenseNoError, kLicenseErrorNoLicense, kLicenseReuseError, kLicenseExpiredError, kLicenseNewOlderThanInstalledError };					 #define kDefaultDatabaseReportName	"DBExport.DAT"#define kDefaultSessionSummaryName	"SessionSummary.TXT"// These are common routines that manage variables at different points during processingvoid SavePictureInformation(CEyeDxVariableList *theVariableList, 						CEyeDxBooleanType theUpPictInfoValid, DCPictInfo &UpGenericPictInfo, DC120PictInfo &UpPictInfo, 						CEyeDxBooleanType theSidePictInfoValid, DCPictInfo &SideGenericPictInfo, DC120PictInfo &SidePictInfo);void HandleStartOfSubject(CEyeDxVariableList *theVariableList);int HandleAgeCalculation(CEyeDxVariableList *theVariableList);void HandleEndOfSubject(CEyeDxVariableList *theVariableList, CEyeDxWindowType *theWindow, CEyeDxLongStringType *theDatabaseFileName);CEyeDxMessageType HandlePromptForVariables(CEyeDxWindowType *theWindow, 										CEyeDxVariableList *theVariableList, 										short thePromptingStyle,										CEyeDxVariable::PromptType thePromptType);CEyeDxMessageType DoPromptForVariable(CEyeDxWindowType *theWindow, 										CEyeDxVariableList *theVariableList,										CEyeDxVariable::PromptType thePromptType, 										short thePromptOrder, 										CEyeDxBooleanType allowGoBack, 										CEyeDxBooleanType reloadValue);										CEyeDxMessageType DoPromptForOutOfMemory(CEyeDxWindowType *theWindow, 										long theAmountNeeded,										CEyeDxLongStringType *hintString);CEyeDxMessageType DoCheckForMemory(CEyeDxWindowType *theWindow, 										CEyeDxBooleanType animationEnabled,										short upRows,										short upCols,										short num3ByteDeepImages,										short num1ByteDeepImages,										CEyeDxLongStringType *hintString);										CEyeDxMessageType HandleNewSession(CEyeDxWindowType *theWindow, 						 CEyeDxVariableList *theVariableList,						 CEyeDxButtonType *theMainWindowButton,						 CEyeDxCaptionType *theMainWindowCaption,						 short thePromptingStyle);CEyeDxMessageType HandleStartOfSession(CEyeDxWindowType *theWindow, 						 CEyeDxVariableList *theVariableList,						 CEyeDxButtonType *theMainWindowButton,						 CEyeDxCaptionType *theMainWindowCaption,						 CEyeDxLongStringType *theSessionName,						 short thePromptingStyle);						 CEyeDxMessageType HandleEndOfSession(CEyeDxWindowType *theWindow, 						 CEyeDxVariableList *theVariableList,						 CEyeDxButtonType *theMainWindowButton,						 CEyeDxCaptionType *theMainWindowCaption,						 CEyeDxVariable *theSessionVariable,						 const char *theSessionSummaryText,						 long theSummaryReportTextSize,						 short thePromptingStyle,						 CEyeDxBooleanType autoSelectDefault = false);CEyeDxBooleanType CheckSessionValidity(CEyeDxWindowType *theWindow, 										CEyeDxLongStringType *theSessionNameString);	CEyeDxBooleanType CheckReportValidity(CEyeDxWindowType *theWindow, 							CEyeDxLongStringType *theReportNameString, 							CEyeDxVariable *theSessionNameVariable, 							CEyeDxBooleanType adjustName);void UpdateSessionButtonAndCaption(CEyeDxBooleanType useSessions, 								   CEyeDxVariable *theSessionNameVariable, 								   CEyeDxButtonType *theSessionButton, 								   CEyeDxCaptionType *theSessionCaption);CTemplateShortStrArray *GetReportList(CEyeDxLongStringType *theSessionName);short *GetReportDuplicateList(CTemplateShortStrArray *theReportList, 								CEyeDxBooleanType *duplicatesFound);void SessionSummaryOutput(CEyeDxWindowType		*theWindow,							CEyeDxVariableList	*theVariableList,							const char			*theSummaryReportText,							long				theSummaryReportTextSize);#ifndef macintoshvoid OpenTextFile(const char *filepath);void OpenReport(const char *reportname);#elseOSErr OpenFile(FSSpec *theFileSpec);#endif;// This is the password string that must be entered when trying to enable the advanced features mode.// Actually, it's this string with the current day number (1..31) appended.#define	kPasswordString	"opacity"