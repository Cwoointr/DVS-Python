	/*******************************************************************	** Some routines which deal with files (reading, writing, etc.)	*******************************************************************/#include <stdio.h>#include <string.h>#include "globals.h"#ifndef macintosh#define HAVE_BOOLEAN#include <windows.h>#include "resource.h"#include <unistd.h>extern "C"{#include "jpeglib.h"}#else#include <stdlib.h>#include <unistd.h>extern "C"{#include "jpeglib.h"}#include "EyeDxMacConstants.h"#include <path2fss.h>#include "memlogger.h"#endifextern long AdvancedFeatures;	/*******************************************************************	** Takes in a complete filename (may include paths, prefix, and any	** number of suffixes) and returns the stripped prefix (without any	** paths or suffixes attached).	*******************************************************************/void StripFilename(char *input,char *stripped, CEyeDxBooleanType StripExtension){	int		c; 	c=strlen(input)-1;	while (c >= 0  &&  input[c] != PATHSEPARATOR) 		 c--;	if (c >= 0)  		strcpy(stripped,&(input[c+1]));	else  		strcpy(stripped,input);	if (StripExtension)	{		c=0;		while (c < (int)strlen(stripped)  &&  stripped[c] != '.')  			c++;		if (c < (int)strlen(stripped))	  		stripped[c]='\0';	}}	/*******************************************************************	** Read a photo-screening image from a file.  Returns EYEDX_ERR_NO_ERROR after a	** successful read, a specific error otherwise.	*******************************************************************/int ReadImage(FILE 						*fpt,					/* complete name of image to read */			 	CEyeDxHandleType 	*rawdata,				/* image data allocated in temporary memory, returned */			 	int						*ROWS,			 	int						*COLS,					/* size of image, returned */			 	char					*filename,			 	CEyeDxWindowType		*theWindow,			 	CEyeDxProgressType 	*theThermometerPane,	/* Control object that displays progress */			 	CEyeDxCaptionType 		*theCaption,			/* Indiates status */			 	CEyeDxBooleanType					allowAnySize){	long								i,r;	char							text[30];	struct jpeg_decompress_struct	cinfo;	struct jpeg_error_mgr			jerr;	JSAMPARRAY						buffer;    unsigned char 					*raw;				/* see if in jpeg format */	text[0]=getc(fpt); text[1]=getc(fpt);	if (text[0] == -1  &&  text[1] == -40)  	{		/* is in jpeg format -- start over and read in */  		fseek(fpt, 0L, SEEK_SET);  		cinfo.err = jpeg_std_error(&jerr);  		  		size_t size = sizeof(struct jpeg_decompress_struct);  		jpeg_create_decompress(&cinfo);  		jpeg_stdio_src(&cinfo, fpt); 		jpeg_read_header(&cinfo, TRUE);  		jpeg_start_decompress(&cinfo);  		*COLS=cinfo.output_width;  		*ROWS=cinfo.output_height;		if (!allowAnySize)		{#ifndef macintosh	  		if ((*ROWS != 960  ||  *COLS != 1280)  &&  strcmp(filename,"EyeDxBg.jpg") != 0)	    		if (theWindow->MessageBox("This image is not the expected size. Load anyway?", AfxGetAppName(), MB_OKCANCEL) == IDCANCEL)				{		  			(*ROWS)=(*COLS)=0;		  			return(0);		  		}#else	  		if ((*ROWS != 960  ||  *COLS != 1280))		  	{				::ParamText("\pThis image is not the expected size. Load anyway?", Str_Empty, Str_Empty, Str_Empty);				DialogItemIndex item_hit = UModalAlerts::CautionAlert(PPob_OKCancelALRT);				if (item_hit == PPob_OKCancelALRT_Cancel)				{		  			(*ROWS)=(*COLS)=0;		  			return(0);		  		}			}#endif		}				  		if (cinfo.output_components != 3)    	{    		StopAlert(theWindow, CommonStringLiteral_("File is not RGB jpeg format"));			*rawdata=NULL;			(*ROWS)=(*COLS)=0;			return(0);    	}    	  		long calloc_size = (((long)*ROWS)*((long)*COLS)*3L);		CEyeDxBooleanType error = FALSE;		#ifndef macintosh		if ((*rawdata = (unsigned char *)calloc(calloc_size, 1)) == NULL)			error = TRUE;    			// Now, point our local pointer to the data that's been allocated    	raw = (unsigned char *) *rawdata;#else		OSErr theErr;		*rawdata = ::TempNewHandle(calloc_size, &theErr);		if (theErr != noErr || *rawdata == NULL)			error = TRUE;		else		{    	    		// Lock the handle so we can dereference it and simulate the raw pointer that's used in     		// the PC version    		HLock(*rawdata);			// Now, point our local pointer to the data that's been allocated    		raw = (unsigned char *) **rawdata;    	}#endif		if (error)		{			StopAlert(theWindow, CommonStringLiteral_("ReadImage(): Unable to allocate memory."));			*rawdata=NULL;			(*ROWS)=(*COLS)=0;			return(0);		}		r=0;		buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, (*COLS)*3, 1);		long tenPercentOfRange = *ROWS / 10;		char LoadText[MAX_PATHNAME_CHARS];		char ShortFilename[MAX_PATHNAME_CHARS];				if (filename)		{			StripFilename(filename, ShortFilename, FALSE);			sprintf(LoadText,"Loading %s",ShortFilename);		}		else			strcpy(LoadText, "No filename");#ifdef macintosh		c2pstr(LoadText);#endif		// Display the progress bar, and set its minimum and maximum values to 0 and rows				// Note that sometimes we use this routine to load small images and we don't use		// a caption or progress bar.				if (theThermometerPane && theCaption)		{			SetThermometerValues(theThermometerPane, 0L, *ROWS, 0L);			SetCaptionText(theCaption, LoadText);		}				unsigned char *p = raw;				while (r < *ROWS)		{   			jpeg_read_scanlines(&cinfo, buffer, 1);   				for (i=0; i<(*COLS)*3; i++)      				*p++ = (unsigned char)buffer[0][i];    		r++;  			if (r%tenPercentOfRange == 0)  			{				if (theThermometerPane)					SetThermometerValue(theThermometerPane, r);				GiveOSTime();			}   		}		if (theThermometerPane && theCaption)			SetCaptionText(theCaption, EMPTYSTR);  		jpeg_finish_decompress(&cinfo);  		jpeg_destroy_decompress(&cinfo);  				// Unlock the handle				HUnlock(*rawdata);		  		fclose(fpt);  		return(1);  	}  		text[2]=getc(fpt); text[2]='\0';	if (strcmp(text,"P6") == 0)  	{		long BYTES;		  		(*ROWS)=(*COLS)=BYTES=-1;  		while (BYTES == -1)    	{    		fscanf(fpt,"%s",text);    		if (text[0] == '#') /* comment -- ignore */      		{      			while ((text[0]=fgetc(fpt)) != '\n')      				;      			continue;      		}    		if ((*COLS) == -1)	    	  	(*COLS)=atoi(text);    		else if ((*ROWS) == -1)      			(*ROWS)=atoi(text);    		else      			BYTES=atoi(text);    	}    		if (BYTES != 255)    	{			StopAlert(theWindow, CommonStringLiteral_("File is not 8-bit ppm format"));			(*ROWS)=(*COLS)=0;			return(0);    	}  		long calloc_size = (((long)*ROWS)*((long)*COLS)*3L);		CEyeDxBooleanType error = FALSE;#ifndef macintosh		if ((*rawdata = (unsigned char *)calloc(calloc_size, 1)) == NULL)			error = TRUE;    			// Now, point our local pointer to the data that's been allocated    	raw = (unsigned char *) *rawdata;#else		OSErr theErr;		*rawdata = ::TempNewHandle(calloc_size, &theErr);		if (theErr != noErr || *rawdata == NULL)			error = TRUE;		else		{    	    		// Lock the handle so we can dereference it and simulate the raw pointer that's used in     		// the PC version    		HLock(*rawdata);			// Now, point our local pointer to the data that's been allocated    		raw = (unsigned char *) **rawdata;    	}#endif		if (error)		{    		StopAlert(theWindow, CommonStringLiteral_("Unable to allocate memory (raw)"));			(*ROWS)=(*COLS)=0;			return(0);    	}  		text[0]=getc(fpt);  		fread(raw, 1L, (unsigned long)calloc_size, fpt);  		fclose(fpt);  		return (1);	}	fclose(fpt);	StopAlert(theWindow, CommonStringLiteral_("Unknown image format"));		return(0);}int GetJPEGImageInfo(FILE *fpt, int *DEPTH, int *ROWS, int *COLS){	char							text[30];	struct jpeg_decompress_struct	cinfo;	struct jpeg_error_mgr			jerr;			/* see if in jpeg format */	text[0]=getc(fpt); text[1]=getc(fpt);	if (text[0] == -1  &&  text[1] == -40)  	{		/* is in jpeg format -- start over and read in */  		fseek(fpt, 0L, SEEK_SET);  		cinfo.err = jpeg_std_error(&jerr);  		  		jpeg_create_decompress(&cinfo);  		  		jpeg_stdio_src(&cinfo, fpt); 		jpeg_read_header(&cinfo, TRUE); 		  		*COLS=cinfo.output_width;  		*ROWS=cinfo.output_height;  		  		*DEPTH = cinfo.output_components;  		jpeg_destroy_decompress(&cinfo);  		  		fclose(fpt);  		return(1);  	}	fclose(fpt);	return(0);}// This routine does not display any notices, as it can be called by the preview routines in// dialogs. Displaying a notice might case an infinite loop do to redrawing events.int CreateJPEGThumbnail(FILE 			*fpt,					/* complete name of image to read */			 	unsigned char		 	**rawdata,				/* image data allocated in temporary memory, returned */			 	int						*ROWS,			 	int 					*COLS){	long							i,r;	char							text[30];	struct jpeg_decompress_struct	cinfo;	struct jpeg_error_mgr			jerr;	JSAMPARRAY						buffer;    unsigned char 					*raw;			/* see if in jpeg format */	text[0]=getc(fpt); text[1]=getc(fpt);	if (text[0] == -1  &&  text[1] == -40)  	{		/* is in jpeg format -- start over and read in */  		fseek(fpt, 0L, SEEK_SET);  		cinfo.err = jpeg_std_error(&jerr);  		  		// We set the maximum desampling size allowed by the library, so that we  		// minimize the amount of memory we allocate for the input image. For the  		// current images, we actually need to scale by 1/16, but the library allows  		// only up to 1/8. We take what we can get.  		  		size_t size = sizeof(struct jpeg_decompress_struct);  		jpeg_create_decompress(&cinfo);  		  		jpeg_stdio_src(&cinfo, fpt); 		jpeg_read_header(&cinfo, TRUE); 		  		cinfo.scale_num = 1;  		cinfo.scale_denom = JPEG_THUMB_SCALE;		cinfo.do_fancy_upsampling = FALSE;		 		jpeg_calc_output_dimensions(&cinfo);	// Force recalculation of the output image size  		jpeg_start_decompress(&cinfo);  		*COLS=cinfo.output_width;  		*ROWS=cinfo.output_height;  		  		if (cinfo.output_components != 3)    	{			*rawdata=NULL;			(*ROWS)=(*COLS)=0;			return(0);    	}    	  		long calloc_size = (((long)*ROWS)*((long)*COLS)*3L);		CEyeDxBooleanType error = FALSE;				if ((*rawdata = (unsigned char *)calloc(calloc_size, 1)) == NULL)		{			*rawdata=NULL;			(*ROWS)=(*COLS)=0;			return(0);		}    			// Now, point our local pointer to the data that's been allocated    	raw = (unsigned char *) *rawdata;		r=0;		buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) &cinfo, JPOOL_IMAGE, (*COLS)*3, 1);		unsigned char *p = raw;				while (r < *ROWS)		{   			jpeg_read_scanlines(&cinfo, buffer, 1);   				for (i=0; i<(*COLS)*3; i++)      				*p++ = (unsigned char)buffer[0][i];    		r++;   		}  		jpeg_finish_decompress(&cinfo);  		jpeg_destroy_decompress(&cinfo);  		  		fclose(fpt);  		return(1);  	}	fclose(fpt);	return(0);}	/*******************************************************************	** Write an annotated image to a file.  Returns EYEDX_ERR_NO_ERROR after a	** successful write, a specific error otherwise.	*******************************************************************/int WriteImage(char				*pathname,					/* file opened for writing */				char			*reportname,				char			*lastTwoDigits,				unsigned char	*raw,		/* original image data */											/* bytes are ordered bgr0,bgr1,bgr2,... */				int				ROWS,int COLS,	/* size of image */				double			*left_circles,		/* 2 concentric circles */				int				*left_corneal_reflex_indices,	/* image indices of CR */				int				left_CR_size,			/* count of CR indices */				int				*left_abnormal_red_reflex_indices, /* image indices of ARR */				int				left_ARR_size,			/* count of ARR indices */				int				left_ARR_class,			/* color to code blob */				double			*right_circles,		/* 2 concentric circles */				int				*right_corneal_reflex_indices,	/* image indices of CR */				int				right_CR_size,			/* count of CR indices */				int				*right_abnormal_red_reflex_indices, /* image indices of ARR */				int				right_ARR_size,			/* count of ARR indices */				int				right_ARR_class,		/* color to code blob */				int				OrientationFlag,	/* 0=>up, 1=>left, 2=>right */				int				FullImageFlag,	/* 0 => don't write, 1 => do write */												/* 2 => anonymize (grey all but eyes) */				int				RawEyesFlag,	/* 0 => don't write, 1 => do write */				int				EyesFlag,		/* 0 => don't write, 1 => do write */				float			eyeScale,			// How big the eye images are 1:1 == 128 pixels			 	CEyeDxWindowType	*theWindow,			 	CEyeDxProgressType *theThermometerPane,	/* Control object that displays progress */			 	CEyeDxCaptionType *theCaption)		/* Indiates status */{	FILE *fpt;	char						outfile[MAX_PATHNAME_CHARS], SaveText[MAX_PATHNAME_CHARS];	int							*circle_points,total_points;	int							r,c,e,i,r2,c2,x,y,EYE_ROWS,EYE_COLS,index;	unsigned char				*eye_image,*annotated;	struct jpeg_compress_struct	cinfo;	struct jpeg_error_mgr		jerr;	JSAMPROW					row_pointer[1];	CEyeDxBooleanType error = FALSE;		char *orientationChar;		switch (OrientationFlag)	{	case 0:		orientationChar = "U";		break;			case 1:		orientationChar = "S";		break;			case 2:		orientationChar = "S";		break;      				}      			/* annotate image with model */#ifndef macintosh	if ((annotated=(unsigned char *)calloc((long)ROWS*(long)COLS*3,1)) == NULL)		error = TRUE;#else		OSErr theErr;	Handle annotHandle = ::TempNewHandle((long)ROWS*(long)COLS*3, &theErr);	if (theErr != noErr || annotHandle == NULL)		error = TRUE;	else	{			// Lock the handle so we can dereference it and simulate the raw pointer that's used in 		// the PC version		HLock(annotHandle);		annotated = (unsigned char *) *annotHandle;	}#endif	if (error)	{		StopAlert(theWindow, CommonStringLiteral_("WriteImage(): Unable to allocate memory."));		return(0);	}	for (i=0; i<ROWS*COLS*3; i++)  		annotated[i]=raw[i];	circle_points=(int *)calloc((long)((double)MaxIrisRad*8.0),sizeof(int));			for (e=0; e<2; e++)  	{  		if (e == 0  &&  left_circles[2] > 0.0)    		MakeCircleIndices(left_circles[0],left_circles[1],							  left_circles[2],ROWS,COLS,circle_points,&total_points);  		else if (e == 1  &&  right_circles[2] > 0.0)    		MakeCircleIndices(right_circles[0],right_circles[1],							  right_circles[2],ROWS,COLS,circle_points,&total_points);  		else    		total_points=0;  		for (i=0; i<total_points; i++)    	{				/* green */    		annotated[circle_points[i]*3+0]=0;    		annotated[circle_points[i]*3+1]=255;    		annotated[circle_points[i]*3+2]=0;		}  		if (e == 0  &&  left_circles[3] > 0.0)    		MakeCircleIndices(left_circles[0],left_circles[1],							  left_circles[3],ROWS,COLS,circle_points,&total_points);  		else if (e == 1  &&  right_circles[3] > 0.0)    		MakeCircleIndices(right_circles[0],right_circles[1],							  right_circles[3],ROWS,COLS,circle_points,&total_points);  		else    		total_points=0;  		for (i=0; i<total_points; i++)   		{				/* yellow */    		annotated[circle_points[i]*3+0]=255;    		annotated[circle_points[i]*3+1]=255;    		annotated[circle_points[i]*3+2]=0;    	}  	}	free(circle_points);		if (RawEyesFlag  ||  EyesFlag || FullImageFlag)	{		if (AdvancedFeatures)		{			for (i=0; i<left_CR_size; i++)		  	{		  		annotated[left_corneal_reflex_indices[i]*3+0]=0;		  		annotated[left_corneal_reflex_indices[i]*3+1]=0;		  		annotated[left_corneal_reflex_indices[i]*3+2]=255;		  	}			for (i=0; i<right_CR_size; i++)		  	{		  		annotated[right_corneal_reflex_indices[i]*3+0]=0;		  		annotated[right_corneal_reflex_indices[i]*3+1]=0;		  		annotated[right_corneal_reflex_indices[i]*3+2]=255;		  	}			for (i=0; i<left_ARR_size; i++)		  	{		  		annotated[left_abnormal_red_reflex_indices[i]*3+2]=255;		  		if (left_ARR_class == CRESCENT)		    	{		    		annotated[left_abnormal_red_reflex_indices[i]*3+1]=255;		    		annotated[left_abnormal_red_reflex_indices[i]*3+0]=0;		    	}		  		else		    	{		    		annotated[left_abnormal_red_reflex_indices[i]*3+1]=175;		    		annotated[left_abnormal_red_reflex_indices[i]*3+0]=175;		    	}		  	}			for (i=0; i<right_ARR_size; i++)		  	{		  		annotated[right_abnormal_red_reflex_indices[i]*3+2]=255;		  		if (right_ARR_class == CRESCENT)		    	{		    		annotated[right_abnormal_red_reflex_indices[i]*3+1]=255;		    		annotated[right_abnormal_red_reflex_indices[i]*3+0]=0;		    	}		  		else		    	{		    		annotated[right_abnormal_red_reflex_indices[i]*3+1]=175;		    		annotated[right_abnormal_red_reflex_indices[i]*3+0]=175;		    	}	  		}  		}  	}			/* save raw (unmarked) and annotated eye images */	if (RawEyesFlag  ||  EyesFlag)  	{  		EYE_ROWS=EYE_COLS=128;  		  		error = FALSE;  		#ifndef macintosh 		eye_image=(unsigned char *)calloc(EYE_ROWS*EYE_COLS*3,1); 		if (eye_image == NULL)			error = TRUE;#else		OSErr theErr;		Handle eyeHandle = ::TempNewHandle(EYE_ROWS*EYE_COLS*3, &theErr);		if (theErr != noErr || eyeHandle == NULL)		{			error = TRUE;    	}    	else    	{	    	// Lock the handle so we can dereference it and simulate the raw pointer that's used in 	    	// the PC version	    	HLock(eyeHandle);	    	eye_image = (unsigned char *) *eyeHandle;    	}#endif		if (error)		{			StopAlert(theWindow, CommonStringLiteral_("WriteImage(): Unable to allocate memory."));			ROWS=COLS=0;			return(0);		}				for (i=0; i<4; i++)    	{    		if (i < 2  &&  !RawEyesFlag)      			continue;    		if (i > 1  &&  !EyesFlag)      			continue;    		if (i%2 == 0)      		{      			y=(int)left_circles[1];      			x=(int)left_circles[0];      		}    		else      		{      			y=(int)right_circles[1];      			x=(int)right_circles[0];      		}      		    		if (i == 0)      			sprintf(outfile,"%s%s%s%slr.jpg", pathname, reportname, lastTwoDigits, orientationChar);    		else if (i == 1)      			sprintf(outfile,"%s%s%s%srr.jpg", pathname, reportname, lastTwoDigits, orientationChar);   			else if (i == 2)      			sprintf(outfile,"%s%s%s%sle.jpg", pathname, reportname, lastTwoDigits, orientationChar);    		else if (i == 3)      			sprintf(outfile,"%s%s%s%sre.jpg", pathname, reportname, lastTwoDigits, orientationChar);    		for (r=y-EYE_ROWS/2,r2=0; r<y+EYE_ROWS/2; r++,r2++)      			for (c=x-EYE_COLS/2,c2=0; c<x+EYE_COLS/2; c++,c2++)        		{					if (OrientationFlag == 0)		  				index=r2*EYE_COLS+c2;					else if (OrientationFlag == 1)		/* rotate CW */		  				index=c2*EYE_COLS+EYE_ROWS-1-r2;					else /* OrientationFlag == 2 */		/* rotate CCW */		  			index=(EYE_COLS-1-c2)*EYE_COLS+r2;					if (r < 0  ||  r >= ROWS  ||  c < 0  ||  c >= COLS)          			{          				eye_image[index*3+0]=0;          				eye_image[index*3+1]=1;          				eye_image[index*3+2]=2;          			}        			else if (i < 2)          			{				        eye_image[index*3+0]=raw[(r*COLS+c)*3+0];				        eye_image[index*3+1]=raw[(r*COLS+c)*3+1];				        eye_image[index*3+2]=raw[(r*COLS+c)*3+2];          			}        			else          			{          				eye_image[index*3+0]=annotated[(r*COLS+c)*3+0];          				eye_image[index*3+1]=annotated[(r*COLS+c)*3+1];          				eye_image[index*3+2]=annotated[(r*COLS+c)*3+2];          			}        		}			SaveImage(outfile, eye_image, EYE_ROWS, EYE_COLS, eyeScale, theWindow, theThermometerPane, theCaption);    	}    	#ifndef macintosh		free(eye_image);#else		HUnlock(eyeHandle);		DisposeHandle(eyeHandle);#endif  	}				/* save full annotated image */	if (FullImageFlag)  	{  		cinfo.err = jpeg_std_error(&jerr);  		jpeg_create_compress(&cinfo);  		sprintf(outfile,"%s%s%s%san.jpg", pathname, reportname, lastTwoDigits, orientationChar);  		if ((fpt=fopen(outfile,"wb")) == NULL)      	{			StopAlert(theWindow, CommonStringLiteral_("Unable to open full images file for writing."));      		return(0);      	} 	 	jpeg_stdio_dest(&cinfo, fpt);  		cinfo.image_width = COLS;  		cinfo.image_height = ROWS;  		cinfo.input_components = 3;  		cinfo.in_color_space = JCS_RGB;  		jpeg_set_defaults(&cinfo);  		jpeg_set_quality(&cinfo, 75, TRUE );  		jpeg_start_compress(&cinfo, TRUE);		long tenPercentOfRange = cinfo.image_height / 10;		char ShortFilename[MAX_PATHNAME_CHARS];		StripFilename(outfile, ShortFilename, FALSE);		sprintf(SaveText,"Writing %s",ShortFilename);#ifdef macintosh		c2pstr(SaveText);#endif		// Display the progress bar, and set its minimum and maximum values to 0 and rows			SetThermometerValues(theThermometerPane, 0L, cinfo.image_height, 0L);		SetCaptionText(theCaption, SaveText);  		while (cinfo.next_scanline < cinfo.image_height)    	{    		row_pointer[0] = & annotated[cinfo.next_scanline * COLS*3];   		 	(void) jpeg_write_scanlines(&cinfo, row_pointer, 1);  			if ((cinfo.next_scanline)%tenPercentOfRange == 0)  			{				SetThermometerValue(theThermometerPane, cinfo.next_scanline);				GiveOSTime();			}    	}		SetCaptionText(theCaption, EMPTYSTR);  		jpeg_finish_compress(&cinfo);  		fclose(fpt);		SetOSType(outfile, kUnknownType, kJPEGType);  		jpeg_destroy_compress(&cinfo);  	}#ifndef macintosh	free(annotated);#else	HUnlock(annotHandle);	DisposeHandle(annotHandle);#endif	return(1);}	/*******************************************************************	** Saves an image to a file in jpeg format.  Returns EYEDX_ERR_NO_ERROR after a	** successful save, a specific error otherwise.	*******************************************************************/int SaveImage(char			*filename,		/* complete name of image to save */			  unsigned char	*image,			/* image data, RGB L->R T->D format */			  int			ROWS,int COLS,	/* size of image */			  float			DownSample,		/* factor to downsample by (1 is full size) */			 	CEyeDxWindowType	*theWindow,			 	CEyeDxProgressType *theThermometerPane,	/* Control object that displays progress */			 	CEyeDxCaptionType 	*theCaption)		/* Indiates status */{	FILE							*fpt;	struct jpeg_compress_struct		cinfo;	struct jpeg_error_mgr			jerr;	JSAMPROW						row_pointer[1];	char							SaveText[MAX_PATHNAME_CHARS];#ifdef macintosh	Handle 							saveHandle;#endif	unsigned char					*save_image;	CEyeDxBooleanType				error = FALSE;		long	dst_rows = (long)((float)ROWS / DownSample);	long	dst_cols = (long)((float)COLS / DownSample);	if (DownSample == 1.0)  		save_image=image;	else  	{#ifndef macintosh  		save_image=(unsigned char *)calloc(dst_rows * dst_cols * 3,1);  		if (!save_image)			error = TRUE;#else		OSErr theErr;		saveHandle = ::TempNewHandle(dst_rows * dst_cols * 3, &theErr);		if (theErr != noErr || saveHandle == NULL)			error = TRUE;		else		{    	    		// Lock the handle so we can dereference it and simulate the raw pointer that's used in     		// the PC version    		HLock(saveHandle);    		save_image = (unsigned char *) *saveHandle;    	}#endif		if (error)		{			StopAlert(theWindow, CommonStringLiteral_("SaveImage(): Could not allocate desampling memory."));			return (0);		}		    	long srcRowBytes = COLS * 3;    	long dstRowBytes = dst_cols * 3;		long srcY = 0;				// We use long-word transfer to speed things up				unsigned char *srcPtr;		unsigned char *dstPtr;    	for (long y = 0; y < dst_rows; y++)    	{    		long srcX = 0;    	    dstPtr = (unsigned char *) (save_image + (dstRowBytes * y));    		for (long x = 0; x < dst_cols; x++)    		{    			srcPtr = (unsigned char *) &image[(srcY * srcRowBytes) + srcX];    			// We load three bytes from the source (RGB).     				    		*dstPtr++ = *srcPtr++;	    		*dstPtr++ = *srcPtr++;	    		*dstPtr++ = *srcPtr++;               	               	srcX = (float) x * DownSample;               	srcX *= 3; // Account for 3 bytes per pixel in the raw source image    		}    		srcY = (float) y * DownSample;    	}	   	}	cinfo.err = jpeg_std_error(&jerr);	jpeg_create_compress(&cinfo);	if ((fpt=fopen(filename,"wb")) == NULL)    {		StopAlert(theWindow, CommonStringLiteral_("Unable to open output file for writing:"));      	return(0);    }	jpeg_stdio_dest(&cinfo, fpt);	cinfo.image_width = dst_cols;	cinfo.image_height = dst_rows;	cinfo.input_components = 3;	cinfo.in_color_space = JCS_RGB;	jpeg_set_defaults(&cinfo);	jpeg_set_quality(&cinfo, 75, TRUE );	jpeg_start_compress(&cinfo, TRUE);	long tenPercentOfRange = cinfo.image_height / 10;	char ShortFilename[MAX_PATHNAME_CHARS];	StripFilename(filename, ShortFilename, FALSE);	sprintf(SaveText,"Writing %s",ShortFilename);#ifdef macintosh	c2pstr(SaveText);#endif	// Display the progress bar, and set its minimum and maximum values to 0 and rows			SetThermometerValues(theThermometerPane, 0L, cinfo.image_height, 0L);	SetCaptionText(theCaption, SaveText);	while (cinfo.next_scanline < cinfo.image_height)  	{ 		 row_pointer[0] = & save_image[cinfo.next_scanline*((int)((float)COLS/DownSample))*3];  		(void) jpeg_write_scanlines(&cinfo, row_pointer, 1);		if ((cinfo.next_scanline)%tenPercentOfRange == 0)		{			SetThermometerValue(theThermometerPane, cinfo.next_scanline);						GiveOSTime();		}  	}	SetCaptionText(theCaption, EMPTYSTR);	jpeg_finish_compress(&cinfo);	fclose(fpt);	SetOSType(filename, kUnknownType, kJPEGType);	jpeg_destroy_compress(&cinfo);	if (DownSample != 1)	{#ifndef macintosh		free(save_image);#else		HUnlock(saveHandle);		DisposeHandle(saveHandle);#endif	}	  	return(1);}