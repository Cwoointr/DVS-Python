#include <stdio.h>#include <math.h>#ifndef macintosh#include <windows.h>#else#include <stdlib.h>#include <unistd.h>#endif#include "globals.h"void ClassifyPupilInterior(unsigned char	*raw,		/* image data, RGB order */							unsigned char	*threshimage,	/* used to mark CR and ARR */							unsigned char	*dispimage,	/* for displaying what's going on */							int		ROWS,int COLS,							double	*pupil_circle,	/* pupil-iris border */							int		corneal_point,		/* input: a point inside corneal reflex */							int		*corneal_reflex_indices, /* output: indices of CR */							int		*total_cr,			/* output: count of pixels in CR */							int		*abnormal_red_reflex_indices,	/* output: indices of ARR */							int		*total_arr,			/* output: count of ARR */							int		*red_reflex_avg,	/* output: avg red reflex luminensce */							int		*red_reflex_class,	/* output: classif. of blob */							int		*red_reflex_col,	/* output: X-centroid of blob */							int		*red_reflex_row,	/* output: Y-centroid of blob */							CEyeDxViewType *theView)	// The view to draw into {	int		EYE_ROWS,EYE_COLS,r,c,r2,c2,pass,x,y,center_row,center_col;	int		AvgShade[3],DevShade[3],count,diff,size,touching_count;	int		perim_count,perim_pixel,r3,c3;	double	area;	int		*circle_points,total_circle_points,i,Zoom;	//char	text[100];	if (DisplayGraphics == 1)  	{	  	if (pupil_circle[3] >= 1.0)			Zoom=(int)(pupil_circle[3]*3.0);	  	else if (pupil_circle[2] >= 1.0)			Zoom=(int)(pupil_circle[2]*3.0);	  	else			Zoom=MaxIrisRad*2;	  	ZoomDisplay(dispimage,ROWS,COLS,corneal_point/COLS,corneal_point%COLS,Zoom,Zoom,ZoomSteps, theView);	  	circle_points=(int *)calloc(MaxIrisRad*8,sizeof(int));		OSSleep(FramePause/4);	  	if (pupil_circle[2] >= 0.0)	    {			MakeCircleIndices(pupil_circle[0],pupil_circle[1],pupil_circle[2],							ROWS,COLS,circle_points,&total_circle_points);			for (i=0; i<total_circle_points; i++)		  		dispimage[circle_points[i]*3+1]=255;	    }	  	if (pupil_circle[3] >= 0.0)	    {			MakeCircleIndices(pupil_circle[0],pupil_circle[1],pupil_circle[3],							ROWS,COLS,circle_points,&total_circle_points);			for (i=0; i<total_circle_points; i++)		 		dispimage[circle_points[i]*3+1]=dispimage[circle_points[i]*3+0]=255;	    }	 	free(circle_points);	  	ZoomDisplay(dispimage,ROWS,COLS,corneal_point/COLS,corneal_point%COLS,Zoom,Zoom,0, theView);		OSSleep(FramePause/4);  	}	/*****************************************************************	** threshimage keeps track of pixel labels.  First, label the	** corneal reflex with a distinctive label, so the CR pixels will	** be ignored in further processing.	*****************************************************************/	size=RegionFill(threshimage,ROWS,COLS,corneal_point/COLS,corneal_point%COLS,		POSS_REFLEX,CORN_REFLEX);	/*****************************************************************	** if there is no red circle, then fill cr_indices array and exit	*****************************************************************/	(*total_arr)=(*total_cr)=0;	(*red_reflex_col)=(*red_reflex_row)=0;	red_reflex_avg[0]=red_reflex_avg[1]=red_reflex_avg[2]=0;	if (pupil_circle[2] <= 0.0)  	{  		for (r=corneal_point/COLS-size; r<corneal_point/COLS+size; r++)    		for (c=corneal_point%COLS-size; c<corneal_point%COLS+size; c++)		      	if (r >= 0  &&  r < ROWS  &&  c >= 0  &&  c < COLS  &&						threshimage[r*COLS+c] == CORN_REFLEX)		        {		       		corneal_reflex_indices[*total_cr]=r*COLS+c;		       		(*total_cr)++;					if (DisplayGraphics == 1)				  	{		         		 dispimage[(r*COLS+c)*3+0]/=8;		          		dispimage[(r*COLS+c)*3+1]/=8;		          		dispimage[(r*COLS+c)*3+2]=255;				  	}		        }  		if (DisplayGraphics == 1)  		{  	 		ZoomDisplay(dispimage,ROWS,COLS,corneal_point/COLS,corneal_point%COLS,Zoom,Zoom,0,theView);			OSSleep(FramePause/4);		}  		return;  	}	(*red_reflex_class)=NORMAL;	/*****************************************************************	** Four passes through the image data:	** 	pass 0: find the average intensity inside the pupil	**	pass 1: find the stddev intensity inside the pupil	** 	pass 2: label abnormal pixels inside the pupil	**	pass 3: paint-fill abnormal areas and classify	*****************************************************************/	EYE_ROWS=EYE_COLS=(int)(pupil_circle[2]*2.0+2.0);	/* inside of pupil */	y=(int)pupil_circle[1]-EYE_ROWS/2;	/* local image bounds to check */	x=(int)pupil_circle[0]-EYE_COLS/2;	AvgShade[0]=AvgShade[1]=AvgShade[2]=count=0;	DevShade[0]=DevShade[1]=DevShade[2]=0;	for (pass=0; pass<4; pass++)  	{  		for (r=y; r<=y+EYE_ROWS; r++)    		for (c=x; c<=x+EYE_COLS; c++)      		{     			if (r < 0  ||  r >= ROWS  ||  c < 0  ||  c >= COLS)        			continue;	/* outside image bounds */      			if (sqrt((double)(SQR((double)r-pupil_circle[1])+SQR((double)c-pupil_circle[0]))) > pupil_circle[2])				{					threshimage[r*COLS+c]=OTHER;	/* so paint-fill stops at circle */					continue;	/* outside pupil circle */				}      			if (threshimage[r*COLS+c] == CORN_REFLEX)        		{        			if (pass == 0)          			{          				corneal_reflex_indices[*total_cr]=r*COLS+c;          				(*total_cr)++;          			}        			continue;	/* don't want to include CR */        		}      			for (r2=-2; r2<=2; r2++)	/* search for 2-deep border of CR */        		{        			for (c2=-2; c2<=2; c2++)          				if (threshimage[(r+r2)*COLS+c+c2] == CORN_REFLEX)		   					break;        			if (c2 <=2) break;				}     			if (r2 <= 2)				{					threshimage[r*COLS+c]=OTHER;        			continue;	/* don't want to include area just around CR */				}      			if (pass == 0)        		{					AvgShade[0]+=raw[(r*COLS+c)*3+0];	/* red */					AvgShade[1]+=raw[(r*COLS+c)*3+1];	/* green */					AvgShade[2]+=raw[(r*COLS+c)*3+2];	/* blue */					count++;        		}      			else if (pass == 1)        		{					DevShade[0]+=SQR(raw[(r*COLS+c)*3+0]-AvgShade[0]);					DevShade[1]+=SQR(raw[(r*COLS+c)*3+1]-AvgShade[1]);					DevShade[2]+=SQR(raw[(r*COLS+c)*3+2]-AvgShade[2]);        		}      			else if (pass == 2)        		{        			diff=(raw[(r*COLS+c)*3+0]-AvgShade[0])+						(raw[(r*COLS+c)*3+1]-AvgShade[1])+						(raw[(r*COLS+c)*3+2]-AvgShade[2]);					if (diff > 70  &&  (AvgShade[0] > 200  ||						raw[(r*COLS+c)*3+0]-AvgShade[0] > 30))		  				threshimage[r*COLS+c]=ABNORMAL;					else		  				threshimage[r*COLS+c]=OTHER;        		}      			else	/* pass == 3 */				{       			 	if (threshimage[r*COLS+c] == ABNORMAL)          				size=RegionFill(threshimage,ROWS,COLS,r,c,ABNORMAL,BRIGHT_CHECKING);       				 else          				continue;        			area=(double)size/(M_PI*SQR(pupil_circle[2]));//sprintf(text,"ARR size %d area %lf (limits %lf %lf)",size,area,MIN_2R_AREA,MAX_2R_AREA);//MessageBox(NULL,text,"ARR analysis",MB_OK | MB_APPLMODAL);       				if (area < MIN_2R_AREA  ||  area > MAX_2R_AREA)          			{          				size=RegionFill(threshimage,ROWS,COLS,r,c,BRIGHT_CHECKING,OTHER);          				continue;          			}                	/* big enough area -- find centroid and circle-border count */       				center_row=center_col=touching_count=perim_count=0;			        for (r2=r-size; r2<r+size; r2++)			          	for (c2=c-size; c2<c+size; c2++)			           		if (r2 >= 0  &&  r2 < ROWS  &&  c2 >= 0  &&  c2 < COLS  &&								threshimage[r2*COLS+c2] == BRIGHT_CHECKING)			              	{				              	center_row+=r2;				              	center_col+=c2;						      	perim_pixel=0;	/* is pixel on perimter of ARR-blob? */						      	for (r3=r2-1; r3<=r2+1; r3++)									for (c3=c2-1; c3<=c2+1; c3++)								  	{								  		if (r3 >= 0  &&  r3 < ROWS  &&  c3 >= 0  &&  c3 < COLS  &&											threshimage[r3*COLS+c3] != BRIGHT_CHECKING)								    			perim_pixel=1;								  	}					      		if (perim_pixel == 1)					        	{					        		perim_count++;			               			if (fabs(pupil_circle[2]-sqrt((double)(SQR((double)r2-pupil_circle[1])+										SQR((double)c2-pupil_circle[0])))) <= 2.5)					         			touching_count++;			                	}					      	}					*red_reflex_col=(int)((double)center_col/(double)size);					*red_reflex_row=(int)((double)center_row/(double)size);	        		if (sqrt((double)(SQR((double)(*red_reflex_row)-pupil_circle[1])+	                 		SQR((double)(*red_reflex_col)-pupil_circle[0])))	                		< pupil_circle[2])	/* centroid inside pupil */	          		{			  			if ((double)touching_count/(double)perim_count > MIN_CRESC)			    			*red_reflex_class=CRESCENT;	         			else			    			*red_reflex_class=OTHER_BLOB;	          			for (r2=r-size; r2<r+size; r2++)	            			for (c2=c-size; c2<c+size; c2++)			              		if (r2 >= 0  &&  r2 < ROWS  &&  c2 >= 0  &&  c2 < COLS  &&			                        threshimage[r2*COLS+c2] == BRIGHT_CHECKING)			                	{			                		abnormal_red_reflex_indices[*total_arr]=r2*COLS+c2;			                		(*total_arr)++;			                	}	          		}	        		size=RegionFill(threshimage,ROWS,COLS,r,c,BRIGHT_CHECKING,OTHER);				}      		}  		if (pass == 0)    	{		    red_reflex_avg[0]=AvgShade[0]=AvgShade[0]/count;		    red_reflex_avg[1]=AvgShade[1]=AvgShade[1]/count;		    red_reflex_avg[2]=AvgShade[2]=AvgShade[2]/count;//sprintf(text,"RR avg inten %d %d %d",AvgShade[0],AvgShade[1],AvgShade[2]);//MessageBox(NULL,text,"ARR analysis",MB_OK | MB_APPLMODAL);    	}  		else if (pass == 1)    	{		    DevShade[0]=(int)sqrt((double)DevShade[0]/(double)count);		    DevShade[1]=(int)sqrt((double)DevShade[1]/(double)count);		    DevShade[2]=(int)sqrt((double)DevShade[2]/(double)count);    	}  		if (pass == 0  &&  DisplayGraphics == 1)    	{    		for (i=0; i<(*total_cr); i++)			{		      	dispimage[corneal_reflex_indices[i]*3+0]/=8;		      	dispimage[corneal_reflex_indices[i]*3+1]/=8;		    	dispimage[corneal_reflex_indices[i]*3+2]=255;			}		    ZoomDisplay(dispimage,ROWS,COLS,corneal_point/COLS,corneal_point%COLS,Zoom,Zoom,0, theView);		    OSSleep(FramePause/4);    	}	}	if (DisplayGraphics == 1)  	{  		for (i=0; i<(*total_arr); i++)		{    		dispimage[abnormal_red_reflex_indices[i]*3+2]=255;			if ((*red_reflex_class) == CRESCENT)	  		{	  			dispimage[abnormal_red_reflex_indices[i]*3+1]=255;	  			dispimage[abnormal_red_reflex_indices[i]*3+0]/=8;	  		}			else	  		{	  			dispimage[abnormal_red_reflex_indices[i]*3+1]/=8;	  			dispimage[abnormal_red_reflex_indices[i]*3+0]=175;	  		}		}    	ZoomDisplay(dispimage,ROWS,COLS,corneal_point/COLS,corneal_point%COLS,Zoom,Zoom,0, theView);		OSSleep(FramePause);  	}}// New version of this routine that implements a gaze finder algorithm. Implemented by Adam Hoover// in October 1999void ClassifyPupilAlignment(double	lefteye_circles[4],	/* input:  left eye model */							int	*lefteye_cr_indices,	/* input:  indices (y*COLS+x) of left CR */							int	total_left_cr,			/* input:  count of left CR pixels */							double	righteye_circles[4],/* input:  right eye model */							int	*righteye_cr_indices,	/* input:  indices (y*COLS+x) of right CR */							int	total_right_cr,			/* input:  count of right CR pixels */							int	COLS,					/* input:  used to decode indices arrays */							int	a,					/* input:  image-ori (0 up, 1 left, 2 right) */							int	*strabismus)		/* output:  classif. of strabismus (0-5) */{	double	left_cr_col,left_cr_row,right_cr_col,right_cr_row;	int		i;	double	pup_to_pup_dist;	double	world_lefteye_pupil[3],world_righteye_pupil[3];	double	world_lefteye_cr[3],world_righteye_cr[3];	double	inter_eye_angle,angle_with_kappa,eyes_to_camera_angle;				/* from P000677 calibration image */	double	camera_calib[19] = { 1.2800000000e+003, 1.2800000000e+003,	                           1.9843750000e-002, 1.9843750000e-002,							   1.9843750000e-002, 1.9843750000e-002,							   7.6289730902e+002, 3.8365349021e+002,							   1.0000000000e+000, 1.3206680868e+002,							   6.3156312582e-006,-1.0161824215e+002,							   -5.8025534755e+001, 1.2556759984e+003,							   3.0839917432e+000, 5.6402164204e-002,							   3.1317391557e+000, 0.0000000000e+000,							   0.0000000000e+000};	double	x1,y1,x2,y2,dist;	double	left_eyeball[3],right_eyeball[3];	double	world_lefteye_gaze[3],world_righteye_gaze[3];	double	leftray[3],rightray[3],dist1,dist2,norm1,norm2;	double	gaze[3],image_center[3],image_proj_center[3],centerray[3];	/*****************************************************************	** Compute corneal reflex centroids for both eyes in the image	** (x,y) coordinate system.  The pupil centers in image coords	** are already known.	*****************************************************************/	left_cr_col = left_cr_row = 0.0;	for (i = 0; i<total_left_cr; i++)	{		left_cr_col += (double)(lefteye_cr_indices[i]%COLS);		left_cr_row += (double)(lefteye_cr_indices[i]/COLS);	}	left_cr_col /= (double)total_left_cr;	left_cr_row /= (double)total_left_cr;	right_cr_col = right_cr_row = 0.0;	for (i = 0; i<total_right_cr; i++)	{	  	right_cr_col += (double)(righteye_cr_indices[i]%COLS);	  	right_cr_row += (double)(righteye_cr_indices[i]/COLS);	}	right_cr_col /= (double)total_right_cr;	right_cr_row /= (double)total_right_cr;	/*****************************************************************	** Transform image (x,y) coordinates to world coordinates.  There	** are four points to be transformed:  pupil center and corneal	** reflex center, each for the left and right eye.	**	** Through camera calibration, each (x,y) pixel coordinate maps	** to a 3D ray in the world (X,Y,Z) space.  The imaged subject	** is assumed to be near the Z=0 world coordiante plane, so the	** Z component of all the world corods is set to 0.  With Z	** specified, X and Y are determined via ray intersection.	*****************************************************************/	world_lefteye_pupil[2] = world_righteye_pupil[2] = 0.0;	world_lefteye_cr[2] = world_righteye_cr[2] = 0.0;	ImageToWorldCoords(lefteye_circles[0],lefteye_circles[1],camera_calib,					   &world_lefteye_pupil[0],&world_lefteye_pupil[1]);	ImageToWorldCoords(righteye_circles[0],righteye_circles[1],camera_calib,					   &world_righteye_pupil[0],&world_righteye_pupil[1]);	ImageToWorldCoords(left_cr_col,left_cr_row,camera_calib,					   &world_lefteye_cr[0],&world_lefteye_cr[1]);	ImageToWorldCoords(right_cr_col,right_cr_row,camera_calib,					   &world_righteye_cr[0],&world_righteye_cr[1]);	/*****************************************************************	** Find the focal point of each eyeball (left and right).	**	** The focal point is not the center of the eyeball (as in the	** center of a sphere), but is rather the center of the lens.	** The lens front surface is 3 mm behind the cornea.	** The front-to-back diameter of the lens is 4 mm.	** Therefore, the center point is 5 mm behind points on the	** surface of the cornea.	*****************************************************************/	norm1 = norm2 = 0.0;	for (i = 0; i<3; i++)	{  		leftray[i] = world_lefteye_cr[i]-camera_calib[i+11];  		norm1 += SQR(leftray[i]); 		rightray[i] = world_righteye_cr[i]-camera_calib[i+11];  		norm2 += SQR(rightray[i]);  	}	for (i = 0; i<3; i++) 	{  		leftray[i] = leftray[i]/sqrt(norm1);  		left_eyeball[i] = world_lefteye_cr[i]+leftray[i]*5.0;  		rightray[i] = rightray[i]/sqrt(norm2);  		right_eyeball[i] = world_righteye_cr[i]+rightray[i]*5.0;  	}	/*****************************************************************	** Compute a ray from the eyeball focal point through the	** pupil center.  There is one ray for each eye (left and right).	** These rays are the gaze vectors.	*****************************************************************/	norm1 = norm2 = 0.0;	for (i = 0; i<3; i++)  	{  		leftray[i] = world_lefteye_pupil[i]-left_eyeball[i];  		norm1 += SQR(leftray[i]);  		rightray[i] = world_righteye_pupil[i]-right_eyeball[i];  		norm2 += SQR(rightray[i]);  	}	for (i = 0; i<3; i++)  	{  		leftray[i] = leftray[i]/sqrt(norm1);  		rightray[i] = rightray[i]/sqrt(norm2);  	}	/*****************************************************************	** Compute the gaze point for each eye of the subject.	**	** The gaze point is found as the intersection of the gaze	** vector with the image plane.  The image plane is located	** roughly parallel to the Z=0 world coordinate plane.  The	** distance to the image plane is given by the camera	** calibration, as the Z coordinate of the focal point of 	** the camera (parameter 13), less the focal distance of	** the camera (parameter 9).	*****************************************************************/	dist1 = (camera_calib[13]-camera_calib[9])/leftray[2];	dist2 = (camera_calib[13]-camera_calib[9])/rightray[2];	for (i = 0; i<3; i++)  	{  		world_lefteye_gaze[i] = world_lefteye_pupil[i]+leftray[i]*dist1;  		world_righteye_gaze[i] = world_righteye_pupil[i]+rightray[i]*dist2;  	}	/*****************************************************************	** Compute the gaze point of the subject as the average of	** the gaze points of both eyes.  Compute the point where the	** subject should be looking as the center of the image plane.	** The center of the image plane is found using the calibration.	*****************************************************************/	norm1 = 0.0;	image_proj_center[2] = 0.0;	ImageToWorldCoords(camera_calib[6],camera_calib[7],camera_calib,					   &image_proj_center[0],&image_proj_center[1]);	for (i = 0; i<3; i++)	{	  	centerray[i] = camera_calib[i+11]-image_proj_center[i];	  	norm1 += SQR(centerray[i]);	}	for (i = 0; i<3; i++) 	{	  	image_center[i] = image_proj_center[i]+centerray[i]/sqrt(norm1)*(camera_calib[13]-camera_calib[9]);	  	gaze[i] = (world_lefteye_gaze[i]+world_righteye_gaze[i])/2.0;	}	image_center[0] -= 30.0;	/* fudge-factor based on Adam gaze sequence */	image_center[1] -= 10.0;	/* fudge-factor based on Adam gaze sequence */	dist = sqrt(SQR(gaze[0]-image_center[0])+SQR(gaze[1]-image_center[1])+			  SQR(gaze[2]-image_center[2]));	/*****************************************************************	** Compute the eye alignment as the angle between the gaze	** vectors, adjusted for the angle "kappa" (5 degrees) that	** exists between a gaze vector and a center pupil vector.	** The angle that the eyes make with the camera is determined	** using the distance between the pupil centers.	*****************************************************************/	pup_to_pup_dist = sqrt(SQR(world_lefteye_pupil[0]-world_righteye_pupil[0])+		SQR(world_lefteye_pupil[1]-world_righteye_pupil[1]));	eyes_to_camera_angle = 2.0*atan((pup_to_pup_dist/2.0)/1143.0)*180.0/M_PI;	inter_eye_angle = acos(leftray[0]*rightray[0]+leftray[1]*rightray[1]+leftray[2]*rightray[2])*180.0/M_PI;	if (a != 0)	{		  /* check the accuracy of the user specifying left/right */	  	if ((a == 1  &&  world_lefteye_pupil[1] > world_righteye_pupil[1])  ||		  	(a == 2  &&  world_lefteye_pupil[1] < world_righteye_pupil[1]))		{	  /* user got it backwards -- switch "a"-flag for following correction */			if (a == 1) 				a = 2;			else 				a = 1;		}	}	if ((a == 0  &&  leftray[0] < rightray[0])  ||	  /* horizontal image */		(a == 1  &&  leftray[1] < rightray[1])  ||	  /* side image -- left */		(a == 2  &&  leftray[1] > rightray[1]))		  /* side image -- right */	  	angle_with_kappa = inter_eye_angle-(10.0 /* 2 kappa */										-eyes_to_camera_angle										-1.57 /* fudge factor */);	else	  	angle_with_kappa = inter_eye_angle+(10.0 /* 2 kappa */										-eyes_to_camera_angle										-1.57 /* fudge factor */);	/*****************************************************************	** Classify corneal reflexes based upon gaze and inter-eye-angle	*****************************************************************/	if (dist > 150.0)	/* must be looking within 150 mm of camera */  		(*strabismus) = NOT_LOOKING;	else if (fabs(angle_with_kappa) < 8.0)  /* micro-to-small cases are normal */  		(*strabismus) = NORMAL;	else	  	(*strabismus) = STRABISMUS;}	/*****************************************************************	** Converts an image coordinate to a world coordinate.  The imaged	** point is assumed to be in the z=0 plane, which means 3.75 feet	** from the camera (according to the calibration).  The world	** coordinate is in mm units in the calibration coordinate system.	*****************************************************************/void ImageToWorldCoords(double u,double v,double *camera_calib,						double *x,double *y){	double	invR[3][3],cp[3],pc[3],pw[3],temp[3][3],r2,t;	double	Rx,Ry,Rz,pitch[3][3],roll[3][3],yaw[3][3];	double	T[3],f,Cx,Cy,Sx,Ncf,Ncx,dx,dy,kappa1;	int		i,j,k;	Ncx = camera_calib[0];	Ncf = camera_calib[1];	dx = camera_calib[2];	dy = camera_calib[3];	Cx = camera_calib[6];	Cy = camera_calib[7];	Sx = camera_calib[8];	f = camera_calib[9];	kappa1 = camera_calib[10];	T[0] = camera_calib[11];	T[1] = camera_calib[12];	T[2] = camera_calib[13];	Rx = camera_calib[14];	Ry = camera_calib[15];	Rz = camera_calib[16];	yaw[0][0] = 1.0;	yaw[0][1] = 0.0;		yaw[0][2] = 0.0;	yaw[1][0] = 0.0;	yaw[1][1] = cos(-Rx);	yaw[1][2] = -sin(-Rx);	yaw[2][0] = 0.0;	yaw[2][1] = sin(-Rx);	yaw[2][2] = cos(-Rx);	pitch[0][0] = cos(-Ry);		pitch[0][1] = 0.0;	pitch[0][2] = sin(-Ry);	pitch[1][0] = 0.0;			pitch[1][1] = 1.0;	pitch[1][2] = 0.0;	pitch[2][0] = -sin(-Ry);	pitch[2][1] = 0.0;	pitch[2][2] = cos(-Ry);	roll[0][0] = cos(-Rz);	roll[0][1] = -sin(-Rz);	roll[0][2] = 0.0;	roll[1][0] = sin(-Rz);	roll[1][1] = cos(-Rz);	roll[1][2] = 0.0;	roll[2][0] = 0.0;		roll[2][1] = 0.0;		roll[2][2] = 1.0;	for(i = 0;i<3;i++)  		for(j = 0;j<3;j++)		{			temp[i][j]  =  0.0;			for(k = 0;k<3;k++)	  			temp[i][j] += pitch[i][k]*roll[k][j];		}	for(i = 0;i<3;i++)  		for(j = 0;j<3;j++)    	{			invR[i][j] = 0.0;			for(k = 0;k<3;k++)	  			invR[i][j] += yaw[i][k]*temp[k][j];		}	for(i = 0;i<3;i++)  	{  		cp[i]  =  0;  		for(j = 0;j<3;j++)			cp[i] += -invR[i][j]*T[j];  	}	/* Transform computer image coords to undistorted view plane	   u_f = sx*(1/dx')*u_d+Cx, v_f = (1/dy)*v_d+Cy	   --> u_d = ((u_f-Cx)/sx)*dx', v_d = (v_f-Cy)*dy	*/	pc[0] = ((double)u-Cx)*dx/Sx;	pc[1] = ((double)v-Cy)*dy;	pc[2] = f;	  /* Transform from undistorted to distorted view plane	   u_u = u_d*(1+kappa1*r^2)	   v_u = v_d*(1+kappa1*r^2)	   r = sqrt(u_d^2+v_d^2)	*/	r2 = SQR(pc[0])+SQR(pc[1]);	pc[0] = pc[0]*(1.0+kappa1*r2);	pc[1] = pc[1]*(1.0+kappa1*r2);	/* Transform from camera coords to world coords. The point [0,0,0]	   is used to get a line. */	for(i = 0;i<3;i++) 	{ /* loop over x y z */	  	pc[i] -= T[i];	}	for(i = 0;i<3;i++) 	{ /* loop over x y z */	  	pw[i] = 0;	  	for(j = 0;j<3;j++) 	  	{ /* Column */	    	pw[i] += invR[i][j]*pc[j];	  	}	}	/* Calclation the intersection between the line and z = 0 */	t = (0-cp[2])/(pw[2]-cp[2]);	(*x) = cp[0]+t*(pw[0]-cp[0]);	(*y) = cp[1]+t*(pw[1]-cp[1]);}#if FALSEvoid ClassifyPupilAlignment(double	lefteye_circles[4],	/* input:  left eye model */							int	*lefteye_cr_indices,	/* input:  indices (y*COLS+x) of left CR */							int	total_left_cr,			/* input:  count of left CR pixels */							double	righteye_circles[4],/* input:  right eye model */							int	*righteye_cr_indices,	/* input:  indices (y*COLS+x) of right CR */							int	total_right_cr,			/* input:  count of right CR pixels */							int	COLS,					/* input:  used to decode indices arrays */							int	a,					/* input:  image-ori (0 up, 1 left, 2 right) */							int	*strabismus)		/* output:  classif. of strabismus (0-5) */{	double	left_cr_col,left_cr_row,right_cr_col,right_cr_row;	int	i,left_align,right_align;	double	pup_to_pup_dist,cr_to_cr_dist;	/*****************************************************************	** Compute corneal reflex centroids for both eyes, in xy coord sys	*****************************************************************/	left_cr_col=left_cr_row=0.0;	for (i=0; i<total_left_cr; i++)  	{	  left_cr_col+=(double)(lefteye_cr_indices[i]%COLS);	  left_cr_row+=(double)(lefteye_cr_indices[i]/COLS);  	}	left_cr_col/=(double)total_left_cr;	left_cr_row/=(double)total_left_cr;	right_cr_col=right_cr_row=0.0;	for (i=0; i<total_right_cr; i++)  	{ 		right_cr_col+=(double)(righteye_cr_indices[i]%COLS);  		right_cr_row+=(double)(righteye_cr_indices[i]/COLS);  	}	right_cr_col/=(double)total_right_cr;	right_cr_row/=(double)total_right_cr;	/*****************************************************************	** Compute alignments of CRs to eye models	*****************************************************************/	pup_to_pup_dist=sqrt((double)(SQR(lefteye_circles[0]-righteye_circles[0])+		SQR(lefteye_circles[1]-righteye_circles[1])));			cr_to_cr_dist=sqrt((double)(SQR(left_cr_col-right_cr_col)+		SQR(left_cr_row-right_cr_row)));			if (sqrt((double)(SQR(lefteye_circles[0]-left_cr_col)+		SQR(lefteye_circles[1]-left_cr_row)))			>= lefteye_circles[3]*MAX_CR_PUP_DIST)  	{			/* left eye not aligned */  		if (fabs(lefteye_circles[0]-left_cr_col) >			fabs(lefteye_circles[1]-left_cr_row))    		left_align=1;	/* worse horizontal misalign then vertical */ 		else    		left_align=2;	/* worse vertical misalign then horizontal */  	}	else  		left_align=0;		/* left eye ok */  			if (sqrt((double)(SQR(righteye_circles[0]-right_cr_col)+		SQR(righteye_circles[1]-right_cr_row)))			>= righteye_circles[3]*MAX_CR_PUP_DIST)  	{			/* right eye not aligned */  		if (fabs(righteye_circles[0]-right_cr_col) >			fabs(righteye_circles[1]-right_cr_row))    		right_align=1;	/* worse horizontal misalign then vertical */  		else   	 		right_align=2;	/* worse vertical misalign then horizontal */  	}	else  		right_align=0;	/* right eye ok */  			if (left_align  &&  right_align)  		(*strabismus)=NOT_LOOKING;	else if (left_align == 0  &&  right_align == 0)  		(*strabismus)=NORMAL;	else if (((left_align == 1  ||  right_align == 1)  &&  a != 0)  ||	 		((left_align == 2  ||  right_align == 2)  &&  a == 0))  		(*strabismus)=HYPERTROPIA;	else if (pup_to_pup_dist > cr_to_cr_dist)  		(*strabismus)=ESOTROPIA;	else  		(*strabismus)=EXOTROPIA;}#endif