		/*********************************************************		** This program finds eyes in images taken for photoscreening.		** It then makes measurements on the eye models and produces		** a (limited) diagnosis and screening decision.		**		** Coded by Adam Hoover in June-December '97.		** Ported to windows in January-February '98. (AH)		*********************************************************/#include <stdio.h>#include <math.h>#include <time.h>#ifndef macintosh#include <windows.h>#include <process.h>#include "globals.h"#include "FileVersion.h"#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"#include "CMFCCameraImageSelectDlg.h"#include "CMFCAnalysisWin.h"#include "CMFCRunWin.h"#include "CMFCRunFromCameraWin.h"#include "CMFCRunFromDiskWin.h"#include "CMFCAboutDialog.h"#include "CMFCPropertiesDlg.h"#include "EyeDxMFCMessages.h"#include "main.h"#else#include <string.h>#include <stdlib.h>#include <unistd.h>#include "EyeDxMacConstants.h"#include "CMyGWorldView.h"#include <LCaption.h>#include <path2fss.h>#include "globals.h"#include "IntlResources.h"#endifvoid EyeDx(		char 				*upfilename,	/* filename of up-image to process; may be empty */			 	char 				*sidefilename,	/* filename of side-image to process; may be empty */			 	int 				SideOrientation,	/* 0 means left, otherwise right */				int 				FULL_FLAG,				/* flag on outputing full-size annotated images */				CEyeDxBooleanType	AdjustReportName,				AnalysisResults		*theAnalysisResults,				CEyeDxWindowType	*theWindow,				CEyeDxViewType		*theViewObject,				CEyeDxProgressType	*theThermometer,				CEyeDxCaptionType	*theCaption,				EyeDxReportFormat	theReportFormat,				CEyeDxVariableList	*theVariableList,				char				**theOptionalReportText,				long				*theOptionalReportTextSize,				long				theNumOptionalReportText){	int		Referral;		// Now we save the start time for the analysis for statistical purposes		CEyeDxVariable *theStartTimeVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTANALYSISSTARTTIME));	if (theStartTimeVariable)		theStartTimeVariable->ResetValue();		CEyeDxVariable *theSessionNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();	char theCSessionName[255];	#ifndef macintosh	strcpy(theCSessionName, *theSessionName);#else	strncpy(theCSessionName, theSessionName->TextPtr(), theSessionName->Length());	theCSessionName[theSessionName->Length()] = '\0';#endif	// Load the focus position values, and test whether they are valid or not.	// These values are used to detect pupil size in the ProcessImage routine.		CEyeDxVariable *theFocusPositionVariable;	long theUpFocusPosition = 0;	long theSideFocusPosition = 0;		theFocusPositionVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGEFOCUS));		if (*(theFocusPositionVariable->GetValue()) != CommonStringLiteral_(kCEyeDxVariableIMAGEFOCUSNotAvailable))		theFocusPositionVariable->GetValue(theUpFocusPosition);			theFocusPositionVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGEFOCUS));		if (*(theFocusPositionVariable->GetValue()) != CommonStringLiteral_(kCEyeDxVariableIMAGEFOCUSNotAvailable))		theFocusPositionVariable->GetValue(theSideFocusPosition);			/*********************************************************	** Process given images.	Result for each image is an eye	** model (two concentric circles), a strabismus value (0-5),	** a red reflex luminensce value (0-3), and left & right	** abnormal red reflex values (0-3).	*********************************************************/		// Note: if the upfilename or sidefilename pointers are NULL, that means that we are doing a	// re-analysis. Therefore, we do not change the contents of theAnalysisResults for that image, so that	// the previous results can be reused for the final determination of referral. The previous code had	// supported analysis using a single image (and thus set the resultflag member to -1 to indicate no	// report), but the higher-level GUI always requires two images. So this logic was never used.		if (upfilename != NULL)		theAnalysisResults->upResults.resultflag=ProcessImage(upfilename, 0, report_filename, theCSessionName, &theAnalysisResults->upResults,																FULL_FLAG,1, theUpFocusPosition, 																theReportFormat, theWindow, theViewObject, theThermometer, theCaption);			if (sidefilename != NULL	&&	SideOrientation == 0)		theAnalysisResults->sideResults.resultflag=ProcessImage(sidefilename, 1, report_filename, theCSessionName, &theAnalysisResults->sideResults,																FULL_FLAG,1, theSideFocusPosition, 																theReportFormat, theWindow, theViewObject, theThermometer, theCaption);																	else if (sidefilename != NULL	&&	SideOrientation != 0)		theAnalysisResults->sideResults.resultflag=ProcessImage(sidefilename, 2, report_filename, theCSessionName, &theAnalysisResults->sideResults,																FULL_FLAG,1, theSideFocusPosition, 																theReportFormat, theWindow, theViewObject, theThermometer, theCaption);	// Now we save the end time for the analysis for statistical purposes		CEyeDxVariable *theEndTimeVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSUBJECTANALYSISENDTIME));	if (theEndTimeVariable)		theEndTimeVariable->ResetValue();				/*********************************************************		** Make referral decision based on reports		*********************************************************/		// Calculate the age based on the setting in the BIRTH DATE variable		int ageInYears = HandleAgeCalculation(theVariableList);	CEyeDxVariable *theOneYrPromptVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableONEYRPROMPT));	if (theOneYrPromptVariable)		theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptNotAsked));		Referral=-1;	/* undefined, for safety */	if (theAnalysisResults->upResults.resultflag >= 0  &&  theAnalysisResults->sideResults.resultflag >= 0)	// decide on two images	{	  	if ((theAnalysisResults->upResults.resultflag == 1  &&		  	(theAnalysisResults->upResults.strabismus > 2            ||  		  	 theAnalysisResults->upResults.red_reflex_lumin == 3     ||		  	 theAnalysisResults->upResults.right_arr_class > 1       ||  		  	 theAnalysisResults->upResults.left_arr_class > 1))      ||		 	 (theAnalysisResults->sideResults.resultflag == 1  &&		 	 (theAnalysisResults->sideResults.strabismus > 2         ||  		 	  theAnalysisResults->sideResults.red_reflex_lumin == 3  ||		  	  theAnalysisResults->sideResults.right_arr_class > 1    ||  		 	  theAnalysisResults->sideResults.left_arr_class > 1)))	    	Referral=1;	/* refer yes; something wrong in at least one image */	  	else if (theAnalysisResults->upResults.resultflag == 0  ||  theAnalysisResults->sideResults.resultflag == 0)			Referral=2;	/* at least one image not analyzed; must retake */	  	else			Referral=0;	/* both images pass all tests; refer no */	  	  	if (Referral == 1)		{	/* check to see if crescent(s) is only referring factor */			if ((theAnalysisResults->upResults.resultflag == 0  ||  (theAnalysisResults->upResults.resultflag == 1  &&				theAnalysisResults->upResults.strabismus == 1  &&  theAnalysisResults->upResults.red_reflex_lumin == 1  &&				theAnalysisResults->upResults.right_arr_class >= 1  &&  theAnalysisResults->upResults.right_arr_class <= 2  &&				theAnalysisResults->upResults.left_arr_class >= 1  &&  theAnalysisResults->upResults.left_arr_class <= 2))  &&				(theAnalysisResults->sideResults.resultflag == 0  ||  (theAnalysisResults->sideResults.resultflag == 1  &&				theAnalysisResults->sideResults.strabismus == 1  &&  theAnalysisResults->sideResults.red_reflex_lumin == 1  &&				theAnalysisResults->sideResults.right_arr_class >= 1  &&  theAnalysisResults->sideResults.right_arr_class <= 2  &&				theAnalysisResults->sideResults.left_arr_class >= 1  &&  theAnalysisResults->sideResults.left_arr_class <= 2)))	  		{	  			if (ageInYears == kAgeNotCalculated)	  			{#ifndef macintosh	  				if (theWindow->MessageBox("Is this person less than 12 months in age?", AfxGetAppName(), MB_YESNO) == IDYES)#else						::ParamText("\pIs this person less than 12 months in age?", Str_Empty, Str_Empty, Str_Empty);						DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_YesNoALRT);						if (item_hit == PPob_YesNoALRT_Yes)#endif						{				    		if (theAnalysisResults->upResults.resultflag == 0 || theAnalysisResults->sideResults.resultflag == 0)				    			Referral = 2;	// Recommend a retake if either image was retake and the other				    							// had only the crescent				    		else				    			Referral = 0;	// less than one year old = don't refer				    							    		if (theOneYrPromptVariable)								theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptYes));						}						else						{				    		if (theOneYrPromptVariable)								theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptNo));						}				}				else if (ageInYears < 1)				{					Referral = 0;					theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptCalculatedYounger));				}				else					theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptCalculatedOlder));	  		}		} 	}	else if (theAnalysisResults->upResults.resultflag >= 0)	// decide on one image -- can only refer Yes or Inconclusive  	{  		if (theAnalysisResults->upResults.resultflag == 1  &&	  		(theAnalysisResults->upResults.strabismus > 2  ||  theAnalysisResults->upResults.red_reflex_lumin == 3  ||	   		 theAnalysisResults->upResults.right_arr_class > 1  ||  theAnalysisResults->upResults.left_arr_class > 1))    		Referral=1;	/* refer yes; something wrong in the one image analyzed */  		else			Referral=2;	/* this image ok but other image not analyzed; must retake */  		  		if (Referral == 1)		{	/* check to see if crescent(s) is only referring factor */			if (theAnalysisResults->upResults.resultflag == 1  &&				theAnalysisResults->upResults.strabismus == 1  &&  theAnalysisResults->upResults.red_reflex_lumin == 1  &&				theAnalysisResults->upResults.right_arr_class >= 1  &&  theAnalysisResults->upResults.right_arr_class <= 2  &&				theAnalysisResults->upResults.left_arr_class >= 1  &&  theAnalysisResults->upResults.left_arr_class <= 2)	  		{	  			if (ageInYears == kAgeNotCalculated)	  			{#ifndef macintosh		  			if (theWindow->MessageBox("Is this person less than 12 months in age?", AfxGetAppName(), MB_YESNO) == IDYES)#else						::ParamText("\pIs this person less than 12 months in age?", Str_Empty, Str_Empty, Str_Empty);						DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_YesNoALRT);						if (item_hit == PPob_YesNoALRT_Yes)#endif						{				    		Referral = 2;	// less than one year old, crescent only, and only one good image				    						// recommend a retake				    		if (theOneYrPromptVariable)								theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptYes));						}						else						{				    		if (theOneYrPromptVariable)								theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptNo));						}				}				else if (ageInYears < 1)				{					Referral = 0;					theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptCalculatedYounger));				}				else					theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptCalculatedOlder));	  		}		}  	}	else if (theAnalysisResults->sideResults.resultflag >= 0)	// decide on one image -- can only refer Yes or Inconclusive,  	{							// or No in special case of <1 year and crescent only  		if (theAnalysisResults->sideResults.resultflag == 1  &&			  (theAnalysisResults->sideResults.strabismus > 2  ||  theAnalysisResults->sideResults.red_reflex_lumin == 3  ||			   theAnalysisResults->sideResults.right_arr_class > 1  ||  theAnalysisResults->sideResults.left_arr_class > 1))    		Referral=1;	/* refer yes; something wrong in the one image analyzed */  		else			Referral=2;	/* this image ok but other image not analyzed; must retake */  		  		if (Referral == 1)		{	/* check to see if crescent(s) is only referring factor */			if (theAnalysisResults->sideResults.resultflag == 1  &&				theAnalysisResults->sideResults.strabismus == 1  &&  theAnalysisResults->sideResults.red_reflex_lumin == 1  &&				theAnalysisResults->sideResults.right_arr_class >= 1  &&  theAnalysisResults->sideResults.right_arr_class <= 2  &&				theAnalysisResults->sideResults.left_arr_class >= 1  &&  theAnalysisResults->sideResults.left_arr_class <= 2)	  		{	  			if (ageInYears == kAgeNotCalculated)	  			{#ifndef macintosh		  			if (theWindow->MessageBox("Is this person less than 12 months in age?", AfxGetAppName(), MB_YESNO) == IDYES)#else						::ParamText("\pIs this person less than 12 months in age?", Str_Empty, Str_Empty, Str_Empty);						DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_YesNoALRT);						if (item_hit == PPob_YesNoALRT_Yes)#endif						{				    		Referral = 2;	// less than one year old, crescent only, and only one good image				    						// recommend a retake				    		if (theOneYrPromptVariable)								theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptYes));						}						else						{				    		if (theOneYrPromptVariable)								theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptNo));						}				}				else if (ageInYears < 1)				{					Referral = 0;					theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptCalculatedYounger));				}				else					theOneYrPromptVariable->SetValue(CommonStringLiteral_(kOneYrPromptCalculatedOlder));	  		}		}  	}	/*********************************************************	** Write graphic and/or letter report	*********************************************************/			// This logic is to alter the file name based on the results of the analysis.	// We prepend one of three strings to the report name based on the result. We	// also return this to the caller so they can adjust the report name as well	// Note that we always return a referral indicator. It is up to the caller to	// use it or not. We also return a code that indicates the referral, so that	// the caller can tell the result even if the user has decided not to prepend the	// string.		CEyeDxVariable *theResultVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableRESULT));		if (Referral == 1)	{		theAnalysisResults->ReferralCode = kYesReferralCode;		theAnalysisResults->ResultsCode = kNoErrors;		if (theResultVariable)			theResultVariable->SetValue(CommonStringLiteral_(kResultRefer));	}  	else if (Referral == 0)  	{		theAnalysisResults->ReferralCode = kNoReferralCode;		theAnalysisResults->ResultsCode = kNoErrors;		if (theResultVariable)			theResultVariable->SetValue(CommonStringLiteral_(kResultPass));	}  	else if (theAnalysisResults->upResults.resultflag == 1  &&  theAnalysisResults->sideResults.resultflag == -1)	{		theAnalysisResults->ReferralCode = kSecondImageReferralCode;		theAnalysisResults->ResultsCode = kRetakeSide;		if (theResultVariable)			theResultVariable->SetValue(CommonStringLiteral_(kResultRetake));	}	else if	(theAnalysisResults->upResults.resultflag == -1  &&  theAnalysisResults->sideResults.resultflag == 1)	{		theAnalysisResults->ReferralCode = kSecondImageReferralCode;		theAnalysisResults->ResultsCode = kRetakeUp;		if (theResultVariable)			theResultVariable->SetValue(CommonStringLiteral_(kResultRetake));	}  	else  	{		theAnalysisResults->ReferralCode = kUnclearReferralCode;				// Now figure out the specific result for each image				if (theAnalysisResults->upResults.resultflag == 0 && theAnalysisResults->sideResults.resultflag == 0)			theAnalysisResults->ResultsCode = kRetakeBoth;		else if (theAnalysisResults->upResults.resultflag == 0)			theAnalysisResults->ResultsCode = kRetakeUp;		else if (theAnalysisResults->sideResults.resultflag == 0)			theAnalysisResults->ResultsCode = kRetakeSide;		if (theResultVariable)			theResultVariable->SetValue(CommonStringLiteral_(kResultRetake));	}		// Now set up the string that would be prepended to the file name		theAnalysisResults->ReferralIndicator = kNullReferralIndicator;		if (AdjustReportName)	{		switch (theAnalysisResults->ReferralCode)		{		case kYesReferralCode:			theAnalysisResults->ReferralIndicator = kYesReferralIndicator;			break;					case kNoReferralCode:			theAnalysisResults->ReferralIndicator = kNoReferralIndicator;			break;					case kSecondImageReferralCode:			theAnalysisResults->ReferralIndicator = kSecondImageReferralIndicator;			break;					case kUnclearReferralCode:			theAnalysisResults->ReferralIndicator = kUnclearReferralIndicator;			break;		}		}		// Set up the results file path array, and we preserve several of the strings and such for	// use later on upstream.		for (short i = 0; i < kNumEyeImages; i++)		theAnalysisResults->eye_image_path[i][0] = '\0';			for (short i = 0; i < kNumResultStrings; i++)		theAnalysisResults->eye_image_annot[i][0] = '\0';		// We use the passed filenames only if non-NULL (obviously!). But a NULL implies that the analysis	// results structure already contains the information for the image that had the associated NULL	// pointer, so we don't want to change it anyway. From this point on, though, we are simply recreating 	// existing values. It's easier to do that than have if statements all over the place.		if (upfilename)		StripFilename(upfilename, theAnalysisResults->UpName);		if (sidefilename)		StripFilename(sidefilename, theAnalysisResults->SideName);	theAnalysisResults->UpAnnotate = TRUE;	theAnalysisResults->SideAnnotate = TRUE;  			strcpy(theAnalysisResults->ReportName, report_filename);		    // We pull out the last two digits of the input file names, and use that in the filenames    // to make them more unique.    	theAnalysisResults->LastTwoCharsUpName[0] = theAnalysisResults->UpName[strlen(theAnalysisResults->UpName) - 2];	theAnalysisResults->LastTwoCharsUpName[1] = theAnalysisResults->UpName[strlen(theAnalysisResults->UpName) - 1];	theAnalysisResults->LastTwoCharsUpName[2] = '\0';	theAnalysisResults->LastTwoCharsSideName[0] = theAnalysisResults->SideName[strlen(theAnalysisResults->SideName) - 2];	theAnalysisResults->LastTwoCharsSideName[1] = theAnalysisResults->SideName[strlen(theAnalysisResults->SideName) - 1];	theAnalysisResults->LastTwoCharsSideName[2] = '\0';#ifndef macintosh	sprintf(theAnalysisResults->Report_path, "%s%c%s%creports%c%s%s.htm", 				DataPath, PATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR,				theAnalysisResults->ReferralIndicator, theAnalysisResults->ReportName);#else	sprintf(theAnalysisResults->Report_path, "%s%s%creports%c%s%s.htm", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, 				theAnalysisResults->ReferralIndicator, theAnalysisResults->ReportName);#endif	sprintf(theAnalysisResults->Simage_path[kUpSimage], "%s%s%cSimages%c%s%sUsc.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);	sprintf(theAnalysisResults->Simage_path[kSideSimage], "%s%s%cSimages%c%s%sSsc.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);	theAnalysisResults->SideOrientation = SideOrientation;			if (theAnalysisResults->upResults.resultflag >= 0)  	{  		if (theAnalysisResults->upResults.resultflag == 0)  			strcpy(theAnalysisResults->eye_image_annot[kUpTopResult], theAnalysisResults->upResults.fail_text);  		if (theAnalysisResults->upResults.resultflag == 0  &&  Referral == 2)  			strcpy(theAnalysisResults->eye_image_annot[kUpBottomResult], "Please retake this picture.");  		else if (theAnalysisResults->upResults.resultflag == 0)  			strcpy(theAnalysisResults->eye_image_annot[kUpBottomResult], "Other photo provides sufficient evidence for referral."); 		else		{  			theAnalysisResults->UpAnnotate = FALSE;  			 			// These results paths are relative to the application, NOT the report file			// Note that we create these paths whether or not the AdvancedFeatures flag is turned on. In version 1.5 and later,			// we don't include the raw eyes in the report unless the AdvancedFeatures flag is turned on. The raw eye images aren't			// even created in the WriteImage routine if not. But to simplify the code, we still create the path so that the structure			// is initialized.						sprintf(theAnalysisResults->eye_image_path[kUpRightRawEye],   "%s%s%ceyes%c%s%sUrr.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);			sprintf(theAnalysisResults->eye_image_path[kUpLeftRawEye],    "%s%s%ceyes%c%s%sUlr.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);			sprintf(theAnalysisResults->eye_image_path[kUpRightAnnotEye], "%s%s%ceyes%c%s%sUre.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName);			sprintf(theAnalysisResults->eye_image_path[kUpLeftAnnotEye],  "%s%s%ceyes%c%s%sUle.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsUpName); 			strcpy(theAnalysisResults->eye_image_annot[kUpBottomResult], ""); 		}  	}		if (theAnalysisResults->sideResults.resultflag >= 0)  	{  		if (theAnalysisResults->sideResults.resultflag == 0)  			strcpy(theAnalysisResults->eye_image_annot[kSideTopResult], theAnalysisResults->sideResults.fail_text);  		if (theAnalysisResults->sideResults.resultflag == 0  &&  Referral == 2)  			strcpy(theAnalysisResults->eye_image_annot[kSideBottomResult], "Please retake this picture.");  		else if (theAnalysisResults->sideResults.resultflag == 0)  			strcpy(theAnalysisResults->eye_image_annot[kSideBottomResult], "Other photo provides sufficient evidence for referral.");  		else  		{  			theAnalysisResults->SideAnnotate = FALSE;  			 			// These results paths are relative to the application, NOT the report file			// Note that we create these paths whether or not the AdvancedFeatures flag is turned on. In version 1.5 and later,			// we don't include the raw eyes in the report unless the AdvancedFeatures flag is turned on. The raw eye images aren't			// even created in the WriteImage routine if not. But to simplify the code, we still create the path so that the structure			// is initialized.			sprintf(theAnalysisResults->eye_image_path[kSideRightRawEye],   "%s%s%ceyes%c%s%sSrr.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);			sprintf(theAnalysisResults->eye_image_path[kSideLeftRawEye],    "%s%s%ceyes%c%s%sSlr.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);			sprintf(theAnalysisResults->eye_image_path[kSideRightAnnotEye], "%s%s%ceyes%c%s%sSre.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName);			sprintf(theAnalysisResults->eye_image_path[kSideLeftAnnotEye],  "%s%s%ceyes%c%s%sSle.jpg", 				LEADINGPATHSEPARATOR, theCSessionName, PATHSEPARATOR, PATHSEPARATOR, theAnalysisResults->ReportName, theAnalysisResults->LastTwoCharsSideName); 		 			strcpy(theAnalysisResults->eye_image_annot[kSideBottomResult], ""); 		}  	}	CEyeDxVariable *theReportNameVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableREPORTNAME));		if (theReportNameVariable)		theReportNameVariable->SetValue(theAnalysisResults->ReportName);	ReportOutput(theWindow, theAnalysisResults, theReportFormat, theVariableList, 				 theOptionalReportText, theOptionalReportTextSize,				 theNumOptionalReportText);}		/*********************************************************		** Takes in a single image (filename).	Produces a report,		** saying whether or not reliable eye models were found.		** If they were found, then the eye models, and classif.s		** for strabisumus, red reflex lumin, and any abnormal		** red reflex areas, are returned.		** This routine also writes out annotated image files.		** Returns 0 on analysis failure, 1 on success.		*********************************************************/int ProcessImage(char					*filename,		/* input filename */				int						OrientationFlag,	/* input:	0 => up, 1 => left, 2 => right */				char					*report_name,				char					*session_name,				resultsStruct			*resultsData,				int						,					/* input:	write out full-size images? */				int						,					/* input:	write out raw zoomed eyes? */				long					FocusPosition,		// Used to detect pupil size				EyeDxReportFormat		theReportFormat,	// Used to determine how to scale the images				CEyeDxWindowType		*theWindow,			// Object to display error messages				CEyeDxViewType			*theViewObject,		// The view object to draw into			 	CEyeDxProgressType		*theThermometer,	/* Control object that displays progress */				CEyeDxCaptionType		*theCaption)		// The text caption to update as we process{	char		text[300], savepath[300], savefile[300];	unsigned char	*Raw, *threshimage, *dispimage;	int			i, ROWS, COLS, temp, RetCode;	int			*points, one = 0, two = 0;						// init to 0 for failure case	double		**red_circles, *red_spacings;	double		*red_gradients, *red_residuals;	double		**white_circles, *white_spacings;	double		*white_gradients, *white_residuals;	double		*white_red_radii;	int			*corneal_reflex_indices1;	int			total_cr1 = 0;			// init to 0 for failure case	int			*corneal_reflex_indices2;	int			total_cr2 = 0;			// init to 0 for failure case	int			*abnormal_red_reflex_indices1;	int			total_arr1 = 0;			// init to 0 for failure case	int			*abnormal_red_reflex_indices2;	int			total_arr2 = 0;			// init to 0 for failure case	double		temp_d;	int			red_reflex_avg1[3],red_reflex_avg2[3];#ifndef macintosh	HANDLE		hFind;	WIN32_FIND_DATA	fd;#endif		// First, initialize the circle arrays to zero		for (int i = 0; i < 4; i++)	{		resultsData->lefteye_circles[i] = 0.0;		resultsData->righteye_circles[i] = 0.0;	}	/*********************************************************	** All reports start out not available	*********************************************************/	resultsData->strabismus = NOT_AVAILABLE;	resultsData->red_reflex_lumin = NOT_AVAILABLE;	resultsData->left_arr_class = NOT_AVAILABLE;	resultsData->right_arr_class = NOT_AVAILABLE;	resultsData->right_arr_row = -1;	resultsData->right_arr_col = -1;	resultsData->left_arr_row = -1;	resultsData->left_arr_col = -1;	resultsData->pupil_threshold = 0.0;	resultsData->pupil_to_pupil_dist = 0.0;	resultsData->pupils_horizon_angle = 0.0;	resultsData->lefteye_cr_point = -1;	resultsData->righteye_cr_point = -1;	strcpy(resultsData->fail_text,"");	resultsData->total_points = 0;	resultsData->total_circles = 0;		/*********************************************************	** Get memory dynamically -- it's a bunch	*********************************************************/	if ((points=(int *)calloc(MAX_BRIGHTS,sizeof(int))) == NULL	||		(red_circles=(double **)calloc(MAX_BRIGHTS,sizeof(double *))) == NULL	||		(red_spacings=(double *)calloc(MAX_BRIGHTS,sizeof(double))) == NULL	||		(red_gradients=(double *)calloc(MAX_BRIGHTS,sizeof(double))) == NULL	||		(red_residuals=(double *)calloc(MAX_BRIGHTS,sizeof(double))) == NULL	||		(white_circles=(double **)calloc(MAX_BRIGHTS,sizeof(double *))) == NULL	||		(white_spacings=(double *)calloc(MAX_BRIGHTS,sizeof(double))) == NULL	||		(white_gradients=(double *)calloc(MAX_BRIGHTS,sizeof(double))) == NULL	||		(white_residuals=(double *)calloc(MAX_BRIGHTS,sizeof(double))) == NULL	||		(white_red_radii=(double *)calloc(MAX_BRIGHTS,sizeof(double))) == NULL ||		(corneal_reflex_indices1 = (int *)calloc(400, sizeof(int))) == NULL ||		(corneal_reflex_indices2 = (int *)calloc(400, sizeof(int))) == NULL ||		(abnormal_red_reflex_indices1 = (int *)calloc(4000, sizeof(int))) == NULL ||		(abnormal_red_reflex_indices2 = (int *)calloc(4000, sizeof(int))) == NULL)	{  		StopAlert(theWindow, CommonStringLiteral_("ProcessImage(): Unable to allocate memory"));		std::exit(0);	}	for (i=0; i<MAX_BRIGHTS; i++)	{		red_circles[i]=(double *)calloc(3,sizeof(double));		white_circles[i]=(double *)calloc(3,sizeof(double));	}	/*********************************************************	** Get image ready to process -- load used to happen here,	** but with GUI interface, just copy for display	*********************************************************/	StripFilename(filename,text);	if (OrientationFlag == 0)	{		Raw=up_image;		ROWS=UP_ROWS;		COLS=UP_COLS;	}	else	{		Raw=side_image;		ROWS=SIDE_ROWS;		COLS=SIDE_COLS;	}		resultsData->cols = COLS;	#ifndef macintosh	threshimage=(unsigned char *)calloc(ROWS*COLS,1);#else	Handle dispHandle;	Handle threshHandle;	OSErr theErr;	threshHandle = ::TempNewHandle(ROWS*COLS, &theErr);	if (theErr != noErr || threshHandle == NULL)	{		::ParamText("\pUnable to allocate memory.", "\pProcessImage() threshimage.", Str_Empty, Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);		std::exit(0);	}		// Lock the handle so we can dereference it and simulate the raw pointer that's used in 	// the PC version	::HLock(threshHandle);	threshimage = (unsigned char *) *threshHandle;	#endif	if (DisplayGraphics == 1)#ifndef macintosh		dispimage=(unsigned char *)calloc(ROWS*COLS*3,1);#else	{		OSErr theErr;		dispHandle = ::TempNewHandle(ROWS*COLS*3, &theErr);		if (theErr != noErr || dispHandle == NULL)		{			::ParamText("\pUnable to allocate memory.", "\pProcessImage() dispimage.", Str_Empty, Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);			exit(0);		}				// Lock the handle so we can dereference it and simulate the raw pointer that's used in 		// the PC version		::HLock(dispHandle);		dispimage = (unsigned char *) *dispHandle;	}#endif	else		dispimage=NULL;	if (threshimage == NULL	||	(DisplayGraphics == 1	&&	dispimage == NULL))	{  		StopAlert(theWindow, CommonStringLiteral_("ProcessImage(): Unable to allocate memory 2"));		std::exit(0);	}	if (DisplayGraphics == 1)	{		for (i=0; i<ROWS*COLS*3; i++)			dispimage[i]=Raw[i]/2;  		theViewObject->SetImageFromRaw24Bit(dispimage,ROWS,COLS);	}		CEyeDxShortStringType firstString = text;	CEyeDxShortStringType theCaptionText = "Analyzing image ";	theCaptionText += firstString;		SetCaptionText(theCaption, theCaptionText);	// Show the progress bar and update it as we process the images, so that the user has some	// feedback that something is happening when animation is off on slow systems. Note that the	// progress bar starts off as a Indeterminate style bar, since we don't know how many circles	// are going to be found. So until we pass the FindBrightSpots function, we just show something	// is happening. Once we get past there, we then set the bar to a Measured type, and show the	// progress of analyzing the found bright spots, from 0 to total_points. Finally, once that	// is complete, we reset to go from 0 to 100%.		// However, Windows does not have an indeterminate style progress bar. So we set the bar here 	// to show incrementing progress during the evaluation of the bright spots that were found. 	// On the Mac, the bar will show the moving barber-pole.	SetThermometerValues(theThermometer, 0L, 100L, 0L);	SetThermometerMode(theThermometer, true);	// true is indeterminate	/*********************************************************	** Find eye models -- corneal reflexes (CRs) modeled by	** blobs, followed by pupil and iris boundaries modeled	** by concentric circles.	*********************************************************/		i=FindBrightSpots(Raw,ROWS,COLS,threshimage, &resultsData->total_points, points, theThermometer);	if (i == 0)	{  		strcpy(resultsData->fail_text,"Image too dark or too bright.");		RetCode = 0;		goto end;	/* too many bright spots */	}	// Now that we have a specific number of items to evaluate (total_points), we can set	// the progress bar to reflect the range of 0..total_points, and switch to a measured	// display mode.		SetThermometerMode(theThermometer, false);	// false is measured		// The thermometer doesn't necessarily like the minimum and maximum values to be the same		if (resultsData->total_points == 0)		SetThermometerValues(theThermometer, 0L, 1, 0L);	else		SetThermometerValues(theThermometer, 0L, resultsData->total_points, 0L);	FindCircles(Raw,ROWS,COLS,dispimage,points, resultsData->total_points,								red_circles,red_gradients,red_spacings,red_residuals,white_circles,								white_red_radii,white_gradients,white_spacings,white_residuals,								theThermometer, theViewObject);	resultsData->total_circles=BestTwoCircles(points,COLS,resultsData->total_points,red_circles,red_gradients,								red_spacings,red_residuals,white_circles,white_red_radii,								white_gradients,white_spacings,white_residuals,&one,&two);	// Reset the progress bar to show 0-100% complete for the remaining steps		SetThermometerValues(theThermometer, 0L, 100L, 0L);	if (resultsData->total_circles < 2)	{  		strcpy(resultsData->fail_text,"Pair of eyes could not be located.");		RetCode = 0;		goto end;	/* no eyes, no report */	}	if (DisplayGraphics == 1)	{		for (i=0; i<ROWS*COLS*3; i++)			dispimage[i]=Raw[i]/2;		theViewObject->SetImageFromRaw24Bit(dispimage,ROWS,COLS);		FlashCircles(dispimage,ROWS,COLS,						red_circles[one][2] >= 0.0 ? red_circles[one] : white_circles[one],						red_circles[two][2] >= 0.0 ? red_circles[two] : white_circles[two],						theViewObject);								for (i=0; i<ROWS*COLS*3; i++)			dispimage[i]=Raw[i];					// We reset the display image so that it becomes brighter after the circles function				theViewObject->SetImageFromRaw24Bit(dispimage,ROWS,COLS);			}	/*********************************************************	** Test resulting eye model pair.	Red circles must be	** minimum strength, minimum spacing (of points in circle).	** Eyes must not be overlapping, and must have tolerable	** angle of inclination with user-given orientation.	*********************************************************/	if (red_residuals[one] > 0.0)	{		resultsData->lefteye_circles[0]=red_circles[one][0];		resultsData->lefteye_circles[1]=red_circles[one][1];		resultsData->lefteye_circles[2]=red_circles[one][2];		resultsData->lefteye_circles[3]=white_red_radii[one];	}	else	{		resultsData->lefteye_circles[0]=white_circles[one][0];		resultsData->lefteye_circles[1]=white_circles[one][1];		resultsData->lefteye_circles[2]=-1.0;		resultsData->lefteye_circles[3]=white_circles[one][2];	}	resultsData->lefteye_cr_point=points[one];	if (red_residuals[two] > 0.0)	{		resultsData->righteye_circles[0]=red_circles[two][0];		resultsData->righteye_circles[1]=red_circles[two][1];		resultsData->righteye_circles[2]=red_circles[two][2];		resultsData->righteye_circles[3]=white_red_radii[two];	}	else	{		resultsData->righteye_circles[0]=white_circles[two][0];		resultsData->righteye_circles[1]=white_circles[two][1];		resultsData->righteye_circles[2]=-1.0;		resultsData->righteye_circles[3]=white_circles[two][2];	}	resultsData->righteye_cr_point=points[two];	resultsData->pupil_to_pupil_dist = sqrt((double)(SQR(resultsData->lefteye_circles[0]-resultsData->righteye_circles[0])+									  				 SQR(resultsData->lefteye_circles[1]-resultsData->righteye_circles[1])));	if (OrientationFlag == 0)	/* up-image */		resultsData->pupils_horizon_angle=atan2(fabs(resultsData->lefteye_circles[1]-resultsData->righteye_circles[1]),								   fabs(resultsData->lefteye_circles[0]-resultsData->righteye_circles[0]));	else				/* side image, right or left */		resultsData->pupils_horizon_angle=atan2(fabs(resultsData->lefteye_circles[0]-resultsData->righteye_circles[0]),								   fabs(resultsData->lefteye_circles[1]-resultsData->righteye_circles[1]));	if (resultsData->pupil_to_pupil_dist < resultsData->lefteye_circles[3]	||		resultsData->pupil_to_pupil_dist < resultsData->righteye_circles[3]	||		resultsData->pupils_horizon_angle > 30.0*M_PI/180.0)	{ 		strcpy(resultsData->fail_text,"Eye orientation not consistent, or background may be confusing analysis.");		RetCode = 0;		goto end;	/* reliable eye models not found */	}	// The following is not implemented - it was an attempt to detect flipped images. But based on examining NC State Fair	// images, most images have the eyes more or less centered. If the image were flipped, the eyes would still be close to the 	// center, and we couldn't distinguish between a good image with eyes just to the right of center vs. a flipped image with	// eyes just to the left of center.	#if FALSE	// Check to see if the Side eyes are in a reasonable location. This means that the X component of the eye circles for the	// Side image should be less than half of the image width. This is just a warning, since it is possible that the image is	// oriented properly (i.e. face shifted to the right) putting the eyes on the right side of the image.		if (OrientationFlag != 0)	{		if ((resultsData->lefteye_circles[0] > (COLS / 2)) || (resultsData->righteye_circles[0] > (COLS / 2)))			CautionAlert(theWindow, CommonStringLiteral_("The eyes in the Side image appear to be too far to the right. Make sure that the top of the subject's head is on the left side of the image. Processing will continue."));	}#endif		// These constants were derived from actual camera measurements by Adam Hoover.		// If we have a valid DC120PictInfo structure, then we can use this formula. Otherwise, we use	// the default value of 7.5 mm		const double pupil_default	= 7.5;	const double pupil_dt 		= 3.5;	const double pupil_m 		= -0.00343;	const double pupil_b 		= 8.855;	if (FocusPosition > 0)		resultsData->pupil_threshold = (pupil_dt * (pupil_m * (double)(FocusPosition) + pupil_b)) / 2.0;	else		resultsData->pupil_threshold = pupil_default;	if (resultsData->lefteye_circles[2]  < resultsData->pupil_threshold || 	    resultsData->righteye_circles[2] < resultsData->pupil_threshold)	{	     strcpy(resultsData->fail_text,"Eyes insufficiently dilated.\nSubject needs to be in a darkened room for a longer period.");	     RetCode = 0;	     goto end;	/* reliable eye models not found */	}		SetThermometerValue(theThermometer, 20L);	/*********************************************************	** Switch left and right eye models if not in proper place	*********************************************************/	if ((OrientationFlag == 0	&&	resultsData->lefteye_circles[0] < resultsData->righteye_circles[0])	||		(OrientationFlag == 1	&&	resultsData->lefteye_circles[1] > resultsData->righteye_circles[1])	||		(OrientationFlag == 2	&&	resultsData->lefteye_circles[1] < resultsData->righteye_circles[1]))	{	/* switch left and right eye to proper places */		for (i=0; i<4; i++)		{			temp_d = resultsData->lefteye_circles[i];			resultsData->lefteye_circles[i] = resultsData->righteye_circles[i];			resultsData->righteye_circles[i] = temp_d;		}		temp = resultsData->lefteye_cr_point;		resultsData->lefteye_cr_point = resultsData->righteye_cr_point;		resultsData->righteye_cr_point = temp;	}	/*********************************************************	** Classify pupil interior.	This finds any abnormal areas	** in the red reflexes, and classifies them.	It also	** classifies any possible strabismus, and decides if	** the red reflexes have equal luminensce.	*********************************************************/		SetThermometerValue(theThermometer, 40L);	ClassifyPupilInterior(Raw,							threshimage,							dispimage,							ROWS,							COLS,							&resultsData->lefteye_circles[0],							resultsData->lefteye_cr_point,							corneal_reflex_indices1,							&total_cr1,							abnormal_red_reflex_indices1,							&total_arr1,							red_reflex_avg1,							&resultsData->left_arr_class,							&resultsData->left_arr_col,							&resultsData->left_arr_row, 							theViewObject);	SetThermometerValue(theThermometer, 60L);	ClassifyPupilInterior(Raw,							threshimage,							dispimage,							ROWS,							COLS,							&resultsData->righteye_circles[0],							resultsData->righteye_cr_point,							corneal_reflex_indices2,							&total_cr2,							abnormal_red_reflex_indices2,							&total_arr2,							red_reflex_avg2,							&resultsData->right_arr_class, 							&resultsData->right_arr_col, 							&resultsData->right_arr_row, 							theViewObject);	SetThermometerValue(theThermometer, 80L);	if (resultsData->lefteye_circles[2] > 0.0  &&  resultsData->righteye_circles[2] > 0.0)	{	  	temp=(abs(red_reflex_avg1[0]-red_reflex_avg2[0])+		  	abs(red_reflex_avg1[1]-red_reflex_avg2[1])+		  	abs(red_reflex_avg1[2]-red_reflex_avg2[2]))/3;	 	if (temp <= MAX_LUMIN_DIFF)	  	{	    	resultsData->red_reflex_lumin=NORMAL;		}	  	else		{	    	resultsData->red_reflex_lumin=UNEQUAL_LUMIN;		}	}	else if (resultsData->lefteye_circles[2] > 0.0  ||  resultsData->righteye_circles[2] > 0.0)	{	  resultsData->red_reflex_lumin=UNEQUAL_LUMIN;	}	else	{	  resultsData->red_reflex_lumin=NOT_DETECTED;	  strcpy(resultsData->fail_text,"Eyes insufficiently dilated.\nSubject needs to be in a darkened room for a longer period.");	  RetCode=0;	/* no RR detected for both eyes */	  goto end;	}	ClassifyPupilAlignment(&resultsData->lefteye_circles[0],							corneal_reflex_indices1,							total_cr1,							&resultsData->righteye_circles[0],							corneal_reflex_indices2,							total_cr2,							COLS,							OrientationFlag,							&resultsData->strabismus);	if (resultsData->strabismus == NOT_LOOKING)	{	  	strcpy(resultsData->fail_text,"Improper analysis due to poor fixation or other causes.");	  	RetCode=0;	/* CR alignment off for both eyes */	  	goto end;	}	SetThermometerValue(theThermometer, 100L);	RetCode = 1;	// successful report		/*********************************************************	** Write out images for report	*********	************************************************/end:	// We determine how much to scale the images based on the report format. The	// images must be pre-scaled, because Netscape, at least, hoses scaling images	// when printing. Thus, the image referred-to in the report must match the	// pixel sizes given in the HTML for width and height.		float SimageScale;	float eyeScale;		switch (theReportFormat)	{	case kStandardReportFormat:		SimageScale = 4.0;		eyeScale = 1.0;		break;	case kCustomReportFormat1:			// We scale the images differently depending on whether we are using the old style report with		// raw and annotated eyes, or the newer report with just the annotated eyes.				if (AdvancedFeatures)		{			SimageScale = 10.0;			eyeScale = 1.3;		}		else		{			SimageScale = 6.0;			eyeScale = 1.0;		}		break;	}	char *orientationChar;		switch (OrientationFlag)	{	case 0:		orientationChar = "U";		break;			case 1:		orientationChar = "S";		break;			case 2:		orientationChar = "S";		break;      				}         // We pull out the last two digits of the input file name, and use that in the filenames    // to make them more unique.    	char lastTwoDigits[3];		lastTwoDigits[0] = filename[strlen(filename) - 2];	lastTwoDigits[1] = filename[strlen(filename) - 1];	lastTwoDigits[2] = '\0';#ifndef macintosh	free(threshimage);	if (DisplayGraphics == 1)		free(dispimage);	// Check to see if we are saving the full raw image		sprintf(savepath,"%s%s\\Simages", DataPath, session_name);	if ((hFind=FindFirstFile(savepath,&fd)) == INVALID_HANDLE_VALUE)		strcpy(savepath, ".\\");	FindClose(hFind);		sprintf(savefile,"%s\\%s%s%s%s",savepath, report_name, lastTwoDigits, orientationChar, "sc.jpg");		SaveImage(savefile,Raw,ROWS,COLS, SimageScale, theWindow, theThermometer, theCaption);	sprintf(savepath,"%s%s\\eyes", DataPath, session_name);	if ((hFind=FindFirstFile(savepath,&fd)) == INVALID_HANDLE_VALUE)		strcpy(savepath, ".\\");	FindClose(hFind);		strcat(savepath, "\\"); #else 		// Get rid of the threshold image and the display image before calling the Save and	// WriteImage routines - they are no longer needed, and that will save 4.8 MB of RAM	// at the peak. WriteImage allocates another image to annotate anyway.		::HUnlock(threshHandle);	::DisposeHandle(threshHandle);	if (DisplayGraphics == 1)	{		::HUnlock(dispHandle);		::DisposeHandle(dispHandle);	}	sprintf(savefile, ":%s:Simages:%s%s%s%s", session_name, report_name, lastTwoDigits, orientationChar, "sc.jpg");		SaveImage(savefile,Raw,ROWS,COLS, SimageScale, theWindow, theThermometer, theCaption);		sprintf(savepath, ":%s:eyes:", session_name);#endif	// We only write the eye images if we didn't skip analysis. This avoids various	// problems with the WriteImage routine using uninitialized variables.	// Note that the raw eye images are written only if we have turned on the AdvancedFeatures	// flag for debugging.		if (RetCode)		WriteImage(savepath, 					report_name, 					lastTwoDigits, 					Raw,					ROWS,					COLS,					resultsData->lefteye_circles,					corneal_reflex_indices1,					total_cr1,					abnormal_red_reflex_indices1,					total_arr1,					resultsData->left_arr_class,					resultsData->righteye_circles,					corneal_reflex_indices2,					total_cr2,					abnormal_red_reflex_indices2,					total_arr2,					resultsData->right_arr_class,					OrientationFlag,					0,					(RetCode & AdvancedFeatures),					RetCode, 					eyeScale, 					theWindow, 					theThermometer, 					theCaption);	/*********************************************************	** Free up dynamic memory	*********************************************************/		for (i=0; i<MAX_BRIGHTS; i++)	{		free(red_circles[i]);		free(white_circles[i]);	}	free(points);	free(red_circles);	free(red_spacings);	free(red_gradients);	free(red_residuals);	free(white_circles);	free(white_spacings);	free(white_gradients);	free(white_residuals);	free(white_red_radii);	free(corneal_reflex_indices1);	free(corneal_reflex_indices2);	free(abnormal_red_reflex_indices1);	free(abnormal_red_reflex_indices2);		SetCaptionText(theCaption, EMPTYSTR);	return(RetCode);}