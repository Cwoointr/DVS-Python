// MainFrm.cpp : implementation of the CMainFrame class//#include "stdafx.h"#include "SdkTest1.h"#include "MainFrm.h"  //**************************************************** // + Ohbe#include "dialog.h"#include "property.h"#ifdef DC50Include#ifndef _50FUNC_H_#include "dc50func.h"#endif#ifndef _50PROPATY_H_#include "dc50prop.h"#endif#endif // - Ohbe//****************************************************#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILEstatic char THIS_FILE[] = __FILE__;#endif //**************************************************** // + Ohbe #ifdef ALLSTAR#define DCProgressProc		KDCProgressProc#define DCImageIOProc		KDCImageIOProc#define DCImageIOCB			KDCImageIOCB#define DCImageIOCBPtr		KDCImageIOCBPtr#define DCImgProcData		KDCImgProcData#define DCImgProcDataPtr	KDCImgProcDataPtr#define DCOutputWindow		KDCOutputWindow#define DCOutputWindowPtr	KDCOutputWindowPtr#define DCStatus			KDCStatus#define DCStatusPtr			KDCStatusPtr#define DCDriver			KDCDriver#define DCDriverPtr			KDCDriverPtr#define DCCamera			KDCCamera#define DCCameraPtr			KDCCameraPtr#define DCProgressCB		KDCProgressCB#define DCProgressCBPtr		KDCProgressCBPtr#define DCXYChroma			KDCXYChroma#define DCCRTData			KDCCRTData#define DCOpenDriver			KDCOpenDriver#define DCCloseDriver			KDCCloseDriver#define DCOpenCamera			KDCOpenCamera#define DCCloseCamera			KDCCloseCamera#define DCGetStatus				KDCGetStatus#define DCGetConfig				KDCGetConfig#define DCSetConfig				KDCSetConfig#define DCGetImageProcessing	KDCGetImageProcessing#define DCSetImageProcessing	KDCSetImageProcessing#define DCGetOutputWindow		KDCGetOutputWindow#define DCSetOutputWindow		KDCSetOutputWindow#define DCTakePicture			KDCTakePicture#define DCDeletePicture			KDCDeletePicture#define DCCopyMemToCard			KDCCopyMemToCard#define DCGetCameraPictInfo		KDCGetCameraPictInfo#define DCGetNativeCameraType	KDCGetNativeCameraType#define DCGetNativePictInfo		KDCGetNativePictInfo#define DCGetCameraPicture		KDCGetCameraPicture#define DCGetNativePicture		KDCGetNativePicture#define DCProcNativePicture		KDCProcNativePicture#endif// - Ohbe//****************************************************/////////////////////////////////////////////////////////////////////////////// CMainFrameIMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)	//{{AFX_MSG_MAP(CMainFrame)		// NOTE - the ClassWizard will add and remove mapping macros here.		//    DO NOT EDIT what you see in these blocks of generated code !	ON_WM_CREATE() //**************************************************** // + Ohbe	ON_COMMAND(ID_DCOpenDriver, OnDCOpenDriver)	ON_COMMAND(ID_DCOpenCamera, OnDCOpenCamera)	ON_COMMAND(ID_DCCloseDriver, OnDCCloseDriver)	ON_COMMAND(ID_DCCloseCamera, OnDCCloseCamera)	ON_COMMAND(ID_DCGetStatus, OnDCGetStatus)	ON_COMMAND(ID_DCGetConfig, OnDCGetConfig)	ON_COMMAND(ID_DCSetConfig, OnDCSetConfig)#ifdef DC50Include	ON_COMMAND(ID_DCResetCamera, OnDCResetCamera)	ON_COMMAND(ID_DCPreviewGetInfo, OnDCPreviewGetInfo)	ON_COMMAND(ID_DCPreviewGetPicture, OnDCPreviewGetPicture)	ON_COMMAND(ID_DCPreviewStore, OnDCPreviewStore)	ON_COMMAND(ID_DCPreviewErase, OnDCPreviewErase)#endif#ifdef DC120Include	ON_COMMAND(ID_DCAlbumGetAvailable, OnDCAlbumGetAvailable)	ON_COMMAND(ID_DCAlbumSetAvailable, OnDCAlbumSetAvailable)	ON_COMMAND(ID_DCAlbumSetActive, OnDCAlbumSetActive)	ON_COMMAND(ID_DCAlbumGetAllName, OnDCAlbumGetAllName)	ON_COMMAND(ID_DCAlbumErase, OnDCAlbumErase)	ON_COMMAND(ID_DCAlbumChangeName, OnDCAlbumChangeName)	ON_COMMAND(ID_DCAlbumMoveImage, OnDCAlbumMoveImage)// + Ogawa	ON_COMMAND(ID_DCAlbumGetPictureName, OnDCAlbumGetPictureName)	ON_COMMAND(ID_DCGetCameraPictureAsJPEG, OnDCGetCameraPictureAsJPEG)	ON_COMMAND(ID_DCProcNativePictureAsJPEG, OnDCGetNativePictureAsJPEG)// - Ogawa#endif	ON_COMMAND(ID_DCTakePicture, OnDCTakePicture)	ON_COMMAND(ID_DCDeletePicture, OnDCDeletePicture)	ON_COMMAND(ID_DCCopyMemToCard, OnDCCopyMemToCard)	ON_COMMAND(ID_DCGetImageProcessing, OnDCGetImageProcessing)	ON_COMMAND(ID_DCSetImageProcessing, OnDCSetImageProcessing)	ON_COMMAND(ID_DCGetOutputWindow, OnDCGetOutputWindow)	ON_COMMAND(ID_DCSetOutputWindow, OnDCSetOutputWindow)	ON_COMMAND(ID_DCGetCameraPictInfo, OnDCGetCameraPictInfo)	ON_COMMAND(ID_DCGetNativePictInfo, OnDCGetNativePictInfo)	ON_COMMAND(ID_DCGetNativeCameraType, OnDCGetNativeCameraType)	ON_COMMAND(ID_DCGetCameraPicture, OnDCGetCameraPicture)	ON_COMMAND(ID_DCGetNativePicture, OnDCGetNativePicture)	ON_COMMAND(ID_DCProcNativePicture, OnDCProcNativePicture) // - Ohbe//****************************************************	//}}AFX_MSG_MAPEND_MESSAGE_MAP()  //**************************************************** // + Ohbe // toolbar buttons - IDs are command buttonsconst static UINT BASED_CODE buttons[] ={	// same order as in the bitmap 'toolbar.bmp'	ID_DCOpenCamera,	ID_DCCloseCamera,		ID_SEPARATOR,	ID_DCGetStatus,	ID_DCGetConfig,	ID_DCSetConfig,		ID_SEPARATOR,	ID_DCTakePicture,	ID_DCDeletePicture,		ID_SEPARATOR,	ID_DCGetCameraPictInfo,	ID_DCGetCameraPicture,	ID_DCGetNativePicture,		ID_SEPARATOR,	ID_DCProcNativePicture,	ID_DCGetNativeCameraType,	ID_DCGetNativePictInfo,		ID_SEPARATOR,	ID_APP_ABOUT};// - Ohbe//**************************************************** //**************************************************** // + Ohbe   // This is the special status bar implementation.#define		kPANE_CANCEL		1						// the ID number of cancel panel in the status bar. #define		kPANE_BAR			2						// the ID number of image processing bar panel in the status bar.static UINT indicators[] ={	ID_SEPARATOR,          	ID_SEPARATOR,          	ID_SEPARATOR,          }; // - Ohbe//****************************************************/////////////////////////////////////////////////////////////////////////////// CMainFrame construction/destruction //**************************************************** // + Ohbe Many writet4 is applyed to the MainFrame.  CMainFrame::CMainFrame(){	// TODO: add member initialization code here	m_pDither=NULL;	theApp.m_pWndFrame = this;}CMainFrame::~CMainFrame(){	if(m_pDither!=NULL){		delete m_pDither;		m_pDither=NULL;	}}int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct){	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)		return -1;	//****************************************************// + Ohbe/*	if (!m_wndToolBar.Create(this) ||		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))	{		TRACE0("Failed to create toolbar\n");		return -1;      // fail to create	}	if (!m_wndStatusBar.Create(this) ||		!m_wndStatusBar.SetIndicators(indicators,		  sizeof(indicators)/sizeof(UINT)))	{		TRACE0("Failed to create status bar\n");		return -1;      // fail to create	}*/ 	if (!m_wndToolBar.Create(this) ||		!m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||		!m_wndToolBar.SetButtons(buttons,		  sizeof(buttons)/sizeof(UINT))){		TRACE("Failed to create toolbar\n");		return -1;      // fail to create	}	if (!m_wndStatusBar.Create(this) ||		!m_wndStatusBar.SetIndicators(indicators,		  sizeof(indicators)/sizeof(UINT))){		TRACE("Failed to create status bar\n");		return -1;      // fail to create	}	m_wndStatusBar.SetPaneInfo(kPANE_CANCEL, ID_SEPARATOR, SBPS_NOBORDERS, 1); 			// cancel button	m_wndStatusBar.SetPaneInfo(kPANE_BAR,    ID_SEPARATOR, SBPS_NORMAL,  100);			// waiting status bar to transfer image.	m_PercentBMP.LoadBitmap(IDB_PERDATA);// - Ohbe//****************************************************	// TODO: Remove this if you don't want tool tips or a resizeable toolbar	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);	// TODO: Delete these three lines if you don't want the toolbar to	//  be dockable	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);	EnableDocking(CBRS_ALIGN_ANY);	DockControlBar(&m_wndToolBar);//****************************************************// + Ohbe 	if(m_pDither==NULL){		m_pDither=new CDither;		if(m_pDither!=NULL){			if(m_pDither->CreatePalette(this)==FALSE){				delete m_pDither;				m_pDither=NULL;			}		}	}// - Ohbe//****************************************************	return 0;}BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs){	// TODO: Modify the Window class or styles here by modifying	//  the CREATESTRUCT cs	return CFrameWnd::PreCreateWindow(cs);}/////////////////////////////////////////////////////////////////////////////// CMainFrame diagnostics#ifdef _DEBUGvoid CMainFrame::AssertValid() const{	CFrameWnd::AssertValid();}void CMainFrame::Dump(CDumpContext& dc) const{	CFrameWnd::Dump(dc);}#endif //_DEBUG/////////////////////////////////////////////////////////////////////////////// CMainFrame message handlers        //**************************************************** // + Ohbe// Newly Added methods. // - Ohbe//****************************************************short CMainFrame::MakeBitmap(ImageStruct& ImageInfo){	short	PalletSize;	short	count;	BOOL	GrayFlag,UseDitherFlag;	ImageInfo.hBitmap=NULL;	if(ImageInfo.BitCount==8){		GrayFlag=TRUE;	}	else{		GrayFlag=FALSE;	}	if(m_pDither==NULL){		UseDitherFlag=FALSE;	}	else{		UseDitherFlag=TRUE;		ImageInfo.BitCount=8;	}	if(ImageInfo.BitCount==8){		PalletSize=sizeof(RGBQUAD)*256;	}	else{		PalletSize=0;	}	ImageInfo.BmpInfoSize=sizeof(BITMAPINFOHEADER)+PalletSize;	ImageInfo.lpBitmapInfo=(LPBITMAPINFOHEADER)GlobalAllocPtr(GHND,(DWORD)ImageInfo.BmpInfoSize);	if(ImageInfo.lpBitmapInfo!=NULL){		ImageInfo.lpBitmapInfo->biSize=sizeof(BITMAPINFOHEADER);		ImageInfo.lpBitmapInfo->biWidth=(long)ImageInfo.PictureWidth;		ImageInfo.lpBitmapInfo->biHeight=(long)ImageInfo.PictureHeight;		ImageInfo.lpBitmapInfo->biPlanes=1;		ImageInfo.lpBitmapInfo->biBitCount=ImageInfo.BitCount;		ImageInfo.lpBitmapInfo->biCompression=BI_RGB;		ImageInfo.lpBitmapInfo->biSizeImage=0;		ImageInfo.lpBitmapInfo->biXPelsPerMeter=0;		ImageInfo.lpBitmapInfo->biYPelsPerMeter=0;		ImageInfo.lpBitmapInfo->biClrUsed=0;		ImageInfo.lpBitmapInfo->biClrImportant=0;		if(UseDitherFlag){			if(GrayFlag){				m_pDither->MakeDitherThumbnail(ImageInfo.lpBitmapInfo,ImageInfo.pPicture,ImageInfo.pPicture,ImageInfo.PictureWidth,ImageInfo.PictureHeight);			}			else{				LPVOID	pDitherImage;				pDitherImage=GlobalAllocPtr(GHND,(DWORD)(ImageInfo.PictureWidth+3)/4*4*ImageInfo.PictureHeight);//				pDitherImage=GlobalAllocPtr(GHND,(DWORD)(ImageInfo.PictureWidth+3)/4*4*ImageInfo.PictureHeight/3);				m_pDither->MakeDitherImage(ImageInfo.lpBitmapInfo,ImageInfo.pPicture,pDitherImage,ImageInfo.PictureWidth,ImageInfo.PictureHeight);				GlobalFreePtr(ImageInfo.pPicture);				ImageInfo.pPicture=(HCHARPTR)pDitherImage;				ImageInfo.BmpPictureSize=(DWORD)(ImageInfo.PictureWidth+3)/4*4*ImageInfo.PictureHeight/3;							}		}		else{			if(PalletSize!=0){				RGBQUAD huge*	hpRGBQUAD;				hpRGBQUAD=(RGBQUAD huge*)((BYTE huge*)ImageInfo.lpBitmapInfo+sizeof(BITMAPINFOHEADER));				for(count=0;count < 256;count++){					hpRGBQUAD->rgbBlue =(BYTE)count;					hpRGBQUAD->rgbGreen=(BYTE)count;					hpRGBQUAD->rgbRed  =(BYTE)count;					hpRGBQUAD->rgbReserved=0;					hpRGBQUAD++;				}			}		}		HDC			hDC=::GetDC(m_hWnd);		HPALETTE	hOldPalette=NULL;		if(UseDitherFlag){			hOldPalette=::SelectPalette(hDC,(HPALETTE)m_pDither->GetSafeHandle(),FALSE);			::RealizePalette(hDC);		}		ImageInfo.hBitmap=CreateDIBitmap(hDC,ImageInfo.lpBitmapInfo,						CBM_INIT,ImageInfo.pPicture,(BITMAPINFO far*)ImageInfo.lpBitmapInfo,						DIB_RGB_COLORS);		if(hOldPalette!=NULL){			::SelectPalette(hDC,hOldPalette,FALSE);		}		::ReleaseDC(m_hWnd,hDC);		Invalidate();	}	if(ImageInfo.hBitmap==NULL){		return(FALSE);	}	return(TRUE);}void CMainFrame::DispResult(){	CString	StatusMessage;	int		MessageStingID;	if(m_TestAppErrorCode==kNoErr){		switch(m_SDKRetValue){			case DC_NoErr:				MessageStingID=IDS_SDKNoErr;				break;			case DC_BadArgError:				MessageStingID=IDS_SDKBadArgError;				break;			case DC_BadCloseError:				MessageStingID=IDS_SDKBadCloseError;				break;			case DC_CameraNotConnected:				MessageStingID=IDS_SDKCameraNotConnected;				break;			case DC_CameraNotEmpty:				MessageStingID=IDS_SDKCameraNotEmpty;				break;			case DC_CameraFunctionNotSupported:				MessageStingID=IDS_SDKCameraFunctionNotSupported;				break;			case DC_CancelCallback:				MessageStingID=IDS_SDKCancelCallback;				break;			case DC_CardNotFound:				MessageStingID=IDS_SDKCardNotFound;				break;			case DC_CommunicationError:				MessageStingID=IDS_SDKCommunicationError;				break;			case DC_FunctionNotSupported:				MessageStingID=IDS_SDKFunctionNotSupported;				break;			case DC_ImageProcessError:				MessageStingID=IDS_SDKImageProcessError;				break;			case DC_InvalidFWError:				MessageStingID=IDS_SDKInvalidFWError;				break;			case DC_MallocError:				MessageStingID=IDS_SDKMallocError;				break;			case DC_MemoryFullError:				MessageStingID=IDS_SDKMemoryFullError;				break;			case DC_NotOpenError:				MessageStingID=IDS_SDKNotOpenError;				break;			case DC_NotROMMode:				MessageStingID=IDS_SDKNotROMMode;				break;			case DC_ReOpenError:				MessageStingID=IDS_SDKReOpenError;				break;			case DC_ROMModeError:				MessageStingID=IDS_SDKROMModeError;				break;			case DC_ROMModeOpen:				MessageStingID=IDS_SDKROMModeOpen;				break;			case DC_SDKVersionError:				MessageStingID=IDS_SDKSDKVersionError;				break;			case DC_SpecificSDKError:				MessageStingID=IDS_SDKSpecificSDKError;				break;			case DC_SystemError:				MessageStingID=IDS_SDKSystemError;				break;			// + Ogawa			case DC_CannotHandleCameraType:				MessageStingID=IDS_SDKCannotHandleCameraType;				break;			case DC_AlbumFullError:				MessageStingID=IDS_SDKAlbumFullError;				break;			// - Ogawa			default:				MessageStingID=IDS_SDKUnknownError;		}	}	else{		switch(m_TestAppErrorCode){			case kNoErr:				MessageStingID=IDS_TestAppNoError;				break;			case kMemErr:				MessageStingID=IDS_TestAppMemError;				break;			default:				MessageStingID=IDS_TestAppUnknownError;		}	}	StatusMessage.LoadString(MessageStingID);	m_wndStatusBar.SetPaneText(0,(LPCSTR)StatusMessage);}//**************************************//	Reset the info structures.//**************************************// Statusstatic const DCConfig 	InitialGenericConfig;//static const DC20Config Initial20Config;//static const DC25Config Initial25Config;// + Ogawa#ifdef DC40Includestatic const DC40Config Initial40Config;#endif#ifdef DC50Includestatic const DC50Config Initial50Config;#endif#ifdef DC120Includestatic const DC120Config Initial120Config;#endif// - Ogawavoid CMainFrame::InitConfig(DCCameraType CameraType){	if(theApp.m_pGenericConfig != NULL)		*theApp.m_pGenericConfig	= InitialGenericConfig;		//	if(CameraType == DC20 && theApp.m_pDC20FullConfig != NULL)	//		*theApp.m_pDC20FullConfig	= Initial20Config;//	if(CameraType == DC25 && theApp.m_pDC25FullConfig != NULL)	//		*theApp.m_pDC25FullConfig	= Initial25Config;	// + Ogawa	#ifdef DC40Include	if(CameraType == DC40 && theApp.m_pDC40FullConfig != NULL)			*theApp.m_pDC40FullConfig	= Initial40Config;	#endif	#ifdef DC50Include	if(CameraType == DC50 && theApp.m_pDC50FullConfig != NULL)			*theApp.m_pDC50FullConfig	= Initial50Config;	#endif	#ifdef DC120Include	if(CameraType == DC120 && theApp.m_pDC120FullConfig != NULL)			*theApp.m_pDC120FullConfig	= Initial120Config;	#endif	// - Ogawa}// Configstatic const DCStatus 	InitialGenericStatus;//static const DC20Status Initial20Status;//static const DC25Status Initial25Status;// + Ogawa#ifdef DC40Includestatic const DC40Status Initial40Status;#endif#ifdef DC50Includestatic const DC50Status Initial50Status;#endif#ifdef DC120Includestatic const DC120Status Initial120Status;#endif// - Ogawavoid CMainFrame::InitStatus(DCCameraType CameraType){	if(theApp.m_pGenericStatus != NULL)		*theApp.m_pGenericStatus	= InitialGenericStatus;//	if(CameraType == DC20 && theApp.m_pDC20FullStatus != NULL)	//		*theApp.m_pDC20FullStatus	= Initial20Status;//	if(CameraType == DC25 && theApp.m_pDC25FullStatus != NULL)	//		*theApp.m_pDC25FullStatus	= Initial25Status;	// + Ogawa	#ifdef DC40Include	if(CameraType == DC40 && theApp.m_pDC40FullStatus != NULL)			*theApp.m_pDC40FullStatus	= Initial40Status;	#endif	#ifdef DC50Include	if(CameraType == DC50 && theApp.m_pDC50FullStatus != NULL)			*theApp.m_pDC50FullStatus	= Initial50Status;	#endif	#ifdef DC120Include	if(CameraType == DC120 && theApp.m_pDC120FullStatus != NULL)			*theApp.m_pDC120FullStatus	= Initial120Status;	#endif	// - Ogawa}                                                     // PictInfo//static const DC25PictInfo 	Initial25PictInfo;   // to fill out with 0.//static const DC20PictInfo 	Initial20PictInfo;   // to fill out with 0.// + Ogawa#ifdef DC40Includestatic const DC40PictInfo 	Initial40PictInfo;   // to fill out with 0.#endif#ifdef DC50Includestatic const DC50PictInfo 	Initial50PictInfo;   // to fill out with 0.#endif#ifdef DC120Includestatic const DC120PictInfo 	Initial120PictInfo;   // to fill out with 0.#endif// - Ogawavoid CMainFrame::InitPictInfo(DCCameraType CameraType){	if(theApp.m_pGenericInfo != NULL){		theApp.m_pGenericInfo->PictNumber = 0;		theApp.m_pGenericInfo->ThumbWidth = 0;		theApp.m_pGenericInfo->ThumbHeight = 0;		theApp.m_pGenericInfo->ThumbPtr = NULL;		theApp.m_pGenericInfo->PictWidth = 0;		theApp.m_pGenericInfo->PictHeight = 0;		theApp.m_pGenericInfo->PictCompSize = 0;		theApp.m_pGenericInfo->PictMinBufIn = 150000;		theApp.m_pGenericInfo->PictMinBufOut = 0;		theApp.m_pGenericInfo->TimeStamp.tm_sec = 0;		theApp.m_pGenericInfo->TimeStamp.tm_min = 0;		theApp.m_pGenericInfo->TimeStamp.tm_hour = 0;		theApp.m_pGenericInfo->TimeStamp.tm_mday = 0;		theApp.m_pGenericInfo->TimeStamp.tm_mon = 0;		theApp.m_pGenericInfo->TimeStamp.tm_year = 0;		theApp.m_pGenericInfo->TimeStamp.tm_wday = 0;		theApp.m_pGenericInfo->TimeStamp.tm_yday = 0;		theApp.m_pGenericInfo->TimeStamp.tm_isdst = 0;	}//	if(CameraType == DC25 && theApp.m_p25FullPictInfo != NULL)	//		*theApp.m_p25FullPictInfo		= Initial25PictInfo;//	if(CameraType == DC20 && theApp.m_p20FullPictInfo != NULL)	//		*theApp.m_p20FullPictInfo		= Initial20PictInfo;	// + Ogawa	#ifdef DC40Include	if(CameraType == DC40 && theApp.m_p40FullPictInfo != NULL)			*theApp.m_p40FullPictInfo		= Initial40PictInfo;	#endif	#ifdef DC50Include	if(CameraType == DC50 && theApp.m_p50FullPictInfo != NULL)			*theApp.m_p50FullPictInfo		= Initial50PictInfo;	#endif	#ifdef DC120Include	if(CameraType == DC120 && theApp.m_p120FullPictInfo != NULL)			*theApp.m_p120FullPictInfo		= Initial120PictInfo;	#endif	// - Ogawa}SHORT CMainFrame::OpenDriver(SHORT VersionValue,BOOL IsVersionNULL,BOOL IsDriverNULL){	SHORT far*		Version;	DCDriverPtr	Driver;	m_TestAppErrorCode=kNoErr;	if(IsVersionNULL){		Version=NULL;	}	else{		Version=&VersionValue;	}	if(IsDriverNULL){		Driver=NULL;	}	else{		Driver=theApp.m_pDCDriver;	}	m_SDKRetValue=DCOpenDriver(Version,Driver);	if(m_SDKRetValue==DC_NoErr){		theApp.m_IsOpenDriver=TRUE;	}	return(VersionValue);}void CMainFrame::CloseDriver(BOOL IsDriverNULL){	DCDriverPtr	Driver;	m_TestAppErrorCode=kNoErr;	if(IsDriverNULL){		Driver=NULL;	}	else{		Driver=theApp.m_pDCDriver;	}	m_SDKRetValue=DCCloseDriver(Driver);	if(m_SDKRetValue==DC_NoErr){		theApp.m_IsOpenDriver=FALSE;	}}void CMainFrame::OpenCamera(BOOL IsCameraDataNULL){	DCCameraPtr	Camera;	m_TestAppErrorCode=kNoErr;	if(IsCameraDataNULL){		Camera=NULL;	}	else{		Camera=theApp.m_pDCCamera;	}//+kita on 10/14/97#ifdef WIN32	clock_t			start, finish;	double			duration;//	CTimeResult		Dlg;	start = clock();#endif//	for ( int c=0; c<50; c++ ) {		m_SDKRetValue=DCOpenCamera(Camera);/*		if(m_SDKRetValue!=DC_NoErr){			c = 50;			break;		}		DCStatusPtr GenericStatus = theApp.m_pGenericStatus;		DC120StatusPtr FullStatus = theApp.m_pDC120FullStatus;		m_SDKRetValue=DCGetStatus(Camera,GenericStatus,FullStatus);		if(m_SDKRetValue!=DC_NoErr){			c = 50;			break;		}		if ( c < 49 ) m_SDKRetValue=DCCloseCamera(Camera);		if(m_SDKRetValue!=DC_NoErr){			c = 50;			break;		}	}*/#ifdef WIN32	finish = clock();    duration = (double)(finish - start) / CLOCKS_PER_SEC;//	Dlg.m_SecTime.Format("%5.2f", duration );//	Dlg.DoModal();#endif//-kita on 10/14/97	if(m_SDKRetValue==DC_NoErr){		theApp.m_IsOpenCamera=TRUE;	}}void CMainFrame::CloseCamera(BOOL IsCameraDataNULL){	DCCameraPtr	Camera;	m_TestAppErrorCode=kNoErr;	if(IsCameraDataNULL){		Camera=NULL;	}	else{		Camera=theApp.m_pDCCamera;	}	m_SDKRetValue=DCCloseCamera(Camera);	if(m_SDKRetValue==DC_NoErr){		theApp.m_IsOpenCamera=FALSE;	}}#ifdef DC50Includevoid CMainFrame::ResetCamera(BOOL IsCameraDataNULL){	DCCameraPtr	Camera;	m_TestAppErrorCode=kNoErr;	if(IsCameraDataNULL){		Camera=NULL;	}	else{		Camera=theApp.m_pDCCamera;	}	m_SDKRetValue=DCResetCamera(Camera);	// + Ogawa	DispResult();	// - Ogawa}#endifvoid CMainFrame::OnDCOpenDriver(){	CDCOpenDriverDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		OpenDriver(ParamDlg.m_Version,ParamDlg.m_IsVersionNULL,ParamDlg.m_IsDriverNULL);		DispResult();	}}void CMainFrame::OnDCCloseDriver(){	CDCCloseDriverDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		CloseDriver(ParamDlg.m_IsDriverNULL);		DispResult();	}}void CMainFrame::OnDCOpenCamera(){	CDCOpenCameraDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		OpenCamera(ParamDlg.m_IsCameraDataNULL);		DispResult();	}}void CMainFrame::OnDCCloseCamera(){	CDCCloseCameraDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		CloseCamera(ParamDlg.m_IsCameraDataNULL);		DispResult();	}}#ifdef DC50Includevoid CMainFrame::OnDCResetCamera(){	CDCResetCameraDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		ResetCamera(ParamDlg.m_IsCameraDataNULL);		DispResult();	}}void CMainFrame::OnDCPreviewGetInfo(){	CDCPreviewGetInfoDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr	CameraData;		DC50PreviewInfoPtr	PreviewInfo;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsPreviewInfoNULL){			PreviewInfo=NULL;			theApp.m_IsPreviewNULL = TRUE;		}		else{			PreviewInfo=theApp.m_pPreviewInfo;			theApp.m_IsPreviewNULL = FALSE;		}		m_SDKRetValue=DCPreviewGetInfo(CameraData,(VOIDPTR)PreviewInfo);		DispResult();		if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;//			ListDlg.SetStatusList();			ListDlg.DoModal(CListDlg::PreviewInfoList);		}	}}void CMainFrame::OnDCPreviewErase(){	CDCPreviewEraseDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr	CameraData;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		m_SDKRetValue=DCPreviewErase(CameraData);		DispResult();	}}void CMainFrame::OnDCPreviewStore(){	CDCPreviewStoreDlg	ParamDlg;	InitPictInfo(theApp.m_pDCCamera->SpecificCamType);	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		DCPictInfoPtr	GenericInfo;		VOIDPTR			FullInfo;	/* Rem by + Ogawa	// This check is to support the invalid "SpecificCamera" input case.		switch (theApp.m_pDCCamera->CamType){	 		case DCGenericCamera:			 theApp.m_CameraType  =  theApp.m_pDCCamera->SpecificCamType; 			break;			case DCNoCamera: // never come here...				 theApp.m_CameraType  =  theApp.m_pDCCamera->SpecificCamType; 			break;			default:     // others.			 theApp.m_CameraType  =  theApp.m_pDCCamera->CamType;			break;		}	// end of invalid test support.	*/ // Rem by - Ogawa		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsThumbFlagTRUE){  				// + Ogawa 				//long OriginalRowBytes;				//long AlignedRowBytes;				long ThumbBufBytes;				if((theApp.m_pDCCamera->SpecificCamType == DC40)||(theApp.m_pDCCamera->SpecificCamType == DC50)) {					//OriginalRowBytes = 96;					//AlignedRowBytes = 96 * 3;					ThumbBufBytes = DC50ThumbnailWidth * DC50ThumbnailHeight * 3;				} else {					//OriginalRowBytes = 80;					//AlignedRowBytes = 80 * 3;					ThumbBufBytes = DC120ThumbnailWidth * DC120ThumbnailHeight * 3;				}				//OriginalRowBytes =  theApp.m_pGenericInfo->ThumbWidth;				//AlignedRowBytes =    ((OriginalRowBytes*3+3)>>2)<<2;				//theApp.m_pThumbnailBuffer	=(HCHARPTR)theApp.HugeMalloc( (long)AlignedRowBytes*theApp.m_pGenericInfo->ThumbHeight);				theApp.m_pThumbnailBuffer	=(HCHARPTR)theApp.HugeMalloc(ThumbBufBytes);				// - Ogawa								if(theApp.m_pThumbnailBuffer == NULL){					AfxMessageBox("Cannot Allocate Thumbnail Buffer");					return;				}																																									theApp.m_pGenericInfo->ThumbPtr = (HCHARPTR)theApp.m_pThumbnailBuffer;		}		else {				theApp.m_pGenericInfo->ThumbPtr = NULL;		}		if(ParamDlg.m_IsGenericInfoNULL){			GenericInfo=NULL;			theApp.m_IsGenericNULL = TRUE;		}		else{			theApp.m_IsGenericNULL = FALSE; 			GenericInfo=theApp.m_pGenericInfo;		}		if(ParamDlg.m_IsFullInfoNULL){			FullInfo=NULL;			theApp.m_IsSpecificNULL = TRUE; 		}		else{			theApp.m_IsSpecificNULL = FALSE;			FullInfo=theApp.m_p50FullPictInfo; 		}		m_SDKRetValue=DCPreviewStore(CameraData, theApp.m_CamMemType,										  ParamDlg.m_IsThumbFlagTRUE,										  GenericInfo,										  FullInfo);		if(m_SDKRetValue == DC_NoErr){			// Show PictureInformation.			CListDlg	ListDlg;//			ListDlg.SetPictureInfoList();			ListDlg.DoModal(CListDlg::PictureInfoList);			// Show Thumbnail Image.// + Ohbe for debug//			if(ParamDlg.m_IsThumbFlagTRUE){ 			if(ParamDlg.m_IsThumbFlagTRUE && GenericInfo  != NULL){// - Ohbe			 				ImageStruct			ImageInfo;				ImageInfo.pPicture=(HCHARPTR)theApp.m_pGenericInfo->ThumbPtr;				ImageInfo.PictureNum=GenericInfo->PictNumber;				switch(theApp.m_pIPData->ImageType) {					case DCGrayImage8:						ImageInfo.BitCount=8;						break;					case DCRGBImage24:						ImageInfo.BitCount=24;						break;                    default: 						ImageInfo.BitCount=24; 						break;				}								// Add special case.//				if(theApp.m_pDCCamera->CamType == DC20)//						ImageInfo.BitCount=8;										if(theApp.m_pIPData->RotateFlag == FALSE ){					ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;					ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight;                }				else					switch(theApp.m_pIPData->RotateAngle){						case DCRotate0: 						case DCRotate180: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 							break;						case DCRotate90: 						case DCRotate270: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbHeight;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbWidth; 							break;						case DCUsePictOrientation: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 							break;						default:							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 	                }				ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureWidth+3)/4)*4)*ImageInfo.PictureHeight*3;				if(MakeBitmap(ImageInfo)==TRUE){					CImage			ImageDlg;									ImageDlg.DoModal(ImageInfo);				}				if(ImageInfo.lpBitmapInfo!=NULL){					GlobalFreePtr((LPVOID)ImageInfo.lpBitmapInfo);				}				}// end of Thumbnail image display routine.		}		// + Ogawa	    if(theApp.m_pGenericInfo->ThumbPtr != NULL) {      		theApp.HugeFree(theApp.m_pGenericInfo->ThumbPtr);			theApp.m_pGenericInfo->ThumbPtr = NULL;		}	    //if(theApp.m_pThumbnailBuffer != NULL)      	//	theApp.HugeFree(theApp.m_pGenericInfo->ThumbPtr); 		// - Ogawa		DispResult();	}}void CMainFrame::OnDCPreviewGetPicture(){	CDCPreviewGetPictureDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		DC50PreviewInfoPtr	Picture;		DCImageIOCBPtr	Input;		DCImageIOCBPtr	Output;		DCProgressCB	Progress;		DCProgressCBPtr	ProgressPtr; 		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}				if(ParamDlg.m_IsInputNULL){			Input=NULL;		}		else{			Input=theApp.m_pInput;		}		if(ParamDlg.m_IsOutputNULL){			Output=NULL;		}		else{			Output=theApp.m_pOutput;		} 		if(ParamDlg.m_IsProgressNULL){			ProgressPtr	= NULL;		}           		else{			ProgressPtr = &Progress;			// File I/O encapturated part. Resemble to the Save-As WinAPI.			Progress			= *(theApp.m_pProgress);			if(theApp.m_IsProgFuncNULL)				Progress.ProgFunc = NULL; //			Progress->ProgFunc	= ReadAndConvertProc;// To fake the C++ method to C interface callback, // ProgressCallbackFunction (C routine) is implemented in this file// And also declared in SDKT.H file. ProgressCallbackFunction is assigned as// theApp(CSDKTest1).m_Progress.ProgFunc when theApp is created.// This way of implementation is not good, but no other solution is found yet.		}		m_SDKRetValue=DCPreviewGetPicture(CameraData,Input,Output,ProgressPtr);		if(m_SDKRetValue!=kNoErr){			DispResult();		}		else{ // Show Full Size Image.			ImageStruct			ImageInfo;			DispResult();			// + Ogawa			if(theApp.m_pPreviewInfo != NULL) {				Picture = theApp.m_pPreviewInfo;			}						if(theApp.m_pOutput->IOFunc == NULL) {				ImageInfo.pPicture = theApp.m_pOutput->Buffer;			} else {				ImageInfo.pPicture = theApp.m_pCompletePicture;			}			// - Ogawa			ImageInfo.pPicture=(HCHARPTR)Output->Buffer;			ImageInfo.PictureNum=0;			switch(theApp.m_pIPData->ImageType) {					case DCGrayImage8:						ImageInfo.BitCount=8;						break;					case DCRGBImage24:						ImageInfo.BitCount=24;						break;                    default: 						ImageInfo.BitCount=8; 						break;			}			// Consider current rotation.			if(theApp.m_pIPData->RotateFlag == FALSE ){					ImageInfo.PictureWidth=(short)Picture->PictWidth;					ImageInfo.PictureHeight=(short)Picture->PictHeight;            }			else					switch(theApp.m_pIPData->RotateAngle){						case DCRotate0: 						case DCRotate180: 							ImageInfo.PictureWidth=(short)Picture->PictWidth;							ImageInfo.PictureHeight=(short)Picture->PictHeight; 							break;						case DCRotate90: 						case DCRotate270: 							ImageInfo.PictureWidth=(short)Picture->PictHeight;							ImageInfo.PictureHeight=(short)Picture->PictWidth; 							break;						default:							ImageInfo.PictureWidth=(short)Picture->PictWidth;							ImageInfo.PictureHeight=(short)Picture->PictHeight; 	                }            // end of else.            			// Calculate  Picture Size			if(	ImageInfo.PictureWidth == (short)Picture->PictWidth ) 	// RowBytes is   (((ImageInfo.PictureWidth*3+3)/4)*4)					ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureWidth*3+3)/4)*4)*ImageInfo.PictureHeight;    		else // RowBytes is   (((ImageInfo.PictureHeight*3+3)/4)*4)					ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureHeight*3+3)/4)*4)*ImageInfo.PictureWidth;			if(MakeBitmap(ImageInfo)==TRUE){				CImage			ImageDlg;								ImageDlg.DoModal(ImageInfo);			}			if(ImageInfo.lpBitmapInfo!=NULL){				GlobalFreePtr((LPVOID)ImageInfo.lpBitmapInfo);			}		}	}}#endif // of ifdef DC50Include#ifdef DC120Includevoid CMainFrame::OnDCAlbumGetAvailable(){	CDCAlbumGetAvailableDlg	ParamDlg;	DCCameraPtr	Camera;	if(ParamDlg.DoModal()==IDOK){		if(ParamDlg.m_IsCameraDataNULL)	Camera=NULL;		else	Camera=theApp.m_pDCCamera;		// + Ogawa		//memset(theApp.m_pAlbumAvailableArray, '\0', DC120OneAlbumLength * 8);		m_SDKRetValue=DCAlbumGetAvailable(Camera, (HCHARPTR)theApp.m_pAlbumAvailableArray);		//m_SDKRetValue=DCAlbumGetAvailable(Camera, (HCHARPTR)theApp.m_pAlbumNameArray->Album[0]);		// - Ogawa		if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;			ListDlg.DoModal(CListDlg::AlbumNameList);		}		DispResult();	}}void CMainFrame::OnDCAlbumSetAvailable(){	CDCAlbumSetAvailableDlg	ParamDlg;	DCCameraPtr	Camera;	if(ParamDlg.DoModal()==IDOK){		if(ParamDlg.m_IsCameraDataNULL)	Camera=NULL;		else	Camera=theApp.m_pDCCamera;		// + Ogawa		m_SDKRetValue=DCAlbumSetAvailable(Camera, (HCHARPTR)theApp.m_pAlbumAvailableArray);		//m_SDKRetValue=DCAlbumSetAvailable(Camera, (HCHARPTR)theApp.m_pAlbumNameArray->Album[0]);		// - Ogawa		DispResult();	}}void CMainFrame::OnDCAlbumGetAllName(){	CDCAlbumGetAllNameDlg	ParamDlg;	DCCameraPtr	Camera;	if(ParamDlg.DoModal()==IDOK){		if(ParamDlg.m_IsCameraDataNULL)	Camera=NULL;		else	Camera=theApp.m_pDCCamera;		// + Ogawa		//for (int cnt = 0; cnt < 61; cnt++) {		//	theApp.m_AlbumPicturesArray[cnt] = 0;		//}		//memset(theApp.m_pAlbumAll->AlbumName, '\0', DC120OneAlbumLength * theApp.m_AlbumAllSize);		//memset(theApp.m_pAlbumAll->PictNum, '\0', sizeof(long) * theApp.m_AlbumAllSize);		m_SDKRetValue=DCAlbumGetAllName(Camera, theApp.m_CamMemType, (VOIDPTR)theApp.m_pAlbumAll);		// - Ogawa		if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;			ListDlg.DoModal(CListDlg::AlbumAllNameList);		}		DispResult();	}}void CMainFrame::OnDCAlbumSetActive(){	CDCAlbumSetActiveDlg	ParamDlg;	DCCameraPtr	Camera;	if(ParamDlg.DoModal()==IDOK){		if(ParamDlg.m_IsCameraDataNULL)	Camera=NULL;		else	Camera=theApp.m_pDCCamera;		m_SDKRetValue=DCAlbumSetActive(Camera, theApp.m_AlbumNumber);		DispResult();	}}void CMainFrame::OnDCAlbumErase(){	CDCAlbumEraseDlg	ParamDlg;	DCCameraPtr	Camera;	if(ParamDlg.DoModal()==IDOK){		if(ParamDlg.m_IsCameraDataNULL)	Camera=NULL;		else	Camera=theApp.m_pDCCamera;		m_SDKRetValue=DCAlbumErase(Camera, theApp.m_CamMemType, theApp.m_AlbumNumber);		DispResult();	}}void CMainFrame::OnDCAlbumChangeName(){	CDCAlbumChangeNameDlg	ParamDlg;	DCCameraPtr	Camera;	if(ParamDlg.DoModal()==IDOK){		if(ParamDlg.m_IsCameraDataNULL)	Camera=NULL;		else	Camera=theApp.m_pDCCamera;		m_SDKRetValue=DCAlbumChangeName(Camera, theApp.m_CamMemType, 			theApp.m_AlbumNumber, (HCHARPTR)ParamDlg.m_AlbumName.GetBuffer(70));		DispResult();	}}void CMainFrame::OnDCAlbumMoveImage(){	CDCAlbumMoveImageDlg	ParamDlg;	DCCameraPtr	Camera;	if(ParamDlg.DoModal()==IDOK){		if(ParamDlg.m_IsCameraDataNULL)	Camera=NULL;		else	Camera=theApp.m_pDCCamera;		m_SDKRetValue=DCAlbumMoveImage(	Camera,	theApp.m_CamMemType, theApp.m_PictNumber,	theApp.m_FromAlbumNumber,										theApp.m_ToAlbumNumber);		DispResult();	}}// + Ogawavoid CMainFrame::OnDCAlbumGetPictureName(){	CDCAlbumGetPictureNameDlg	ParamDlg;	DCCameraPtr	Camera;	if(ParamDlg.DoModal()==IDOK){		if(ParamDlg.m_IsCameraDataNULL) {			Camera=NULL;		} else {			Camera=theApp.m_pDCCamera;		}		m_SDKRetValue=DCAlbumGetPictureName(Camera, theApp.m_CamMemType, theApp.m_AlbumNumber, (HCHARPTR)theApp.m_pAlbumPictNameArray);		if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;			ListDlg.DoModal(CListDlg::AlbumPictureNameList);		}		DispResult();	}}// - Ogawa#endif // of ifdef DC120Includevoid CMainFrame::OnDCGetStatus(){	CDCGetStatusDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr	CameraData;		DCStatusPtr	GenericStatus;		VOIDPTR		FullStatus;		DCCameraType  DispCameraType;		switch(theApp.m_pDCCamera->CamType){		case DCGenericCamera:			DispCameraType = theApp.m_pDCCamera->SpecificCamType;			break;		case DC20:		case DC25:		case DC40:		case DC50:		case DC120:		default:		// Allow Invalid Camera Type			DispCameraType = theApp.m_pDCCamera->CamType;		}		InitStatus(DispCameraType);		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsGenericStatusNULL){			GenericStatus=NULL;			theApp.m_IsGenericNULL = TRUE;		}		else{			GenericStatus=theApp.m_pGenericStatus;			theApp.m_IsGenericNULL = FALSE;		}		if(ParamDlg.m_IsFullStatusNULL){			FullStatus=NULL;			theApp.m_IsSpecificNULL = TRUE;		}		else{			theApp.m_IsSpecificNULL = FALSE;			// + Ogawa			switch(DispCameraType) {//			case DC20://				FullStatus=theApp.m_pDC20FullStatus;//				break;//			case DC25://				FullStatus=theApp.m_pDC25FullStatus;//				break;			#ifdef DC40Include			case DC40:				FullStatus=theApp.m_pDC40FullStatus;				break;			#endif			#ifdef DC40Include			case DC50:				FullStatus=theApp.m_pDC50FullStatus;				break;			#endif			#ifdef DC120Include			case DC120:				FullStatus=theApp.m_pDC120FullStatus;				break;			#endif			default:				FullStatus=NULL;				break;			}		}		InitStatus(theApp.m_pDCCamera->SpecificCamType);//+kita on 10/14/97#ifdef WIN32		clock_t			start, finish;		double			duration;//		CTimeResult		Dlg;		start = clock();#endif		m_SDKRetValue=DCGetStatus(CameraData,GenericStatus,FullStatus);#ifdef WIN32		finish = clock();		duration = (double)(finish - start) / CLOCKS_PER_SEC;//		Dlg.m_SecTime.Format("%5.2f", duration );//		Dlg.DoModal();#endif//-kita on 10/14/97		DispResult();		if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;//			ListDlg.SetStatusList();			ListDlg.DoModal(CListDlg::StatusList);		}	}}void CMainFrame::OnDCGetConfig(){	CDCGetConfigDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr	CameraData;		DCConfigPtr	GenericConfig;		VOIDPTR		FullConfig;		DCCameraType  DispCameraType;		switch(theApp.m_pDCCamera->CamType){		case DCGenericCamera:			DispCameraType = theApp.m_pDCCamera->SpecificCamType;			break;		case DC20:		case DC25:		case DC40:		case DC50:		case DC120:		default:		// Allow Invalid Camera Type			DispCameraType = theApp.m_pDCCamera->CamType;		}		InitConfig(DispCameraType);		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsGenericConfigNULL){			GenericConfig=NULL;			theApp.m_IsGenericNULL = TRUE;		}		else{			GenericConfig=theApp.m_pGenericConfig;			// + Ogawa			theApp.m_pGenericConfig->CamId = theApp.m_pCamId;			// - Ogawa			theApp.m_IsGenericNULL = FALSE;		}		if(ParamDlg.m_IsFullConfigNULL){			FullConfig=NULL;			theApp.m_IsSpecificNULL = TRUE;		}		else{			theApp.m_IsSpecificNULL = FALSE;			// + Ogawa			switch(theApp.m_pDCCamera->SpecificCamType) {//			case DC20://				FullConfig=theApp.m_pDC20FullConfig;//				break;//			case DC25://				FullConfig=theApp.m_pDC25FullConfig;//				break;			#ifdef DC40Include			case DC40:				FullConfig=theApp.m_pDC40FullConfig;				break;			#endif			#ifdef DC50Include			case DC50:				FullConfig=theApp.m_pDC50FullConfig;				break;			#endif			#ifdef DC120Include			case DC120:				FullConfig=theApp.m_pDC120FullConfig;				break;			#endif			}			// - Ogawa		}		m_SDKRetValue=DCGetConfig(CameraData,GenericConfig,FullConfig);		DispResult();		if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;//			ListDlg.SetConfigList();			ListDlg.DoModal(CListDlg::ConfigList);		}	}}void CMainFrame::OnDCSetConfig(){	CDCSetConfigDlg	ParamDlg;/*DCConfigPtr	GenericConfig;DCCameraPtr	CameraData;VOIDPTR		FullConfig;CameraData=theApp.m_pDCCamera;FullConfig=theApp.m_pDC40FullConfig;GenericConfig=theApp.m_pGenericConfig;m_SDKRetValue=DCSetConfig(CameraData,GenericConfig,FullConfig);*/	if(ParamDlg.DoModal()==IDOK){		DCConfigPtr	GenericConfig;		DCCameraPtr	CameraData;		VOIDPTR		FullConfig;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsGenericConfigNULL){			GenericConfig=NULL;		}		else{			GenericConfig=theApp.m_pGenericConfig;		}		if(ParamDlg.m_IsFullConfigNULL){			FullConfig=NULL;		}		else{			switch(theApp.m_pDCCamera->SpecificCamType) {//			case DC20://				FullConfig=theApp.m_pDC20FullConfig;//				break;//			case DC25://				FullConfig=theApp.m_pDC25FullConfig;//				break;			#ifdef DC40Include			case DC40:				FullConfig=theApp.m_pDC40FullConfig;				break;			#endif			#ifdef DC50Include			case DC50:				FullConfig=theApp.m_pDC50FullConfig;				break;			#endif			#ifdef DC120Include			case DC120:				FullConfig=theApp.m_pDC120FullConfig;				break;			#endif			}		}		//InitConfig(theApp.m_pDCCamera->SpecificCamType);		// Rem by Ogawa		m_SDKRetValue=DCSetConfig(CameraData,GenericConfig,FullConfig);		DispResult();	}}void CMainFrame::OnDCGetImageProcessing(){	CDCGetImageProcessingDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr			CameraData;		DCImgProcDataPtr	IPData;		theApp.m_pIPData->ImageType = DCGrayImage8;		theApp.m_pIPData->RotateFlag = FALSE;		theApp.m_pIPData->RotateAngle = DCRotate0;		theApp.m_pIPData->UseDefaultCRT = TRUE;		theApp.m_pIPData->WhiteBalance = DCWBAuto;		theApp.m_pIPData->WBManual.WBGainR = 0.0;		theApp.m_pIPData->WBManual.WBGainG = 0.0;		theApp.m_pIPData->WBManual.WBGainB = 0.0;		theApp.m_pIPData->CRTData.RedChroma.XChroma = 0.0;		theApp.m_pIPData->CRTData.RedChroma.YChroma = 0.0;		theApp.m_pIPData->CRTData.GrnChroma.XChroma = 0.0;		theApp.m_pIPData->CRTData.GrnChroma.YChroma = 0.0;		theApp.m_pIPData->CRTData.BluChroma.XChroma = 0.0;		theApp.m_pIPData->CRTData.BluChroma.YChroma = 0.0;		theApp.m_pIPData->CRTData.Gamma = 0.0;		theApp.m_pIPData->CRTData.WhiteTemp = 0.0;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsIPDataNULL){			IPData=NULL;		}		else{			IPData=theApp.m_pIPData;		}		m_SDKRetValue=DCGetImageProcessing(CameraData,IPData);		DispResult();		if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;//			ListDlg.SetImageProcessingInfoList();			ListDlg.DoModal(CListDlg::ImageProcessingInfoList);		}	}}void CMainFrame::OnDCSetImageProcessing(){	CDCSetImageProcessingDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr			CameraData;		DCImgProcDataPtr	IPData;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsIPDataNULL){			IPData=NULL;		}		else{			IPData=theApp.m_pIPData;		}		m_SDKRetValue=DCSetImageProcessing(CameraData,IPData);		DispResult();	}}void CMainFrame::OnDCGetOutputWindow(){	CDCGetOutputWindowDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr			CameraData;		DCOutputWindowPtr	WindowData;		theApp.m_pWindowData->HOffset = 0;		theApp.m_pWindowData->VOffset = 0;		theApp.m_pWindowData->Width = 0;		theApp.m_pWindowData->Height = 0;		theApp.m_pWindowData->RowBytes = 0;		theApp.m_pWindowData->ThumbRowBytes = 0;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsWindowDataNULL){			WindowData=NULL;		}		else{			WindowData=theApp.m_pWindowData;		}		m_SDKRetValue=DCGetOutputWindow(CameraData,WindowData);		if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;//			ListDlg.SetOutputWindowInfoList();			ListDlg.DoModal(CListDlg::OutputWindowInfoList);		}		DispResult();	}}void CMainFrame::OnDCSetOutputWindow(){	CDCSetOutputWindowDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr			CameraData;		DCOutputWindowPtr	WindowData;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsWindowDataNULL){			WindowData=NULL;		}		else{			WindowData=theApp.m_pWindowData;		}		m_SDKRetValue=DCSetOutputWindow(CameraData,WindowData);		DispResult();	}}void CMainFrame::OnDCTakePicture(){	CDCTakePictureDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		DCCamMemType	MemoryType;		DCPictInfoPtr	GenericInfo;		VOIDPTR			FullInfo;	/* Rem by + Ogawa	// This check is to support the invalid "SpecificCamera" input case.	switch (theApp.m_pDCCamera->CamType){	 	case DCGenericCamera:			 theApp.m_CameraType  =  theApp.m_pDCCamera->SpecificCamType; 			break;		case DCNoCamera: // never come here...				 theApp.m_CameraType  =  theApp.m_pDCCamera->SpecificCamType; 			break;		default:     // others.			 theApp.m_CameraType  =  theApp.m_pDCCamera->CamType;			break;	}	// end of invalid test support.	*/ // Rem by - Ogawa		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsGenericInfoNULL){			GenericInfo=NULL;			theApp.m_IsGenericNULL = TRUE;		}		else{			GenericInfo=theApp.m_pGenericInfo;			theApp.m_IsGenericNULL = FALSE; 		}		if(ParamDlg.m_IsFullInfoNULL){			FullInfo=NULL;			theApp.m_IsSpecificNULL = TRUE; 		}		else{			theApp.m_IsSpecificNULL = FALSE; 						// + Ogawa			switch(theApp.m_pDCCamera->CamType) {			//switch(theApp.m_CameraType) {			// - Ogawa			case DCGenericCamera:				switch (theApp.m_pDCCamera->SpecificCamType){				case DC40:					FullInfo=theApp.m_p40FullPictInfo; 					break;				case DC50:					FullInfo=theApp.m_p50FullPictInfo; 					break;				case DC120:					FullInfo=theApp.m_p120FullPictInfo; 					break;				}				break;//			case DC25://				FullInfo=theApp.m_p25FullPictInfo; //				break;//			case DC20://				FullInfo=theApp.m_p20FullPictInfo; //				break;			// + Ogawa			#ifdef DC40Include			case DC40:				FullInfo=theApp.m_p40FullPictInfo; 				break;			#endif			#ifdef DC50Include			case DC50:				FullInfo=theApp.m_p50FullPictInfo; 				break;			#endif			#ifdef DC120Include			case DC120:				FullInfo=theApp.m_p120FullPictInfo; 				break;			#endif			// - Ogawa			}				}		if(ParamDlg.m_IsThumbFlagTRUE){			long ThumbBufBytes;			if(theApp.m_pDCCamera->CamType == DCGenericCamera) {				if((theApp.m_pDCCamera->SpecificCamType == DC40)||(theApp.m_pDCCamera->SpecificCamType == DC50)) {					ThumbBufBytes = DC50ThumbnailWidth * DC50ThumbnailHeight * 3;				} else {					ThumbBufBytes = DC120ThumbnailWidth * DC120ThumbnailHeight * 3;				}			} else {				if((theApp.m_pDCCamera->CamType == DC40)||(theApp.m_pDCCamera->CamType == DC50)) {					ThumbBufBytes = DC50ThumbnailWidth * DC50ThumbnailHeight * 3;				} else {					ThumbBufBytes = DC120ThumbnailWidth * DC120ThumbnailHeight * 3;				}			}			theApp.m_pThumbnailBuffer	=(HCHARPTR)theApp.HugeMalloc(ThumbBufBytes);			if(theApp.m_pThumbnailBuffer == NULL){				AfxMessageBox("Cannot Allocate Thumbnail Buffer");				return;			}																																								theApp.m_pGenericInfo->ThumbPtr = (HCHARPTR)theApp.m_pThumbnailBuffer;		}		else {				theApp.m_pGenericInfo->ThumbPtr = NULL;		}			MemoryType = theApp.m_CamMemType;//		for ( int j=0; j<100; j++ ){		m_SDKRetValue=DCTakePicture(CameraData,									MemoryType,									ParamDlg.m_IsThumbFlagTRUE,									GenericInfo, FullInfo); //		if(m_SDKRetValue != DC_NoErr) break;//		}		if(m_SDKRetValue == DC_NoErr){			// Show PictureInformation.			CListDlg	ListDlg;// To support the invalid specificcamtype testing			ListDlg.DoModal(CListDlg::PictureInfoList);			// Show Thumbnail Image.// + Ohbe for debug//			if(ParamDlg.m_IsThumbFlagTRUE){ 			if(ParamDlg.m_IsThumbFlagTRUE &&GenericInfo  != NULL){// - Ohbe			 				ImageStruct			ImageInfo;				ImageInfo.pPicture=(HCHARPTR)theApp.m_pGenericInfo->ThumbPtr;				ImageInfo.PictureNum=GenericInfo->PictNumber;				switch(theApp.m_pIPData->ImageType) {					case DCGrayImage8:						ImageInfo.BitCount=8;						break;					case DCRGBImage24:						ImageInfo.BitCount=24;						break;                    default: 						ImageInfo.BitCount=24; 						break;				}				// Consider current rotation.				if(theApp.m_pIPData->RotateFlag == FALSE ){					ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;					ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight;                }				else					switch(theApp.m_pIPData->RotateAngle){						case DCRotate0: 						case DCRotate180: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 							break;						case DCRotate90: 						case DCRotate270: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbHeight;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbWidth; 							break;						case DCUsePictOrientation:							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 							break;						default:							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 	                }				ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureWidth+3)/4)*4)*ImageInfo.PictureHeight*3;				if(MakeBitmap(ImageInfo)==TRUE){					CImage			ImageDlg;									ImageDlg.DoModal(ImageInfo);				}				if(ImageInfo.lpBitmapInfo!=NULL){					GlobalFreePtr((LPVOID)ImageInfo.lpBitmapInfo);				}				}// end of Thumbnail image display routine.		}// end of if DC_NoErr	    if(theApp.m_pThumbnailBuffer != NULL)      		theApp.HugeFree(theApp.m_pGenericInfo->ThumbPtr); 		DispResult();	}}void CMainFrame::OnDCDeletePicture(){	CDCDeletePictureDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		DCCamMemType	MemType;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		MemType = theApp.m_CamMemType;// + Ohbe add memory type				m_SDKRetValue=DCDeletePicture(CameraData,MemType, theApp.m_AlbumNumber, ParamDlg.m_PictNum);// - Ohbe		DispResult();	}}void CMainFrame::OnDCGetCameraPictInfo(){	CDCGetCameraPictInfoDlg	ParamDlg;	//InitPictInfo(theApp.m_pDCCamera->SpecificCamType);		// Rem by Ogawa	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		DCCamMemType	MemoryType;		DCPictInfoPtr	GenericInfo;		VOIDPTR			FullInfo;		//InitPictInfo(theApp.m_pDCCamera->SpecificCamType);		// Rem by Ogawa	// Rem by + Ogwaa  	// This check is to support the invalid "SpecificCamera" input case.	//switch (theApp.m_pDCCamera->CamType){	//	case DCGenericCamera:	//		theApp.m_CameraType  =  theApp.m_pDCCamera->SpecificCamType; 	//		break;	//	case DCNoCamera: // never come here...		//		theApp.m_CameraType  =  theApp.m_pDCCamera->SpecificCamType; 	//		break;	//	default:     // others.	//		theApp.m_CameraType  =  theApp.m_pDCCamera->CamType;	//		break;	//}	// end of invalid test support.	// Rem by - Ogawa		DCCameraType  DispCameraType;		switch(theApp.m_pDCCamera->CamType){		case DCGenericCamera:			DispCameraType = theApp.m_pDCCamera->SpecificCamType;			break;		case DC20:		case DC25:		case DC40:		case DC50:		case DC120:		default:		// Allow Invalid Camera Type			DispCameraType = theApp.m_pDCCamera->CamType;		}		InitPictInfo(DispCameraType);		m_TestAppErrorCode=kNoErr;		MemoryType = theApp.m_CamMemType;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsThumbFlagTRUE){  			long ThumbBufBytes;			if((DispCameraType == DC40)||(DispCameraType == DC50)) {				ThumbBufBytes = DC50ThumbnailWidth * DC50ThumbnailHeight * 3;			} else {				ThumbBufBytes = DC120ThumbnailWidth * DC120ThumbnailHeight * 3;			}			theApp.m_pThumbnailBuffer	=(HCHARPTR)theApp.HugeMalloc(ThumbBufBytes);			if(theApp.m_pThumbnailBuffer == NULL){				AfxMessageBox("Cannot Allocate Thumbnail Buffer");				return;			}																																								theApp.m_pGenericInfo->ThumbPtr = (HCHARPTR)theApp.m_pThumbnailBuffer;		}		else {			theApp.m_pGenericInfo->ThumbPtr = NULL;		}		if(ParamDlg.m_IsGenericInfoNULL){			GenericInfo=NULL;			theApp.m_IsGenericNULL = TRUE;		}		else{			theApp.m_IsGenericNULL = FALSE; 			GenericInfo=theApp.m_pGenericInfo;		}		if(ParamDlg.m_IsFullInfoNULL){			FullInfo=NULL;			theApp.m_IsSpecificNULL = TRUE; 		}		else{			theApp.m_IsSpecificNULL = FALSE;// to support the invalid specificcamtype testing.//			switch(theApp.m_pDCCamera->SpecificCamType){			// + Ogawa			switch(DispCameraType){			//switch(theApp.m_CameraType){			// - Ogawa//			case DC20://				FullInfo=theApp.m_p20FullPictInfo;//				break;//			case DC25://				FullInfo=theApp.m_p25FullPictInfo; //				break;			#ifdef DC40Include			case DC40:				FullInfo=theApp.m_p40FullPictInfo; 				break;			#endif			#ifdef DC50Include			case DC50:				FullInfo=theApp.m_p50FullPictInfo; 				break;			#endif			#ifdef DC120Include			case DC120:				FullInfo=theApp.m_p120FullPictInfo; 				break;			#endif			}				}		MemoryType = theApp.m_CamMemType;//+kita on 10/14/97#ifdef WIN32		clock_t			start, finish;		double			duration;//		CTimeResult		Dlg;		start = clock();#endif		m_SDKRetValue=DCGetCameraPictInfo(CameraData,										  MemoryType,										  ParamDlg.m_AlbumNum,										  ParamDlg.m_PictNum,										  ParamDlg.m_IsThumbFlagTRUE,										  GenericInfo,										  FullInfo);#ifdef WIN32		finish = clock();	    duration = (double)(finish - start) / CLOCKS_PER_SEC;//		Dlg.m_SecTime.Format("%5.2f", duration );//		Dlg.DoModal();#endif//-kita on 10/14/97		if(m_SDKRetValue == DC_NoErr){			// Show PictureInformation.			CListDlg	ListDlg;//			ListDlg.SetPictureInfoList();			ListDlg.DoModal(CListDlg::PictureInfoList);			// Show Thumbnail Image.// + Ohbe for debug//			if(ParamDlg.m_IsThumbFlagTRUE){ 			if(ParamDlg.m_IsThumbFlagTRUE && GenericInfo  != NULL){// - Ohbe			 				ImageStruct			ImageInfo;				ImageInfo.pPicture=(HCHARPTR)theApp.m_pGenericInfo->ThumbPtr;				ImageInfo.PictureNum=GenericInfo->PictNumber;				switch(theApp.m_pIPData->ImageType) {					case DCGrayImage8:						ImageInfo.BitCount=8;						break;					case DCRGBImage24:						ImageInfo.BitCount=24;						break;                    default: 						ImageInfo.BitCount=24; 						break;				}								// Add special case.//				if(theApp.m_pDCCamera->CamType == DC20)//						ImageInfo.BitCount=8;										if(theApp.m_pIPData->RotateFlag == FALSE ){					ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;					ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight;                }				else					switch(theApp.m_pIPData->RotateAngle){						case DCRotate0: 						case DCRotate180: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 							break;						case DCRotate90: 						case DCRotate270: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbHeight;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbWidth; 							break;						case DCUsePictOrientation: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 							break;						default:							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 	                }				ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureWidth+3)/4)*4)*ImageInfo.PictureHeight*3;				if(MakeBitmap(ImageInfo)==TRUE){					CImage			ImageDlg;									ImageDlg.DoModal(ImageInfo);				}				if(ImageInfo.lpBitmapInfo!=NULL){					GlobalFreePtr((LPVOID)ImageInfo.lpBitmapInfo);				}				}// end of Thumbnail image display routine.		}		// + Ogawa	    if(theApp.m_pGenericInfo->ThumbPtr != NULL) {      		theApp.HugeFree(theApp.m_pGenericInfo->ThumbPtr);			theApp.m_pGenericInfo->ThumbPtr = NULL;		}	    //if(theApp.m_pThumbnailBuffer != NULL)      	//	theApp.HugeFree(theApp.m_pGenericInfo->ThumbPtr); 		// - Ogawa		DispResult();	}}void CMainFrame::OnDCGetNativePictInfo(){	// File I/O encapturated part. Resemble to the OpenFile WinAPI.			{				CFileDialog			TargetDlg(TRUE,"KDC","*.KDC",									OFN_EXTENSIONDIFFERENT | OFN_READONLY,									"KDC files(*.KDC)|*.KDC|All files(*.*)|*.*||",this);				CFile				TargetFile;				CFileException		FileErr;				if(TargetDlg.DoModal()==IDOK){					if(TargetFile.Open(						TargetDlg.GetPathName(),CFile::modeRead, &FileErr)!=0){												if(theApp.m_pInputBuffer != NULL)							theApp.HugeFree(theApp.m_pInputBuffer);						theApp.m_pInputBuffer	=(HCHARPTR)theApp.HugeMalloc(NativeFileSize);						theApp.m_pInput->Buffer 	= theApp.m_pInputBuffer;						theApp.m_pInput->BufferSize 	= NativeFileSize;						TargetFile.ReadHuge((void far*)(theApp.m_pInputBuffer),NativeFileSize);						if(FileErr.m_cause==CFileException::none){							TargetFile.Close();						}						else{ // Exception happened.							TargetFile.Close();							AfxMessageBox("File IO Exception Error");							return;						}					}					else{   // File Open is failed.						AfxMessageBox("File Open Error");						return;					}				}				else{ // FileOpen is canceled.					return;				}				}				// Show the Parmeter settting dialog.	InitPictInfo(theApp.m_pDCCamera->SpecificCamType);	CDCGetNativePictInfoDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){	DCCameraPtr		CameraData;	DCImageIOCBPtr	Input;	DCPictInfoPtr	GenericInfo;	VOIDPTR			FullInfo;		//InitPictInfo(theApp.m_pDCCamera->SpecificCamType);		// Rem by Ogawa	DCCameraType  DispCameraType;	switch(theApp.m_NativeCameraType){	case DC20:	case DC25:	case DC40:	case DC50:	case DC120:		DispCameraType = theApp.m_NativeCameraType;		break;	default:		if((theApp.m_pDCCamera->CamType == DCNoCamera) || (theApp.m_pDCCamera->CamType == DCGenericCamera)) {			DispCameraType = theApp.m_pDCCamera->SpecificCamType;		} else {			DispCameraType = theApp.m_pDCCamera->CamType;		}	}		InitPictInfo(DispCameraType);					m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsInputNULL){			Input=NULL;		}		else{			Input=theApp.m_pInput;		}		if(ParamDlg.m_IsThumbFlagTRUE){  				// + Ogawa 				//long OriginalRowBytes;				//long AlignedRowBytes;				long ThumbBufBytes;				if((DispCameraType == DC40)||(DispCameraType == DC50)) {					//OriginalRowBytes = 96;					//AlignedRowBytes = 96 * 3;					ThumbBufBytes = DC50ThumbnailWidth * DC50ThumbnailHeight * 3;				} else {					//OriginalRowBytes = 80;					//AlignedRowBytes = 80 * 3;					ThumbBufBytes = DC120ThumbnailWidth * DC120ThumbnailHeight * 3;				}				//OriginalRowBytes =  theApp.m_pGenericInfo->ThumbWidth;				//AlignedRowBytes =    ((OriginalRowBytes*3+3)>>2)<<2;				//theApp.m_pThumbnailBuffer	=(HCHARPTR)theApp.HugeMalloc( (long)AlignedRowBytes*theApp.m_pGenericInfo->ThumbHeight);				theApp.m_pThumbnailBuffer	=(HCHARPTR)theApp.HugeMalloc(ThumbBufBytes);				// - Ogawa				if(theApp.m_pThumbnailBuffer == NULL){					AfxMessageBox("Cannot Allocate Thumbnail Buffer");					return;				}																																									theApp.m_pGenericInfo->ThumbPtr = (HCHARPTR)theApp.m_pThumbnailBuffer;		}		else {				theApp.m_pGenericInfo->ThumbPtr = NULL;		}		if(ParamDlg.m_IsGenericInfoNULL){			GenericInfo=NULL;			theApp.m_IsGenericNULL = TRUE;		}		else{			theApp.m_IsGenericNULL = FALSE; 			GenericInfo=theApp.m_pGenericInfo;		}		if(ParamDlg.m_IsFullInfoNULL){			FullInfo=NULL;			theApp.m_IsSpecificNULL = TRUE; 		}		else{			theApp.m_IsSpecificNULL = FALSE;			switch(DispCameraType){//			case DC20://				FullInfo=theApp.m_p20FullPictInfo; //				break;//			case DC25://				FullInfo=theApp.m_p25FullPictInfo; //				break;			#ifdef DC40Include			case DC40:				FullInfo=theApp.m_p40FullPictInfo; 				break;			#endif			#ifdef DC50Include			case DC50:				FullInfo=theApp.m_p50FullPictInfo; 				break;			#endif			#ifdef DC120Include			case DC120:				FullInfo=theApp.m_p120FullPictInfo; 				break;			#endif			default: 				AfxMessageBox("Call DCGetnativeCameraType before specifiing FullInfo.");				if(theApp.m_pThumbnailBuffer != NULL)      					theApp.HugeFree(theApp.m_pGenericInfo->ThumbPtr); 				return;			} //end of case 				}        // end of else.				m_SDKRetValue=DCGetNativePictInfo(CameraData,Input,ParamDlg.m_IsThumbFlagTRUE,						GenericInfo,FullInfo);		DispResult();		if(m_SDKRetValue == DC_NoErr){			// Show Picture Information.			CListDlg	ListDlg;//			ListDlg.SetPictureInfoList();			ListDlg.DoModal(CListDlg::NativePictureInfoList);			// Show Thumbnail Image.// + Ohbe for debug//			if(ParamDlg.m_IsThumbFlagTRUE){ 			if(ParamDlg.m_IsThumbFlagTRUE && GenericInfo  != NULL){// - Ohbe			 				ImageStruct			ImageInfo;				ImageInfo.pPicture=(HCHARPTR)theApp.m_pGenericInfo->ThumbPtr;				ImageInfo.PictureNum=GenericInfo->PictNumber;				switch(theApp.m_pIPData->ImageType) {					case DCGrayImage8:						ImageInfo.BitCount=8;						break;					case DCRGBImage24:						ImageInfo.BitCount=24;						break;                    default: 						ImageInfo.BitCount=24; 						break;				}            				// Add special case.//				if(theApp.m_pDCCamera->CamType == DC20)//						ImageInfo.BitCount=8;										// Consider current rotation.				if(theApp.m_pIPData->RotateFlag == FALSE ){					ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;					ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight;                }				else					switch(theApp.m_pIPData->RotateAngle){						case DCRotate0: 						case DCRotate180: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 							break;						case DCRotate90: 						case DCRotate270: 							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbHeight;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbWidth; 							break;						case DCUsePictOrientation:  							if(FullInfo == NULL){								AfxMessageBox("FullInfo is NULL. No Rotation Information");							    if(theApp.m_pThumbnailBuffer != NULL)      									theApp.HugeFree(	theApp.m_pGenericInfo->ThumbPtr); 							    return;							}							DCRotateImg CurrentRotation;							switch(DispCameraType){ //							case DC20://								CurrentRotation = theApp.m_p20FullPictInfo->PictOrientation; //								break;//							case DC25://								CurrentRotation = theApp.m_p25FullPictInfo->PictOrientation; //								break;							// + Ogawa							#ifdef DC40Include							case DC40:								CurrentRotation = theApp.m_p40FullPictInfo->PictOrientation; 								break;							#endif							#ifdef DC50Include							case DC50:								CurrentRotation = theApp.m_p50FullPictInfo->PictOrientation; 								break;							#endif							#ifdef DC120Include							case DC120:								CurrentRotation = theApp.m_p120FullPictInfo->PictOrientation; 								break;							#endif							// - Ogawa							default:								CurrentRotation = DCRotate0; 							}							switch(CurrentRotation){								case DCRotate0: 								case DCRotate180: 									ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;									ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 									break;								case DCRotate90: 								case DCRotate270: 									ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbHeight;									ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbWidth; 									break;							}								break; // end of UsePictOrientation case.						default:							ImageInfo.PictureWidth=theApp.m_pGenericInfo->ThumbWidth;							ImageInfo.PictureHeight=theApp.m_pGenericInfo->ThumbHeight; 	                }				ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureWidth+3)/4)*4)*ImageInfo.PictureHeight*3;				if(MakeBitmap(ImageInfo)==TRUE){					CImage			ImageDlg;									ImageDlg.DoModal(ImageInfo);				}				if(ImageInfo.lpBitmapInfo!=NULL){					GlobalFreePtr((LPVOID)ImageInfo.lpBitmapInfo);				}				}// end of Thumbnail image display routine.		} 		// + Ogawa	    if(theApp.m_pGenericInfo->ThumbPtr != NULL) {      		theApp.HugeFree(theApp.m_pGenericInfo->ThumbPtr); 			theApp.m_pGenericInfo->ThumbPtr = NULL;		}		//if(theApp.m_pThumbnailBuffer != NULL)      	//	theApp.HugeFree(theApp.m_pGenericInfo->ThumbPtr); 		// - Ogawa		// reset to the default value if the return value is not correct.		if(GenericInfo != NULL){			if( GenericInfo->PictMinBufOut < 0 || GenericInfo->PictMinBufIn < 0 || GenericInfo->PictCompSize < 0  )				InitPictInfo(theApp.m_pDCCamera->SpecificCamType);		}	}}void CMainFrame::OnDCGetCameraPicture(){	CDCGetCameraPictureDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		DCCamMemType	MemoryType;		short			AlbumNumber;		DCPictInfoPtr	Picture;		DCImageIOCBPtr	Input;		DCImageIOCBPtr	Output;		DCProgressCB	Progress;		DCProgressCBPtr	ProgressPtr; 		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}				MemoryType = theApp.m_CamMemType;#ifdef DC50Include		AlbumNumber = theApp.m_AlbumNumber;#endif				if(ParamDlg.m_IsPictureNULL){			Picture=NULL;		}		else{			Picture=theApp.m_pGenericInfo;		}		if(ParamDlg.m_IsInputNULL){			Input=NULL;		}		else{			Input=theApp.m_pInput;		}		if(ParamDlg.m_IsOutputNULL){			Output=NULL;		}		else{			Output=theApp.m_pOutput;		} 		if(ParamDlg.m_IsProgressNULL){			ProgressPtr	= NULL;		}           		else{			ProgressPtr = &Progress;			// File I/O encapturated part. Resemble to the Save-As WinAPI.			Progress			= *(theApp.m_pProgress);			if(theApp.m_IsProgFuncNULL)				Progress.ProgFunc = NULL; //			Progress->ProgFunc	= ReadAndConvertProc;// To fake the C++ method to C interface callback, // ProgressCallbackFunction (C routine) is implemented in this file// And also declared in SDKT.H file. ProgressCallbackFunction is assigned as// theApp(CSDKTest1).m_Progress.ProgFunc when theApp is created.// This way of implementation is not good, but no other solution is found yet.		}//for ( int b=0; b<50; b++ ){#ifdef DC50Include		m_SDKRetValue=DCGetCameraPicture(CameraData,MemoryType,AlbumNumber, Picture,Input,Output,ProgressPtr);#else		m_SDKRetValue=DCGetCameraPicture(CameraData,MemoryType,AlbumNumber, Picture,Input,Output,ProgressPtr);#endif//if(m_SDKRetValue!=kNoErr)break;//}		if(m_SDKRetValue!=kNoErr){			DispResult();		}		else{ // Show Full Size Image.			ImageStruct			ImageInfo;			DispResult();			// + Ogawa			if(theApp.m_pOutput->IOFunc == NULL) {				ImageInfo.pPicture = theApp.m_pOutput->Buffer;			} else {				ImageInfo.pPicture = theApp.m_pCompletePicture;			}			// - Ogawa			ImageInfo.PictureNum=Picture->PictNumber;			switch(theApp.m_pIPData->ImageType) {					case DCGrayImage8:						ImageInfo.BitCount=8;						break;					case DCRGBImage24:						ImageInfo.BitCount=24;						break;                    default: 						ImageInfo.BitCount=24; 						break;			}			// Consider current rotation.			if(theApp.m_pIPData->RotateFlag == FALSE ){					ImageInfo.PictureWidth=(short)Picture->PictWidth;					ImageInfo.PictureHeight=(short)Picture->PictHeight;            }			else					switch(theApp.m_pIPData->RotateAngle){						case DCRotate0: 						case DCRotate180: 							ImageInfo.PictureWidth=(short)Picture->PictWidth;							ImageInfo.PictureHeight=(short)Picture->PictHeight; 							break;						case DCRotate90: 						case DCRotate270: 							ImageInfo.PictureWidth=(short)Picture->PictHeight;							ImageInfo.PictureHeight=(short)Picture->PictWidth; 							break;						default:							ImageInfo.PictureWidth=(short)Picture->PictWidth;							ImageInfo.PictureHeight=(short)Picture->PictHeight; 	                }            // end of else.            			// Calculate  Picture Size			if(	ImageInfo.PictureWidth == (short)Picture->PictWidth ) 	// RowBytes is   (((ImageInfo.PictureWidth*3+3)/4)*4)					ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureWidth*3+3)/4)*4)*ImageInfo.PictureHeight;    		else // RowBytes is   (((ImageInfo.PictureHeight*3+3)/4)*4)					ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureHeight*3+3)/4)*4)*ImageInfo.PictureWidth;			if(MakeBitmap(ImageInfo)==TRUE){				CImage			ImageDlg;								ImageDlg.DoModal(ImageInfo);			}			if(ImageInfo.lpBitmapInfo!=NULL){				GlobalFreePtr((LPVOID)ImageInfo.lpBitmapInfo);			}		}	}}void CMainFrame::OnDCGetNativePicture(){	CDCGetNativePictureDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		DCPictInfoPtr	Picture;		DCImageIOCBPtr	Output;		DCProgressCB	Progress;		DCProgressCBPtr	ProgressPtr; 		DCCamMemType	MemoryType;		short			AlbumNumber;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		MemoryType = theApp.m_CamMemType;#ifdef DC50Include		AlbumNumber = theApp.m_AlbumNumber;#endif		if(ParamDlg.m_IsPictureNULL){			Picture=NULL;		}		else{			Picture=theApp.m_pGenericInfo;		}		if(ParamDlg.m_IsOutputNULL){			Output=NULL;		}		else{			Output=theApp.m_pInput;		}		if(ParamDlg.m_IsProgressNULL){			ProgressPtr	= NULL;		}           		else{			ProgressPtr = &Progress;			// File I/O encapturated part. Resemble to the Save-As WinAPI.			Progress			= *(theApp.m_pProgress);			if(theApp.m_IsProgFuncNULL)				Progress.ProgFunc = NULL; //			Progress->ProgFunc	= ReadAndConvertProc;// To fake the C++ method to C interface callback, // ProgressCallbackFunction (C routine) is implemented in this file// And also declared in SDKT.H file. ProgressCallbackFunction is assigned as// theApp(CSDKTest1).m_Progress.ProgFunc when theApp is created.// This way of implementation is not good, but no other solution is found yet.		}#ifdef DC50Include		m_SDKRetValue=DCGetNativePicture(CameraData,MemoryType,AlbumNumber, Picture,Output,ProgressPtr);#else		m_SDKRetValue=DCGetNativePicture(CameraData,MemoryType,Picture,Output,ProgressPtr);#endif		if(m_SDKRetValue!=kNoErr){			DispResult();		}		else{ // Save as a native file.			DispResult();			{				CFileDialog			SaveDlg(FALSE,"KDC","*.KDC",									OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,									"KDC files(*.KDC)|*.KDC|All files(*.*)|*.*||",this);				CFile				SaveFile;				CFileException		FileErr;				if(SaveDlg.DoModal()==IDOK){					if(SaveFile.Open(						SaveDlg.GetPathName(),CFile::modeWrite | CFile::modeCreate | 						CFile::shareExclusive, &FileErr)!=0){						SaveFile.WriteHuge((const void far*)(Output->Buffer),Output->BufferSize);						if(FileErr.m_cause==CFileException::none){							SaveFile.Close();							return;						}						else{ // Exception happened.							SaveFile.Close();							AfxMessageBox("File I/O Exception Error");							return;						}					}   // end of Open.				} 				else{ // FileOpen is canceled.					return;				}	 			}		}	}}void CMainFrame::OnDCProcNativePicture(){	// File I/O encapturated part. Resemble to the OpenFile WinAPI.			{				CFileDialog			TargetDlg(TRUE,"KDC","*.KDC",									OFN_EXTENSIONDIFFERENT | OFN_READONLY,									"KDC files(*.KDC)|*.KDC|All files(*.*)|*.*||",this);				CFile				TargetFile;				CFileException		FileErr;				if(TargetDlg.DoModal()==IDOK){					// + Kataoka					CFileStatus	Status;					CFile::GetStatus(TargetDlg.GetPathName(),Status);					// - Kataoka					if(TargetFile.Open(						TargetDlg.GetPathName(),CFile::modeRead, &FileErr)!=0){												if(theApp.m_pInputBuffer != NULL)							theApp.HugeFree(theApp.m_pInputBuffer);						theApp.m_pInputBuffer=(HCHARPTR)theApp.HugeMalloc(Status.m_size);						theApp.m_pInput->Buffer 	= theApp.m_pInputBuffer;						theApp.m_pInput->BufferSize 	= Status.m_size;						TargetFile.ReadHuge((void far*)(theApp.m_pInputBuffer),Status.m_size);						if(FileErr.m_cause==CFileException::none){							TargetFile.Close();						}						else{ // Exception happened.							TargetFile.Close();							AfxMessageBox("File I/O Exception Error");							return;						}					}					else{   // File Open is failed.						AfxMessageBox("File Open Error");						return;					}				}				else{ // FileOpen is canceled.					return;				}				}	CDCProcNativePictureDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		// Set the parameters..			DCCameraPtr		CameraData;		DCPictInfoPtr	Picture;		DCImageIOCBPtr	Input;		DCImageIOCBPtr	Output;		DCProgressCB	Progress;		DCProgressCBPtr	ProgressPtr;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		if(ParamDlg.m_IsPictureNULL){			Picture=NULL;		}		else{			Picture=theApp.m_pGenericInfo;		}		if(ParamDlg.m_IsInputNULL){			Input=NULL;		}		else{			Input=theApp.m_pInput;		}		if(ParamDlg.m_IsOutputNULL){			Output=NULL;		}		else{ // + Ohbe Output must be re-alocated to fit the curent PictOrientation when handling NativePicture....//   This is the temporary processing. 			Output=theApp.m_pOutput; // - Ohbe					} 		if(ParamDlg.m_IsProgressNULL){			ProgressPtr	= NULL;		}           		else{			ProgressPtr = &Progress;			// File I/O encapturated part. Resemble to the Save-As WinAPI.			Progress			= *(theApp.m_pProgress);			if(theApp.m_IsProgFuncNULL)				Progress.ProgFunc = NULL; 		}		// Call ProcNativePicture Function.			m_SDKRetValue=DCProcNativePicture(CameraData,Picture,Input,Output,ProgressPtr);		if(m_SDKRetValue!=kNoErr){			DispResult();		}		else{ // Show Full Size Image.			ImageStruct			ImageInfo;			DispResult();			// + Ogawa			if(Output->IOFunc == NULL) {				ImageInfo.pPicture=(HCHARPTR)theApp.m_pOutput->Buffer;			} else {				ImageInfo.pPicture=(HCHARPTR)theApp.m_pCompletePicture;			}			// - Ogawa			ImageInfo.PictureNum=Picture->PictNumber;			switch(theApp.m_pIPData->ImageType) {					case DCGrayImage8:						ImageInfo.BitCount=8;						break;					case DCRGBImage24:						ImageInfo.BitCount=24;						break;                    default: 						ImageInfo.BitCount=24; 						break;			}			// Consider current rotation.			if(theApp.m_pIPData->RotateFlag == FALSE ){					ImageInfo.PictureWidth=(short)Picture->PictWidth;					ImageInfo.PictureHeight=(short)Picture->PictHeight;            }			else					switch(theApp.m_pIPData->RotateAngle){						case DCRotate0: 						case DCRotate180: 							ImageInfo.PictureWidth=(short)Picture->PictWidth;							ImageInfo.PictureHeight=(short)Picture->PictHeight; 							break;						case DCRotate90: 						case DCRotate270: 							ImageInfo.PictureWidth=(short)Picture->PictHeight;							ImageInfo.PictureHeight=(short)Picture->PictWidth; 							break;							// + Ohbe to support PictOrientation.						case DCUsePictOrientation:							DCRotateImg CurrentRotation;							// + Ogawa							switch(theApp.m_pDCCamera->CamType){ 							//switch(theApp.m_CameraType){							// - Ogawa//								case DC20://								 CurrentRotation = theApp.m_p20FullPictInfo->PictOrientation; //								 break;//								case DC25://								 CurrentRotation = theApp.m_p25FullPictInfo->PictOrientation; //								 break;								// + Ogawa								#ifdef DC40Include								case DC40:								 CurrentRotation = theApp.m_p40FullPictInfo->PictOrientation; 								 break;								#endif								#ifdef DC50Include								case DC50:								 CurrentRotation = theApp.m_p50FullPictInfo->PictOrientation; 								 break;								#endif								#ifdef DC120Include								case DC120:								 CurrentRotation = theApp.m_p120FullPictInfo->PictOrientation; 								 break;								#endif								// - Ogawa								default:								 CurrentRotation = DCRotate0; 							}							switch(CurrentRotation){								case DCRotate0: 								case DCRotate180: 									ImageInfo.PictureWidth=(short)Picture->PictWidth;									ImageInfo.PictureHeight=(short)Picture->PictHeight; 									break;								case DCRotate90: 								case DCRotate270: 									ImageInfo.PictureWidth=(short)Picture->PictHeight;									ImageInfo.PictureHeight=(short)Picture->PictWidth; 									break;							}													break;// - Ohbe						  						default:							ImageInfo.PictureWidth=(short)Picture->PictWidth;							ImageInfo.PictureHeight=(short)Picture->PictHeight; 	                }            // end of else.            			// Calculate  Picture Size			if(	ImageInfo.PictureWidth == (short)Picture->PictWidth ) 	// RowBytes is   (((ImageInfo.PictureWidth*3+3)/4)*4)					ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureWidth*3+3)/4)*4)*ImageInfo.PictureHeight;    		else // RowBytes is   (((ImageInfo.PictureHeight*3+3)/4)*4)					ImageInfo.BmpPictureSize=(DWORD)(((ImageInfo.PictureHeight*3+3)/4)*4)*ImageInfo.PictureWidth;			// Make Bitmap			if(MakeBitmap(ImageInfo)==TRUE){				CImage			ImageDlg;								ImageDlg.DoModal(ImageInfo);			}			if(ImageInfo.lpBitmapInfo!=NULL){				GlobalFreePtr((LPVOID)ImageInfo.lpBitmapInfo);			}		}	}}/////////////////////////////////////////////////////////////////////////////void CMainFrame::OnDCCopyMemToCard(){	CDCCopyMemToCardDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}#ifdef DC50Include		// + Ogawa		m_SDKRetValue=DCCopyMemToCard(CameraData, theApp.m_AlbumNumber, ParamDlg.m_PictNum);		//m_SDKRetValue=DCCopyMemToCard(CameraData, ParamDlg.m_AlbumNum, ParamDlg.m_PictNum);		// - Ogawa#else		m_SDKRetValue=DCCopyMemToCard(CameraData,ParamDlg.m_PictNum);#endif		DispResult();	}}void CMainFrame::OnDCGetNativeCameraType(){	long BakcupSize;		// To fake the size of the buffer in Native Handling..		BakcupSize =  theApp.m_pGenericInfo->PictMinBufIn;	// File I/O encapturated part. Resemble to the OpenFile WinAPI.			{				CFileDialog			TargetDlg(TRUE,"KDC","*.KDC",									OFN_EXTENSIONDIFFERENT | OFN_READONLY,									"KDC files(*.KDC)|*.KDC|All files(*.*)|*.*||",this);				CFile				TargetFile;				CFileException		FileErr;				if(TargetDlg.DoModal()==IDOK){					if(TargetFile.Open(						TargetDlg.GetPathName(),CFile::modeRead, &FileErr)!=0){												if(theApp.m_pInputBuffer != NULL)							theApp.HugeFree(theApp.m_pInputBuffer);						theApp.m_pInputBuffer	=(HCHARPTR)theApp.HugeMalloc(NativeFileSize);						theApp.m_pInput->Buffer 	= theApp.m_pInputBuffer;						theApp.m_pInput->BufferSize 	= NativeFileSize;						TargetFile.ReadHuge((void far*)(theApp.m_pInputBuffer),NativeFileSize);						if(FileErr.m_cause==CFileException::none){							TargetFile.Close();  							// To fake the Native file handling.							 theApp.m_pGenericInfo->PictMinBufIn =  NativeFileSize;						}						else{ // Exception happened.							TargetFile.Close();							AfxMessageBox("File I/O Exception Error");							return;						}					}					else{   // File Open is failed.					//	TargetFile.Close();						AfxMessageBox("File Open Error");						return;					}				}				else{ // FileOpen is canceled.					return;				}				}    // Get the tester's choice.	CDCGetNativeCameraTypeDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		DCImageIOCBPtr	Input;		DCCameraTypePtr	pCameraType;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}        		if(ParamDlg.m_IsCameraPointerNULL){			pCameraType=NULL;		}		else{			// + Ogawa			pCameraType = &(theApp.m_NativeCameraType);			//pCameraType=&(theApp.m_CameraType);		}        		if(ParamDlg.m_IsInputNULL){			Input=NULL;		}		else{			Input=theApp.m_pInput;		}		// Caution:  Input may be modified by CInputPage dialog.		m_SDKRetValue=DCGetNativeCameraType(CameraData,Input,pCameraType);				DispResult();		if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;//			ListDlg.SetCameraTypeList();			ListDlg.DoModal(CListDlg::CameraTypeList);		}	}}/////////////////////////////////////////////////////////////////////////////void  CMainFrame::ResetStatusBar(){		UINT			ngID, ngStyle;		int				cxgWidth;		m_wndStatusBar.GetPaneInfo(kPANE_CANCEL, ngID, ngStyle, cxgWidth);	// cancel button to transfer image.		m_wndStatusBar.SetPaneInfo(kPANE_CANCEL, ngID, SBPS_NOBORDERS, 1);	// cancel button to transfer image.		m_wndStatusBar.SetPaneText(kPANE_CANCEL, NULL, TRUE);		m_wndStatusBar.SetPaneText(kPANE_BAR,    NULL, TRUE);		m_wndStatusBar.SetWindowText((LPCSTR)NULL);		m_wndStatusBar.UpdateWindow();}////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////			Callback Routines.//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#ifdef WIN32extern "C" __declspec(dllexport) BOOL pascal CMainFrame::ReadAndConvertProc(DCProgressStatus state, 													   short Percent, 													   DCProgressType CbType)#elseextern "C" BOOL far pascal __export CMainFrame::ReadAndConvertProc(DCProgressStatus state, 													   short Percent, 													   DCProgressType CbType)#endif{UINT			ngID, ngStyle;int				cxgWidth;BOOL			RetCode = TRUE;MSG				msgtbl;CRect			rtItem;	CString			StrMsg;static  BOOL 	bCancel, bCapturing;	if(m_wndStatusBar.m_hWnd != NULL)	{		CClientDC 	dc(&m_wndStatusBar);						switch(state)		{			case DCProgressInit:				if(CbType == DCImageProcess)	StrMsg.LoadString(IDS_LIB_START_DECOMP);					 	else							 	StrMsg.LoadString(IDS_LIB_START_UPLOAD);										break;							case DCProgressIncomplete:				if(bCapturing)	::ReleaseCapture();					 ResetStatusBar();				return(FALSE); 							case DCProgressEnd:				if(CbType == DCImageProcess){					 	StrMsg.LoadString(IDS_LIB_END_DECOMP);						}else					 StrMsg.LoadString(IDS_LIB_END_UPLOAD);				break;			default:				if(CbType == DCImageProcess)	StrMsg.LoadString(IDS_LIB_NOW_DECOMP);						else                               StrMsg.LoadString(IDS_LIB_NOW_UPLOAD);				break;		}		m_wndStatusBar.SetWindowText((LPCSTR)StrMsg);		m_wndStatusBar.UpdateWindow();		if(state == DCProgressInit){			bCancel = FALSE;			StrMsg.Empty();			StrMsg.LoadString(IDS_CANCEL);			m_wndStatusBar.GetPaneInfo(kPANE_CANCEL, ngID, ngStyle, cxgWidth);						// cancel button to transfer image.			m_wndStatusBar.SetPaneInfo(kPANE_CANCEL, ngID, SBPS_POPOUT, dc.GetTextExtent(StrMsg, StrMsg.GetLength()).cx);					// cancel button to transfer image.			m_wndStatusBar.SetPaneText(kPANE_CANCEL, StrMsg, TRUE);			m_wndStatusBar.UpdateWindow();		}else if(state == DCProgressEnd){								StrMsg.LoadString(IDS_LIB_END_UPLOAD);			m_wndStatusBar.SetWindowText((LPCSTR)StrMsg);			m_wndStatusBar.GetItemRect(kPANE_BAR, (LPRECT)&rtItem);			DrawWaitRectBar(&dc, rtItem, Percent);			goto UploadEnd;		}		m_wndStatusBar.GetItemRect(kPANE_BAR, (LPRECT)&rtItem);		DrawWaitRectBar(&dc, rtItem, Percent);		if(::PeekMessage(&msgtbl,NULL,0,0,PM_REMOVE))		{			if(msgtbl.message == WM_KEYDOWN && msgtbl.wParam == VK_CANCEL)					// the control + break key down is to Cancel.			{				RetCode = FALSE;				goto UploadEnd;			}			if(msgtbl.hwnd != m_wndStatusBar.m_hWnd)			{				if(bCancel)				{					m_wndStatusBar.GetPaneInfo(kPANE_CANCEL, ngID, ngStyle, cxgWidth);				// cancel button to transfer image.					m_wndStatusBar.SetPaneInfo(kPANE_CANCEL, ngID, SBPS_POPOUT, cxgWidth);			// cancel button to transfer image.					m_wndStatusBar.GetItemRect(kPANE_CANCEL, (LPRECT)&rtItem);					m_wndStatusBar.RedrawWindow((LPCRECT)rtItem);									// redraw cancel button.				}			}else				return(CancelButtonMessageControl(msgtbl, (BOOL *)&bCancel, (BOOL *)&bCapturing));		}	}	return(RetCode);	UploadEnd:		if(bCapturing)	::ReleaseCapture();#ifdef WIN32		Sleep(100);#else		{  // Temporary routine. wait 100 msec.			TIMERINFO	curtime;			DWORD		endtime;			curtime.dwSize = sizeof(curtime);			TimerCount(&curtime);			endtime = curtime.dwmsThisVM+100;			while(curtime.dwmsThisVM < endtime)				TimerCount(&curtime);		}		#endif		m_wndStatusBar.GetPaneInfo(kPANE_CANCEL, ngID, ngStyle, cxgWidth);							// cancel button to transfer image.		m_wndStatusBar.SetPaneInfo(kPANE_CANCEL, ngID, SBPS_NOBORDERS, 1);							// cancel button to transfer image.		m_wndStatusBar.SetPaneText(kPANE_CANCEL, NULL, TRUE);		m_wndStatusBar.SetPaneText(kPANE_BAR,    NULL, TRUE);		return(RetCode);}/////////////////////////////////////////////////////////////////////////////extern "C" BOOL CMainFrame::CancelButtonMessageControl(MSG msgtbl, BOOL *bCancel, BOOL *bCapturing){BOOL	RetCode = TRUE;int		cxgWidth;UINT	ngID, ngStyle;CRect	rt;	CPoint	pt;	if(msgtbl.message == WM_MOUSEMOVE || msgtbl.message == WM_LBUTTONDOWN || msgtbl.message == WM_LBUTTONUP)	{		CPoint pt((int)(LOWORD(msgtbl.lParam)), (int)(HIWORD(msgtbl.lParam)));		m_wndStatusBar.GetItemRect(kPANE_CANCEL, (LPRECT)&rt);		m_wndStatusBar.GetPaneInfo(kPANE_CANCEL, ngID, ngStyle, cxgWidth);							// cancel button to transfer image.		switch(msgtbl.message)		{			case WM_LBUTTONDOWN:				if(*bCapturing == FALSE)				{					*bCapturing = TRUE;					::SetCapture(msgtbl.hwnd);				}				if(!rt.PtInRect(pt))				{					*bCancel = FALSE;																	return(RetCode);				}				*bCancel = TRUE;																ngStyle  = SBPS_NORMAL;				break;			case WM_MOUSEMOVE:				if(*bCancel == FALSE)	return(RetCode);				ngStyle = (rt.PtInRect(pt) && msgtbl.wParam == MK_LBUTTON) ? SBPS_NORMAL : SBPS_POPOUT;				break;			case WM_LBUTTONUP:				if(*bCapturing)				{					*bCapturing = FALSE;					::ReleaseCapture();				}				if(*bCancel == FALSE || !rt.PtInRect(pt))					return(RetCode);				*bCancel = RetCode = FALSE;				ngStyle  = SBPS_NOBORDERS;				cxgWidth = 1;				m_wndStatusBar.SetWindowText((LPCSTR)NULL);				m_wndStatusBar.SetPaneText(kPANE_CANCEL, (LPCSTR)NULL, TRUE);				m_wndStatusBar.SetPaneText(kPANE_BAR,    (LPCSTR)NULL, TRUE);				break;			default:				return(RetCode);		}		m_wndStatusBar.SetPaneInfo(kPANE_CANCEL, ngID, ngStyle, cxgWidth);							// cancel button to transfer image.		m_wndStatusBar.RedrawWindow((LPCRECT)rt);													// redraw cancel button.	}	return(RetCode);}/////////////////////////////////////////////////////////////////////////////extern "C" void CMainFrame::DrawWaitRectBar(CDC* pdc, CRect rt, short perdata)							// in is frame size. percent data.{CDC					CMemDC;CBitmap*			pOldBitmap = NULL;CBrush				CNewBrush;CBrush*				pBkBrush;CRect				rtBar;int					wpix = 1;										int 				ileft;	rtBar.CopyRect((LPCRECT)&rt);	rtBar.InflateRect(-1, -1);	ileft = rtBar.left;			rt.left+= 30;																			// set display left point of percent data. (ex:25%)	rt.top += 3;																			// set display top point of percent data.  (ex:25%)		if((pBkBrush = (CBrush*)pdc->SelectStockObject(WHITE_BRUSH)) != NULL)	{		rtBar.left = rtBar.left + perdata;		pdc->FillRect(&rtBar, pBkBrush);		pdc->SelectObject(pBkBrush);														// reset object by old back brash 		rtBar.left = ileft;	}	if(perdata == 0)																		// perdata is 0	{		if((CMemDC.CreateCompatibleDC(pdc)) != 0)		{			pOldBitmap = CMemDC.SelectObject(&m_PercentBMP);			pdc->BitBlt(rt.left+16,rt.top, 8,10,&CMemDC,   0,0,SRCINVERT);				// display data '0', +16 = 8*2 			pdc->BitBlt(rt.left+24,rt.top,11,10,&CMemDC,10*8,0,SRCINVERT);  			// display data '%', +24 = 8*3			if(pOldBitmap)	CMemDC.SelectObject(pOldBitmap);			CMemDC.DeleteDC();		}	}	if((CMemDC.CreateCompatibleDC(pdc)) != 0)	{		pOldBitmap = CMemDC.SelectObject(&m_PercentBMP);		CharPersent(pdc,&CMemDC,perdata,rt,SRCPAINT);										// dipslay percent data				if(CNewBrush.CreateSolidBrush(RGB(0,0,255)))										// blue		{			rtBar.right = rtBar.left + perdata;			pdc->FillRect(&rtBar,&CNewBrush);			CNewBrush.DeleteObject();		}		CharPersent(pdc,&CMemDC,perdata,rt,SRCINVERT);		if(pOldBitmap)		CMemDC.SelectObject(pOldBitmap);		CMemDC.DeleteDC();	}}/////////////////////////////////////////////////////////////////////////////extern "C" void CMainFrame::CharPersent(CDC *pDC,CDC *pmDC, short data, CRect rt, DWORD mode){char	wbuf[5];	wsprintf((LPSTR)wbuf,"%3d", data);	for(int i=0;;i++)	{		if(wbuf[i] == 0x20)																	// check space !			continue;																		// for loop -> top		if(wbuf[i] == 0)			break;		pDC->BitBlt(rt.left+8*i,rt.top,8,10,pmDC,(wbuf[i]-'0')*8,0,mode);					// diplay percent data.	}	pDC->BitBlt(rt.left+8*i,rt.top,11,10,pmDC,10*8,0,mode);									// display '%'}/////////////////////////////////////////////////////////////////////////////// + Ogawa#ifdef WIN32extern "C" __declspec(dllexport) BOOL pascal  InputCallbackFunction(HCHARPTR Buffer, long Offset, long Length, long RefCon) {#elseextern "C" BOOL far pascal __export InputCallbackFunction(DCProgressStatus state, 												short Percent, DCProgressType CbType){ #endif	BOOL result = TRUE;	if(theApp.m_pDCCamera->SpecificCamType != DC120) {		memcpy(theApp.m_pCompletePicture + Offset, Buffer, Length);	}		return(result);	}													   		 // - Ogawa// + Ogawa#ifdef WIN32extern "C" __declspec(dllexport) BOOL pascal  OutputCallbackFunction(HCHARPTR Buffer, long Offset, long Length, long RefCon) {#elseextern "C" BOOL far pascal __export InputCallbackFunction(DCProgressStatus state, 												short Percent, DCProgressType CbType){ #endif	BOOL result = TRUE;	memcpy(theApp.m_pCompletePicture + Offset, Buffer, Length);		return(result);	}													   		 // - Ogawa#ifdef WIN32// + Ogawaextern "C" __declspec(dllexport)BOOL pascal  ProgressCallbackFunction(DCProgressStatus state, 												short Percent, DCProgressType CbType, long RefCon){ //extern "C" __declspec(dllexport)BOOL pascal  ProgressCallbackFunction(DCProgressStatus state, //												short Percent, DCProgressType CbType){ // - Ogawa#elseextern "C" BOOL far pascal __export ProgressCallbackFunction(DCProgressStatus state, 												short Percent, DCProgressType CbType){ #endif	BOOL result = TRUE;	short value;	value = (short)state;	value = (short)Percent;	value = (short)CbType;	/*	{		CString	DebugStr;		DebugStr.Format("Percent=%3d  State=%d\n",Percent,state);		afxDump << DebugStr;	}	*/	if(theApp.m_pWndFrame != NULL)													   		 		result = theApp.m_pWndFrame->ReadAndConvertProc(state,Percent,CbType);	return(result);	}													   		 void CMainFrame::OnDCGetCameraPictureAsJPEG(){	CDCGetCameraPictureAsJPEGDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		DCCameraPtr		CameraData;		// + Ogawa		DCImageIOCBPtr	Input;		DCPictInfoPtr	Picture;		// - Ogawa		DCImageIOCBPtr	Output;		DCProgressCB	Progress;		DCProgressCBPtr	ProgressPtr; 		DCCamMemType	MemoryType;		short			AlbumNumber;		short			PictureNumber;		DCJPEGCompLevel	JPEGCompLevel;		long			JPEGSize = 0;		m_TestAppErrorCode=kNoErr;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		MemoryType = theApp.m_CamMemType;		AlbumNumber = theApp.m_AlbumNumber;		PictureNumber = theApp.m_PictureNumber;		JPEGCompLevel = theApp.m_JPEGCompLevel;		// + Ogawa		if(ParamDlg.m_IsInputNULL){			Input=NULL;		}		else{			Input=theApp.m_pInput;		}		if(ParamDlg.m_IsOutputNULL){			Output=NULL;		}		else{			Output=theApp.m_pOutput;		}		if(ParamDlg.m_IsPictInfoNULL){			Picture=NULL;		}		else{			Picture=theApp.m_pGenericInfo;		}		//if(ParamDlg.m_IsOutputNULL){		//	Output=NULL;		//}		//else{		//	Output=theApp.m_pInput;		//}		// - Ogawa		if(ParamDlg.m_IsProgressNULL){			ProgressPtr	= NULL;		}           		else{			ProgressPtr = &Progress;			// File I/O encapturated part. Resemble to the Save-As WinAPI.			Progress			= *(theApp.m_pProgress);			if(theApp.m_IsProgFuncNULL)				Progress.ProgFunc = NULL; //			Progress->ProgFunc	= ReadAndConvertProc;// To fake the C++ method to C interface callback, // ProgressCallbackFunction (C routine) is implemented in this file// And also declared in SDKT.H file. ProgressCallbackFunction is assigned as// theApp(CSDKTest1).m_Progress.ProgFunc when theApp is created.// This way of implementation is not good, but no other solution is found yet.		}//		m_SDKRetValue=DCGetCameraPictureAsJPEG(CameraData,MemoryType,AlbumNumber, PictureNumber, CompLevel,//												&JPEGSize, Output,ProgressPtr);		// + Ogawa		m_SDKRetValue=DCGetCameraPictureAsJPEG(CameraData,MemoryType,AlbumNumber, Picture, JPEGCompLevel,												&JPEGSize,Input,Output,ProgressPtr);		// - Ogawa		if(m_SDKRetValue!=kNoErr){			DispResult();		}		else{ // Save as a JPEG file.			DispResult();			if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;//			ListDlg.SetCameraTypeList();			ListDlg.DoModal(CListDlg::JPEGList, JPEGSize);			}			{				CFileDialog			SaveDlg(FALSE,"JPG","*.JPG",									OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,									"JPEG files(*.JPG)|*.DC2|All files(*.*)|*.*||",this);				CFile				SaveFile;				CFileException		FileErr;				if(SaveDlg.DoModal()==IDOK){					if(SaveFile.Open(						SaveDlg.GetPathName(),CFile::modeWrite | CFile::modeCreate | 						CFile::shareExclusive, &FileErr)!=0){						// + Ogawa						SaveFile.WriteHuge((const void far*)(Output->Buffer), JPEGSize);						//SaveFile.WriteHuge((const void far*)(Output->Buffer),Output->BufferSize);						// - Ogawa						if(FileErr.m_cause==CFileException::none){							SaveFile.Close();							return;						}						else{ // Exception happened.							SaveFile.Close();							AfxMessageBox("File I/O Exception Error");							return;						}					}   // end of Open.				} 				else{ // FileOpen is canceled.					return;				}	 			}		}	}}void CMainFrame::OnDCGetNativePictureAsJPEG(){	// File I/O encapturated part. Resemble to the OpenFile WinAPI.			{				CFileDialog			TarGetDlg(TRUE,"KDC","*.KDC",									OFN_EXTENSIONDIFFERENT | OFN_READONLY,									"KDC files(*.KDC)|*.KDC|All files(*.*)|*.*||",this);				CFile				TarGetFile;				CFileException		FileErr;				if(TarGetDlg.DoModal()==IDOK){					// + Kataoka					CFileStatus	Status;					CFile::GetStatus(TarGetDlg.GetPathName(),Status);					// - Kataoka					if(TarGetFile.Open(						TarGetDlg.GetPathName(),CFile::modeRead, &FileErr)!=0){								if(theApp.m_pInputBuffer != NULL)							theApp.HugeFree(theApp.m_pInputBuffer);						theApp.m_pInputBuffer=(HCHARPTR)theApp.HugeMalloc(Status.m_size);						theApp.m_pInput->Buffer 	= theApp.m_pInputBuffer;						theApp.m_pInput->BufferSize 	= NativeFileSize;						TarGetFile.ReadHuge((void far*)(theApp.m_pInputBuffer),Status.m_size);						if(FileErr.m_cause==CFileException::none){							TarGetFile.Close();						}						else{ // Exception happened.							TarGetFile.Close();							AfxMessageBox("File I/O Exception Error");							return;						}					}					else{   // File Open is failed.						AfxMessageBox("File Open Error");						return;					}				}				else{ // FileOpen is canceled.					return;				}				}	CDCGetNativePictureAsJPEGDlg	ParamDlg;	if(ParamDlg.DoModal()==IDOK){		// Set the parameters..			DCCameraPtr		CameraData;		// + Ogawa		DCPictInfoPtr	Picture;		// - Ogawa		DCImageIOCBPtr	Input;		DCImageIOCBPtr	Output;		DCProgressCB	Progress;		DCProgressCBPtr	ProgressPtr;		DCJPEGCompLevel	JPEGCompLevel;		long			JPEGSize = 0;		m_TestAppErrorCode=kNoErr;		JPEGCompLevel = theApp.m_JPEGCompLevel;		if(ParamDlg.m_IsCameraDataNULL){			CameraData=NULL;		}		else{			CameraData=theApp.m_pDCCamera;		}		// + Ogawa		if(ParamDlg.m_IsPictInfoNULL){			Picture=NULL;		}		else{			Picture=theApp.m_pGenericInfo;		}		// - Ogawa		if(ParamDlg.m_IsInputNULL){			Input=NULL;		}		else{			Input=theApp.m_pInput;		}		if(ParamDlg.m_IsOutputNULL){			Output=NULL;		}		else{ // + Ohbe Output must be re-alocated to fit the curent PictOrientation when handling NativePicture....//   This is the temporary processing. 			Output=theApp.m_pOutput; // - Ohbe					} 		if(ParamDlg.m_IsProgressNULL){			ProgressPtr	= NULL;		}           		else{			ProgressPtr = &Progress;			// File I/O encapturated part. Resemble to the Save-As WinAPI.			Progress			= *(theApp.m_pProgress);			if(theApp.m_IsProgFuncNULL)				Progress.ProgFunc = NULL; 		}		// Call GetNativePictureAsJPEG Function.	//		m_SDKRetValue=DCGetNativePictureAsJPEG(CameraData,JPEGCompLevel,//										&JPEGSize, Input,Output,ProgressPtr);		// + Ogawa		m_SDKRetValue=DCProcNativePictureAsJPEG(CameraData,Picture,JPEGCompLevel,										&JPEGSize,Input,Output,ProgressPtr);		// - Ogawa		if(m_SDKRetValue!=kNoErr){			DispResult();		}		else{ // Save as a JPEG file.			DispResult();			if(m_SDKRetValue == DC_NoErr){			CListDlg	ListDlg;//			ListDlg.SetCameraTypeList();			ListDlg.DoModal(CListDlg::JPEGList, JPEGSize);			}			{				CFileDialog			SaveDlg(FALSE,"JPG","*.JPG",									OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,									"JPEG files(*.JPG)|*.DC2|All files(*.*)|*.*||",this);				CFile				SaveFile;				CFileException		FileErr;				if(SaveDlg.DoModal()==IDOK){					if(SaveFile.Open(						SaveDlg.GetPathName(),CFile::modeWrite | CFile::modeCreate | 						CFile::shareExclusive, &FileErr)!=0){						SaveFile.WriteHuge((const void far*)(Output->Buffer), JPEGSize);						if(FileErr.m_cause==CFileException::none){							SaveFile.Close();							return;						}						else{ // Exception happened.							SaveFile.Close();							AfxMessageBox("File I/O Exception Error");							return;						}					}   // end of Open.				} 				else{ // FileOpen is canceled.					return;				}	 			}		}	}}