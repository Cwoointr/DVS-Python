/***************************************************************  Copyright 1996, Eastman Kodak Company	**  All Rights Reserved                           ******************************************************************  FACILITY:**       DITHER.CPP --- This file is made by 4-htab.****  ABSTRACT:****  AUTHORS:**		Toru Kataoka, Eastman Kodak (Japan) R&D Center ****  CREATION DATE:****		Mar./1/1996****  MODIFICATION HISTORY:****		Mar./26/1996**			This is d1 version.*************************************************************/#include "stdafx.h"#ifdef	EqualizeColorPalette	#if ColorDepth==5		const BYTE CDither::m_ColorTable[]={0,64,128,192,255};	#else		#if ColorDepth==6			const BYTE CDither::m_ColorTable[]={0,51,102,153,204,255};		#else			#error ColorDepth must be 5 or 6.		#endif	#endif#else	const BYTE	CDither::m_RedTable[]={0,43,85,128,170,213,255};	const BYTE	CDither::m_GreenTable[]={0,43,85,128,170,213,255};	const BYTE	CDither::m_BlueTable[]={0,85,170,255};#endifconst BYTE CDither::m_GrayTable[]={0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255};const short CDither::m_Filter[]={0,0,-112,-48,-80,-16};CDither::CDither(){	m_PaletteEnable=FALSE;}CDither::~CDither(){	if(m_PaletteEnable==TRUE){		DeleteObject();	}}BOOL CDither::CreatePalette(CWnd* pWnd){	short			Count;	LPLOGPALETTE	pLogPalette;	int				RetValue;	CDC*			pDC;	if(m_PaletteEnable==TRUE){		return(TRUE);	}	pDC=pWnd->GetDC();	if(pDC==NULL){		return(FALSE);	}	RetValue=pDC->GetDeviceCaps(RASTERCAPS);	pWnd->ReleaseDC(pDC);	if(!(RetValue & RC_PALETTE)){		return(FALSE);	}	pLogPalette=(LPLOGPALETTE)GlobalAllocPtr(GHND,sizeof(LOGPALETTE)+sizeof(PALETTEENTRY)*DitheringPaletteSize);	if(pLogPalette==NULL){		return(FALSE);	}	for(Count=0;Count < ColorPaletteSize;Count++){#ifdef	EqualizeColorPalette		pLogPalette->palPalEntry[Count].peRed	=m_ColorTable[Count % ColorDepth];		pLogPalette->palPalEntry[Count].peGreen	=m_ColorTable[(Count / ColorDepth) % ColorDepth];    	pLogPalette->palPalEntry[Count].peBlue	=m_ColorTable[Count / (ColorDepth*ColorDepth)];		pLogPalette->palPalEntry[Count].peFlags	=PC_RESERVED;#else		pLogPalette->palPalEntry[Count].peRed	=m_RedTable[Count % RedDepth];		pLogPalette->palPalEntry[Count].peGreen	=m_GreenTable[(Count / RedDepth) % GreenDepth];    	pLogPalette->palPalEntry[Count].peBlue	=m_BlueTable[Count / (RedDepth*GreenDepth)];		pLogPalette->palPalEntry[Count].peFlags	=PC_RESERVED;#endif	}	for(Count=0;Count < GrayPaletteSize;Count++){		pLogPalette->palPalEntry[Count+ColorPaletteSize].peRed		=m_GrayTable[Count];		pLogPalette->palPalEntry[Count+ColorPaletteSize].peGreen	=m_GrayTable[Count];    	pLogPalette->palPalEntry[Count+ColorPaletteSize].peBlue		=m_GrayTable[Count];		pLogPalette->palPalEntry[Count+ColorPaletteSize].peFlags	=PC_RESERVED;	}	pLogPalette->palNumEntries=DitheringPaletteSize;	pLogPalette->palVersion=0x0300;	if(CPalette::CreatePalette(pLogPalette)!=0){		m_PaletteEnable=TRUE;	}	GlobalFreePtr(pLogPalette);	return(m_PaletteEnable);}BOOL CDither::SetColorIndex(BYTE huge* DstPtr){	WORD	Count;	BYTE	ByteTemp;	if(CPalette::GetPaletteEntries(0,DitheringPaletteSize,(LPPALETTEENTRY)DstPtr)==0){		return(FALSE);	}	for(Count=0;Count < DitheringPaletteSize;Count++){		ByteTemp=((RGBQUAD huge*)DstPtr)->rgbRed;		((RGBQUAD huge*)DstPtr)->rgbRed=((RGBQUAD huge*)DstPtr)->rgbBlue;		((RGBQUAD huge*)DstPtr)->rgbBlue=ByteTemp;		((RGBQUAD huge*)DstPtr)->rgbReserved=0;		DstPtr=DstPtr+sizeof(RGBQUAD);	}	for(;Count < 256;Count++){		((RGBQUAD huge*)DstPtr)->rgbRed=0;		((RGBQUAD huge*)DstPtr)->rgbGreen=0;		((RGBQUAD huge*)DstPtr)->rgbBlue=0;		((RGBQUAD huge*)DstPtr)->rgbReserved=0;		DstPtr=DstPtr+sizeof(RGBQUAD);	}	return(TRUE);}BOOL CDither::MakeDitherImage(LPVOID BMPHeader,LPVOID SourceImage,LPVOID DestnationImage,WORD ImageWidth,WORD ImageHeight){	register BYTE huge*	SrcPtr;	register BYTE huge*	DstPtr;	WORD				SrcRowBytes,DstRowBytes;	WORD				HCount,VCount,XCount,YCount;	WORD				MCount;	short				dat,out;	short				err;	WORD				ErrorWidth;	WORD				ErrorOffset;	short*				pError;	short*				FilterPtr;	short*				ErrPtr;	short*				pGetErr;	register short*		pSetErr;	short				x,wd;	if(m_PaletteEnable==FALSE){		return(FALSE);	}	if(SetColorIndex((BYTE huge*)BMPHeader+sizeof(BITMAPINFOHEADER))==FALSE){		return(FALSE);	}	ErrorWidth=(ImageWidth+10);	ErrorOffset=ErrorWidth*2;	pError=new short[ErrorOffset*3];	if(pError==NULL){		return(NULL);	}	for(VCount=0;VCount < (ErrorOffset*3);VCount++){		pError[VCount]=0;	}	SrcPtr=(BYTE huge*)SourceImage;	DstPtr=(BYTE huge*)DestnationImage;	SrcRowBytes=(ImageWidth*3+3)/4*4-ImageWidth*3;//	SrcRowBytes=0;	DstRowBytes=(ImageWidth+3)/4*4-ImageWidth;	for(VCount=0;VCount < ImageHeight;VCount++){		for(HCount=0;HCount < ImageWidth;HCount++,DstPtr++){			ErrPtr=pError;			pGetErr=ErrPtr+((VCount & 0x0001) ? ErrorWidth : 0)+HCount;#ifdef	EqualizeColorPalette			for(MCount=0;MCount < 3;MCount++,SrcPtr++){				dat=*(SrcPtr);				err=*(pGetErr) >> 8;	#if ColorDepth==5				out=4-((dat+err) >> 6);				out=256-(out << 6);				out=out >> 6;				*DstPtr=*(DstPtr)*5+(BYTE)out;				out=out << 6;				err=out-dat-err;	#else		#if ColorDepth==6				out=5-(dat+err)/51;				out=255-out*51;				err=out-dat-err;				*DstPtr=*(DstPtr)*6+(BYTE)(out/51);		#endif	#endif				x=HCount-1;				FilterPtr=(short*)m_Filter;				for(YCount=0;YCount < 2;YCount++){					pSetErr=ErrPtr+x+(((YCount + VCount) & 0x0001) ? ErrorWidth : 0);					if(x >= 0){						wd=*(FilterPtr)*err;						*(pSetErr)+=wd;					}					FilterPtr++;					pSetErr++;					wd=*(FilterPtr)*err;					*(pSetErr)+=wd;					FilterPtr++;					pSetErr++;					wd=*(FilterPtr)*err;					*(pSetErr)+=wd;					FilterPtr++;				}				pGetErr=pGetErr+ErrorOffset;				ErrPtr=ErrPtr+ErrorOffset;			}#else//// Blue			dat=*SrcPtr++;			err=*(pGetErr) >> 8;			out=(255-(dat+err))*(BlueDepth-1)/255;			out=255-out*255/(BlueDepth-1);			err=out-dat-err;			MCount=(WORD)out*(BlueDepth-1)*RedDepth*GreenDepth/255;			x=HCount-1;			FilterPtr=(short*)m_Filter;			for(YCount=0;YCount < 2;YCount++){				pSetErr=ErrPtr+x+(((YCount + VCount) & 0x0001) ? ErrorWidth : 0);				if(x >= 0){					wd=*(FilterPtr)*err;					*(pSetErr)+=wd;				}				FilterPtr++;				pSetErr++;				wd=*(FilterPtr)*err;				*(pSetErr)+=wd;				FilterPtr++;				pSetErr++;				wd=*(FilterPtr)*err;				*(pSetErr)+=wd;				FilterPtr++;			}			pGetErr=pGetErr+ErrorOffset;			ErrPtr=ErrPtr+ErrorOffset;//// Green			dat=*SrcPtr++;			err=*(pGetErr) >> 8;			out=(255-(dat+err))*(GreenDepth-1)/255;			out=255-out*255/(GreenDepth-1);			err=out-dat-err;			MCount=MCount+(WORD)out*(GreenDepth-1)*RedDepth/255;			x=HCount-1;			FilterPtr=(short*)m_Filter;			for(YCount=0;YCount < 2;YCount++){				pSetErr=ErrPtr+x+(((YCount + VCount) & 0x0001) ? ErrorWidth : 0);				if(x >= 0){					wd=*(FilterPtr)*err;					*(pSetErr)+=wd;				}				FilterPtr++;				pSetErr++;				wd=*(FilterPtr)*err;				*(pSetErr)+=wd;				FilterPtr++;				pSetErr++;				wd=*(FilterPtr)*err;				*(pSetErr)+=wd;				FilterPtr++;			}			pGetErr=pGetErr+ErrorOffset;			ErrPtr=ErrPtr+ErrorOffset;//// Red			dat=*SrcPtr++;			err=*(pGetErr) >> 8;			out=(255-(dat+err))*(RedDepth-1)/255;			out=255-out*255/(RedDepth-1);			err=out-dat-err;			MCount=MCount+(WORD)out*(RedDepth-1)/255;			*DstPtr=(BYTE)MCount;			x=HCount-1;			FilterPtr=(short*)m_Filter;			for(YCount=0;YCount < 2;YCount++){				pSetErr=ErrPtr+x+(((YCount + VCount) & 0x0001) ? ErrorWidth : 0);				if(x >= 0){					wd=*(FilterPtr)*err;					*(pSetErr)+=wd;				}				FilterPtr++;				pSetErr++;				wd=*(FilterPtr)*err;				*(pSetErr)+=wd;				FilterPtr++;				pSetErr++;				wd=*(FilterPtr)*err;				*(pSetErr)+=wd;				FilterPtr++;			}#endif		}		pSetErr=pError+((VCount & 0x0001) ? ErrorWidth : 0);		for(YCount=0;YCount < 3;YCount++){			ErrPtr=pSetErr;			for(XCount=0;XCount < ErrorWidth;XCount++,ErrPtr++){				*ErrPtr=0;			}			pSetErr=pSetErr+ErrorOffset;		}		SrcPtr=SrcPtr+SrcRowBytes;		DstPtr=DstPtr+DstRowBytes;	}	delete [] pError;	return(TRUE);}BOOL CDither::MakeDitherThumbnail(LPVOID BMPHeader,LPVOID SourceImage,LPVOID DestnationImage,WORD ImageWidth,WORD ImageHeight){	register BYTE huge*	SrcPtr;	register BYTE huge*	DstPtr;	WORD				RowBytes;	WORD				HCount,VCount,YCount;	short				dat,out;	short				err;	WORD				ErrorWidth;	WORD				ErrorOffset;	short*				pError;	short*				FilterPtr;	short*				ErrPtr;	short*				pGetErr;	short				x,wd;	if(m_PaletteEnable==FALSE){		return(FALSE);	}	if(SetColorIndex((BYTE huge*)BMPHeader+sizeof(BITMAPINFOHEADER))==FALSE){		return(FALSE);	}	ErrorWidth=ImageWidth+10;	ErrorOffset=ErrorWidth*2;	pError=new short[ErrorOffset];	if(pError==NULL){		return(NULL);	}	for(VCount=0;VCount < ErrorOffset;VCount++){		pError[VCount]=0;	}	SrcPtr=(BYTE huge*)SourceImage;	DstPtr=(BYTE huge*)DestnationImage;	RowBytes=(ImageWidth+3)/4*4-ImageWidth;	for(VCount=0;VCount < ImageHeight;VCount++){		pGetErr=pError+((VCount & 0x0001) ? ErrorWidth : 0);		for(HCount=0;HCount < ImageWidth;HCount++,SrcPtr++,DstPtr++,pGetErr++){			dat=*SrcPtr;			err=*pGetErr >> 8;			out=GrayCoef1(255-(dat+err));			out=255-GrayCoef2(out);			err=out-dat-err;			*DstPtr=(BYTE)GrayCoef1(out)+ColorPaletteSize;			x=HCount-1;			FilterPtr=(short*)m_Filter;			for(YCount=0;YCount < 2;YCount++){				ErrPtr=pError+x+(((YCount + VCount) & 0x0001) ? ErrorWidth : 0);				if(x >= 0){					wd=*(FilterPtr)*err;					*(ErrPtr)+=wd;				}				FilterPtr++;				ErrPtr++;				wd=*(FilterPtr)*err;				*(ErrPtr)+=wd;				FilterPtr++;				ErrPtr++;				wd=*(FilterPtr)*err;				*(ErrPtr)+=wd;				FilterPtr++;			}		}		ErrPtr=pError+((VCount & 0x0001) ? ErrorWidth : 0);		for(HCount=0;HCount < ErrorWidth;HCount++,ErrPtr++){			*ErrPtr=0;		}		SrcPtr=SrcPtr+RowBytes;		DstPtr=DstPtr+RowBytes;	}	delete [] pError;	return(TRUE);}