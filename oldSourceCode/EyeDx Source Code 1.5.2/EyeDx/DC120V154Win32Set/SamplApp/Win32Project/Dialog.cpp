// dialog.cpp : implementation file//#include "stdafx.h"#include <limits.h>#include "SdkTest1.h"#include "Dialog.h"#include "Property.h"#ifdef _DEBUG#undef THIS_FILEstatic char BASED_CODE THIS_FILE[] = __FILE__;#endif/////////////////////////////////////////////////////////////////////////////// CTimeStampDlg dialogCTimeStampDlg::CTimeStampDlg(CWnd* pParent /*=NULL*/)	: CDialog(CTimeStampDlg::IDD, pParent){	//{{AFX_DATA_INIT(CTimeStampDlg)	m_Year = 0;	m_Month = 0;	m_Day = 0;	m_Hour = 0;	m_Minute = 0;	m_sec = 0;	m_YearDay = 0;	m_WeekDay = 0;	m_Isdst = 0;	//}}AFX_DATA_INIT}void CTimeStampDlg::DoDataExchange(CDataExchange* pDX){	CDialog::DoDataExchange(pDX);	//{{AFX_DATA_MAP(CTimeStampDlg)	DDX_Text(pDX, IDC_Year, m_Year);	DDX_Text(pDX, IDC_Mon, m_Month);	DDX_Text(pDX, IDC_Day, m_Day);	DDX_Text(pDX, IDC_Hour, m_Hour);	DDX_Text(pDX, IDC_Min, m_Minute);	DDX_Text(pDX, IDC_Sec, m_sec);	DDX_Text(pDX, IDC_yDay, m_YearDay);	DDX_Text(pDX, IDC_wDay, m_WeekDay);	DDX_Text(pDX, IDC_Isdst, m_Isdst);	//}}AFX_DATA_MAP}BEGIN_MESSAGE_MAP(CTimeStampDlg, CDialog)	//{{AFX_MSG_MAP(CTimeStampDlg)	//}}AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CTimeStampDlg message handlersBOOL CTimeStampDlg::OnInitDialog(){	CDialog::OnInitDialog();		// TODO: Add extra initialization here		return TRUE;  // return TRUE  unless you set the focus to a control}/////////////////////////////////////////////////////////////////////////////// CDump dialogCDump::CDump(CWnd* pParent /*=NULL*/)	: CDialog(CDump::IDD, pParent){	//{{AFX_DATA_INIT(CDump)		// NOTE: the ClassWizard will add member initialization here	//}}AFX_DATA_INIT}void CDump::DoDataExchange(CDataExchange* pDX){	CDialog::DoDataExchange(pDX);	//{{AFX_DATA_MAP(CDump)		// NOTE: the ClassWizard will add DDX and DDV calls here	//}}AFX_DATA_MAP}BEGIN_MESSAGE_MAP(CDump, CDialog)	//{{AFX_MSG_MAP(CDump)		// NOTE: the ClassWizard will add message map macros here	//}}AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CDump message handlersvoid CPictInfoPage::OnTimeStamp(){	// TODO: Add your control notification handler code here	}/////////////////////////////////////////////////////////////////////////////// CImageType dialogCImageType::CImageType(CWnd* pParent/*=NULL*/)	: CDialog(CImageType::IDD, pParent){	//{{AFX_DATA_INIT(CImageType)		// NOTE: the ClassWizard will add member initialization here	//}}AFX_DATA_INIT}void CImageType::DoDataExchange(CDataExchange* pDX){	CDialog::DoDataExchange(pDX);	//{{AFX_DATA_MAP(CImageType)		// NOTE: the ClassWizard will add DDX and DDV calls here	//}}AFX_DATA_MAP}BEGIN_MESSAGE_MAP(CImageType, CDialog)	//{{AFX_MSG_MAP(CImageType)	ON_WM_RBUTTONDOWN()	ON_WM_NCRBUTTONDOWN()	ON_BN_CLICKED(IDC_FULLIMG, OnFullimg)	ON_BN_CLICKED(IDC_INFO, OnInfo)	//}}AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CImageType message handlersBOOL CImageType::OnInitDialog() {	CDialog::OnInitDialog();	CRect	WndRect,DesktopRect,ChkRect;	POINT	MousePoint;	CSize	WndSize;	GetCursorPos(&MousePoint);	GetDesktopWindow()->GetWindowRect(DesktopRect);	GetWindowRect(WndRect);	WndRect.OffsetRect(-WndRect.TopLeft());	WndSize=WndRect.Size();	MousePoint.x=MousePoint.x-WndSize.cx/2;	MousePoint.y=MousePoint.y-WndSize.cy/2;	WndRect.OffsetRect(MousePoint);	ChkRect.IntersectRect(WndRect,DesktopRect);	if(ChkRect!=WndRect){	//Out of desktop window		CPoint	OffsetPoint(0,0);		if(WndRect.left < DesktopRect.left){			OffsetPoint.x=DesktopRect.left-WndRect.left;		} else {			if(WndRect.right > DesktopRect.right){				OffsetPoint.x=DesktopRect.right-WndRect.right;			}		}		if(WndRect.top < DesktopRect.top){			OffsetPoint.y=DesktopRect.top-WndRect.top;		} else {			if(WndRect.bottom > DesktopRect.bottom){				OffsetPoint.y=DesktopRect.bottom-WndRect.bottom;			}		}		WndRect.OffsetRect(OffsetPoint);		MousePoint.x=WndRect.left+WndRect.Width()/2;		MousePoint.y=WndRect.top+WndRect.Height()/2;		SetCursorPos(MousePoint.x,MousePoint.y);	}	MoveWindow(WndRect);	WndRect.InflateRect(-1,-1);	ClipCursor(WndRect);	return TRUE;  // return TRUE unless you set the focus to a control	              // EXCEPTION: OCX Property Pages should return FALSE}void CImageType::OnRButtonDown(UINT nFlags, CPoint point) {	SetRetValue(IDCANCEL);}void CImageType::OnNcRButtonDown(UINT nHitTest, CPoint point) {	SetRetValue(IDCANCEL);}void CImageType::OnFullimg() {	SetRetValue(IDC_FULLIMG);}void CImageType::OnInfo() {	SetRetValue(IDC_INFO);}void CImageType::SetRetValue(int RetID){	ClipCursor(NULL);	CDialog::EndDialog(RetID);}/////////////////////////////////////////////////////////////////////////////// CLoadThumb dialogCLoadThumb::CLoadThumb(int TotalImages,CWnd* pParent /*=NULL*/)	: CDialog(CLoadThumb::IDD, pParent){	m_TotalImages=TotalImages;	//{{AFX_DATA_INIT(CLoadThumb)	m_Images = _T("");	m_LoadFlag = 0;	m_Start = 0;	m_End = 0;	//}}AFX_DATA_INIT}void CLoadThumb::DoDataExchange(CDataExchange* pDX){	CDialog::DoDataExchange(pDX);	//{{AFX_DATA_MAP(CLoadThumb)	DDX_Text(pDX, IDC_END, m_End);	DDX_Text(pDX, IDC_START, m_Start);	DDX_Text(pDX, IDC_IMAGES, m_Images);	DDX_Radio(pDX, IDC_ALL, m_LoadFlag);	//}}AFX_DATA_MAP}BEGIN_MESSAGE_MAP(CLoadThumb, CDialog)	//{{AFX_MSG_MAP(CLoadThumb)	ON_BN_CLICKED(IDC_ALL, UpdateControl)	ON_BN_CLICKED(IDC_FROM, UpdateControl)	//}}AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CLoadThumb message handlersBOOL CLoadThumb::OnInitDialog() {	CDialog::OnInitDialog();	wsprintf(m_Images.GetBuffer(16),"%d",m_TotalImages);	m_Images.ReleaseBuffer();	m_Start = 1;	m_End = m_TotalImages;	UpdateData(FALSE);	UpdateControl();	return TRUE;  // return TRUE unless you set the focus to a control	              // EXCEPTION: OCX Property Pages should return FALSE}void CLoadThumb::UpdateControl(){	UpdateData(TRUE);	GetDlgItem(IDC_START)->EnableWindow(m_LoadFlag);	GetDlgItem(IDC_TO)->EnableWindow(m_LoadFlag);	GetDlgItem(IDC_END)->EnableWindow(m_LoadFlag);}void CLoadThumb::NumberError(){	AfxMessageBox("From or To Number Error");}void CLoadThumb::OnOK() {	UpdateData(TRUE);	switch(m_LoadFlag){		case 1:			if(m_Start > m_End){				NumberError();				break;			}			if(m_Start < 1){				NumberError();				break;			}			if(m_End > m_TotalImages){				NumberError();				break;			}			CDialog::OnOK();			break;		default:			m_Start=1;			m_End=m_TotalImages;			CDialog::OnOK();	}}/////////////////////////////////////////////////////////////////////////////// CImage dialogCImage::CImage(CWnd* pParent /*=NULL*/)	: CDialog(CImage::IDD, pParent){	m_CxFrame=GetSystemMetrics(SM_CXFRAME)*2;	m_CyFrame=GetSystemMetrics(SM_CYFRAME)*2+GetSystemMetrics(SM_CYCAPTION)+GetSystemMetrics(SM_CYMENU);	m_VertScrollSize=GetSystemMetrics(SM_CXVSCROLL);	m_HorzScrollSize=GetSystemMetrics(SM_CYHSCROLL);}CImage::~CImage(){	if(m_Image.hBitmap!=NULL){		DeleteObject(m_Image.hBitmap);	}}int CImage::DoModal(ImageStruct& ImageInfo){	m_Image=ImageInfo;	return(CDialog::DoModal());}void CImage::DoDataExchange(CDataExchange* pDX){	CDialog::DoDataExchange(pDX);}BEGIN_MESSAGE_MAP(CImage, CDialog)	//{{AFX_MSG_MAP(CImage)	ON_COMMAND(ID_SAVE, OnSaveImage)	ON_COMMAND(ID_TRANSFER, OnTransfer)	ON_WM_PAINT()	ON_WM_HSCROLL()	ON_WM_VSCROLL()	ON_WM_SIZE()	ON_WM_DESTROY()	//}}AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CImage message handlersBOOL CImage::OnInitDialog(){	CDialog::OnInitDialog();	SetScroll();	return TRUE;  										// return TRUE  unless you set the focus to a control}///////////////////////////////////////////////////////////////////////////////void CImage::SetScroll(){	BOOL	HorzScrollFlag=FALSE;	GetWindowRect(m_ViewRect);	m_ViewRect.right=m_ViewRect.right-m_CxFrame;	m_ViewRect.bottom=m_ViewRect.bottom-m_CyFrame;	m_HorzScrollRange=m_Image.PictureWidth-m_ViewRect.Width();	if(m_HorzScrollRange <= 0){		m_HorzScrollRange=0;		HorzScrollFlag=FALSE;	} else {		m_ViewRect.bottom=m_ViewRect.bottom-m_HorzScrollSize;		if(m_ViewRect.bottom < m_ViewRect.top){			m_ViewRect.bottom=m_ViewRect.top;		}		HorzScrollFlag=TRUE;	}	m_VertScrollRange=m_Image.PictureHeight-m_ViewRect.Height();	if(m_VertScrollRange <= 0){		m_VertScrollRange=0;	} else {		m_ViewRect.right=m_ViewRect.right-m_VertScrollSize;		if(m_ViewRect.right < m_ViewRect.left){			m_ViewRect.right=m_ViewRect.left;		}		m_VertScrollRange=m_Image.PictureHeight-m_ViewRect.Height();			m_HorzScrollRange=m_Image.PictureWidth-m_ViewRect.Width();		if(HorzScrollFlag==FALSE){			if(m_HorzScrollRange > 0){				m_ViewRect.bottom=m_ViewRect.bottom-m_HorzScrollSize;				if(m_ViewRect.bottom < m_ViewRect.top){					m_ViewRect.bottom=m_ViewRect.top;				}				m_VertScrollRange=m_Image.PictureHeight-m_ViewRect.Height();			}		}	}	m_ViewRect.bottom=m_ViewRect.bottom-m_ViewRect.top;	m_ViewRect.top=0;	m_ViewRect.right=m_ViewRect.right-m_ViewRect.left;	m_ViewRect.left=0;	SetScrollRange(SB_HORZ,0,m_HorzScrollRange,FALSE);	SetScrollRange(SB_VERT,0,m_VertScrollRange,FALSE);	m_HorzScrollPos=0;	m_VertScrollPos=0;	m_DrawHorzPos=m_HorzScrollPos;	m_DrawVertPos=m_VertScrollPos;	SetScrollPos(SB_HORZ,m_HorzScrollPos,TRUE);	SetScrollPos(SB_VERT,m_VertScrollPos,TRUE);}///////////////////////////////////////////////////////////////////////////////void CImage::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) {	int		ScrollPosTemp;	ScrollPosTemp=m_HorzScrollPos;	switch(nSBCode){	case SB_LEFT:			// Scroll to far left.		ScrollPosTemp=0;		break;	case SB_RIGHT:			// Scroll to far right.		ScrollPosTemp=m_Image.PictureWidth;		break;	case SB_LINELEFT:		// Scroll left.		ScrollPosTemp--;		break;	case SB_LINERIGHT:		// Scroll right.		ScrollPosTemp++;		break;	case SB_PAGELEFT:		// Scroll one page left.		ScrollPosTemp=ScrollPosTemp-m_ViewRect.Width();		break;	case SB_PAGERIGHT:		// Scroll one page right.		ScrollPosTemp=ScrollPosTemp+m_ViewRect.Width();		break;	case SB_THUMBPOSITION:	// Scroll to absolute position. The current position is specified by the nPos parameter.	case SB_THUMBTRACK:		// Drag scroll box to specified position. The current position is specified by the nPos parameter.		ScrollPosTemp=nPos;		break;	case SB_ENDSCROLL:		// End scroll.	default:		break;	}	if(ScrollPosTemp < 0){		ScrollPosTemp=0;	}	if(ScrollPosTemp > m_HorzScrollRange){		ScrollPosTemp=m_HorzScrollRange;	}	if(ScrollPosTemp!=m_HorzScrollPos){		CRect	InvalidateArea(m_ViewRect);		if((m_HorzScrollPos-ScrollPosTemp) < 0){			InvalidateArea.left=InvalidateArea.right+(m_HorzScrollPos-ScrollPosTemp);		} else {			InvalidateArea.right=m_HorzScrollPos-ScrollPosTemp;		}		if(InvalidateArea.Width() < m_ViewRect.Width()){			ScrollWindow(m_HorzScrollPos-ScrollPosTemp,0,NULL,NULL);			InvalidateRect(InvalidateArea,TRUE);		} else {			Invalidate();		}	}	m_HorzScrollPos=ScrollPosTemp;	SetScrollPos(SB_HORZ,m_HorzScrollPos,TRUE);	nPos=m_HorzScrollPos;	UpdateWindow();	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);}void CImage::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) {	int		ScrollPosTemp;	ScrollPosTemp=m_VertScrollPos;	switch(nSBCode){	case SB_TOP:			// Scroll to top.		ScrollPosTemp=0;		break;	case SB_BOTTOM:			// Scroll to bottom.		ScrollPosTemp=m_Image.PictureHeight;		break;	case SB_LINEUP:			// Scroll up.		ScrollPosTemp--;		break;	case SB_LINEDOWN:		// Scroll down.		ScrollPosTemp++;		break;	case SB_PAGEUP:			// Scroll one page up.		ScrollPosTemp=ScrollPosTemp-m_ViewRect.Height();		break;	case SB_PAGEDOWN:		// Scroll one page down.		ScrollPosTemp=ScrollPosTemp+m_ViewRect.Height();		break;	case SB_THUMBPOSITION:	// Scroll to absolute position. The current position is specified by the nPos parameter.	case SB_THUMBTRACK:		// Drag scroll box to specified position. The current position is specified by the nPos parameter.		ScrollPosTemp=nPos;		break;	case SB_ENDSCROLL:		// End scroll.	default:		break;	}	if(ScrollPosTemp < 0){		ScrollPosTemp=0;	}	if(ScrollPosTemp > m_VertScrollRange){		ScrollPosTemp=m_VertScrollRange;	}	if(ScrollPosTemp!=m_VertScrollPos){		CRect	InvalidateArea(m_ViewRect);		if((m_VertScrollPos-ScrollPosTemp) < 0){			InvalidateArea.top=InvalidateArea.bottom+(m_VertScrollPos-ScrollPosTemp);		} else {			InvalidateArea.bottom=m_VertScrollPos-ScrollPosTemp;		}		if(InvalidateArea.Height() < m_ViewRect.Height()){			ScrollWindow(0,m_VertScrollPos-ScrollPosTemp,NULL,NULL);			InvalidateRect(InvalidateArea,TRUE);		} else {			Invalidate(TRUE);		}	}	m_VertScrollPos=ScrollPosTemp;	SetScrollPos(SB_VERT,m_VertScrollPos,TRUE);	nPos=m_VertScrollPos;	UpdateWindow();	CDialog::OnVScroll(nSBCode, nPos, pScrollBar);}///////////////////////////////////////////////////////////////////////////////void CImage::OnSize(UINT nType, int cx, int cy){	CDialog::OnSize(nType, cx, cy);	SetScroll();	Invalidate();}///////////////////////////////////////////////////////////////////////////////void CImage::OnPaint(){	CPaintDC dc(this); // device context for painting	CRect	DrawRect;	dc.GetClipBox(DrawRect);	HDC			hdc;	HDC			hdcmem;	HGDIOBJ		hOldGDI;	int			BitmapWidth;	int			BitmapHeight;	if(m_Image.hBitmap!=NULL){		BitmapWidth=m_Image.PictureWidth;		BitmapHeight=m_Image.PictureHeight;		if(BitmapWidth > DrawRect.Width()){			BitmapWidth=DrawRect.Width();		}		if(BitmapHeight > DrawRect.Height()){			BitmapHeight=DrawRect.Height();		}			hdc = dc.m_ps.hdc;		if((hdcmem = CreateCompatibleDC(hdc)) != NULL)			// create compatible dc to draw thumb nail image		{			hOldGDI = SelectObject(hdcmem,m_Image.hBitmap);	// select object of thumb nail image 			BitBlt( hdc,					DrawRect.left,					DrawRect.top,		    	   	BitmapWidth,		    	   	BitmapHeight,			       	hdcmem,			       	DrawRect.left+m_HorzScrollPos,			       	DrawRect.top+m_VertScrollPos,			       	SRCCOPY);			if(hOldGDI)				SelectObject(hdcmem, hOldGDI);					// reset object by old bitmap 			DeleteDC(hdcmem);									// delete the dc memory was created by CreateCompatibleDC(). 			}	}}void CImage::OnSaveImage(){	CFileDialog			SaveDlg(FALSE,"BMP","*.BMP",								OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,								"Bitmap files(*.BMP)|*.BMP|All files(*.*)|*.*||",this);	CFile				SaveFile;	CFileException		FileErr;	BITMAPFILEHEADER    BitmapFileHeader;	if(SaveDlg.DoModal()==IDOK){		if(SaveFile.Open(			SaveDlg.GetPathName(),			CFile::modeWrite | CFile::modeCreate | CFile::shareExclusive,			&FileErr)!=0){			*((char*)&BitmapFileHeader.bfType+0)='B';			*((char*)&BitmapFileHeader.bfType+1)='M';			BitmapFileHeader.bfSize=(DWORD)sizeof(BITMAPFILEHEADER)+m_Image.BmpInfoSize+m_Image.BmpPictureSize;			BitmapFileHeader.bfReserved1=0;			BitmapFileHeader.bfReserved2=0;			BitmapFileHeader.bfOffBits=sizeof(BITMAPFILEHEADER)+m_Image.BmpInfoSize;			SaveFile.Write((const void far*)&BitmapFileHeader,sizeof(BITMAPFILEHEADER));			if(FileErr.m_cause==CFileException::none){				SaveFile.WriteHuge((const void far*)m_Image.lpBitmapInfo,(DWORD)m_Image.BmpInfoSize);				if(FileErr.m_cause==CFileException::none){					SaveFile.WriteHuge((const void far*)m_Image.pPicture,m_Image.BmpPictureSize);					if(FileErr.m_cause==CFileException::none){						SaveFile.Close();						return;					}				}			}			SaveFile.Close();			AfxMessageBox("File Write Error");		}	}}void CImage::OnTransfer(){	::OpenClipboard(m_hWnd);	::EmptyClipboard();	::SetClipboardData(CF_BITMAP,m_Image.hBitmap);    ::CloseClipboard();}void CImage::OnDestroy() {	CDialog::OnDestroy();}/////////////////////////////////////////////////////////////////////////////// CListDlg dialogCListDlg::CListDlg(CWnd* pParent /*=NULL*/)	: CDialog(CListDlg::IDD, pParent){	//{{AFX_DATA_INIT(CListDlg)		// NOTE: the ClassWizard will add member initialization here	//}}AFX_DATA_INIT}const LPCSTR CListDlg::BOOLArray[2]={ {"FALSE"}, {"TRUE"} };const LPCSTR CListDlg::PictureModeArray[3]={ {"HighResolution"},											 {"StandardResolution"}, {"DataError"} };const LPCSTR CListDlg::BatteryArray[4]={ {"BatteryOK"}, {"BatteryWeek"},										 {"BatteryEmpty"}, {"DataError"} };const LPCSTR CListDlg::FlashArray[4]={ {"FlashAuto"}, {"FlashOn"},									   {"FlashOff"}, {"DataError"} };const LPCSTR RotateAngleArray[6]={ {"0 degree"}, {"90 degree"}, {"180 degree"},								   {"270 degree"}, {"UsePictOrientation"}, {"Unknown"} };void CListDlg::DoDataExchange(CDataExchange* pDX){	CDialog::DoDataExchange(pDX);	//{{AFX_DATA_MAP(CListDlg)	DDX_Control(pDX, IDC_LISTBOX, m_ListControl);	//}}AFX_DATA_MAP}BEGIN_MESSAGE_MAP(CListDlg, CDialog)	//{{AFX_MSG_MAP(CListDlg)	ON_WM_CREATE()	//}}AFX_MSG_MAPEND_MESSAGE_MAP()int CListDlg::DoModal(eKindOfList KindOfList){	m_KindOfList=KindOfList;	return(CDialog::DoModal());}int CListDlg::DoModal(eKindOfList KindOfList, long JPEGSize){	m_KindOfList=KindOfList;	m_JPEGSize = JPEGSize;	return(CDialog::DoModal());}void CListDlg::SetStatusList(void){	LPSTR	pBuff;	char	*szBatteryStatus[]={ {"BatteryOK"},	{"BatteryWeak"},								 {"BatteryEmpty"}, {"DataError"} };	char 	*szBool[]     = {"FALSE", "TRUE"};	pBuff=new char[256];	if(pBuff==NULL)		return;	SetWindowText("Status");	//else, store the status	// + Ogawa	if(theApp.m_IsGenericNULL) {	//if(!theApp.m_IsGenericNULL){		wsprintf(pBuff, "----------GenericStatusPtr == NULL----------");		m_ListControl.AddString(pBuff);	// - Ogawa	//********************************	//		GENERIC STATUS		//********************************	} else {		wsprintf(pBuff, "**********     Generic Status     **********");		m_ListControl.AddString(pBuff);	// Time	{		wsprintf(pBuff,"Current Time         ---  %02d/%02d/%02d %02d:%02d:%02d", 							 theApp.m_pGenericStatus->Time.tm_mon, theApp.m_pGenericStatus->Time.tm_mday, theApp.m_pGenericStatus->Time.tm_year,							 theApp.m_pGenericStatus->Time.tm_hour, theApp.m_pGenericStatus->Time.tm_min, theApp.m_pGenericStatus->Time.tm_sec);		m_ListControl.AddString(pBuff);	}	// Firmware Version	{		wsprintf(pBuff, "Camera firmware Version            %lx%lx.%lx%lx",							 theApp.m_pGenericStatus->FirmwareVersion / 0x1000000,							 theApp.m_pGenericStatus->FirmwareVersion / 0x10000 % 0x100,							 theApp.m_pGenericStatus->FirmwareVersion % 0x10000 / 0x100,							 theApp.m_pGenericStatus->FirmwareVersion % 0x100);		m_ListControl.AddString(pBuff);	}	// Number of Pict	{		wsprintf(pBuff, "Number of pictures                 %d",  theApp.m_pGenericStatus->NumPictTaken);		m_ListControl.AddString(pBuff);	}	// Number of Remaining space	{		wsprintf(pBuff, "Remaining picture Number           %d",  theApp.m_pGenericStatus->NumPictRemaining);		m_ListControl.AddString(pBuff);	}	// ThumbnailWidth	{		wsprintf(pBuff, "Thumbnail Width                    %d",  theApp.m_pGenericStatus->ThumbWidth);		m_ListControl.AddString(pBuff);	}	// ThumbnailHeight	{		wsprintf(pBuff, "Thumbnail Height                   %d",  theApp.m_pGenericStatus->ThumbHeight);		m_ListControl.AddString(pBuff);	}	// PictureWidth	{		wsprintf(pBuff, "Picture Width                      %d",  theApp.m_pGenericStatus->PictWidth);		m_ListControl.AddString(pBuff);	}	// PictureHeight	{		wsprintf(pBuff, "Picture Height                     %d",  theApp.m_pGenericStatus->PictHeight);		m_ListControl.AddString(pBuff);	}		} // end of if theApp.IsGenericNULL;		//if DC25, store the DC25 full status. 	if( theApp.m_pDCCamera->CamType ==     DCGenericCamera ){ 		// No Info returned.		delete [] pBuff;		return;	} 	// else, keep processing.					//********************************	//		FULL STATUS		//********************************	if(theApp.m_IsSpecificNULL) {		wsprintf(pBuff, "----------  FullStatusPtr == NULL ----------");		m_ListControl.AddString(pBuff);	} else {		wsprintf(pBuff, "**********      Full  Status      **********");		m_ListControl.AddString(pBuff);	// This check is to support the invalid "SpecificCamera" input case.	DCCameraType  DispCameraType;	if(theApp.m_pDCCamera->CamType == DCGenericCamera)			DispCameraType =  theApp.m_pDCCamera->SpecificCamType;	else			DispCameraType =  theApp.m_pDCCamera->CamType;	// end of invalid test support.	 	switch(DispCameraType){//		case DC20://			{//			wsprintf(pBuff,"BatteryStatus         %s",BatteryArray[theApp.m_pDC20FullStatus->BatteryStatus]);//			m_ListControl.AddString(pBuff);//			}//    		break;//    	case DC25://			{//				int	BatteryStatus;//				if((theApp.m_pDC25FullStatus->BatteryStatus > DC25BatteryEmpty) || (theApp.m_pDC25FullStatus->BatteryStatus < DC25BatteryOK))//					BatteryStatus=sizeof(BatteryArray)/sizeof(LPCSTR)-1;//				else//					BatteryStatus=(int)theApp.m_pDC25FullStatus->BatteryStatus;//				wsprintf(pBuff,"BatteryStatus         %s",BatteryArray[theApp.m_pDC25FullStatus->BatteryStatus]);//				m_ListControl.AddString(pBuff);//			}//			{//			int	ACAdapter;//				if(theApp.m_pDC25FullStatus->ACAdapter)//					ACAdapter=1;//				else//					ACAdapter=0;//				wsprintf(pBuff,"ACAdapter             %s",BOOLArray[ACAdapter]);//				m_ListControl.AddString(pBuff);//			}//			{//			int	CardAvilable;//				if(theApp.m_pDC25FullStatus->CardAvailable)//					CardAvilable=1;//				else//					CardAvilable=0;//				wsprintf(pBuff,"CardAvailable          %s",BOOLArray[CardAvilable]);//				m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"MemHighTaken          %d",theApp.m_pDC25FullStatus->MemHighTaken);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"MemStdTaken           %d",theApp.m_pDC25FullStatus->MemStdTaken);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"MemHighRemaining      %d",theApp.m_pDC25FullStatus->MemHighRemaining);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"MemStdRemaining       %d",theApp.m_pDC25FullStatus->MemStdRemaining);//			m_ListControl.AddString(pBuff);//			}		//			{//			wsprintf(pBuff,"CardHighTaken         %d",theApp.m_pDC25FullStatus->CardHighTaken);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"CardStdTaken          %d",theApp.m_pDC25FullStatus->CardStdTaken);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"CardHighRemaining     %d",theApp.m_pDC25FullStatus->CardHighRemaining);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"CardStdRemaining      %d",theApp.m_pDC25FullStatus->CardStdRemaining);//			m_ListControl.AddString(pBuff);//			}//			break;#ifdef DC50Include		case DC50:			// BatteryLevel			{			wsprintf(pBuff,"BatteryLevel          %s",szBatteryStatus[theApp.m_pDC50FullStatus->BatteryLevel]);			m_ListControl.AddString(pBuff);			}			// ACAdapter			{			wsprintf(pBuff,"ACAdapter             %s",szBool[theApp.m_pDC50FullStatus->ACAdapter]);			m_ListControl.AddString(pBuff);			}			// CardAvailable			{			wsprintf(pBuff,"CardAvailable         %s",szBool[theApp.m_pDC50FullStatus->CardAvailable]);			m_ListControl.AddString(pBuff);			}			// MemFirstImageNum			{			wsprintf(pBuff,"MemFirstImageNum      %d",theApp.m_pDC50FullStatus->MemFirstImageNum);			m_ListControl.AddString(pBuff);			}			// MemNumberOfImages			{			wsprintf(pBuff,"MemNumberOfImages     %d",theApp.m_pDC50FullStatus->MemNumberOfImages);			m_ListControl.AddString(pBuff);			}			// CardFirstImageNum			{			wsprintf(pBuff,"CardFirstImageNum     %d",theApp.m_pDC50FullStatus->CardFirstImageNum);			m_ListControl.AddString(pBuff);			}			// CardNumberOfImages			{			wsprintf(pBuff,"CardNumberOfImages    %d",theApp.m_pDC50FullStatus->CardNumberOfImages);			m_ListControl.AddString(pBuff);			}			// LightValue			{			wsprintf(pBuff,"LightValue            %d",theApp.m_pDC50FullStatus->LightValue);			m_ListControl.AddString(pBuff);			}			// ProgramStatus			{			long ProgStatus;			ProgStatus = (long)theApp.m_pDC50FullStatus->ProgramStatus;			wsprintf(pBuff,"Program Status        %ld",ProgStatus);			m_ListControl.AddString(pBuff);			}			// MemBestTaken			{			wsprintf(pBuff,"MemBestTaken          %d",theApp.m_pDC50FullStatus->MemBestTaken);			m_ListControl.AddString(pBuff);			}			// MemBetterTaken			{			wsprintf(pBuff,"MemBetterTaken        %d",theApp.m_pDC50FullStatus->MemBetterTaken);			m_ListControl.AddString(pBuff);			}			// MemGoodTaken			{			wsprintf(pBuff,"MemGoodTaken          %d",theApp.m_pDC50FullStatus->MemGoodTaken);			m_ListControl.AddString(pBuff);			}			// MemBestRemaining			{			wsprintf(pBuff,"MemBestRemaining      %d",theApp.m_pDC50FullStatus->MemBestRemaining);			m_ListControl.AddString(pBuff);			}			// MemBetterRemaining			{			wsprintf(pBuff,"MemBetterRemaining    %d",theApp.m_pDC50FullStatus->MemBetterRemaining);			m_ListControl.AddString(pBuff);			}			// MemGoodRemaining			{			wsprintf(pBuff,"MemGoodRemaining      %d",theApp.m_pDC50FullStatus->MemGoodRemaining);			m_ListControl.AddString(pBuff);			}			// ATABestTaken			{			wsprintf(pBuff,"ATABestTaken          %d",theApp.m_pDC50FullStatus->ATABestTaken);			m_ListControl.AddString(pBuff);			}			// ATABetterTaken			{			wsprintf(pBuff,"ATABetterTaken        %d",theApp.m_pDC50FullStatus->ATABetterTaken);			m_ListControl.AddString(pBuff);			}			// ATAGoodTaken			{			wsprintf(pBuff,"ATAGoodTaken          %d",theApp.m_pDC50FullStatus->ATAGoodTaken);			m_ListControl.AddString(pBuff);			}			// ATABestRemaining			{			wsprintf(pBuff,"ATABestRemaining      %d",theApp.m_pDC50FullStatus->ATABestRemaining);			m_ListControl.AddString(pBuff);			}			// ATABetterRemaining			{			wsprintf(pBuff,"ATABetterRemaining    %d",theApp.m_pDC50FullStatus->ATABetterRemaining);			m_ListControl.AddString(pBuff);			}			// ATAGoodRemaining			{			wsprintf(pBuff,"ATAGoodRemaining      %d",theApp.m_pDC50FullStatus->ATAGoodRemaining);			m_ListControl.AddString(pBuff);			}			// ATAVolumeName			{			wsprintf(pBuff,"ATAVolumeName         %s",theApp.m_pDC50FullStatus->ATAVolumeName);			m_ListControl.AddString(pBuff);			}			break;#endif			#ifdef DC40Include		case DC40:			// BatteryLevel			{			wsprintf(pBuff,"BatteryLevel          %s",szBatteryStatus[theApp.m_pDC40FullStatus->BatteryLevel]);			m_ListControl.AddString(pBuff);			}			// BatteryCharger			{			wsprintf(pBuff,"BatteryCharger        %s",szBool[theApp.m_pDC40FullStatus->BatteryCharger]);			m_ListControl.AddString(pBuff);			}			// HiResRemaining			{			wsprintf(pBuff,"HiResRemaining        %d",theApp.m_pDC40FullStatus->HiResRemaining);			m_ListControl.AddString(pBuff);			}			// LoResRemaining			{			wsprintf(pBuff,"LoResRemaining        %d",theApp.m_pDC40FullStatus->LoResRemaining);			m_ListControl.AddString(pBuff);			}    		break;#endif#ifdef DC120Include		case DC120:			// BatteryLevel			{			wsprintf(pBuff,"BatteryLevel            %s",BatteryArray[theApp.m_pDC120FullStatus->BatteryLevel]);			m_ListControl.AddString(pBuff);			}			// ACAdapter			{			wsprintf(pBuff,"ACAdapter               %s",szBool[theApp.m_pDC120FullStatus->ACAdapter]);			m_ListControl.AddString(pBuff);			}			// CardAvailable			{			wsprintf(pBuff,"CardAvailable           %s",szBool[theApp.m_pDC120FullStatus->CardAvailable]);			m_ListControl.AddString(pBuff);			}			// CoverStatus			{			wsprintf(pBuff,"CoverStatus             %s",szBool[theApp.m_pDC120FullStatus->CoverStatus]);			m_ListControl.AddString(pBuff);			}			// FlashStatus			{			wsprintf(pBuff,"FlashStatus             %s",szBool[theApp.m_pDC120FullStatus->FlashStatus]);			m_ListControl.AddString(pBuff);			}			// LightValue			{			wsprintf(pBuff,"LightValue              %d",theApp.m_pDC120FullStatus->LightValue);			m_ListControl.AddString(pBuff);			}			// MemNumImages			{			wsprintf(pBuff,"MemNumImages            %d",theApp.m_pDC120FullStatus->MemNumImages);			m_ListControl.AddString(pBuff);			}			// MemNoCompRemaining			{			wsprintf(pBuff,"MemNoCompRemaining      %d",theApp.m_pDC120FullStatus->MemNoCompRemaining);			m_ListControl.AddString(pBuff);			}			// MemBestRemaining			{			wsprintf(pBuff,"MemBestRemaining        %d",theApp.m_pDC120FullStatus->MemBestRemaining);			m_ListControl.AddString(pBuff);			}			// MemBetterRemaining			{			wsprintf(pBuff,"MemBetterRemaining      %d",theApp.m_pDC120FullStatus->MemBetterRemaining);			m_ListControl.AddString(pBuff);			}			// MemGoodRemaining			{			wsprintf(pBuff,"MemGoodRemaining        %d",theApp.m_pDC120FullStatus->MemGoodRemaining);			m_ListControl.AddString(pBuff);			}			// MemNumAlbums			{			wsprintf(pBuff,"MemNumAlbums            %d",theApp.m_pDC120FullStatus->MemNumAlbums);			m_ListControl.AddString(pBuff);			}			// CardNumImages			{			wsprintf(pBuff,"CardNumImages           %d",theApp.m_pDC120FullStatus->CardNumImages);			m_ListControl.AddString(pBuff);			}			// CardNoCompRemaining			{			wsprintf(pBuff,"CardNoCompRemaining     %d",theApp.m_pDC120FullStatus->CardNoCompRemaining);			m_ListControl.AddString(pBuff);			}			// CardBestRemaining			{			wsprintf(pBuff,"CardBestRemaining       %d",theApp.m_pDC120FullStatus->CardBestRemaining);			m_ListControl.AddString(pBuff);			}			// CardBetterRemaining			{			wsprintf(pBuff,"CardBetterRemaining     %d",theApp.m_pDC120FullStatus->CardBetterRemaining);			m_ListControl.AddString(pBuff);			}			// CardGoodRemaining			{			wsprintf(pBuff,"CardGoodRemaining       %d",theApp.m_pDC120FullStatus->CardGoodRemaining);			m_ListControl.AddString(pBuff);			}			// CardNumAlbums			{			wsprintf(pBuff,"CardNumAlbums           %d",theApp.m_pDC120FullStatus->CardNumAlbums);			m_ListControl.AddString(pBuff);			}			// CardVolumeName			{			wsprintf(pBuff,"CardVolumeName          %s",theApp.m_pDC120FullStatus->CardVolumeName);			m_ListControl.AddString(pBuff);			}			break;#endif							default:			break;	}	} // end of !theApp.IsSpecificNULL	delete [] pBuff;}void CListDlg::SetConfigList(void){	LPSTR	pBuff;	pBuff=new char[256];	if(pBuff==NULL)		return;	//else, store the generic status	if(theApp.m_IsGenericNULL) {		wsprintf(pBuff, "----------GenericConfigPtr == NULL----------");		m_ListControl.AddString(pBuff);	} else {		wsprintf(pBuff, "**********     Generic Config     **********");		m_ListControl.AddString(pBuff);		//********************************		//		GENERIC CONFIG			//********************************		SetWindowText("Camera Configuration");		// Time		{		wsprintf(pBuff, "Current Time  ---  %02d/%02d/%02d %02d:%02d:%02d", 							 theApp.m_pGenericConfig->Time.tm_mon, theApp.m_pGenericConfig->Time.tm_mday, theApp.m_pGenericConfig->Time.tm_year,							 theApp.m_pGenericConfig->Time.tm_hour, theApp.m_pGenericConfig->Time.tm_min, theApp.m_pGenericConfig->Time.tm_sec);		m_ListControl.AddString(pBuff);		}		// Camera ID		{		wsprintf(pBuff, "Camera Id     ---  %s", theApp.m_pCamId);			m_ListControl.AddString(pBuff);		}	} // end of 	if(!theApp.m_IsGenericNULL){	//********************************	//		FULL CONFIG		//******************************** 	if(theApp.m_IsSpecificNULL) {		wsprintf(pBuff, "----------  FullConfigPtr == NULL ----------");		m_ListControl.AddString(pBuff);	} else {		wsprintf(pBuff, "**********      Full  Config      **********");		m_ListControl.AddString(pBuff);		// This check is to support the invalid "SpecificCamera" input case.		DCCameraType  DispCameraType;		if(theApp.m_pDCCamera->CamType == DCGenericCamera)				DispCameraType =  theApp.m_pDCCamera->SpecificCamType;		else				DispCameraType =  theApp.m_pDCCamera->CamType;		// end of invalid test support.		 		switch(DispCameraType){//		case DC20://			{//			wsprintf(pBuff,"PictureMode         %s",PictureModeArray[theApp.m_pDC20FullConfig->PictMode]);//			m_ListControl.AddString(pBuff);//			}//			break;//		case DC25://			{//			wsprintf(pBuff,"PictureMode         %s",PictureModeArray[theApp.m_pDC25FullConfig->PictMode]);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"Flash Mode          %s",FlashArray[theApp.m_pDC25FullConfig->FlashMode]);//			m_ListControl.AddString(pBuff);//			}//			break;	#ifdef DC50Include		case DC50:			{			DC50ConfigPtr	fptr = theApp.m_pDC50FullConfig;			short			idat;			// + Ogawa			char			*szTimer[]  = {"0 (sec)", "10 (sec)"};			// - Ogawa			char 			*szbool[]   = {"FALSE", "TRUE"};			char			*szIQ[]     = {"Best", "Better", "Good"};			char 			*szFlash[]  = {"Auto", "On", "Off"};			char			*szZoom[]   = {"37mm", "46mm", "61mm", "77mm",										   "92mm",  "100mm",  "111mm"};			char			*szMFlag[]	= {"Automatic", "Manual"};						char			*szFocus[]	= {"Multi", "Single", "Closeup"};						wsprintf((LPSTR)pBuff, "Sleep Timeout                   %d",  fptr->SleepTimeout); 			  			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Timer Delay                     %s", (LPSTR)szTimer[fptr->TimerDelay]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Flash Mode                      %s",  (LPSTR)szFlash[fptr->FlashMode]); 			m_ListControl.AddString(pBuff);			switch(fptr->PictQuality) {			case DC50BestQuality:				idat = 0; 				break;			case DC50BetterQuality:				idat = 1; 				break;			case DC50GoodQuality:				idat = 2; 				break;			default: idat = fptr->PictQuality;  			}			if(idat <= 2)	wsprintf((LPSTR)pBuff, "Picture Quality                 %s", (LPSTR)szIQ[idat]);			else			wsprintf((LPSTR)pBuff, "Picture Quality                 Err:%d", idat);			m_ListControl.AddString(pBuff);			if(fptr->ZoomPosition <= 6) {				wsprintf((LPSTR)pBuff, "Zoom Position                   %s", (LPSTR)szZoom[fptr->ZoomPosition]);			} else {				wsprintf((LPSTR)pBuff, "Zoom Position                   Err:%d", fptr->ZoomPosition);			}			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Manual Exposure Flag            %s",  (LPSTR)szMFlag[fptr->ManualExpFlag]); 			m_ListControl.AddString(pBuff);			sprintf((LPSTR)pBuff, "Manual Exposure Time            %9.6f (sec)", (float)fptr->ManualExpTime / 1000000);			m_ListControl.AddString(pBuff);			sprintf((LPSTR)pBuff, "Manual Exposure F-Number        %4.1f", (float)fptr->ManualFNumber / 10);			m_ListControl.AddString(pBuff);			sprintf((LPSTR)pBuff, "AutoExpo Compensation Value     %3.1f (E.V.)",  (float)fptr->AutoExpCompValue / 10);			m_ListControl.AddString(pBuff);									wsprintf((LPSTR)pBuff, "Focus Mode                      %s",  (LPSTR)szFocus[fptr->FocusMode]); 			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Program Mode                    %d",  fptr->ProgramMode);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Manual Exposure UI Flag         %s",  (LPSTR)szbool[fptr->ManualExpUIFlag]);			m_ListControl.AddString(pBuff);			}						break;	#endif	#ifdef DC40Include		case DC40:			{			DC40ConfigPtr 	fptr = theApp.m_pDC40FullConfig;			char 			*szbool[]     = {"Disabled",  "Enabled"};			char			*szCmmode[]   = {"Mute  Mode", "Acknowledge Mode"};			char			*szCouter[]   = {"Count Down", "Count Up"};			char 			*szexpomode[] = {"Automatic", "Manual" };			char			*szflash[]    = {"Auto", "On", "Off"};			char			*sztimer[]    = {"No Delay", "10 Seconds", "20 Seconds"};			char			*szexpo[]     = {"", "Plus 2", "Plus 1", "Normal", "Minus 1", "Minus 2"};			wsprintf((LPSTR)pBuff, "Sleep timeout          %d", fptr->SleepTimeout);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Acknowledge mode       %s", (LPSTR)szCmmode[fptr->AcknowledgeMode]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Default exposure mode  %s", (LPSTR)szexpo[fptr->DefExpMode]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Default timer mode     %s", (LPSTR)sztimer[fptr->DefTimerMode]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Default flash mode     %s", (LPSTR)szflash[fptr->DefFlashMode]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Count up or down mode  %s", (LPSTR)szCouter[fptr->UpDownMode]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Current exposure mode  %s", (LPSTR)szexpo[fptr->ExpMode]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Current timer mode     %s", (LPSTR)sztimer[fptr->TimerMode]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Current flash mode     %s", (LPSTR)szflash[fptr->FlashMode]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Beep Button            %s", (LPSTR)szbool[fptr->BeepButton]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Beep Event             %s", (LPSTR)szbool[fptr->BeepEvent]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Delete Last            %s", (LPSTR)szbool[fptr->DeleteLast]);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Delete All             %s", (LPSTR)szbool[fptr->DeleteAll]);			m_ListControl.AddString(pBuff);			if(fptr->PictMode == DC40Snapshot)				wsprintf((LPSTR)pBuff, "Pict mode              DC40Snapshot");			else				wsprintf((LPSTR)pBuff, "Pict mode              DC40HighResolution");			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Exposure mode          %s", (LPSTR)szexpomode[fptr->ManualExpFlag]);			m_ListControl.AddString(pBuff);			sprintf((LPSTR)pBuff, "Manual Exposure Time   %9.6f sec", (float)fptr->ManualExpTime/1000000);			m_ListControl.AddString(pBuff);			sprintf((LPSTR)pBuff, "Manual F-Number        %4.1f", (float)fptr->ManualFNumber / 10);			m_ListControl.AddString(pBuff);			}			break;#endif#ifdef DC120Include		case DC120:			{			DC120ConfigPtr	fptr = theApp.m_pDC120FullConfig;			short	idat;						char 	*szBool[]    = {"FALSE", "TRUE"};			char	*szIQ[]      = {"NoComp", "Best", "Better", "Good"};			char 	*szFlash[]   = {"Auto", "On", "Off"};			char	*szZoom[]    = {"37mm", "46mm", "61mm", "77mm",								    "92mm", "100mm", "111mm", "Macro"};			char	*szMFlag[]	 = {"Automatic", "Manual"};						char	*szFocus[]	 = {"Multi", "Single", "Closeup"};						char	*szDate[]	 = {"Day 1st", "Month 1st", "Year 1st"};						char	*szTimeFrm[] = {"12h", "24H"};			char	*szDistFrm[] = {"cm", "inch"};			wsprintf((LPSTR)pBuff, "CaptureSleep Time Out        %d (sec)",  fptr->CaptureSleepTO);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "ReviewSleep Time Out         %d (sec)",  fptr->ReviewSleepTO);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Timer Delay                  %d (sec)",  fptr->TimerDelay);			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Flash Mode                   %s",  (LPSTR)szFlash[fptr->FlashMode]);			m_ListControl.AddString(pBuff);			switch(fptr->PictQuality) {			case DC120NoCompression:				idat = 0;				break;			case DC120BestQuality:				idat = 1; 				break;			case DC120BetterQuality:				idat = 2; 				break;			case DC120GoodQuality:				idat = 3; 				break;			default:				idat = fptr->PictQuality;  			}			if(idat <= 3) {				wsprintf((LPSTR)pBuff, "Picture Quality              %s", (LPSTR)szIQ[idat]);			} else {				wsprintf((LPSTR)pBuff, "Picture Quality              Err:%d", idat);			}			m_ListControl.AddString(pBuff);						if(fptr->ZoomPosition <= 7) {				wsprintf((LPSTR)pBuff, "Zoom Position                %s", (LPSTR)szZoom[fptr->ZoomPosition]);			} else {				wsprintf((LPSTR)pBuff, "Zoom Position                Err:%d", fptr->ZoomPosition);			}			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Manual Exposure Flag         %s",  (LPSTR)szMFlag[fptr->ManualExpFlag]); 			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Manual Exposure Time         %ld", fptr->ManualExpTime);	 			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Manual Exposure F-Number     %d",  fptr->ManualFNumber);	 			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "AutoExpo Compensation Value  %d (E.V.)",  fptr->AutoExpCompValue);			m_ListControl.AddString(pBuff);								wsprintf((LPSTR)pBuff, "Focus Mode                   %s",  (LPSTR)szFocus[fptr->FocusMode]); 			m_ListControl.AddString(pBuff);			// Rem by + Ogawa			//wsprintf((LPSTR)pBuff, "Manual Exposure UI Flag    %s",  (LPSTR)szBool[fptr->ManualExpUIFlag]); 			 			//m_ListControl.AddString(pBuff);			// Rem by - Ogawa			switch(fptr->DateFormat) {			case DC120DayFirst:				idat = 0; 				break;			case DC120MonthFirst:				idat = 1; 				break;			case DC120YearFirst:				idat = 2; 				break;			default: idat = fptr->PictQuality;  			}			if(idat <= 2) {				wsprintf((LPSTR)pBuff, "Date Format                  %s", (LPSTR)szDate[idat]);			} else {				wsprintf((LPSTR)pBuff, "Date Format                  Err:%d", idat);			}			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "TimeFormat                   %s",  (LPSTR)szTimeFrm[fptr->TimeFormat]); 			 			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "DistanceDspFormat            %s",  (LPSTR)szDistFrm[fptr->DistanceDspFormat]); 			 			m_ListControl.AddString(pBuff);			wsprintf((LPSTR)pBuff, "Default Flash Mode           %s",  (LPSTR)szFlash[fptr->DefFlashMode]); 			m_ListControl.AddString(pBuff);			}						break;#endif		default:			break;		}	} // end of  	if(!theApp.m_IsSpecificNULL){				delete [] pBuff;}void CListDlg::SetPictureInfoList(void){	LPSTR	pBuff;	char 	*szBool[]		   = {"FALSE", "TRUE"};	char	*szTimer[]         = {"No Delay", "10 (sec)", "20 (sec)"};	char 	*szFlash[]         = {"Auto", "On", "Off", "Unknown"};	char	*sz50PictMode[]    = { {"BestQuality"}, {"BetterQuality"},								 {"GoodQuality"},{"Unknown"} };	char	*sz120PictMode[]   = { {"NoCompQuality"}, {"BestQuality"},								   {"BetterQuality"},{"GoodQuality"},{"Unknown"} };	char	*szZoom[]		   = {"37mm", "46mm", "61mm", "77mm", "92mm",								  "100mm", "111mm", "Macro"};	char	*szBatteryStatus[] = { {"BatteryOK"}, {"BatteryWeek"},								 {"BatteryEmpty"}, {"DataError"} };	char	*szFocus[]		   = {"Multi", "Single", "Closeup", "Unknown"};				pBuff=new char[256];	if(pBuff==NULL)		return;	SetWindowText("Picture Information");	//********************************	//		GENERIC PICTINFO		//********************************	if(theApp.m_IsGenericNULL){		wsprintf(pBuff, "---------- GenericInfoPtr == NULL ----------");		m_ListControl.AddString(pBuff);	} else {		wsprintf(pBuff, "**********      Generic Info      **********");		m_ListControl.AddString(pBuff);		// Picture Number		{		wsprintf(pBuff, "Picture Number      %4d",  theApp.m_pGenericInfo->PictNumber);		m_ListControl.AddString(pBuff);		}		// ThumbnailWidth		{		wsprintf(pBuff, "Thumbnail Width     %4d",  theApp.m_pGenericInfo->ThumbWidth);		m_ListControl.AddString(pBuff);		}		// ThumbnailHeight		{		wsprintf(pBuff, "Thumbnail Height    %4d",  theApp.m_pGenericInfo->ThumbHeight);		m_ListControl.AddString(pBuff);		}		// ThumbnailPointer		{		if(theApp.m_pGenericInfo->ThumbPtr != NULL)			wsprintf(pBuff, "ThumbPtr            TRUE");		else			wsprintf(pBuff, "ThumbPtr            FALSE");		m_ListControl.AddString(pBuff);		}		// PictWidth		{		wsprintf(pBuff, "PictWidth           %4ld",  theApp.m_pGenericInfo->PictWidth);		m_ListControl.AddString(pBuff);		}		// PictHeight		{		wsprintf(pBuff, "PictHeight          %4ld",  theApp.m_pGenericInfo->PictHeight);		m_ListControl.AddString(pBuff);		}		// PictCompSize		{		wsprintf(pBuff, "PictCompSize        %6ld",  theApp.m_pGenericInfo->PictCompSize);		m_ListControl.AddString(pBuff);		}		// PictMinBufIn		{		wsprintf(pBuff, "PictMinBufIn        %6ld",  theApp.m_pGenericInfo->PictMinBufIn);		m_ListControl.AddString(pBuff);		}		// PictMinBufOut		{		wsprintf(pBuff, "PictMinBufOut       %6ld",  theApp.m_pGenericInfo->PictMinBufOut);		m_ListControl.AddString(pBuff);		}		// TimeStamp		{		wsprintf(pBuff,"TimeStamp            %02d/%02d/%02d %02d:%02d:%02d", 							 theApp.m_pGenericInfo->TimeStamp.tm_mon, theApp.m_pGenericInfo->TimeStamp.tm_mday, theApp.m_pGenericInfo->TimeStamp.tm_year,							 theApp.m_pGenericInfo->TimeStamp.tm_hour, theApp.m_pGenericInfo->TimeStamp.tm_min, theApp.m_pGenericInfo->TimeStamp.tm_sec);		m_ListControl.AddString(pBuff);		}	} // end of else.		//********************************	//		FULL PICTINFO		//********************************	if(theApp.m_IsSpecificNULL){		wsprintf(pBuff, "----------  FullInfoPtr == NULL   ----------");		m_ListControl.AddString(pBuff);	} else {		wsprintf(pBuff, "**********       Full  Info       **********");		m_ListControl.AddString(pBuff);		DCCameraType  DispCameraType;		switch(theApp.m_pDCCamera->CamType){		case DC20:		case DC25:		case DC40:		case DC50:		case DC120:			DispCameraType = theApp.m_pDCCamera->CamType;			break;		default:			if(theApp.m_pDCCamera->CamType == DCGenericCamera) {				DispCameraType = theApp.m_pDCCamera->SpecificCamType;			} else {				DispCameraType = theApp.m_pDCCamera->CamType;			}		}		switch(DispCameraType){//		case DC20://			{//			wsprintf(pBuff,"PictOrientation  %s",RotateAngleArray[theApp.m_p20FullPictInfo->PictOrientation]);//			m_ListControl.AddString(pBuff);//			}//			break;//		case DC25://			{//			wsprintf(pBuff,"PictureMode      %s",PictureModeArray[theApp.m_p25FullPictInfo->PictMode]);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"FlashModeMode    %s",FlashArray[theApp.m_p25FullPictInfo->FlashMode]);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"PictOrientation  %s",RotateAngleArray[theApp.m_p25FullPictInfo->PictOrientation]);//			m_ListControl.AddString(pBuff);//			}//			break;#ifdef DC50Include		case DC50:			// TimerMode			{			wsprintf(pBuff, "TimerMode       %s",  szTimer[theApp.m_p50FullPictInfo->TimerMode]);			m_ListControl.AddString(pBuff);			}			// FlashUsed			{			wsprintf(pBuff, "FlashUsed       %s",  szBool[theApp.m_p50FullPictInfo->FlashUsed]);			m_ListControl.AddString(pBuff);			}			// FlashMode			{			wsprintf(pBuff, "FlashMode       %s",  szFlash[theApp.m_p50FullPictInfo->FlashMode]);			m_ListControl.AddString(pBuff);			}			// PictQuality			{			wsprintf(pBuff, "PictQuality     %s",  sz50PictMode[theApp.m_p50FullPictInfo->PictQuality]);			m_ListControl.AddString(pBuff);			}			// ZoomPosition			{			wsprintf(pBuff, "ZoomPosition    %s",  szZoom[theApp.m_p50FullPictInfo->ZoomPosition]);			m_ListControl.AddString(pBuff);			}			// ManualExpFlag			{			wsprintf(pBuff, "ManualExpFlag   %s",  szBool[theApp.m_p50FullPictInfo->ManualExpFlag]);			m_ListControl.AddString(pBuff);			}			// ExposureTime			{			sprintf(pBuff, "ExposureTime    %9.6f (sec)",  (float)theApp.m_p50FullPictInfo->ExposureTime / 1000000);			m_ListControl.AddString(pBuff);			}			// FNumber			{			sprintf(pBuff, "FNumber         %4.1f",  (float)theApp.m_p50FullPictInfo->FNumber / 10);			m_ListControl.AddString(pBuff);			}			// BatteryLevel			{			wsprintf(pBuff, "BatteryLevel    %s",  szBatteryStatus[theApp.m_p50FullPictInfo->BatteryLevel]);			m_ListControl.AddString(pBuff);			}			// PictOrientation			{			wsprintf(pBuff, "PictOrientation %s",  RotateAngleArray[theApp.m_p50FullPictInfo->PictOrientation]);			m_ListControl.AddString(pBuff);			}			// ProgramUsed			{			wsprintf(pBuff, "ProgramUsed     %d",  theApp.m_p50FullPictInfo->ProgramUsed);			m_ListControl.AddString(pBuff);			}			// FocusMode			{			wsprintf(pBuff, "FocusMode       %s",  szFocus[theApp.m_p50FullPictInfo->FocusMode]);			m_ListControl.AddString(pBuff);			}			// FocusPosition			{			wsprintf(pBuff, "FocusPosition   %ld",  theApp.m_p50FullPictInfo->FocusPosition);			m_ListControl.AddString(pBuff);			}			// LightValue			{			wsprintf(pBuff, "LightValue      %d",  theApp.m_p50FullPictInfo->LightValue);			m_ListControl.AddString(pBuff);			}			// ExposureValue			{			wsprintf(pBuff, "ExposureValue   %d",  theApp.m_p50FullPictInfo->ExposureValue);			m_ListControl.AddString(pBuff);			}			// AVData			{			wsprintf(pBuff, "AVData          %d",  theApp.m_p50FullPictInfo->AVData);			m_ListControl.AddString(pBuff);			}			// ImageName			{			wsprintf(pBuff, "ImageName       %s",  theApp.m_p50FullPictInfo->ImageName);			m_ListControl.AddString(pBuff);			}			break;#endif#ifdef DC40Include		case DC40:			// ExposureTime			{			sprintf(pBuff, "ExposureTime    %9.6f (sec)",  (float)theApp.m_p40FullPictInfo->ExposureTime / 1000000);			m_ListControl.AddString(pBuff);			}			// FlashUsed			{			wsprintf(pBuff, "FlashUsed       %s",  szBool[theApp.m_p40FullPictInfo->FlashUsed]);			m_ListControl.AddString(pBuff);			}			{			sprintf(pBuff, "FNumber         %4.1f",  (float)theApp.m_p40FullPictInfo->FNumber / 10);			m_ListControl.AddString(pBuff);			}			break;#endif#ifdef DC120Include		case DC120:			// TimerMode			{			wsprintf(pBuff, "TimerMode        %s",  szTimer[theApp.m_p120FullPictInfo->TimerMode]);			m_ListControl.AddString(pBuff);			}			// FlashUsed			{			wsprintf(pBuff, "FlashUsed        %s",  szBool[theApp.m_p120FullPictInfo->FlashUsed]);			m_ListControl.AddString(pBuff);			}			// FlashMode			{			wsprintf(pBuff, "FlashMode        %s",  szFlash[theApp.m_p120FullPictInfo->FlashMode]);			m_ListControl.AddString(pBuff);			}			// PictQuality			{			wsprintf(pBuff, "PictQuality      %s",  sz120PictMode[theApp.m_p120FullPictInfo->PictQuality]);			m_ListControl.AddString(pBuff);			}			// ZoomPosition			{			wsprintf(pBuff, "ZoomPosition     %s",  szZoom[theApp.m_p120FullPictInfo->ZoomPosition]);			m_ListControl.AddString(pBuff);			}			// ManualExpFlag			{			wsprintf(pBuff, "ManualExpFlag    %s",  szBool[theApp.m_p120FullPictInfo->ManualExpFlag]);			m_ListControl.AddString(pBuff);			}			// ExposureTime			{			sprintf(pBuff, "ExposureTime     %9.6f (sec)",  (float)theApp.m_p120FullPictInfo->ExposureTime / 1000000);			m_ListControl.AddString(pBuff);			}			// FNumber			{			sprintf(pBuff, "FNumber          %4.1f",  (float)theApp.m_p120FullPictInfo->FNumber / 10);			m_ListControl.AddString(pBuff);			}			// BatteryLevel			{			wsprintf(pBuff, "BatteryLevel     %s",  szBatteryStatus[theApp.m_p120FullPictInfo->BatteryLevel]);			m_ListControl.AddString(pBuff);			}			// PictOrientation			{			wsprintf(pBuff, "PictOrientation  %s",  RotateAngleArray[theApp.m_p120FullPictInfo->PictOrientation]);			m_ListControl.AddString(pBuff);			}			// FocusMode			{			wsprintf(pBuff, "FocusMode        %s",  szFocus[theApp.m_p120FullPictInfo->FocusMode]);			m_ListControl.AddString(pBuff);			}			// FocusPosition			{			wsprintf(pBuff, "FocusPosition    %ld",  theApp.m_p120FullPictInfo->FocusPosition);			m_ListControl.AddString(pBuff);			}			// LightValue			{			wsprintf(pBuff, "LightValue       %d",  theApp.m_p120FullPictInfo->LightValue);			m_ListControl.AddString(pBuff);			}			// WBAuto			{			sprintf(pBuff, "WBAuto:          R=%f, G=%f, B=%f", 							theApp.m_p120FullPictInfo->WBAuto.WBGainR,							theApp.m_p120FullPictInfo->WBAuto.WBGainG,							theApp.m_p120FullPictInfo->WBAuto.WBGainB							);			m_ListControl.AddString(pBuff);			}			// WBDayLight			{			sprintf(pBuff, "WBDayLight:      R=%f, G=%f, B=%f", 							theApp.m_p120FullPictInfo->WBDayLight.WBGainR,							theApp.m_p120FullPictInfo->WBDayLight.WBGainG,							theApp.m_p120FullPictInfo->WBDayLight.WBGainB							);			m_ListControl.AddString(pBuff);			}			// WBIndoor			{			sprintf(pBuff, "WBIndoor:        R=%f, G=%f, B=%f", 							theApp.m_p120FullPictInfo->WBIndoor.WBGainR,							theApp.m_p120FullPictInfo->WBIndoor.WBGainG,							theApp.m_p120FullPictInfo->WBIndoor.WBGainB							);			m_ListControl.AddString(pBuff);			}			// WBFluorescent			{			sprintf(pBuff, "WBFluorescent:   R=%f, G=%f, B=%f", 							theApp.m_p120FullPictInfo->WBFluorescent.WBGainR,							theApp.m_p120FullPictInfo->WBFluorescent.WBGainG,							theApp.m_p120FullPictInfo->WBFluorescent.WBGainB							);			m_ListControl.AddString(pBuff);			}			// ImageName			{			wsprintf(pBuff, "ImageName        %s",  theApp.m_p120FullPictInfo->ImageName);			m_ListControl.AddString(pBuff);			}			break;#endif		default:			break;		}	} // end of else.						delete [] pBuff;}// + Ogawavoid CListDlg::SetNativePictureInfoList(void){	LPSTR	pBuff;	char 	*szBool[]   = {"FALSE",  "TRUE"};	char	*szTimer[]  = {"No Delay",  "10 (sec)", "20 (sec)"};	char 	*szFlash[]  = {"Auto", "On", "Off", "Unknown"};	char	*sz50PictMode[]    = { {"BestQuality"},{"BetterQuality"},								   {"GoodQuality"},{"Unknown"} };	char	*sz120PictMode[]   = { {"NoCompQuality"},{"BestQuality"},								   {"BetterQuality"},{"GoodQuality"},{"Unknown"} };	char	*szZoom[]          = {"37mm", "46mm", "61mm", "77mm",								  "92mm",  "100mm",  "111mm", "Macro"};	char	*szBatteryStatus[] = { {"BatteryOK"},{"BatteryWeek"},								   {"BatteryEmpty"},{"DataError"} };	char	*szFocus[]		   = {"Multi","Single", "Closeup", "Unknown"};				pBuff=new char[256];	if(pBuff==NULL)		return;	SetWindowText("Picture Information");	//********************************	//		GENERIC PICTINFO		//********************************	if(theApp.m_IsGenericNULL){		wsprintf(pBuff, "---------- GenericInfoPtr == NULL ----------");		m_ListControl.AddString(pBuff);	} else {		wsprintf(pBuff, "**********      Generic Info      **********");		m_ListControl.AddString(pBuff);	// Picture Number		{		wsprintf(pBuff, "Picture Number      %4d",  theApp.m_pGenericInfo->PictNumber);		m_ListControl.AddString(pBuff);		}	// ThumbnailWidth		{		wsprintf(pBuff, "Thumbnail Width     %4d",  theApp.m_pGenericInfo->ThumbWidth);		m_ListControl.AddString(pBuff);		}	// ThumbnailHeight		{		wsprintf(pBuff, "Thumbnail Height    %4d",  theApp.m_pGenericInfo->ThumbHeight);		m_ListControl.AddString(pBuff);		}	// ThumbnailPointer		{		if(theApp.m_pGenericInfo->ThumbPtr != NULL)			wsprintf(pBuff, "ThumbPtr            TRUE");		else			wsprintf(pBuff, "ThumbPtr            FALSE");		m_ListControl.AddString(pBuff);		}	// PictWidth		{		wsprintf(pBuff, "PictWidth           %4ld",  theApp.m_pGenericInfo->PictWidth);		m_ListControl.AddString(pBuff);		}	// PictHeight		{		wsprintf(pBuff, "PictHeight          %4ld",  theApp.m_pGenericInfo->PictHeight);		m_ListControl.AddString(pBuff);		}	// PictCompSize		{		wsprintf(pBuff, "PictCompSize        %6ld",  theApp.m_pGenericInfo->PictCompSize);		m_ListControl.AddString(pBuff);		}	// PictMinBufIn		{		wsprintf(pBuff, "PictMinBufIn        %6ld",  theApp.m_pGenericInfo->PictMinBufIn);		m_ListControl.AddString(pBuff);		}	// PictMinBufOut		{		wsprintf(pBuff, "PictMinBufOut       %6ld",  theApp.m_pGenericInfo->PictMinBufOut);		m_ListControl.AddString(pBuff);		}	// TimeStamp		{		wsprintf(pBuff,"TimeStamp            %02d/%02d/%02d %02d:%02d:%02d", 							 theApp.m_pGenericInfo->TimeStamp.tm_mon, theApp.m_pGenericInfo->TimeStamp.tm_mday, theApp.m_pGenericInfo->TimeStamp.tm_year,							 theApp.m_pGenericInfo->TimeStamp.tm_hour, theApp.m_pGenericInfo->TimeStamp.tm_min, theApp.m_pGenericInfo->TimeStamp.tm_sec);		m_ListControl.AddString(pBuff);		}	} // end of else.		//********************************	//		FULL PICTINFO		//********************************	if(theApp.m_IsSpecificNULL){		wsprintf(pBuff, "----------  FullInfoPtr == NULL   ----------");		m_ListControl.AddString(pBuff);	} else {		wsprintf(pBuff, "**********       Full  Info       **********");		m_ListControl.AddString(pBuff);		DCCameraType  DispCameraType;		switch(theApp.m_NativeCameraType){		case DC20:		case DC25:		case DC40:		case DC50:		case DC120:			DispCameraType = theApp.m_NativeCameraType;			break;		default:			if((theApp.m_pDCCamera->CamType == DCNoCamera) || (theApp.m_pDCCamera->CamType == DCGenericCamera)) {				DispCameraType = theApp.m_pDCCamera->SpecificCamType;			} else {				DispCameraType = theApp.m_pDCCamera->CamType;			}		}		switch(DispCameraType){//		case DC20://			{//			wsprintf(pBuff,"PictOrientation  %s",RotateAngleArray[theApp.m_p20FullPictInfo->PictOrientation]);//			m_ListControl.AddString(pBuff);//			}//			break;//		case DC25://			{//			wsprintf(pBuff,"PictureMode      %s",PictureModeArray[theApp.m_p25FullPictInfo->PictMode]);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"FlashModeMode    %s",FlashArray[theApp.m_p25FullPictInfo->FlashMode]);//			m_ListControl.AddString(pBuff);//			}//			{//			wsprintf(pBuff,"PictOrientation  %s",RotateAngleArray[theApp.m_p25FullPictInfo->PictOrientation]);//			m_ListControl.AddString(pBuff);//			}//			break;#ifdef DC50Include		case DC50:			// TimerMode			{			wsprintf(pBuff, "TimerMode       %s",  szTimer[theApp.m_p50FullPictInfo->TimerMode]);			m_ListControl.AddString(pBuff);			}			// FlashUsed			{			wsprintf(pBuff, "FlashUsed       %s",  szBool[theApp.m_p50FullPictInfo->FlashUsed]);			m_ListControl.AddString(pBuff);			}			// FlashMode			{			wsprintf(pBuff, "FlashMode       %s",  szFlash[theApp.m_p50FullPictInfo->FlashMode]);			m_ListControl.AddString(pBuff);			}			// PictQuality			{			wsprintf(pBuff, "PictQuality     %s",  sz50PictMode[theApp.m_p50FullPictInfo->PictQuality]);			m_ListControl.AddString(pBuff);			}			// ZoomPosition			{			wsprintf(pBuff, "ZoomPosition    %s",  szZoom[theApp.m_p50FullPictInfo->ZoomPosition]);			m_ListControl.AddString(pBuff);			}			// ManualExpFlag			{			wsprintf(pBuff, "ManualExpFlag   %s",  szBool[theApp.m_p50FullPictInfo->ManualExpFlag]);			m_ListControl.AddString(pBuff);			}			// ExposureTime			{			sprintf(pBuff, "ExposureTime    %9.6f (sec)",  (float)theApp.m_p50FullPictInfo->ExposureTime / 1000000);			m_ListControl.AddString(pBuff);			}			// FNumber			{			sprintf(pBuff, "FNumber         %4.1f",  (float)theApp.m_p50FullPictInfo->FNumber / 10);			m_ListControl.AddString(pBuff);			}			// BatteryLevel			{			wsprintf(pBuff, "BatteryLevel    %s",  szBatteryStatus[theApp.m_p50FullPictInfo->BatteryLevel]);			m_ListControl.AddString(pBuff);			}			// PictOrientation			{			wsprintf(pBuff, "PictOrientation %s",  RotateAngleArray[theApp.m_p50FullPictInfo->PictOrientation]);			m_ListControl.AddString(pBuff);			}			// ProgramUsed			{			wsprintf(pBuff, "ProgramUsed     %d",  theApp.m_p50FullPictInfo->ProgramUsed);			m_ListControl.AddString(pBuff);			}			// FocusMode			{			wsprintf(pBuff, "FocusMode       %s",  szFocus[theApp.m_p50FullPictInfo->FocusMode]);			m_ListControl.AddString(pBuff);			}			// FocusPosition			{			wsprintf(pBuff, "FocusPosition   %ld",  theApp.m_p50FullPictInfo->FocusPosition);			m_ListControl.AddString(pBuff);			}			// LightValue			{			wsprintf(pBuff, "LightValue      %d",  theApp.m_p50FullPictInfo->LightValue);			m_ListControl.AddString(pBuff);			}			// ExposureValue			{			wsprintf(pBuff, "ExposureValue   %d",  theApp.m_p50FullPictInfo->ExposureValue);			m_ListControl.AddString(pBuff);			}			// AVData			{			wsprintf(pBuff, "AVData          %d",  theApp.m_p50FullPictInfo->AVData);			m_ListControl.AddString(pBuff);			}			// ImageName			{			wsprintf(pBuff, "ImageName       %s",  theApp.m_p50FullPictInfo->ImageName);			m_ListControl.AddString(pBuff);			}			break;#endif#ifdef DC40Include		case DC40:			// ExposureTime			{			sprintf(pBuff, "ExposureTime    %9.6f (sec)",  (float)theApp.m_p40FullPictInfo->ExposureTime / 1000000);			m_ListControl.AddString(pBuff);			}			// FlashUsed			{			wsprintf(pBuff, "FlashUsed       %s",  szBool[theApp.m_p40FullPictInfo->FlashUsed]);			m_ListControl.AddString(pBuff);			}			{			sprintf(pBuff, "FNumber         %4.1f",  (float)theApp.m_p40FullPictInfo->FNumber / 10);			m_ListControl.AddString(pBuff);			}			break;#endif#ifdef DC120Include		case DC120:			// TimerMode			{			wsprintf(pBuff, "TimerMode        %s",  szTimer[theApp.m_p120FullPictInfo->TimerMode]);			m_ListControl.AddString(pBuff);			}			// FlashUsed			{			wsprintf(pBuff, "FlashUsed        %s",  szBool[theApp.m_p120FullPictInfo->FlashUsed]);			m_ListControl.AddString(pBuff);			}			// FlashMode			{			wsprintf(pBuff, "FlashMode        %s",  szFlash[theApp.m_p120FullPictInfo->FlashMode]);			m_ListControl.AddString(pBuff);			}			// PictQuality			{			wsprintf(pBuff, "PictQuality      %s",  sz120PictMode[theApp.m_p120FullPictInfo->PictQuality]);			m_ListControl.AddString(pBuff);			}			// ZoomPosition			{			wsprintf(pBuff, "ZoomPosition     %s",  szZoom[theApp.m_p120FullPictInfo->ZoomPosition]);			m_ListControl.AddString(pBuff);			}			// ManualExpFlag			{			wsprintf(pBuff, "ManualExpFlag    %s",  szBool[theApp.m_p120FullPictInfo->ManualExpFlag]);			m_ListControl.AddString(pBuff);			}			// ExposureTime			{			sprintf(pBuff, "ExposureTime     %9.6f (sec)",  (float)theApp.m_p120FullPictInfo->ExposureTime / 1000000);			m_ListControl.AddString(pBuff);			}			// FNumber			{			sprintf(pBuff, "FNumber          %4.1f",  (float)theApp.m_p120FullPictInfo->FNumber / 10);			m_ListControl.AddString(pBuff);			}			// BatteryLevel			{			wsprintf(pBuff, "BatteryLevel     %s",  szBatteryStatus[theApp.m_p120FullPictInfo->BatteryLevel]);			m_ListControl.AddString(pBuff);			}			// PictOrientation			{			wsprintf(pBuff, "PictOrientation  %s",  RotateAngleArray[theApp.m_p120FullPictInfo->PictOrientation]);			m_ListControl.AddString(pBuff);			}			// FocusMode			{			wsprintf(pBuff, "FocusMode        %s",  szFocus[theApp.m_p120FullPictInfo->FocusMode]);			m_ListControl.AddString(pBuff);			}			// FocusPosition			{			wsprintf(pBuff, "FocusPosition    %ld",  theApp.m_p120FullPictInfo->FocusPosition);			m_ListControl.AddString(pBuff);			}			// LightValue			{			wsprintf(pBuff, "LightValue       %d",  theApp.m_p120FullPictInfo->LightValue);			m_ListControl.AddString(pBuff);			}			// WBAuto			{				sprintf(pBuff, "WBAuto:          R=%f, G=%f, B=%f", 							theApp.m_p120FullPictInfo->WBAuto.WBGainR,							theApp.m_p120FullPictInfo->WBAuto.WBGainG,							theApp.m_p120FullPictInfo->WBAuto.WBGainB							);			m_ListControl.AddString(pBuff);			}			// WBDayLight			{			sprintf(pBuff, "WBDayLight:      R=%f, G=%f, B=%f", 							theApp.m_p120FullPictInfo->WBDayLight.WBGainR,							theApp.m_p120FullPictInfo->WBDayLight.WBGainG,							theApp.m_p120FullPictInfo->WBDayLight.WBGainB							);			m_ListControl.AddString(pBuff);			}			// WBIndoor			{			sprintf(pBuff, "WBIndoor:        R=%f, G=%f, B=%f", 							theApp.m_p120FullPictInfo->WBIndoor.WBGainR,							theApp.m_p120FullPictInfo->WBIndoor.WBGainG,							theApp.m_p120FullPictInfo->WBIndoor.WBGainB							);			m_ListControl.AddString(pBuff);			}			// WBFluorescent			{			sprintf(pBuff, "WBFluorescent:   R=%f, G=%f, B=%f", 							theApp.m_p120FullPictInfo->WBFluorescent.WBGainR,							theApp.m_p120FullPictInfo->WBFluorescent.WBGainG,							theApp.m_p120FullPictInfo->WBFluorescent.WBGainB							);			m_ListControl.AddString(pBuff);			}			// ImageName			{			wsprintf(pBuff, "ImageName        %s",  theApp.m_p120FullPictInfo->ImageName);			m_ListControl.AddString(pBuff);			}			break;#endif		default:			break;		}	} // end of else.						delete [] pBuff;}void CListDlg::SetImageProcessingInfoList(void){	LPCSTR ImgTypeArray[4]={ {"Gray8"}, {"RGB24"}, {"RGB32"}, {"Unknown"} };	LPCSTR WhiteBalanceArray[7]={ {"Auto"}, {"DayLight"}, {"InDoor"},								  {"Fluorescent"}, {"None"}, {"UseManual"}, {"Unknown"} };	LPSTR	pBuff;	pBuff=new char[256];	if(pBuff==NULL)		return;	//********************************	//		IPInformation		//********************************	SetWindowText("IPDataInformation");	//	{		wsprintf(pBuff,"ImageType         %s",ImgTypeArray[theApp.m_pIPData->ImageType]);		m_ListControl.AddString(pBuff);    }	//	{		wsprintf(pBuff,"RotateFlag        %s",BOOLArray[theApp.m_pIPData->RotateFlag]);		m_ListControl.AddString(pBuff);    }	//	{		wsprintf(pBuff,"RotateAngle       %s",RotateAngleArray[theApp.m_pIPData->RotateAngle]);		m_ListControl.AddString(pBuff);    }	//	{		wsprintf(pBuff,"UseDefaultCRT     %s",BOOLArray[theApp.m_pIPData->UseDefaultCRT]);		m_ListControl.AddString(pBuff);    }	//	{		wsprintf(pBuff,"WhiteBalance      %s",WhiteBalanceArray[theApp.m_pIPData->WhiteBalance]);		m_ListControl.AddString(pBuff);    }#ifdef DC50Include	//	WBManual	{		sprintf(pBuff,"WBManual:         %4.2f, %4.2f, %4.2f",						theApp.m_pIPData->WBManual.WBGainR,						theApp.m_pIPData->WBManual.WBGainG,						theApp.m_pIPData->WBManual.WBGainB						);		m_ListControl.AddString(pBuff);    }#endif	// CRTData	{		sprintf(pBuff,"CRTData.Red.XChroma      %f",theApp.m_pIPData->CRTData.RedChroma.XChroma);		m_ListControl.AddString(pBuff);		sprintf(pBuff,"CRTData.Red.YChroma      %f",theApp.m_pIPData->CRTData.RedChroma.YChroma);		m_ListControl.AddString(pBuff);		sprintf(pBuff,"CRTData.Green.XChroma    %f",theApp.m_pIPData->CRTData.GrnChroma.XChroma);		m_ListControl.AddString(pBuff);		sprintf(pBuff,"CRTData.Green.YChroma    %f",theApp.m_pIPData->CRTData.GrnChroma.YChroma);		m_ListControl.AddString(pBuff);		sprintf(pBuff,"CRTData.Blue.XChroma     %f",theApp.m_pIPData->CRTData.BluChroma.XChroma);		m_ListControl.AddString(pBuff);		sprintf(pBuff,"CRTData.Bule.YChroma     %f",theApp.m_pIPData->CRTData.BluChroma.YChroma);		m_ListControl.AddString(pBuff);		sprintf(pBuff,"CRT Gamma Value               %f",theApp.m_pIPData->CRTData.Gamma);		m_ListControl.AddString(pBuff);		sprintf(pBuff,"White Tempreture in Kelvin    %f",theApp.m_pIPData->CRTData.WhiteTemp);		m_ListControl.AddString(pBuff);    }	delete [] pBuff;}void CListDlg::SetOutputWindowInfoList(void){	LPSTR	pBuff;	pBuff=new char[256];	if(pBuff==NULL)		return;	//********************************	//		IPInformation		//********************************	SetWindowText("OutputWindow Information");	//	{		wsprintf(pBuff,"HOffset         %5d",theApp.m_pWindowData->HOffset);		m_ListControl.AddString(pBuff);    }	//	{		wsprintf(pBuff,"VOffset         %5d",theApp.m_pWindowData->VOffset);		m_ListControl.AddString(pBuff);    }	//	{		wsprintf(pBuff,"Width           %5d",theApp.m_pWindowData->Width);		m_ListControl.AddString(pBuff);    }	//	{		wsprintf(pBuff,"Height          %5d",theApp.m_pWindowData->Height);		m_ListControl.AddString(pBuff);    }	//	{		wsprintf(pBuff,"RowBytes        %5d",theApp.m_pWindowData->RowBytes);		m_ListControl.AddString(pBuff);    }	delete [] pBuff;} void CListDlg::SetCameraTypeList(void){	LPSTR	pBuff;	pBuff=new char[256];	if(pBuff==NULL)		return;	SetWindowText("Camera Type of the picture");	switch(theApp.m_NativeCameraType){		case DCNoCamera:			wsprintf(pBuff,"Camera Type -------- DCNoCamera");			break;		case DCGenericCamera:			wsprintf(pBuff,"Camera Type -------- DCGenericCamera");			break;//		case DCStdStillCamera://			wsprintf(pBuff,"Camera Type -------- DCStdStillCamera");//			break;		case DC20:			wsprintf(pBuff,"Camera Type -------- DC20");			break;		case DC25:			wsprintf(pBuff,"Camera Type -------- DC25");			break;		case DC40:			wsprintf(pBuff,"Camera Type -------- DC40");			break;		case DC50:			wsprintf(pBuff,"Camera Type -------- DC50");			break;// + Ogawa		case DC120:			wsprintf(pBuff,"Camera Type -------- DC120");			break;// - Ogawa		default:			wsprintf(pBuff,"Camera Type -------- Unknown");			break;	}			m_ListControl.AddString(pBuff);	delete [] pBuff;}#ifdef DC50Include void CListDlg::SetPreviewInfoList(void){	LPSTR	pBuff;	LPCSTR ImgTypeArray[4]={ {"Gray8"}, {"RGB24"}, {"RGB32"}, {"Unknown"} };	if((theApp.m_pDCCamera->CamType != DC50) && (theApp.m_pDCCamera->SpecificCamType != DC50))		return;	pBuff=new char[256];	if(pBuff==NULL)		return;		SetWindowText("Preview Information");	// PictWidth		{		wsprintf(pBuff, "PictWidth           %ld",  theApp.m_pPreviewInfo->PictWidth);		m_ListControl.AddString(pBuff);		}	// PictHeight		{		wsprintf(pBuff, "PictHeight          %ld",  theApp.m_pPreviewInfo->PictHeight);		m_ListControl.AddString(pBuff);		}	// PictCompSize		{		wsprintf(pBuff, "PictCompSize        %ld",  theApp.m_pPreviewInfo->PictCompSize);		m_ListControl.AddString(pBuff);		}	// PictMinBufIn		{		wsprintf(pBuff, "PictMinBufIn        %ld",  theApp.m_pPreviewInfo->PictMinBufIn);		m_ListControl.AddString(pBuff);		}	// PictMinBufOut		{		wsprintf(pBuff, "PictMinBufOut       %ld",  theApp.m_pPreviewInfo->PictMinBufOut);		m_ListControl.AddString(pBuff);		}	// ImageType	{		wsprintf(pBuff, "PictType            %s",ImgTypeArray[theApp.m_pPreviewInfo->PictType]);		m_ListControl.AddString(pBuff);    }	delete [] pBuff;}#endif#ifdef DC120Includevoid CListDlg::SetAlbumNameList(void){	LPSTR	pBuff;	short	i;	short	MaxLoop;	if((theApp.m_pDCCamera->CamType != DC120) && (theApp.m_pDCCamera->SpecificCamType != DC120)){		return;	}	pBuff=new char[256];	if(pBuff==NULL)	return;	SetWindowText("AlbumName Information");		MaxLoop = (short)theApp.m_AlbumAvailableArraySize;	for(i=0; i<MaxLoop; i++){		wsprintf(pBuff,"AlbumName[%2d] = %s",i+1, theApp.m_pAlbumAvailableArray + DC120OneAlbumLength * i);		m_ListControl.AddString(pBuff);	}	delete [] pBuff;}// + Ogawa void CListDlg::SetAlbumAllNameList(void){	LPSTR	pBuff;	//long	RemainedSize;			short	i;	short	MaxLoop;	if((theApp.m_pDCCamera->CamType != DC120) && (theApp.m_pDCCamera->SpecificCamType != DC120)){		return;	}	pBuff=new char[256];	if(pBuff==NULL)	return;	SetWindowText("All AlbumName Information");		MaxLoop	 = (short)theApp.m_AlbumAllSize;	for(i=0; i<MaxLoop; i++){		if(i == 0) {			wsprintf(pBuff, "AlbumName[%2d] = %15s : %4ld", i, "NO ALBUM", theApp.m_pAlbumAll[i].PictNum);		} else {			wsprintf(pBuff, "AlbumName[%2d] = %15s : %4ld", i, theApp.m_pAlbumAll[i].AlbumName, theApp.m_pAlbumAll[i].PictNum);		}		m_ListControl.AddString(pBuff);	}	delete [] pBuff;}// - Ogawavoid CListDlg::SetAlbumPictureNameList(void){	LPSTR	pBuff;	short	i;	short	MaxLoop;	// + Ogawa	if((theApp.m_pDCCamera->CamType != DC120) && (theApp.m_pDCCamera->SpecificCamType != DC120)){		return;	}	// - Ogawa	pBuff=new char[256];	if(pBuff==NULL)	return;	SetWindowText("AlbumPictureName Information");		MaxLoop = (short)(theApp.m_AlbumPictNameArraySize);	for(i=0; i<MaxLoop; i++){		wsprintf(pBuff,"PictName[%4d] = %s",i+1, theApp.m_pAlbumPictNameArray + DC120OneAlbumLength * i);		m_ListControl.AddString(pBuff);	}	delete [] pBuff;}#endif void CListDlg::SetJPEGList(void){	LPSTR	pBuff;	pBuff=new char[256];	if(pBuff==NULL)		return;	SetWindowText("JPEG File Info.");	// JPEG size	{		wsprintf(pBuff,"Size of the JPEG compressed image: %d",m_JPEGSize);		m_ListControl.AddString(pBuff);    }	delete [] pBuff;} /////////////////////////////////////////////////////////////////////////////// CListDlg message handlersint CListDlg::OnCreate(LPCREATESTRUCT lpCreateStruct) {	if (CDialog::OnCreate(lpCreateStruct) == -1)		return -1;		return 0;}BOOL CListDlg::OnInitDialog() {	CDialog::OnInitDialog();	{		CFont	ListBoxFont;		ListBoxFont.CreateStockObject(SYSTEM_FIXED_FONT);		m_ListControl.SetFont(&ListBoxFont);	}	switch(m_KindOfList){		case StatusList:			SetStatusList();			break;		case ConfigList:			SetConfigList();			break;		case PictureInfoList:			SetPictureInfoList();			break;		// + Ogawa		case NativePictureInfoList:			SetNativePictureInfoList();			break;		// - Ogawa		case ImageProcessingInfoList:			SetImageProcessingInfoList();			break;		case OutputWindowInfoList:			SetOutputWindowInfoList();			break;		case CameraTypeList:			SetCameraTypeList();			break;#ifdef DC50Include		case PreviewInfoList:			SetPreviewInfoList();			break;#endif#ifdef DC120Include		case AlbumNameList:			SetAlbumNameList();			break;		// + Ogawa		case AlbumAllNameList:			SetAlbumAllNameList();			break;		case AlbumPictureNameList:			SetAlbumPictureNameList();			break;		// - Ogawa#endif		case JPEGList:			SetJPEGList();			break;		default:			CDialog::OnCancel();	}	return TRUE;  // return TRUE unless you set the focus to a control	              // EXCEPTION: OCX Property Pages should return FALSE}